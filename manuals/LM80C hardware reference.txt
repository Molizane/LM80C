************************************************************************
*                                                                      *
*              L M 8 0 C    C O L O R    C O M P U T E R               *
*                                                                      *
*                      Hardware reference manual                       *
*                                                                      *
************************************************************************
*                                                                      *
*                             Version  1.1                             *
*                             (2019/09/28)                             *
*                This release applies to the LM80C R2.2                *
*                                                                      *
************************************************************************

                              1. Quick view
                              -------------

1.1 The LM80C Color Computer
----------------------------
The LM80C Color Computer is an homebrew computer developed and
prograammed by Leonardo Miliani (Italy) in an effort to have his own,
old-stile, 80s' computer. It is built upon the Z80, an 8-bit CPU
developed in the '70s by Zilog. LM80C derives from "L"eonardo "M"iliani
(Z)80 "C"olor.

1.2 Main features
-----------------
The LM80C might have been a good computer at that time:
- CPU: Zilog Z80@3.68 MHz
- RAM: 32 KB SRAM
- ROM: 32 KB EEPROM with built-in Nascom BASIC from Microsoft
- Video: TMS9918A with 16 KB VRAM, 256x192 pixels, 15 colors and 32
         sprites
- Audio: Yamaha YM2149F (or GI AY-3-8910) with 3 analog channels,
         2x8-bit I/O ports
- Serial I/O: 1xZ80 SIO
- Parallel I/O: 1xZ80 PIO
- Timer: 1xZ80 CTC
- Serial line: 19,200 bps
------------------------------------------------------------------------

                            2. Memory map
                            -------------

EEPROM occupies the first 32 KB of address space, from $0000 to $7FFF.
SRAM occupies the last 3 KB, from $8000 to $FFFF. 
BASIC space starts at $81ED (33.261)
STACK space starts at $FFFF decreasing.
------------------------------------------------------------------------

                             3. Start-up
                             -----------

At startup the Z80 loads the address $0000 into the PC (Program Counter)
and jumps to execute the code stored there. On LM80C this corresponds to
a jump to the routine that initializes the HW of the computer. After
each peripheral has been set up, the control passes to the BASIC
interpreter, that checks if this is a cold start (i.e. after a
power-up): if this isn't such case, it asks the user if he/she wants to
perform a cold or warm start: the first one initializes the working
space like at boot, deleting every possible program still resident in
RAM and clearing every variable, while the latter preserves both these
data.
At the end of the startup process, the control is passed to the BASIC
interpreter in direct mode: this means that the computer is able to
execute commands as soon as they are entered.
------------------------------------------------------------------------

                             4. I/O ports
                             ------------

Peripheral I/O chips have their I/O channels mapped at the following
logical ports:
PIO:
- PIO data channel A: $00
- PIO data channel B: $01
- PIO control channel A: $02
- PIO control channel B: $03

CTC:
- CTC channel 0: $10
- CTC channel 1: $11
- CTC channel 2: $12
- CTC channel 3: $13

SIO:
- SIO data channel A: $20
- SIO data channel B: $21
- SIO control channel A: $22
- SIO control channel B: $23

VDP:
- VDP data port: $30
- VDP control port: $32

PSG:
- PSG register port: $40
- PSG data port: $42

The user can control these chips by directly read/write from/to the
ports above.
------------------------------------------------------------------------ 

                          5. RAM registers

The LM80C uses some RAM cells to store important informations and data.
By manually writing into these locations the user can alter the
functioning of the system, sometimes leading to crashes and/or non-
predictable functionings.

WRKSPC       8045H              BASIC Work space
USR          WRKSPC+3H          "USR (x)" jump  <-- in $8049/804A the
                                user can store the address of a specific
                                machine language routine
OUTSUB       WRKSPC+6H          "out p,n"
OTPORT       WRKSPC+7H          Port (p)
DIVSUP       WRKSPC+9H          Division support routine
DIV1         WRKSPC+0AH         <- Values
DIV2         WRKSPC+0EH         <-   to
DIV3         WRKSPC+12H         <-   be
DIV4         WRKSPC+15H         <-inserted
SEED         WRKSPC+17H         Random number seed  <-- starting address
                                of a seed table
LSTRND       WRKSPC+3AH         Last random number
INPSUB       WRKSPC+3EH         #INP (x)" Routine
INPORT       WRKSPC+3FH         PORT (x)
NULLS        WRKSPC+41H         Number of nulls
LWIDTH       WRKSPC+42H         Terminal width
COMMAN       WRKSPC+43H         Width for commas
NULFLG       WRKSPC+44H         Null after input byte flag
CTLOFG       WRKSPC+45H         Control "O" flag
LINESC       WRKSPC+46H         Lines counter
LINESN       WRKSPC+48H         Lines number
CHKSUM       WRKSPC+4AH         Array load/save check sum
NMIFLG       WRKSPC+4CH         Flag for NMI break routine
BRKFLG       WRKSPC+4DH         Break flag
RINPUT       WRKSPC+4EH         Input reflection
POINT        WRKSPC+51H         "POINT" reflection (unused)
PSET         WRKSPC+54H         "SET"   reflection
RESET        WRKSPC+57H         Reset system (it was a command that
                                reset a video pixel)
STRSPC       WRKSPC+5AH         Bottom of string space
LINEAT       WRKSPC+5CH         Current line number
BASTXT       WRKSPC+5EH         Pointer to start of program
                                (actually this is the last value pre-
                                -filled by the firmware at startup)
BUFFER       WRKSPC+61H         Input buffer
STACK        WRKSPC+66H         Initial stack
CURPOS       WRKSPC+0ABH        Character position on line
LCRFLG       WRKSPC+0ACH        Locate/Create flag
TYPE         WRKSPC+0ADH        Data type flag
DATFLG       WRKSPC+0AEH        Literal statement flag
LSTRAM       WRKSPC+0AFH        Last available RAM
TMSTPT       WRKSPC+0B1H        Temporary string pointer
TMSTPL       WRKSPC+0B3H        Temporary string pool
TMPSTR       WRKSPC+0BFH        Temporary string
STRBOT       WRKSPC+0C3H        Bottom of string space
CUROPR       WRKSPC+0C5H        Current operator in EVAL
LOOPST       WRKSPC+0C7H        First statement of loop
BRKLIN       WRKSPC+0CEH        Line of break
DATLIN       WRKSPC+0C9H        Line of current DATA item
FORFLG       WRKSPC+0CBH        "FOR" loop flag
LSTBIN       WRKSPC+0CCH        Last byte entered
READFG       WRKSPC+0CDH        Read/Input flag
NXTOPR       WRKSPC+0D0H        Next operator in EVAL
ERRLIN       WRKSPC+0D2H        Line of error
CONTAD       WRKSPC+0D4H        Where to CONTinue
PROGND       WRKSPC+0D6H        End of program
VAREND       WRKSPC+0D8H        End of variables
ARREND       WRKSPC+0DAH        End of arrays
NXTDAT       WRKSPC+0DCH        Next data item
FNRGNM       WRKSPC+0DEH        Name of FN argument
FNARG        WRKSPC+0E0H        FN argument value
FPREG        WRKSPC+0E4H        Floating point register
FPEXP        FPREG+03H          Floating point exponent
SGNRES       WRKSPC+0E8H        Sign of result
TMRCNT       WRKSPC+0E9H        TMR counter for 1/100 seconds
SCR_SIZE_W   TMRCNT+04H         screen width (it can be either 40 chars
                                or 32 chars/bytes)
SCR_SIZE_H   WRKSPC+0EEH        screen height (it can be 24/48/192: 24
                                for text, 48 for MC, 192 for graphics)
SCR_SIZE_B   WRKSPC+0EFH        screen size in bytes
SCR_NAM_TB   WRKSPC+0F1H        video name table address
SCR_CURS_X   WRKSPC+0F3H        cursor X
SCR_CURS_Y   WRKSPC+0F4H        cursor Y
SCR_CUR_NX   WRKSPC+0F5H        new cursor X position
SCR_CUR_NY   WRKSPC+0F6H        new cursor Y position
SCR_ORG_CHR  WRKSPC+0F7H        original char positioned under the
                                cursor
CRSR_STATE   WRKSPC+0F8H        state of cursor (1=on, 0=off)
LSTCSRSTA    WRKSPC+0F9H        last cursor state
PRNTVIDEO    WRKSPC+0FAH        buffer video on/off
CHR4VID      WRKSPC+0FBH        char for video buffer
TMPBFR1      WRKSPC+0FCH        word for general purposes use
                                (temp. buffer for 1 or 2 bytes)
TMPBFR2      WRKSPC+0FEH        word for general purposes use
                                (temp. buffer for 1 or 2 bytes)
TMPBFR3      WRKSPC+100H        word for general purposes use
                                (temp. buffer for 1 or 2 bytes)
VIDEOBUFF    WRKSPC+102H        temp video buffer used fro scrolling and
                                other purposes
VIDTMP1      VIDEOBUFF+028H     temporary video buffer
VIDTMP2      VIDTMP1+002H       temporary video buffer
CHASNDDTN    VIDTMP2+002H       sound Ch.A duration (hds)
CHBSNDDTN    CHASNDDTN+002H     sound Ch.B duration (hds)
CHCSNDDTN    CHBSNDDTN+002H     sound Ch.C duration (hds)
PBUFF        CHCSNDDTN+002H     Number print buffer
MULVAL       PBUFF+0DH          Multiplier
PROGST       MULVAL+03H         Start of program text area
STLOOK       PROGST+064H        (WRKSPC+16CH) Start of memory test