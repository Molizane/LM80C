************************************************************************
*                                                                      *
*              L M 8 0 C    C O L O R    C O M P U T E R               *
*                                                                      *
*                      Hardware reference manual                       *
*                                                                      *
************************************************************************
*                                                                      *
*                             Version  1.4                             *
*                             (2020/02/01)                             *
*                This release applies to the LM80C R2.2                *
*                                                                      *
************************************************************************

                              1. Quick view
                              -------------

1.1 The LM80C Color Computer
----------------------------
The LM80C Color Computer is an homebrew computer developed and
prograammed by Leonardo Miliani (Italy) in an effort to have his own,
old-stile, 80s' computer. It is built upon the Z80, an 8-bit CPU
developed in the '70s by Zilog. LM80C derives from "L"eonardo "M"iliani
(Z)80 "C"olor.

1.2 Main features
-----------------
The LM80C might have been a good computer at that time:
- CPU: Zilog Z80@3.68 MHz
- RAM: 32 KB SRAM
- ROM: 32 KB EEPROM with built-in Nascom BASIC from Microsoft
- Video: TMS9918A with 16 KB VRAM, 256x192 pixels, 15 colors and 32
         sprites
- Audio: Yamaha YM2149F (or GI AY-3-8910) with 3 analog channels,
         2x8-bit I/O ports (used to read the external keyboard)
- Serial I/O: 1xZ80 SIO
- Parallel I/O: 1xZ80 PIO
- Timer: 1xZ80 CTC
- Serial line: 19,200 bps
------------------------------------------------------------------------

                            2. Memory map
                            -------------

EEPROM occupies the first 32 KB of address space, from $0000 to $7FFF.
From $0000 to $00FF interrupt vectors are stored.

SRAM occupies the last 32 KB, from $8000 to $FFFF. Cells from $8000 to
$81EF are used by BASIC to store its own variables (see sec. 6). STACK
space starts at $FFFF decreasing. The RAM within the two addresses is
available for user's BASIC programs.
------------------------------------------------------------------------

                             3. Start-up
                             -----------

At startup the Z80 loads the address $0000 into the PC (Program Counter)
and jumps to execute the code stored there. On LM80C this corresponds to
a jump to the routine that initializes the HW of the computer. After
each peripheral has been set up, the control passes to the BASIC
interpreter, that checks if this is a cold start (i.e. after a
power-up): if this isn't such case, it asks the user if he/she wants to
perform a cold or warm start: the first one initializes the working
space like at boot, deleting every possible program still resident in
RAM and clearing every variable, while the latter preserves both these
data.
At the end of the startup process, the control is passed to the BASIC
interpreter in direct mode: this means that the computer is able to
execute commands as soon as they are entered.
------------------------------------------------------------------------

                             4. I/O ports
                             ------------

Peripheral I/O chips have their I/O channels mapped at the following
logical ports:
PIO:
- PIO data channel A: $00
- PIO data channel B: $01
- PIO control channel A: $02
- PIO control channel B: $03

CTC:
- CTC channel 0: $10
- CTC channel 1: $11
- CTC channel 2: $12
- CTC channel 3: $13

SIO:
- SIO data channel A: $20
- SIO data channel B: $21
- SIO control channel A: $22
- SIO control channel B: $23

VDP:
- VDP data port: $30
- VDP control port: $32

PSG:
- PSG register port: $40
- PSG data port: $42

The user can control these chips directly by reading/writing from/to the
ports listed above.
------------------------------------------------------------------------ 
                           5. Interrupts

Several interrupt vectors are stored into ROM

$0000   RESET: Z80 jumps here after a reset or at power-up
$0008   RST8: this restart calls a function that sends a char via serial
$000C   INT vector for SIO RX_CHA_AVAILABLE interrupt signal
$000E   INT vector for SIO SPEC_RX_CONDITION (special receive condition)
        interrupt signal
$0010   RST10: this restart jumps to a function that receives a char
        from the input buffer (serial and/or keyboard)
$0016   INT vector for CTC_CH3_TIMER interrupt signal (system tick)
$0018   RST18: jumps to function that checks if a char is available in
        the input buffer
$0066   NMI IRQ: actually, the NMI interrupt is not used, so nothing
        is done other than RETN to caller
------------------------------------------------------------------------
                          6. RAM registers

The LM80C uses some RAM cells to store important informations and data.
By manually writing into these locations the user can alter the
functioning of the system, sometimes leading to crashes and/or non-
predictable functionings.

WRKSPC          8045H           BASIC Work space
USR             WRKSPC+3H       "USR (x)" jump  <-- in $8049/804A the
                                user can store the address of a specific
                                machine language routine
OUTSUB          WRKSPC+6H       "out p,n"
OTPORT          WRKSPC+7H       Port (p)
DIVSUP          WRKSPC+9H       Division support routine
DIV1            WRKSPC+0AH      <- Values
DIV2            WRKSPC+0EH      <-   to
DIV3            WRKSPC+12H      <-   be
DIV4            WRKSPC+15H      <-inserted
SEED            WRKSPC+17H      Random number seed  <-- starting address
                                of a seed table
LSTRND          WRKSPC+3AH      Last random number
INPSUB          WRKSPC+3EH      #INP (x)" Routine
INPORT          WRKSPC+3FH      PORT (x)
NULLS           WRKSPC+41H      Number of nulls
LWIDTH          WRKSPC+42H      Terminal width
COMMAN          WRKSPC+43H      Width for commas
NULFLG          WRKSPC+44H      Null after input byte flag
CTLOFG          WRKSPC+45H      Control "O" flag
LINESC          WRKSPC+46H      Lines counter
LINESN          WRKSPC+48H      Lines number
CHKSUM          WRKSPC+4AH      Array load/save check sum
NMIFLG          WRKSPC+4CH      Flag for NMI break routine
BRKFLG          WRKSPC+4DH      Break flag
RINPUT          WRKSPC+4EH      Input reflection
POINT           WRKSPC+51H      "POINT" reflection (unused)
PSET            WRKSPC+54H      "SET"   reflection
RESET           WRKSPC+57H      Reset system
STRSPC          WRKSPC+5AH      Bottom of string space
LINEAT          WRKSPC+5CH      Current line number
BASTXT          WRKSPC+5EH      Pointer to start of program
                                actually this is the last value pre-
                                filled by the firmware at startup
BUFFER          WRKSPC+61H      Input buffer
STACK           WRKSPC+66H      Initial stack
CURPOS          WRKSPC+0ABH     Character position on line
LCRFLG          WRKSPC+0ACH     Locate/Create flag
TYPE            WRKSPC+0ADH     Data type flag
DATFLG          WRKSPC+0AEH     Literal statement flag
LSTRAM          WRKSPC+0AFH     Last available RAM
TMSTPT          WRKSPC+0B1H     Temporary string pointer
TMSTPL          WRKSPC+0B3H     Temporary string pool
TMPSTR          WRKSPC+0BFH     Temporary string
STRBOT          WRKSPC+0C3H     Bottom of string space
CUROPR          WRKSPC+0C5H     Current operator in EVAL
LOOPST          WRKSPC+0C7H     First statement of loop
DATLIN          WRKSPC+0C9H     Line of current DATA item
FORFLG          WRKSPC+0CBH     "FOR" loop flag
LSTBIN          WRKSPC+0CCH     Last byte entered
READFG          WRKSPC+0CDH     Read/Input flag
BRKLIN          WRKSPC+0CEH     Line of break
NXTOPR          WRKSPC+0D0H     Next operator in EVAL
ERRLIN          WRKSPC+0D2H     Line of error
CONTAD          WRKSPC+0D4H     Where to CONTinue
PROGND          WRKSPC+0D6H     End of program
VAREND          WRKSPC+0D8H     End of variables
ARREND          WRKSPC+0DAH     End of arrays
NXTDAT          WRKSPC+0DCH     Next data item
FNRGNM          WRKSPC+0DEH     Name of FN argument
FNARG           WRKSPC+0E0H     FN argument value
FPREG           WRKSPC+0E4H     Floating point register
FPEXP           FPREG+03H       Floating point exponent
SGNRES          WRKSPC+0E8H     Sign of result
TMRCNT          WRKSPC+0E9H     TMR counter for 1/100 seconds
; - VIDEO REGISTERS
SCR_SIZE_W      TMRCNT+04H      screen width (it can be either 40 chars
                                or 32 chars/bytes
SCR_SIZE_H      SCR_SIZE_W+01H  screen height (it can be 24/48/192: 24
                                for text, 48 for MC, 192 for graphics)
SCR_MODE        SCR_SIZE_H+01H  screen mode (0=text, 1=G1, 2=G2, 3=MC,
                                4=ExG2)
SCR_NAM_TB      SCR_MODE+02H    video name table address
SCR_CURS_X      SCR_NAM_TB+02H  cursor X
SCR_CURS_Y      SCR_CURS_X+01H  cursor Y
SCR_CUR_NX      SCR_CURS_Y+01H  new cursor X position
SCR_CUR_NY      SCR_CUR_NX+01H  new cursor Y position
SCR_ORG_CHR     SCR_CUR_NY+01H  original char positioned under the
                                cursor
CRSR_STATE      SCR_ORG_CHR+01H state of cursor (1=on, 0=off)
LSTCSRSTA       CRSR_STATE+01H  last cursor state
PRNTVIDEO       LSTCSRSTA+01H   print on video buffer (1=on / 0=off) set
                                to off on graphic only modes
CHR4VID         PRNTVIDEO+01H   char for video buffer
FRGNDCLR        CHR4VID+01H     foreground color as set by SCREEN or
                                COLOR commands
BKGNDCLR        FRGNDCLR+01H    background color as set by SCREEN or
                                COLOR commands
TMPBFR1         BKGNDCLR+01H    word for general purposes use (temp.
                                buffer for 1 or 2 bytes)
TMPBFR2         TMPBFR1+02H     word for general purposes use (temp.
                                buffer for 1 or 2 bytes)
TMPBFR3         TMPBFR2+02H     word for general purposes use (temp.
                                buffer for 1 or 2 bytes)
VIDEOBUFF       TMPBFR3+02H     buffer used for video scrolling and
                                other purposes (40 bytes)
VIDTMP1         VIDEOBUFF+028H  temporary video word
VIDTMP2         VIDTMP1+002H    temporary video word
; - SOUND & KEYBOARD REGISTERS - FROM HERE...
CHASNDDTN       VIDTMP2+002H    sound Ch.A duration (1/100s)
CHBSNDDTN       CHASNDDTN+002H  sound Ch.B duration (1/100s)
CHCSNDDTN       CHBSNDDTN+002H  sound Ch.C duration (1/100s)
KBTMP           CHCSNDDTN+002H  temp cell used by keyboard scanner
TMPKEYBFR       KBTMP+001H      temp buffer for last key pressed
LASTKEYPRSD     TMPKEYBFR+001H  last key code pressed
CONTROLKEYS     LASTKEYPRSD+01H flags for control keys (bit#0=SHIFT;
                                bit#1=CTRL; bit#2=C=)
; - - - - - - - - - - - - - - -
PBUFF           CONTROLKEYS+01H ; Number print buffer
MULVAL          PBUFF+0DH       ; Multiplier
PROGST          MULVAL+03H      ; Start of program text area
STLOOK          PROGST+064H     ; (WRKSPC+16DH) Start of memory test
------------------------------------------------------------------------ 
                       7. Serial configuration

If you intend to connect the LM80C to a host computer through the
serial port A, you have to use am FT232 module to adapt the RS232 serial
lines of the LM80X to the USB port of moderm systems. Moreover, to avoid
serial issues during sending data to the LM80C, please configure the
terminal emulator you are using (i.e. CoolTerm or TeraTherm) with these
params:

PORT: choose the port your system has mounted the FT232 module to
BAUDRATE: 19,200 bps
DATA BITS: 8
PARITY: none (0)
STOP BITS: 1
FLOW CONTROL: CTS
SOFTWARE SUPPORT FOR FLOW CONTROL: yes
RTS AT STARTUP: on
HANDLE BS AND DEL CHARS: yes
HANDLE FF (FormFeed) CHAR: yes
USE TX DELAY: min. 5ms (increment it if you experience issues)

------------------------------------------------------------------------
                            8. VDP settings

The VDP, aka Video Display Processor, is the video chip of the LM80C
computer. It is a TMS9918A from Texas Instruments. It can visualize a
video image of 256x192 pixels with 15 colors and 32 sprites. It has
several graphics modes, each of them configured to store video datas in
particular areas of the VRAM. These are the main settings for the 
modes supported by LM80C. Before to proceed, a little explanation of the
meaning of different areas:
* pattern table: it's the area where the patterns that compose the chars
are stored.
* name table: this is a sort of look-up table. This area maps what's is
shown by the VDP in each cell of the video. The VDP reads the byte
stored into a particular cell and then looks into the pattern table to
find the data needed to draw the corresponding char.
* color table: some graphics modes store the color of a particular cell
into this table.
* sprite pattern table:  similarly to the pattern table, this area
stores the data needed to draw the sprites
* sprite attribute table: this area contains the info needed by the VDP
to locate and color the sprites.
N.B: the addresses below are referred to Video RAM, so to access it you
must use the VPOKE and VPEEK statements.

TEXT MODE (screen 0):
pattern table: $0000-$07FF
name table: $0800-$0BBF

GRAPHICS 1 MODE (screen 1):
pattern table: $0000-$07FF
name table: $1800-$1AFF
sprite attribute table: $1B00-$1B7F
color table: $2000-$201F
sprite pattern table: $3800-$3FFF

GRAPHICS 2 MODE (screen 2):
pattern table: $0000-$17FF
name table: $1800-$1AFF
sprite attribute table: $1B00-$1B7F
color table: $2000-$37FF
sprite pattern table: $3800-$3FFF

MULTICOLOR MODE (screen 3):
pattern table: $0000-$07FF
name table: $0800-$0AFF
sprite attribute table: $1B00-$1B7F
sprite pattern table: $3800-$3FFF

EXTENDED GRAPHICS 2 MODE (screen 4):
pattern table: $0000-$07FF
sprite pattern table: $1800-$1FFF
color table: $2000-$27FF
name table: $3800-$3AFF
sprite attribute table: $3B00-$3B7F

