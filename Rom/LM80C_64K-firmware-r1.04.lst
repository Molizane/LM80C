# file opened: LM80C_64K-firmware-r1.04.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C 64K - FIRMWARE - R1.04
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.0
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; set name for binary output file
  55  0000                  OUTPUT "LM80C-64K-firmware-r1.04.bin"
  56  0000
  57  0000              ; set computer model
  58  0000                  DEFINE LM80C64K
  59  0000
  60  0000              ; set firmware version
  61  0000                  DEFINE VERSION "1.04"
  62  0000
  63  0000              ; define shorter VDP_DAT load instruction
  64  0000                  DEFINE LD_VDP_DAT dec     C
  65  0000
  66  0000              ; ------------------------------------------------------------------------------
  67  0000              ; include the latest version of the bootloader: this sets up the address aliases
  68  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  69  0000                  INCLUDE "../include/bootloader/bootloader-1.05.asm"
# file opened: ../include/bootloader/bootloader-1.05.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.04
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000                  IFDEF LM8064K
  54+ 0000 ~            VDP_SET         equ %00110001
  55+ 0000                  ELSE
  56+ 0000              VDP_SET         equ %00110010
  57+ 0000                  ENDIF
  58+ 0000
  59+ 0000              ; label defining for PSG (Programmable Sound Generator)
  60+ 0000              PSG_REG         equ %01000000
  61+ 0000              PSG_DAT         equ %01000001
  62+ 0000
  63+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  64+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  65+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  66+ 0000              SER_BUFSIZE     equ     $58
  67+ 0000              SER_FULLSIZE    equ     $50
  68+ 0000              SER_EMPTYSIZE   equ     $05
  69+ 0000
  70+ 0000
  71+ 0000              ;------------------------------------------------------------------------------
  72+ 0000              ;                                F I R M W A R E
  73+ 0000              ;------------------------------------------------------------------------------
  74+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  75+ 0000                              org     $0000
  76+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  77+ 0001                  IFDEF LM80C64K
  78+ 0001 C3 EF 50                     jp      ROM2RAM         ; jump to ROM/RAM switcher
  79+ 0004                  ELSE
  80+ 0004 ~                            jp      INIT_HW         ; jump to system initialization
  81+ 0004                  ENDIF
  82+ 0004
  83+ 0004              ;------------------------------------------------------------------------------
  84+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  85+ 0004                              ;$0004
  86+ 0004 64 01                        defw    RX_CHB_AVAIL
  87+ 0006
  88+ 0006              ;------------------------------------------------------------------------------
  89+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  90+ 0006                              ;$0006
  91+ 0006 67 01                        defw    SPEC_RXB_CNDT
  92+ 0008
  93+ 0008              ;------------------------------------------------------------------------------
  94+ 0008              ; send a character over serial ch. A
  95+ 0008                              ;$0008
  96+ 0008 C3 4D 02     RST08:          jp      TXA
  97+ 000B FF                           BLOCK   1,$FF   ; filler
  98+ 000C
  99+ 000C              ;------------------------------------------------------------------------------
 100+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
 101+ 000C                              ;$000C
 102+ 000C 00 01                        defw    RX_CHA_AVAIL
 103+ 000E
 104+ 000E              ;------------------------------------------------------------------------------
 105+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
 106+ 000E                              ;$000E
 107+ 000E 35 01                        defw    SPEC_RXA_CNDT
 108+ 0010
 109+ 0010              ;------------------------------------------------------------------------------
 110+ 0010              ; receive a character over serial ch. A
 111+ 0010                              ;$0010
 112+ 0010 C3 23 02     RST10:          jp      RXA
 113+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 114+ 0018              ;------------------------------------------------------------------------------
 115+ 0018              ; check serial status
 116+ 0018
 117+ 0018                              ;$0018
 118+ 0018 C3 7A 02     RST18:          jp      CKINCHAR
 119+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 120+ 0040              ;------------------------------------------------------------------------------
 121+ 0040              ; interrupt vectors for CTC
 122+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 123+ 0040 DF 52                        defw    CTC0IV
 124+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 125+ 0042 E2 52                        defw    CTC1IV
 126+ 0044                              ;$0044               ; for CH2 timer - unused
 127+ 0044 E5 52                        defw    CTC2IV
 128+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 129+ 0046 E8 52                        defw    CTC3IV
 130+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 131+ 0066              ;------------------------------------------------------------------------------
 132+ 0066              ; interrupt routine for NMI
 133+ 0066                              ;$0066
 134+ 0066 C3 7F 51                     jp      NMIUSR              ; jump to execute NMI service routine
 135+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 136+ 0090              ;------------------------------------------------------------------------------
 137+ 0090
 138+ 0090                              ;$0090
 139+ 0090                  IFDEF LM80C
 140+ 0090 ~                            defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
 141+ 0090 ~                            defb    $4C,$4F,$52,$00,$00,$00,$00,$00
 142+ 0090                  ELSE
 143+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 143+ 0094 43 20 36 34
 144+ 0098 4B 20 43 4F                  defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 144+ 009C 4C 4F 52 00
 145+ 00A0                  ENDIF
 146+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 146+ 00A4 55 54 45 52
 147+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$30,$29,$00
 147+ 00AC 32 30 29 00
 148+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 148+ 00B4 67 6E 65 64
 149+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 149+ 00BC 00 00 00 00
 150+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 150+ 00C4 61 72 64 6F
 151+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 151+ 00CC 69 61 6E 69
 152+ 00D0 46 57 20 31  FWVER:          defm    "FW ","1.04",$20,"2021-01-05",$20,"17:57:19",$00
 152+ 00D4 2E 30 34 20
 152+ 00D8 32 30 32 31
 152+ 00DC 2D 30 31 2D
 152+ 00E0 30 35 20 31
 152+ 00E4 37 3A 35 37
 152+ 00E8 3A 31 39 00
 153+ 00EC              FMVEREND:       equ     $
 154+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 155+ 0100              ;------------------------------------------------------------------------------
 156+ 0100
 157+ 0100              ;-------------------------------------------------------------------------------
 158+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 159+ 0100              ;-------------------------------------------------------------------------------
 160+ 0100
 161+ 0100              ;-------------------------------------------------------------------------------
 162+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 163+ 0100              ; this is the only channel that can print received chars onto the screen
 164+ 0100                              ;$0100
 165+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 166+ 0101 E5                           push    HL              ; and HL
 167+ 0102 CD 8E 01                     call    A_RTS_OFF       ; disable RTS line
 168+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 169+ 0107 32 38 53                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 170+ 010A CD F4 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 171+ 010D D2 30 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 172+ 0110 3A 38 53                     ld      A,(TMPKEYBFR)   ; retrieve char
 173+ 0113 32 F9 52                     ld      (CHR4VID),A     ; write into buffer for video printing
 174+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 175+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 176+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 177+ 011D DA 30 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 178+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 179+ 0121 AF                           xor     A
 180+ 0122 32 36 53                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 181+ 0125 3A F6 52                     ld      A,(CRSR_STATE)  ; check cursor state
 182+ 0128 B7                           or      A               ; is it on?
 183+ 0129 C4 4E 07                     call    NZ,CHAR2VID     ; yes, print on screen
 184+ 012C F1                           pop     AF              ; retrieve char
 185+ 012D CD 4D 02                     call    TXA             ; send back to serial
 186+ 0130 E1           LVRXCHA:        pop     HL              ; retrieve HL
 187+ 0131 F1                           pop     AF              ; and A
 188+ 0132 FB                           ei                      ; re-enable interrupts
 189+ 0133 ED 4D                        reti                    ; and exit
 190+ 0135
 191+ 0135              ;-------------------------------------------------------------------------------
 192+ 0135              ; special SIO ch.A condition (i.e., buffer overrun)
 193+ 0135              ; if buffer overruns then show an error, empty the RX buffer and send
 194+ 0135              ; a break char
 195+ 0135 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 196+ 0136 CD 8E 01                     call    A_RTS_OFF       ; disable RTS
 197+ 0139 CD C2 01                     call    SIO_A_DI        ; disable RX on ch. A
 198+ 013C 3A 3E 53                     ld      A,(SERIALS_EN)  ; load serial status
 199+ 013F CB 97                        res     2,A             ; disable RX on port 1
 200+ 0141 32 3E 53                     ld      (SERIALS_EN),A  ; store new serial status
 201+ 0144 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 202+ 0146 CB E7                        set     4,A             ; set 5th pin ON
 203+ 0148 D3 01                        out     (PIO_DB),A      ; send new setting
 204+ 014A 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 205+ 014C D3 22                        out     (SIO_CA),A      ; send command to SIO
 206+ 014E AF           EMPTYCHABFR:    xor     A
 207+ 014F D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 208+ 0151 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 209+ 0153 E6 01                        and     $01             ; check if input buffer if empty
 210+ 0155 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 211+ 0158 DB 20                        in      A,(SIO_DA)      ; read chars
 212+ 015A 18 F2                        jr      EMPTYCHABFR     ; repeat
 213+ 015C F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 214+ 015D 21 FD 3C                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 215+ 0160 E3                           ex      (SP),HL         ; store onto stack
 216+ 0161 FB                           ei                      ; re-enable interrupts
 217+ 0162 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 218+ 0164
 219+ 0164              ;-------------------------------------------------------------------------------
 220+ 0164              ;               Z80 SIO CH. A MANAGEMENT
 221+ 0164              ;-------------------------------------------------------------------------------
 222+ 0164
 223+ 0164              ;-------------------------------------------------------------------------------
 224+ 0164              ; interrupt driven routine to get chars from Z80 SIO ch.B
 225+ 0164 FB           RX_CHB_AVAIL:   ei
 226+ 0165 ED 4D                        reti
 227+ 0167
 228+ 0167              ;-------------------------------------------------------------------------------
 229+ 0167              ; special SIO ch.A condition (i.e., buffer overrun)
 230+ 0167              ; if buffer overruns then show an error, empty the RX buffer and send
 231+ 0167              ; a break char
 232+ 0167 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 233+ 0168 CD 96 01                     call    B_RTS_OFF       ; disable RTS
 234+ 016B CD CA 01                     call    SIO_B_DI        ; disable RX on ch.B
 235+ 016E 3A 3E 53                     ld      A,(SERIALS_EN)  ; load serial status
 236+ 0171 CB 9F                        res     3,A             ; disable RX on port 2
 237+ 0173 32 3E 53                     ld      (SERIALS_EN),A  ; store new serial status
 238+ 0176 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 239+ 0178 CB EF                        set     5,A             ; set 5th pin ON
 240+ 017A D3 01                        out     (PIO_DB),A      ; send new setting
 241+ 017C 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 242+ 017E D3 23                        out     (SIO_CB),A      ; send command to SIO
 243+ 0180 AF           EMPTYCHBBFR:    xor     A
 244+ 0181 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 245+ 0183 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 246+ 0185 E6 01                        and     $01             ; check if input buffer if empty
 247+ 0187 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 248+ 018A DB 21                        in      A,(SIO_DB)      ; read chars
 249+ 018C 18 F2                        jr      EMPTYCHBBFR     ; repeat
 250+ 018E
 251+ 018E
 252+ 018E              ;-------------------------------------------------------------------------------
 253+ 018E              ;               Z80 SIO MANAGEMENT
 254+ 018E              ;-------------------------------------------------------------------------------
 255+ 018E              ; disable RTS:
 256+ 018E              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 257+ 018E C5           A_RTS_OFF:      push    BC              ; store BC
 258+ 018F 0E 22                        ld      C,SIO_CA        ; select channel A
 259+ 0191 3A 3F 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 260+ 0194 18 06                        jr      SIO_RTS_OFF
 261+ 0196 C5           B_RTS_OFF:      push    BC              ; store BC
 262+ 0197 0E 23                        ld      C,SIO_CB        ; select channel B
 263+ 0199 3A 40 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 264+ 019C 47           SIO_RTS_OFF:    ld      B,A             ; store data bits
 265+ 019D 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 266+ 019F ED 79                        out     (C),A
 267+ 01A1 78                           ld      A,B             ; retrieve data bits
 268+ 01A2 F6 28                        or      %00101000       ; TX enable; RTS disable
 269+ 01A4 ED 79                        out     (C),A           ; send setting
 270+ 01A6 C1                           pop     BC              ; retrieve BC
 271+ 01A7 C9                           ret                     ; exit
 272+ 01A8
 273+ 01A8              ;-------------------------------------------------------------------------------
 274+ 01A8              ; enable RTS
 275+ 01A8              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 276+ 01A8 C5           A_RTS_ON:       push    BC              ; store BC
 277+ 01A9 0E 22                        ld      C,SIO_CA        ; select channel A
 278+ 01AB 3A 3F 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 279+ 01AE 18 06                        jr      SIO_RTS_ON
 280+ 01B0 C5           B_RTS_ON:       push    BC              ; store BC
 281+ 01B1 0E 23                        ld      C,SIO_CB        ; select channel B
 282+ 01B3 3A 40 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 283+ 01B6 47           SIO_RTS_ON:     ld      B,A             ; store data bits
 284+ 01B7 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 285+ 01B9 ED 79                        out     (C),A
 286+ 01BB 78                           ld      A,B             ; retrieve data bits
 287+ 01BC F6 2A                        or      %00101010       ; TX enable; RTS enable
 288+ 01BE ED 79                        out     (C),A           ; send setting
 289+ 01C0 C1                           pop     BC              ; retrieve BC
 290+ 01C1 C9                           ret                     ; return
 291+ 01C2
 292+ 01C2              ;-------------------------------------------------------------------------------
 293+ 01C2              ; disable SIO RX channel
 294+ 01C2 C5           SIO_A_DI:       push    BC              ; store BC
 295+ 01C3 0E 22                        ld      C,SIO_CA        ; SIO channel A
 296+ 01C5 3A 3F 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 297+ 01C8 18 06                        jr      SIO_RXDI        ; jump to disable RX
 298+ 01CA C5           SIO_B_DI:       push    BC              ; store BC
 299+ 01CB 0E 23                        ld      C,SIO_CB        ; SIO channel B
 300+ 01CD 3A 40 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 301+ 01D0 47           SIO_RXDI:       ld      B,A             ; store data bits
 302+ 01D1 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 303+ 01D3 ED 79                        out     (C),A
 304+ 01D5 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 305+ 01D6 ED 79                        out     (C),A
 306+ 01D8 C1                           pop     BC              ; retrieve BC
 307+ 01D9 C9                           ret                     ; return
 308+ 01DA
 309+ 01DA              ;-------------------------------------------------------------------------------
 310+ 01DA              ; enable SIO RX channel
 311+ 01DA C5           SIO_A_EI:       push    BC              ; store BC
 312+ 01DB 0E 22                        ld      C,SIO_CA
 313+ 01DD 3A 3F 53                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 314+ 01E0 18 06                        jr      SIO_RXEN
 315+ 01E2 C5           SIO_B_EI:       push    BC              ; store BC
 316+ 01E3 0E 23                        ld      C,SIO_CB
 317+ 01E5 3A 40 53                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 318+ 01E8 47           SIO_RXEN:       ld      B,A             ; store data bits
 319+ 01E9 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 320+ 01EB ED 79                        out     (C),A           ; select register
 321+ 01ED 78                           ld      A,B             ; retrieve data bits
 322+ 01EE CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 323+ 01F0 ED 79                        out     (C),A           ; send settings to SIO
 324+ 01F2 C1                           pop     BC              ; retrieve BC
 325+ 01F3 C9                           ret
 326+ 01F4
 327+ 01F4              ;------------------------------------------------------------------------------
 328+ 01F4              ; put a char into the input buffer, char is into A
 329+ 01F4              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 330+ 01F4              ; the RETURN key is pressed on the keyboard
 331+ 01F4 F5           CHARINTOBFR:    push    AF              ; store it
 332+ 01F5 3A 7A 51                     ld      A,(serBufUsed)  ; load buffer size
 333+ 01F8 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 334+ 01FA DA FF 01                     jp      C,NOTFULL       ; then store the char
 335+ 01FD F1                           pop     AF              ; else drop it
 336+ 01FE C9                           ret                     ; and exit
 337+ 01FF 2A 76 51     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 338+ 0202 23                           inc     HL              ; load pointer to find first free cell
 339+ 0203 7D                           ld      A,L             ; only check low byte because buffer<256
 340+ 0204 FE 76                        cp      bufWrap         ; check if the pointer is at the last cell
 341+ 0206 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 342+ 0208 21 1E 51                     ld      HL,SERBUF_START ; else load the address of the first cell
 343+ 020B 22 76 51     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 344+ 020E F1                           pop     AF              ; then recover the char
 345+ 020F 77                           ld      (HL),A          ; and store it in the appropriate cell
 346+ 0210 3A 7A 51                     ld      A,(serBufUsed)  ; load the size of the input buffer
 347+ 0213 3C                           inc     A               ; increment it
 348+ 0214 32 7A 51                     ld      (serBufUsed),A  ; and store the new size
 349+ 0217 FE 50                        cp      SER_FULLSIZE    ; check if input buffer is full
 350+ 0219 D8                           ret     C               ; exit if buffer is not full
 351+ 021A 3A 3E 53                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 352+ 021D 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 353+ 021E DC 8E 01                     call    C,A_RTS_OFF     ; ...stop receiving further chars
 354+ 0221 AF                           xor     A               ; clear Carry to set a buffer full condition
 355+ 0222 C9                           ret
 356+ 0223
 357+ 0223
 358+ 0223              ;-------------------------------------------------------------------------------
 359+ 0223              ; retrieve a char from the input buffer
 360+ 0223 3A 7A 51     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 361+ 0226 A7                           and     A               ; check if it's 0 (empty)
 362+ 0227 CA 23 02                     jp      Z,RXA           ; if it's empty, wait for a char
 363+ 022A F3                           di                      ; disable interrupts
 364+ 022B E5                           push    HL              ; store HL
 365+ 022C 2A 78 51                     ld      HL,(serRdPtr)   ; load pointer to first available char
 366+ 022F 23                           inc     HL              ; increment it (go to the next char)
 367+ 0230 7D                           ld      A,L             ; check if the end of the buffer has been reached
 368+ 0231 FE 76                        cp      bufWrap         ; (only check low byte because buffer<256)
 369+ 0233 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 370+ 0235 21 1E 51                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 371+ 0238 22 78 51     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 372+ 023B 3A 7A 51                     ld      A,(serBufUsed)  ; load buffer size
 373+ 023E 3D                           dec     A               ; decrement it
 374+ 023F 32 7A 51                     ld      (serBufUsed),A  ; and store the new size
 375+ 0242 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 376+ 0244 30 03                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 377+ 0246 CD A8 01                     call    A_RTS_ON        ; else re-enable receiving chars
 378+ 0249 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 379+ 024A E1                           pop     HL              ; retrieve HL
 380+ 024B FB                           ei                      ; re-enable interrupts
 381+ 024C C9                           ret                     ; return
 382+ 024D
 383+ 024D              ;------------------------------------------------------------------------------
 384+ 024D              ; sends a char over the serial (trick for INTs from WikiTI)
 385+ 024D              ; char is into A
 386+ 024D F5           TXA:            push    AF              ; store AF
 387+ 024E C5                           push    BC              ; store BC
 388+ 024F 47                           ld      B,A             ; store char
 389+ 0250 ED 57                        ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
 390+ 0252 EA 57 02                     jp      PE,CNTTXA       ; if set, jump over
 391+ 0255 ED 57                        ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
 392+ 0257 F5           CNTTXA:         push    AF              ; store current P/V flag
 393+ 0258 F3                           di                      ; disable INTs
 394+ 0259 3A 3E 53                     ld      A,(SERIALS_EN)  ; load serial status
 395+ 025C FE 05                        cp      %00000101       ; check if serial 1 is open and RX/TX is enabled
 396+ 025E 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 397+ 0260 78                           ld      A,B             ; retrieve char
 398+ 0261 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 399+ 0263 CD 6E 02                     call    TX_EMP          ; wait for outgoing char to be sent
 400+ 0266 F1           TXA_EXIT:       pop     AF              ; retrieve P/V flag
 401+ 0267 E2 6B 02                     jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
 402+ 026A FB                           ei                      ; INTs were enabled, so re-enable interrupts
 403+ 026B C1           EXTXA:          pop     BC              ; retrieve BC
 404+ 026C F1                           pop     AF              ; retrieve AF
 405+ 026D C9                           ret                     ; return
 406+ 026E
 407+ 026E              ;------------------------------------------------------------------------------
 408+ 026E              ; wait until outgoing serial has been sent
 409+ 026E 97           TX_EMP:         sub     A               ; set A to 0
 410+ 026F 3C                           inc     A               ; set A to 1
 411+ 0270 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 412+ 0272 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 413+ 0274 CB 47                        bit     0,A             ; check if all chars have been sent
 414+ 0276 CA 6E 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 415+ 0279 C9                           ret                     ; else exit
 416+ 027A
 417+ 027A
 418+ 027A              ;------------------------------------------------------------------------------
 419+ 027A              ; check if there is some chars into the buffer
 420+ 027A 3A 7A 51     CKINCHAR:       ld      A,(serBufUsed)  ; load char in buffer
 421+ 027D A7                           and     A               ; compare to 0
 422+ 027E C9                           ret                     ; return
 423+ 027F
 424+ 027F              ;------------------------------------------------------------------------------
 425+ 027F              ; print a text from memory, and terminate when $00 is found
 426+ 027F 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 427+ 0280 B7                           or      A               ; is it $00 (end string)?
 428+ 0281 C8                           ret     Z               ; Yes, then return
 429+ 0282 32 F9 52                     ld      (CHR4VID),A     ; store char
 430+ 0285 F3                           di
 431+ 0286 CD 4E 07                     call    CHAR2VID        ; and send it to screen
 432+ 0289 FB                           ei
 433+ 028A 23                           inc     HL              ; and select the next one
 434+ 028B 18 F2                        jr      RAWPRINT        ; repeat
 435+ 028D
 436+ 028D              ;-------------------------------------------------
 437+ 028D              ; Interrupt service routine (ISR) for CH3 timer
 438+ 028D              ; this is used to increment the 100ths of a second counter and for cursor flashing
 439+ 028D F5           CH3_TIMER:      push    AF              ; save regs. A,
 440+ 028E C5                           push    BC              ; BC,
 441+ 028F D5                           push    DE              ; DE,
 442+ 0290 E5                           push    HL              ; HL
 443+ 0291 21 DB 52                     ld      HL,TMRCNT       ; load starting address of the timer
 444+ 0294 06 04                        ld      B,$04           ; 4 bytes to check
 445+ 0296 34           INCTMR3:        inc     (HL)            ; increment timer
 446+ 0297 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 447+ 0299 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 448+ 029A 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 449+ 029C CD B8 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 450+ 029F CD DE 0C                     call    MNGSNDS         ; call the tone managemenet
 451+ 02A2 3A DB 52                     ld      A,(TMRCNT)      ; check for keyboard management
 452+ 02A5 1F                           rra                     ; bit 0 = 1 ?
 453+ 02A6 D4 43 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 454+ 02A9 E1                           pop     HL              ; retrieve HL,
 455+ 02AA D1                           pop     DE              ; DE,
 456+ 02AB C1                           pop     BC              ; BC,
 457+ 02AC F1                           pop     AF              ; and A
 458+ 02AD FB                           ei                      ; re-enable interrupts
 459+ 02AE ED 4D                        reti                    ; exit from ISR
 460+ 02B0
 461+ 02B0              ;------------------------------------------------------------------------------
 462+ 02B0              ;               HARDWARE INITIALISATION
 463+ 02B0              ;------------------------------------------------------------------------------
 464+ 02B0              ; first run - setup HW & SW
 465+ 02B0              ; (on LN80C 64K runs from RAM)
 466+ 02B0 21 AD 52     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 467+ 02B3 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 468+ 02B4 21 1E 51                     ld      HL,SERBUF_START ; set beginning of input buffer
 469+ 02B7 22 76 51                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 470+ 02BA 22 78 51                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 471+ 02BD AF                           xor     A               ; reset A
 472+ 02BE 32 7A 51                     ld      (serBufUsed),A  ; actual buffer size is 0
 473+ 02C1 32 3E 53                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 474+ 02C4                  IFDEF LM80C
 475+ 02C4 ~                            call    HELLOWRLD       ; little serial blink with LEDs
 476+ 02C4                  ENDIF
 477+ 02C4 CD 42 03                     call    initCTC         ; configure CTC, then...
 478+ 02C7 CD 7C 0C                     call    initPSG         ; ...configure PSG
 479+ 02CA CD F4 04                     call    SHOW_LOGO       ; show computer logo
 480+ 02CD 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 481+ 02CF CD D3 03                     call    initVDP         ; set video display
 482+ 02D2 AF                           xor     A
 483+ 02D3 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 484+ 02D5 ED 5E                        im      2               ; interrupt mode 2
 485+ 02D7 FB                           ei                      ; enable interrupts
 486+ 02D8                              ; print system messages
 487+ 02D8 AF                           xor     A               ; A=0 so...
 488+ 02D9 32 36 53                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 489+ 02DC 3C                           inc     A               ; A=1...
 490+ 02DD 32 F8 52                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 491+ 02E0 21 78 03                     ld      HL,MSGTXT1      ; sign-on message
 492+ 02E3 CD 7F 02                     call    RAWPRINT        ; print message
 493+ 02E6 3A 7B 51                     ld      A,(basicStarted); check if BASIC is already started
 494+ 02E9 FE 59                        cp      'Y'             ; to see if this is a power-up
 495+ 02EB 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 496+ 02ED 21 B6 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 497+ 02F0 CD 7F 02                     call    RAWPRINT        ; print message
 498+ 02F3 CD 19 09                     call    CURSOR_ON       ; enable cursor
 499+ 02F6 AF                           xor     A
 500+ 02F7 32 F8 52                     ld      (PRNTVIDEO),A   ; disable print-on-video
 501+ 02FA CD 23 02     CORW:           call    RXA             ; look for a pressed key
 502+ 02FD E6 DF                        and     %11011111       ; only UPPERCASE char
 503+ 02FF FE 43                        cp      'C'             ; cold start?
 504+ 0301 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 505+ 0303 CD 1E 03                     call    ECHO_CHAR       ; echoes the char
 506+ 0306 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 507+ 0308 32 7B 51                     ld      (basicStarted),A
 508+ 030B CD 2E 09                     call    CURSOR_OFF      ; disable cursor
 509+ 030E C3 E2 11                     jp      COLD            ; start BASIC COLD
 510+ 0311 FE 57        CHECKWARM:      cp      'W'
 511+ 0313 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 512+ 0315 CD 1E 03                     call    ECHO_CHAR       ; echoes the char
 513+ 0318 CD 2E 09                     call    CURSOR_OFF      ; disable cursor
 514+ 031B C3 E5 11                     jp      WARM            ; start BASIC WARM
 515+ 031E
 516+ 031E              ;-------------------------------------------------------------------------------
 517+ 031E              ; send back char received through ch. A
 518+ 031E 32 F9 52     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 519+ 0321 AF                           xor     A
 520+ 0322 32 36 53                     ld      (KBDNPT),A      ; input is not from keyboard
 521+ 0325 F3                           di                      ; disable INTs
 522+ 0326 CD 4E 07                     call    CHAR2VID        ; echoes back the pressed key,
 523+ 0329 3E 0D                        ld      A,CR            ; then set a CR
 524+ 032B 32 F9 52                     ld      (CHR4VID),A     ; set char for video printing
 525+ 032E CD 4E 07                     call    CHAR2VID        ; and send it to screen
 526+ 0331 FB                           ei                      ; re-enable INTs
 527+ 0332 3E 01                        ld      A,$01
 528+ 0334 32 F8 52                     ld      (PRNTVIDEO),A   ; re-enable video printing
 529+ 0337 C9                           ret                     ; return to caller
 530+ 0338
 531+ 0338                  IFDEF LM80C
 532+ 0338 ~            ;-------------------------------------------------------------------------------
 533+ 0338 ~            ; little serial blink with LEDs
 534+ 0338 ~            HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
 535+ 0338 ~                            ld      A,%11001111     ; set mode 3 (mode control)
 536+ 0338 ~                            out     (PIO_CB),A      ; for PIO port B
 537+ 0338 ~                            xor     A               ; set pins to OUTPUT
 538+ 0338 ~                            out     (PIO_CB),A      ; for port B
 539+ 0338 ~                            inc     A               ; LSB on
 540+ 0338 ~            LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
 541+ 0338 ~                            ld      E,$20           ; little delay
 542+ 0338 ~            DEC_E:          ld      B,$00           ; count to 256
 543+ 0338 ~            COUNTER:        djnz    COUNTER         ; decrement inner counter
 544+ 0338 ~                            dec     E               ; decrement outer counter
 545+ 0338 ~                            jr      NZ,DEC_E        ; finish delay
 546+ 0338 ~                            sla     A               ; shift reg.A to left 1 bit
 547+ 0338 ~                            dec     C               ; next LED
 548+ 0338 ~                            jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
 549+ 0338 ~                            ret                     ; return to caller
 550+ 0338                  ENDIF
 551+ 0338              ;-------------------------------------------------------------------------------
 552+ 0338              ; Z80 SIO default settings for serial channels
 553+ 0338 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 554+ 0339 18                           defb    %00011000       ; write into WR0: channel reset
 555+ 033A 04                           defb    %00000100       ; write into WR0: select WR4
 556+ 033B 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 557+ 033C 05                           defb    %00000101       ; write into WR0: select WR5
 558+ 033D E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 559+ 033E 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 560+ 033F 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 561+ 0340 02                           defb    %00000010       ; write into WR0: select WR2
 562+ 0341 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 563+ 0342                                                      ; will be affected by the channel & condition that raised the interrupt
 564+ 0342                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 565+ 0342                                                      ; for special conditions
 566+ 0342              ;------------------------------------------------------------------------------
 567+ 0342              ;               Z80 CTC SETTING UP
 568+ 0342              ;------------------------------------------------------------------------------
 569+ 0342              initCTC:
 570+ 0342 21 6C 03                     ld      HL,CTCCONF      ; CTC configuration
 571+ 0345 11 DF 52                     ld      DE,CTC0IV       ; CTC interrupt vector table
 572+ 0348 01 0C 00                     ld      BC,$000C        ; 12 bytes
 573+ 034B ED B0                        ldir                    ; copy data
 574+ 034D              ;CH0, CH1, & CH2 disabled
 575+ 034D 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 576+ 034F                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 577+ 034F D3 10                        out     (CTC_CH0),A     ; set CH0
 578+ 0351 D3 11                        out     (CTC_CH1),A     ; set CH1
 579+ 0353 D3 12                        out     (CTC_CH2),A     ; set CH2
 580+ 0355              ;init CH3
 581+ 0355              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 582+ 0355              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 583+ 0355 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 584+ 0357                                                      ; time constant follows; cont. operation; command word
 585+ 0357 D3 13                        out     (CTC_CH3),A     ; send to CH3
 586+ 0359 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 587+ 035B D3 13                        out     (CTC_CH3),A     ; send to CH3
 588+ 035D 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 589+ 035F                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 590+ 035F                                                      ; so int vector is 01000xx00
 591+ 035F D3 10                        out     (CTC_CH0),A     ; send to CTC
 592+ 0361                              ; reset cells of 100ths of a second counter
 593+ 0361 AF                           xor     A               ; reset A
 594+ 0362 21 DB 52                     ld      HL,TMRCNT       ; load TMR pointer
 595+ 0365 06 04                        ld      B,$04           ; 4 memory cells
 596+ 0367 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 597+ 0368 23                           inc     HL              ; next cell
 598+ 0369 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 599+ 036B C9                           ret
 600+ 036C
 601+ 036C
 602+ 036C              ;------------------------------------------------------------------------------
 603+ 036C              ; jump table for CHx interrupts
 604+ 036C FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 605+ 036F FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 606+ 0372 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 607+ 0375 C3 8D 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 608+ 0378
 609+ 0378
 610+ 0378              ;------------------------------------------------------------------------------
 611+ 0378              ; welcome messages
 612+ 0378              MSGTXT1:
 613+ 0378                  IFDEF LM80C64K
 614+ 0378 20 20 20 20                  defm    "    LM80C 64K Color Computer",CR
 614+ 037C 4C 4D 38 30
 614+ 0380 43 20 36 34
 614+ 0384 4B 20 43 6F
 614+ 0388 6C 6F 72 20
 614+ 038C 43 6F 6D 70
 614+ 0390 75 74 65 72
 614+ 0394 0D
 615+ 0395                  ELSE
 616+ 0395 ~                            defm    "      LM80C Color Computer",CR
 617+ 0395                  ENDIF
 618+ 0395 20 62 79 20                  defm    " by Leonardo Miliani * FW R","1.04",CR,0
 618+ 0399 4C 65 6F 6E
 618+ 039D 61 72 64 6F
 618+ 03A1 20 4D 69 6C
 618+ 03A5 69 61 6E 69
 618+ 03A9 20 2A 20 46
 618+ 03AD 57 20 52 31
 618+ 03B1 2E 30 34 0D
 618+ 03B5 00
 619+ 03B6 0D           MSGTXT2:        defb    CR
 620+ 03B7 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 620+ 03BB 43 3E 6F 6C
 620+ 03BF 64 20 6F 72
 620+ 03C3 20 3C 57 3E
 620+ 03C7 61 72 6D 20
 620+ 03CB 73 74 61 72
 620+ 03CF 74 3F 20 00
 621+ 03D3
# file closed: ../include/bootloader/bootloader-1.05.asm
  70  03D3
  71  03D3              ; incude the latest version of the VDP module
  72  03D3                  INCLUDE "../include/vdp/vdp-1.3.asm"
# file opened: ../include/vdp/vdp-1.3.asm
   1+ 03D3              ; ------------------------------------------------------------------------------
   2+ 03D3              ; LM80C - VDP ROUTINES - 1.3
   3+ 03D3              ; ------------------------------------------------------------------------------
   4+ 03D3              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03D3              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03D3              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03D3              ; kind of warranty: you can use them at your own risk.
   8+ 03D3              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03D3              ; maintain the copyright notices, include this advice and the note to the
  10+ 03D3              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03D3              ; redistribuite them.
  12+ 03D3              ; https://www.leonardomiliani.com
  13+ 03D3              ;
  14+ 03D3              ; Please support me by visiting the following links:
  15+ 03D3              ; Main project page: https://www.leonardomiliani.com
  16+ 03D3              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03D3              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03D3              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03D3              ; ------------------------------------------------------------------------------
  20+ 03D3              ;
  21+ 03D3              ;------------------------------------------------------------------------------
  22+ 03D3              ; VDP INITIALISATION
  23+ 03D3              ; initialize VDP for a specific graphics mode
  24+ 03D3              ; INPUT: E -> contains the graphics mode:
  25+ 03D3              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03D3 D5           initVDP:        push    DE              ; store E
  27+ 03D4 CD BA 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03D7 CD D8 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03DA CD CD 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03DD D1                           pop     DE              ; restore reg. E
  31+ 03DE AF                           xor     A               ; reset A
  32+ 03DF 47                           ld      B,A             ; reset B (will be used later)
  33+ 03E0 7B                           ld      A,E             ; move E into A
  34+ 03E1 32 ED 52                     ld      (SCR_MODE),A    ; store screen mode
  35+ 03E4 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 03E6 CA 22 04                     jp      Z,G1MD          ; yes, jump over
  37+ 03E9 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 03EB CA 62 04                     jp      Z,G2MD          ; yes, jump over
  39+ 03EE FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 03F0 CA 84 04                     jp      Z,MCMD          ; yes, jump over
  41+ 03F3 FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 03F5 CA A7 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 03F8                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 03F8
  45+ 03F8              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 03F8
  47+ 03F8                              ; TEXT MODE (G0)
  48+ 03F8                              ; load charset
  49+ 03F8 60           TXTMD:          ld      H,B
  50+ 03F9 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 03FA CD F4 0A                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 03FD                              ; set cursor & video overlay
  53+ 03FD AF                           xor     A               ; reset A
  54+ 03FE 32 F1 52                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 0401 32 F2 52                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 0404 3E 05                        ld      A,$05           ; light blue
  57+ 0406 32 FB 52                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0409 3E 28                        ld      A,$28
  59+ 040B 32 EB 52                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 040E 3E 18                        ld      A,$18
  61+ 0410 32 EC 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 0413 3E 1E                        ld      A,$1E
  63+ 0415 32 C1 51                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0418 11 00 08                     ld      DE,$0800
  65+ 041B ED 53 EF 52                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 041F C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 0422
  68+ 0422                              ; GRAPHICS 1 MODE (G1)
  69+ 0422                              ; load pattern table
  70+ 0422 68           G1MD:           ld      L,B
  71+ 0423 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 0424 CD F4 0A                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0427                              ; set cursor & video overlay
  74+ 0427 AF                           xor     A               ; position cursor
  75+ 0428 32 F1 52                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 042B 32 F2 52                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 042E 3E 20                        ld      A,$20
  78+ 0430 32 EB 52                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 0433 3E 18                        ld      A,$18
  80+ 0435 32 EC 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0438 3E 14                        ld      A,$14
  82+ 043A 32 C1 51                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 043D 11 00 18                     ld      DE,$1800
  84+ 0440 ED 53 EF 52                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 0444                              ; load color table
  86+ 0444 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0447 CD 5D 06                     call    SETVDPADRS
  88+ 044A 3E 01                        ld      A,$01           ; foreground color...
  89+ 044C 32 FA 52                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 044F 3E 0F                        ld      A,$0F           ; background color...
  91+ 0451 32 FB 52                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 0454 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0456 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0458 0D                           dec     C              ; VDP data mode
  95+ 0459 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 045B 00                           nop
  97+ 045C 00                           nop
  98+ 045D 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 045F C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 0462
 101+ 0462                              ; GRAPHICS 2 MODE (G2)
 102+ 0462 AF           G2MD:           xor     A               ; position cursor
 103+ 0463 32 F1 52                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0466 32 F2 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0469 32 EB 52                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 046C 3C                           inc     A               ; black on...
 107+ 046D 32 FA 52                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 0470 3E 0F                        ld      A,$0F           ; white on...
 109+ 0472 32 FB 52                     ld      (BKGNDCLR),A    ; ...background
 110+ 0475 3E C0                        ld      A,$C0
 111+ 0477 32 EC 52                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 047A 11 00 18                     ld      DE,$1800
 113+ 047D ED 53 EF 52                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 0481 C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 0484
 116+ 0484                              ; MULTICOLOR MODE (G3)
 117+ 0484 AF           MCMD:           xor     A               ; position cursor
 118+ 0485 32 F1 52                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 0488 32 F2 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 048B 3E 0F                        ld      A,$0F           ; white color for...
 121+ 048D 32 FB 52                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 0490 32 FA 52                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 0493 3E 40                        ld      A,$40
 124+ 0495 32 EB 52                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 0498 3E 30                        ld      A,$30
 126+ 049A 32 EC 52                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 049D 11 00 08                     ld      DE,$0800
 128+ 04A0 ED 53 EF 52                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04A4 C3 E9 04                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04A7
 131+ 04A7                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04A7              EXG2MD:         ; load pattern table
 133+ 04A7 60                           ld      H,B
 134+ 04A8 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04A9 CD F4 0A                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04AC                              ; set cursor & video overlay
 137+ 04AC AF                           xor     A               ; position cursor
 138+ 04AD 32 F1 52                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04B0 32 F2 52                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04B3 3E 20                        ld      A,$20
 141+ 04B5 32 EB 52                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04B8 3E 18                        ld      A,$18
 143+ 04BA 32 EC 52                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04BD 3E 14                        ld      A,$14
 145+ 04BF 32 C1 51                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04C2 11 00 38                     ld      DE,$3800
 147+ 04C5 ED 53 EF 52                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04C9                               ; load color table
 149+ 04C9 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04CC CD 5D 06                     call    SETVDPADRS
 151+ 04CF 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04D1 32 FA 52                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04D4 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04D6 32 FB 52                     ld      (BKGNDCLR),A    ; ...background
 155+ 04D9 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04DB 16 08                        ld      D,$08           ; 8 pages of
 157+ 04DD 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04DF 0D                           dec     C              ; VDP data mode
 159+ 04E0 ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 04E2 00                           nop
 161+ 04E3 00                           nop
 162+ 04E4 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 04E6 15                           dec     D               ; did we fill up all the cells?
 164+ 04E7 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 04E9                              ; LAST VDP SETTINGS
 166+ 04E9 CD 2E 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 04EC CD CE 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 04EF AF                           xor     A
 169+ 04F0 32 F5 52                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 04F3 C9                           ret                     ; return to caller
 171+ 04F4
 172+ 04F4
 173+ 04F4              ; show initial logo
 174+ 04F4 CD BA 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 04F7                              ; set VDP for G2 mode
 176+ 04F7 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 04F9 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 04FC CD E0 0A                     call    SET_GFX_MODE2   ; load register settings
 179+ 04FF 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 0501 ED 51                        out     (C),D           ; send data to VDP
 181+ 0503 ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0505                              ; set name table
 183+ 0505 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0508 CD 4B 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 050B CD 6E 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 050E                              ; set colors for logo
 187+ 050E 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 0511 CD 5D 06                     call    SETVDPADRS
 189+ 0514 06 05                        ld      B,$05           ; 5 bands
 190+ 0516 21 B9 05                     ld      HL,CLRTABLE
 191+ 0519 0D                           dec     C              ; set VDP_DAT
 192+ 051A 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 051C 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 051E 7E                           ld      A,(HL)          ; load data
 195+ 051F ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 0521 00                           nop                     ; little delay
 197+ 0522 1D                           dec     E               ; decrement counter
 198+ 0523 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0525 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0527 15                           dec     D               ; decrement char band counter
 201+ 0528 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 052A 23                           inc     HL              ; next pattern
 203+ 052B 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 052D                              ; set pattern table
 205+ 052D 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 0530 11 3C 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0533 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 208+ 0535 CD 99 05     RPT103:         call    LOADLOGOCHRS
 209+ 0538 13                           inc     DE              ; next logo pattern
 210+ 0539 10 FA                        djnz    RPT103
 211+ 053B 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 053D CD 99 05     RPT104:         call    LOADLOGOCHRS
 213+ 0540 13                           inc     DE              ; next logo pattern
 214+ 0541 10 FA                        djnz    RPT104
 215+ 0543                              ; show logo/message, play a beep, check for SHIFT pressure (to disable DOS), and wait a while
 216+ 0543 06 02                        ld      B,$02           ; two times
 217+ 0545 AF                           xor     A               ; reset A
 218+ 0546 57                           ld      D,A             ; 256 times
 219+ 0547 5F                           ld      E,A             ; x 256 times
 220+ 0548 32 FC 52                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 054B                  IFDEF LM80C64K
 222+ 054B 3C                           inc     A               ; by default, I/O DOS buffer is enabled on LM80C 64K, disabled on LM80C
 223+ 054C                  ENDIF
 224+ 054C 32 41 53                     ld      (DOS_EN),A      ; DOS enabled
 225+ 054F 00           DEC_D:          nop                     ; does nothing...
 226+ 0550 00                           nop
 227+ 0551 00                           nop
 228+ 0552 00                           nop
 229+ 0553 00                           nop
 230+ 0554 00                           nop                     ; ...until here
 231+ 0555 1D                           dec     E               ; decrement E
 232+ 0556 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 233+ 0558 7A                           ld      A,D
 234+ 0559 FE 40                        cp      $40             ; ...equal to 64
 235+ 055B CC 85 05                     call    Z,SETBEEP       ; if yes, start sound
 236+ 055E 15                           dec     D
 237+ 055F 20 EE                        jr      NZ,DEC_D        ; repeat
 238+ 0561 3A FC 52                     ld      A,(TMPBFR1)     ; sound state
 239+ 0564 FE 02                        cp      $02             ; check if sound is to be set off
 240+ 0566 C4 91 05                     call    NZ,BEEPOFF      ; yes
 241+ 0569                  IFDEF LM80C64K
 242+ 0569 CD BE 05                     call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 243+ 056C                                                      ; on LM80C 64K, you can disabled the I/O DOS buffer, on LM80C you can't
 244+ 056C                  ENDIF
 245+ 056C 10 E1                        djnz    DEC_D           ; repeat
 246+ 056E              ERASECLRTBL:    ; erase color table
 247+ 056E 3E 11                        ld      A,$11           ; foreground and background set to black
 248+ 0570 16 0A                        ld      D,$0A           ; 10 pages
 249+ 0572 06 00                        ld      B,$00           ; 256 color cells per page
 250+ 0574 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 251+ 0577 CD 5D 06                     call    SETVDPADRS      ; send address
 252+ 057A 0D                           dec     C              ; VDP address for passing data
 253+ 057B ED 79        RPT100:         out     (C),A           ; send data
 254+ 057D 00                           nop
 255+ 057E 00                           nop                     ; little delay
 256+ 057F 10 FA                        djnz    RPT100          ; repeat for entire page
 257+ 0581 15                           dec     D
 258+ 0582 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 259+ 0584 C9                           ret                     ; return to caller
 260+ 0585
 261+ 0585              ; play a beep
 262+ 0585 3A FC 52     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 263+ 0588 B7                           or      A               ; is it 0?
 264+ 0589 C0                           ret     NZ              ; no, exit
 265+ 058A 3C                           inc     A               ; flag to 1
 266+ 058B 32 FC 52                     ld      (TMPBFR1),A     ; set sound
 267+ 058E C3 AA 0C                     jp      WLCMBEEP        ; play a beep & return
 268+ 0591
 269+ 0591              ; beep off
 270+ 0591 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 271+ 0593 32 FC 52                     ld      (TMPBFR1),A     ; set flag
 272+ 0596 C3 B0 0C                     jp      NOBEEP          ; stop beep and return
 273+ 0599
 274+ 0599
 275+ 0599              ; used to load the chars that will compose the logo of the splash screen
 276+ 0599 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 277+ 059A 87                           add     A,A
 278+ 059B 87                           add     A,A
 279+ 059C 87                           add     A,A             ; multiply times 8 to get the offset
 280+ 059D C5                           push    BC
 281+ 059E D5                           push    DE              ; store BC and DE
 282+ 059F E5                           push    HL              ; store VRAM address to write to
 283+ 05A0 21 1A 50                     ld      HL,LOGOFONT     ; start of logo font data
 284+ 05A3 5F                           ld      E,A
 285+ 05A4 16 00                        ld      D,$00           ; put offset (A) into DE
 286+ 05A6 19                           add     HL,DE           ; get address of pattern data
 287+ 05A7 EB                           ex      DE,HL           ; move address into DE
 288+ 05A8 E1                           pop     HL              ; retrieve VRAM address
 289+ 05A9 06 08                        ld      B,$08           ; 8 bytes per pattern
 290+ 05AB CD 5D 06                     call    SETVDPADRS      ; set VDP address
 291+ 05AE 0D                           dec     C              ; VDP_DAT
 292+ 05AF 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 293+ 05B0 ED 79                        out     (C),A           ; and send to VRAM
 294+ 05B2 13                           inc     DE              ; next byte into RAM
 295+ 05B3 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 296+ 05B4 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 297+ 05B6 D1                           pop     DE
 298+ 05B7 C1                           pop     BC              ; retrieve BC & DE
 299+ 05B8 C9                           ret                     ; return to caller
 300+ 05B9              CLRTABLE:       equ $
 301+ 05B9 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 301+ 05BD 1D
 302+ 05BE
 303+ 05BE
 304+ 05BE              ; while showing the logo, check if special key (CTRL) is being pressed
 305+ 05BE              ; if yes, then disable DOS functions recovering RAM
 306+ 05BE F5           CHKSPCK:        push    AF
 307+ 05BF 3E FE                        ld      A,%11111110     ; select CTRL row
 308+ 05C1 CD 2E 0D                     call    READKBLN        ; read row
 309+ 05C4 CB 57                        bit     2,A             ; test if CTRL key is pressed
 310+ 05C6 20 04                        jr      NZ,LVCKSPLK     ; no, leave
 311+ 05C8 AF                           xor     A               ; yes, so...
 312+ 05C9 32 41 53                     ld      (DOS_EN),A      ; ...disable DOS
 313+ 05CC F1           LVCKSPLK:       pop     AF
 314+ 05CD C9                           ret
 315+ 05CE
 316+ 05CE
 317+ 05CE              ; empty video buffer
 318+ 05CE 3A ED 52     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 319+ 05D1 FE 02                        cp      $02             ; is it G2 mode?
 320+ 05D3 CA F6 05                     jp      Z,EMPTYG2       ; yes, jump over
 321+ 05D6 FE 03                        cp      $03             ; is it MC mode?
 322+ 05D8 CA 26 06                     jp      Z,EMPTYMC       ; yes, jump over
 323+ 05DB 3A EC 52                     ld      A,(SCR_SIZE_H)  ; load height of screen
 324+ 05DE 47                           ld      B,A             ; move rows into B
 325+ 05DF AF                           xor     A               ; filling char is $00
 326+ 05E0 2A EF 52                     ld      HL,(SCR_NAM_TB) ; load the name table address
 327+ 05E3 CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 328+ 05E6 0D                           dec     C              ; VDP address for passing data
 329+ 05E7 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 330+ 05E8 3A EB 52                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 331+ 05EB 57                           ld      D,A             ; move A into D
 332+ 05EC 7B                           ld      A,E             ; recover filling char
 333+ 05ED ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 334+ 05EF 00                           nop
 335+ 05F0 15                           dec     D               ; decr. D
 336+ 05F1 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 337+ 05F3 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 338+ 05F5 C9                           ret                     ; return to caller
 339+ 05F6 2A EF 52     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 340+ 05F9 CD 4B 06                     call    SETNAMETABLE    ; set name table
 341+ 05FC 21 00 00                     ld      HL,$0000        ; set pattern table
 342+ 05FF CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 343+ 0602 AF                           xor     A               ; empty pattern
 344+ 0603 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 345+ 0605 47                           ld      B,A             ; 256 bytes for page
 346+ 0606 0D                           dec     C              ; VDP data mode
 347+ 0607 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 348+ 0609 00                           nop                     ; little delay
 349+ 060A 00                           nop
 350+ 060B 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 351+ 060D 15                           dec     D               ; next page
 352+ 060E 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 353+ 0610 21 00 20                     ld      HL,$2000        ; load the color table address
 354+ 0613 CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 355+ 0616 3A FA 52                     ld      A,(FRGNDCLR)    ; load foreground
 356+ 0619 87                           add     A,A
 357+ 061A 87                           add     A,A
 358+ 061B 87                           add     A,A
 359+ 061C 87                           add     A,A             ; move to high nibble
 360+ 061D 57                           ld      D,A             ; store into D
 361+ 061E 3A FB 52                     ld      A,(BKGNDCLR)    ; load background color
 362+ 0621 B2                           or      D               ; combine with background color
 363+ 0622 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 364+ 0624 18 17                        jr      STARTEMPTY
 365+ 0626 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 366+ 0629 CD 4B 06                     call    SETNAMETABLE    ; set name table
 367+ 062C 21 00 00                     ld      HL,$0000        ; color table address
 368+ 062F CD 5D 06                     call    SETVDPADRS      ; send address to VDP
 369+ 0632 3A FB 52                     ld      A,(BKGNDCLR)    ; load background
 370+ 0635 57                           ld      D,A             ; store into D
 371+ 0636 87                           add     A,A
 372+ 0637 87                           add     A,A
 373+ 0638 87                           add     A,A
 374+ 0639 87                           add     A,A             ; move to high nibble
 375+ 063A B2                           or      D               ; set background color for high and low nibble
 376+ 063B 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 377+ 063D 0E 30        STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
 378+ 063F 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 379+ 0641 ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 380+ 0643 00                           nop                     ; wait a while
 381+ 0644 00                           nop
 382+ 0645 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 383+ 0647 15                           dec     D               ; have we filled all the pages?
 384+ 0648 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 385+ 064A C9                           ret                     ; return to caller
 386+ 064B
 387+ 064B              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 388+ 064B CD 5D 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 389+ 064E 0D                           dec     C              ; VDP address for passing data
 390+ 064F 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 391+ 0651 AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 392+ 0652 47                           ld      B,A             ; reset B
 393+ 0653 ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 394+ 0655 00                           nop
 395+ 0656 3C                           inc     A               ; increment # of name
 396+ 0657 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 397+ 0659 15                           dec     D               ; did we fill all the pages?
 398+ 065A 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 399+ 065C C9                           ret                     ; return to caller
 400+ 065D
 401+ 065D              ; set an address into VRAM: address is in HL - HL is changed after it
 402+ 065D 0E 32        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 403+ 065F CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 404+ 0661 ED 69                        out     (C),L           ; send low and...
 405+ 0663 ED 61                        out     (C),H           ; ...high byte of the first cell
 406+ 0665 C9                           ret                     ; return to caller
 407+ 0666
 408+ 0666              ; clear the video buffer and position the cursor at 0,0
 409+ 0666 CD CE 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 410+ 0669 AF                           xor     A               ; reset A
 411+ 066A 32 F1 52                     ld      (SCR_CURS_X),A  ; cursor X to 0
 412+ 066D 32 F2 52                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 413+ 0670 C3 B9 06                     jp      POS_CURSOR      ; position cursor & return to caller
 414+ 0673
 415+ 0673              ; HOME: position the cursor at coords. 0,0
 416+ 0673 AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 417+ 0674 32 F4 52                     ld      (SCR_CUR_NY),A  ; ...new Y...
 418+ 0677 32 F3 52                     ld      (SCR_CUR_NX),A  ; ...and new X
 419+ 067A C3 C3 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 420+ 067D
 421+ 067D              ; load the char or byte at the VRAM position set by HL
 422+ 067D              ; value is returned into A
 423+ 067D C5           READ_VIDEO_LOC: push    BC              ; store BC
 424+ 067E 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 425+ 0680 44                           ld      B,H
 426+ 0681 CB B8                        res     7,B
 427+ 0683 CB B0                        res     6,B
 428+ 0685 ED 69                        out     (C),L           ; low byte then...
 429+ 0687 ED 41                        out     (C),B           ; high byte
 430+ 0689 0D                           dec     C              ; VDP data mode
 431+ 068A 00                           nop                     ; wait...
 432+ 068B 00                           nop                     ; ...a while
 433+ 068C 00                           nop
 434+ 068D                  IFDEF LM80C64K
 435+ 068D 00                           nop
 436+ 068E                  ENDIF
 437+ 068E ED 78                        in      A,(C)           ; read byte at current VRAM location
 438+ 0690 C1                           pop     BC              ; restore BC
 439+ 0691 C9                           ret                     ; return to caller
 440+ 0692
 441+ 0692              ; write a byte at the VRAM position pointed by HL
 442+ 0692              ; value is in A
 443+ 0692 C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 444+ 0693 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 445+ 0695 44                           ld      B,H             ; copy H into B
 446+ 0696 CB B8                        res     7,B
 447+ 0698 CB F0                        set     6,B             ; write to VRAM
 448+ 069A ED 69                        out     (C),L           ; low byte then...
 449+ 069C ED 41                        out     (C),B           ; high byte of VRAM address
 450+ 069E 0D                           dec     C              ; VDP data mode
 451+ 069F 00                           nop                     ; wait...
 452+ 06A0 00                           nop                     ; ...a while
 453+ 06A1 00                           nop
 454+ 06A2                  IFDEF LM80C64K
 455+ 06A2 00                           nop
 456+ 06A3                  ENDIF
 457+ 06A3 ED 79                        out     (C),A           ; write byte into VRAM
 458+ 06A5 C1                           pop     BC              ; restore BC
 459+ 06A6 C9                           ret                     ; return to caller
 460+ 06A7
 461+ 06A7              ; write a value into a specific VDP register
 462+ 06A7              ; value is in E, register is in A
 463+ 06A7 C5           WRITE_VREG:     push    BC              ; store BC
 464+ 06A8 C6 80                        add     A,$80           ; set VDP to write to registers
 465+ 06AA 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 466+ 06AC ED 59                        out     (C),E           ; send data to VDP
 467+ 06AE ED 79                        out     (C),A           ; select the destination register
 468+ 06B0 C1                           pop     BC              ; restore BC
 469+ 06B1 C9                           ret                     ; return to caller
 470+ 06B2
 471+ 06B2              ; read VDP status register and return value into A
 472+ 06B2 C5           READ_VSTAT:     push    BC              ; store BC
 473+ 06B3 0E 32                        ld      C,VDP_SET       ; VDP register access
 474+ 06B5 ED 78                        in      A,(C)           ; read status register
 475+ 06B7 C1                           pop     BC              ; restore BC
 476+ 06B8 C9                           ret                     ; return to caller
 477+ 06B9
 478+ 06B9              ; position the cursor at the current coordinates, preserving underlying char
 479+ 06B9 CD FC 06     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 480+ 06BC CD 7D 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 481+ 06BF 32 F5 52                     ld      (SCR_ORG_CHR),A ; store the current char
 482+ 06C2 C9                           ret
 483+ 06C3
 484+ 06C3              ; move cursor to new X,Y coordinates
 485+ 06C3 CD F3 06     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 486+ 06C6 CD DE 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 487+ 06C9 CD B9 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 488+ 06CC 3A F6 52                     ld      A,(CRSR_STATE)  ; load status of cursor
 489+ 06CF A7                           and     A               ; is cursor off?
 490+ 06D0 C8                           ret     Z               ; yes, return
 491+ 06D1 3A DB 52                     ld      A,(TMRCNT)      ; load timer
 492+ 06D4 E6 20                        and     $20             ; check status of cursor flashing
 493+ 06D6 32 F7 52                     ld      (LSTCSRSTA),A   ; store the last cursor state
 494+ 06D9 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 495+ 06DB C3 92 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 496+ 06DE
 497+ 06DE
 498+ 06DE              ; set new cursor's coordinates
 499+ 06DE 3A F3 52     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 500+ 06E1 32 F1 52                     ld      (SCR_CURS_X),A  ; write new X
 501+ 06E4 3A F4 52                     ld      A,(SCR_CUR_NY)  ; load new Y
 502+ 06E7 32 F2 52                     ld      (SCR_CURS_Y),A  ; write new Y
 503+ 06EA 3E FF                        ld      A,$FF           ; delete new values
 504+ 06EC 32 F3 52                     ld      (SCR_CUR_NX),A  ; of X
 505+ 06EF 32 F4 52                     ld      (SCR_CUR_NY),A  ; and Y
 506+ 06F2 C9                           ret
 507+ 06F3
 508+ 06F3              ; recover char under the cursor and prints it onto the screen
 509+ 06F3 CD FC 06     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 510+ 06F6 3A F5 52                     ld      A,(SCR_ORG_CHR) ; recover old char
 511+ 06F9 C3 92 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 512+ 06FC
 513+ 06FC              ; retrieve cursor position from either current coordinates or next place
 514+ 06FC              ; return address position into HL
 515+ 06FC 3A F2 52     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 516+ 06FF 6F                           ld      L,A             ; move it into reg.L
 517+ 0700 AF                           xor     A               ; reset A
 518+ 0701 67                           ld      H,A             ; reset H
 519+ 0702 47                           ld      B,A             ; reset B
 520+ 0703 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 521+ 0704 11 8A 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 522+ 0707 3A EB 52                     ld      A,(SCR_SIZE_W)  ; load screen width
 523+ 070A FE 28                        cp      $28             ; is it 40 cols?
 524+ 070C 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 525+ 070E 11 5A 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 526+ 0711 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 527+ 0712 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 528+ 0713 23                           inc     HL
 529+ 0714 56                           ld      D,(HL)
 530+ 0715 2A EF 52                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 531+ 0718 19                           add     HL,DE           ; starting address of the current row into name table
 532+ 0719 3A F1 52                     ld      A,(SCR_CURS_X)  ; load cursor X
 533+ 071C 4F                           ld      C,A             ; transfer A into C
 534+ 071D 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 535+ 071E C9                           ret
 536+ 071F
 537+ 071F              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 538+ 071F              ; return them into L,A for X,Y
 539+ 071F D5           HL2XY:          push    DE              ; store DE
 540+ 0720 ED 5B EF 52                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 541+ 0724 AF                           xor     A               ; clear Carry
 542+ 0725 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 543+ 0727 D1                           pop     DE
 544+ 0728 3A EB 52                     ld      A,(SCR_SIZE_W)  ; load screen width
 545+ 072B 4F                           ld      C,A             ; move it into C
 546+ 072C CD F6 3F                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 547+ 072F C9                           ret                     ; return to caller
 548+ 0730
 549+ 0730              ;-------------------------------------------------------------------------------
 550+ 0730              ; char table for jumps
 551+ 0730 19           CHRTBL:         defb    HOME
 552+ 0731 73 06                        defw    ATHOME          ; move the cursor to 0,0
 553+ 0733
 554+ 0733 0C                           defb    CS
 555+ 0734 66 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 556+ 0736
 557+ 0736 0D                           defb    CR
 558+ 0737 AD 09                        defw    CRGRETURN       ; go to the beginning of the next line
 559+ 0739
 560+ 0739 08                           defb    BKSP
 561+ 073A 1C 08                        defw    BACKSPACE       ; move cursor left 1 position
 562+ 073C
 563+ 073C 1C                           defb    CRSLFT
 564+ 073D 5F 08                        defw    CURSORLEFT      ; move cursor left
 565+ 073F
 566+ 073F 1E                           defb    CRSUP
 567+ 0740 AB 08                        defw    CURSORUP        ; move cursor up
 568+ 0742
 569+ 0742 1D                           defb    CRSRGT
 570+ 0743 C4 08                        defw    CURSORRIGHT     ; move cursor right
 571+ 0745
 572+ 0745 1F                           defb    CRSDN
 573+ 0746 F9 08                        defw    CURSORDOWN      ; move cursor up
 574+ 0748
 575+ 0748 1A                           defb    INSRT
 576+ 0749 DB 07                        defw    INSERTKEY       ; insert a space
 577+ 074B
 578+ 074B 0A                           defb    LF
 579+ 074C B7 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 580+ 074E
 581+ 074E              ; send current char to video buffer
 582+ 074E F5           CHAR2VID:       push    AF              ; store AF
 583+ 074F C5                           push    BC              ; store BC
 584+ 0750 D5                           push    DE              ; store DE
 585+ 0751 E5                           push    HL              ; store HL
 586+ 0752 3A F6 52                     ld      A,(CRSR_STATE)  ; store cursor state...
 587+ 0755 F5                           push    AF              ; into stack
 588+ 0756 CD 2E 09                     call    CURSOR_OFF      ; cursor off
 589+ 0759 3A F9 52                     ld      A,(CHR4VID)     ; recover char
 590+ 075C 06 0A                        ld      B,$0A           ; 10 chars to check
 591+ 075E 21 30 07                     ld      HL,CHRTBL       ; address of key table
 592+ 0761 BE           RPTCPCK:        cp      (HL)            ; compare with char
 593+ 0762 23                           inc     HL              ; beginning of sub-routine address
 594+ 0763 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 595+ 0765 5E                           ld      E,(HL)          ; load addres into DE
 596+ 0766 23                           inc     HL
 597+ 0767 56                           ld      D,(HL)
 598+ 0768 EB                           ex      DE,HL           ; move user routine's address into HL
 599+ 0769 11 AA 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 600+ 076C D5                           push    DE              ; store into stack
 601+ 076D E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 602+ 076E 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 603+ 076F 23                           inc     HL              ; ...to the next char code
 604+ 0770 10 EF                        djnz    RPTCPCK         ; repeat
 605+ 0772                              ; it'a not a special char, just print it
 606+ 0772 CD FC 06                     call    LOAD_CRSR_POS   ; recover position of cursor
 607+ 0775 3A F9 52                     ld      A,(CHR4VID)     ; recover char to print
 608+ 0778 CD 92 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 609+ 077B 3A F2 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 610+ 077E 5F                           ld      E,A             ; store cursor Y into E
 611+ 077F 3A F1 52                     ld      A,(SCR_CURS_X)  ; load cursor X
 612+ 0782 3C                           inc     A               ; move 1 step to right
 613+ 0783 21 EB 52                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 614+ 0786 BE                           cp      (HL)            ; have we reached the most right position?
 615+ 0787 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 616+ 0789 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 617+ 078A 7B                           ld      A,E             ; move cursor Y into A
 618+ 078B 21 EC 52                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 619+ 078E BE                           cp      (HL)            ; have we reached the bottom of the screen?
 620+ 078F 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 621+ 0791 D5                           push    DE
 622+ 0792 CD 35 09                     call    SCROLLUP        ; scroll screen up
 623+ 0795 D1                           pop     DE
 624+ 0796 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 625+ 0797 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 626+ 0798 32 F1 52     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 627+ 079B 7B                           ld      A,E             ; recover Y
 628+ 079C 32 F2 52                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 629+ 079F CD B9 06                     call    POS_CURSOR      ; position cursor into new location
 630+ 07A2 3A DB 52                     ld      A,(TMRCNT)      ; load status of cursor flashing
 631+ 07A5 E6 20                        and     $20             ; check cursor state
 632+ 07A7 32 F7 52                     ld      (LSTCSRSTA),A   ; store the last cursor state
 633+ 07AA AF           EXITCHAR2VID:   xor     A               ; reset char
 634+ 07AB 32 F9 52                     ld      (CHR4VID),A     ; to be sent to screen
 635+ 07AE F1                           pop     AF              ; recover cursor state
 636+ 07AF A7                           and     A               ; was it off (A=0)?
 637+ 07B0 C4 19 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 638+ 07B3 E1                           pop     HL              ; restore HL
 639+ 07B4 D1                           pop     DE              ; restore DE
 640+ 07B5 C1                           pop     BC              ; restore BC
 641+ 07B6 F1                           pop     AF              ; restore AF
 642+ 07B7 C9           PLACEHOLDER:    ret                     ; return to caller
 643+ 07B8
 644+ 07B8              ; flash the cursor at the current position
 645+ 07B8              ; (this sub-routine is called by CH3 timer ISR)
 646+ 07B8 3A F6 52     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 647+ 07BB A7                           and     A               ; cursor off (A=0)?
 648+ 07BC C8                           ret     Z               ; yes, return
 649+ 07BD 3A DB 52                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 650+ 07C0 E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 651+ 07C2 21 F7 52                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 652+ 07C5 BE                           cp      (HL)            ; compare current state with last state
 653+ 07C6 C8                           ret     Z               ; same state, no change required - exit
 654+ 07C7 77                           ld      (HL),A          ; save new state
 655+ 07C8 F5                           push    AF              ; store A (keep state for later use)
 656+ 07C9 CD FC 06                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 657+ 07CC F1                           pop     AF              ; recover current state
 658+ 07CD 06 FF                        ld      B,$FF           ; cursor char
 659+ 07CF FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 660+ 07D1 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 661+ 07D3 3A F5 52                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 662+ 07D6 47                           ld      B,A             ; move char into B
 663+ 07D7 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 664+ 07D8 C3 92 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 665+ 07DB
 666+ 07DB
 667+ 07DB              ; insert an empty space at the current position of the cursor, moving the following text
 668+ 07DB              ; 1 cell straight
 669+ 07DB CD F3 06     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 670+ 07DE CD FC 06                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 671+ 07E1 22 FC 52                     ld      (CUR_POS),HL    ; store it
 672+ 07E4 CD 34 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 673+ 07E7                                                      ; DE is the address of the bottom right cell of the screen
 674+ 07E7 22 00 53                     ld      (ENDTXT),HL     ; store it
 675+ 07EA ED 4B FC 52                  ld      BC,(CUR_POS)    ; load starting address
 676+ 07EE AF                           xor     A
 677+ 07EF ED 42                        sbc     HL,BC           ; how many positions to move?
 678+ 07F1 CA C9 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 679+ 07F4 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 680+ 07F6 2A 00 53                     ld      HL,(ENDTXT)     ; load address of the end of text
 681+ 07F9 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 682+ 07FA E5                           push    HL
 683+ 07FB CD B7 3F                     call    CMP16           ; is it the last cell (bottom right) of screen?
 684+ 07FE E1                           pop     HL
 685+ 07FF D2 0A 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 686+ 0802 CD 7D 06                     call    READ_VIDEO_LOC  ; no, so read current char
 687+ 0805 23                           inc     HL              ; next cell
 688+ 0806 CD 92 06                     call    WRITE_VIDEO_LOC ; write into new position
 689+ 0809 2B                           dec     HL              ; decrement to old position
 690+ 080A 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 691+ 080B 79                           ld      A,C
 692+ 080C B0                           or      B               ; finished?
 693+ 080D 20 EA                        jr      NZ,CHKHL        ; no, repeat
 694+ 080F AF           ENDINSRT:       xor     A
 695+ 0810 2A FC 52                     ld      HL,(CUR_POS)
 696+ 0813 32 F5 52                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 697+ 0816 CD 92 06                     call    WRITE_VIDEO_LOC ; empty current video location
 698+ 0819 C3 C9 06                     jp      MOVSHOWCRS      ; re-place cursor
 699+ 081C
 700+ 081C              ; delete the char at the left of the cursor
 701+ 081C CD F3 06     BACKSPACE:      call    RSTCHRCRS       ; restore char
 702+ 081F 2A EF 52                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 703+ 0822 44 4D                        ld      BC,HL           ; store into BC
 704+ 0824 CD FC 06                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 705+ 0827 54 5D                        ld      DE,HL           ; copy into DE
 706+ 0829 AF                           xor     A               ; reset Carry
 707+ 082A ED 42                        sbc     HL,BC           ; check how many chars between
 708+ 082C CA 56 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 709+ 082F ED 53 FC 52                  ld      (CUR_POS),DE    ; store current cursor position
 710+ 0833 CD 34 0A                     call    ENDOFLN         ; check end of text
 711+ 0836 ED 5B FC 52                  ld      DE,(CUR_POS)    ; retrieve cursor position
 712+ 083A AF                           xor     A               ; reset Carry
 713+ 083B ED 52                        sbc     HL,DE           ; check if none follows
 714+ 083D CA 56 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 715+ 0840 44 4D                        ld      BC,HL           ; save numbers of chars to move
 716+ 0842 EB                           ex      DE,HL           ; copy starting position into HL
 717+ 0843 CD 7D 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 718+ 0846 2B                           dec     HL              ; 1 position to left
 719+ 0847 CD 92 06                     call    WRITE_VIDEO_LOC ; write char
 720+ 084A 23                           inc     HL              ; goto next char to copy (2 steps to right)
 721+ 084B 23                           inc     HL
 722+ 084C 0B                           dec     BC              ; decrement # of chars
 723+ 084D 79                           ld      A,C
 724+ 084E B0                           or      B               ; 0 chars?
 725+ 084F 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 726+ 0851 2B                           dec     HL
 727+ 0852 AF                           xor     A
 728+ 0853 CD 92 06                     call    WRITE_VIDEO_LOC ; reset last char
 729+ 0856 CD 88 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 730+ 0859 CD DE 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 731+ 085C C3 C9 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 732+ 085F
 733+ 085F
 734+ 085F              ; move cursor to left
 735+ 085F F5           CURSORLEFT:     push    AF              ; store A
 736+ 0860 3A F1 52                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 737+ 0863 A7                           and     A               ; is it at the most left of the screen (X=0)?
 738+ 0864 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 739+ 0866 3D                           dec     A               ; no, decrement X
 740+ 0867 32 F3 52                     ld      (SCR_CUR_NX),A  ; store new X
 741+ 086A 3A F2 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 742+ 086D 32 F4 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 743+ 0870 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 744+ 0872 3A F2 52     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 745+ 0875 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 746+ 0876 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 747+ 0878 3D                           dec     A               ; no, decrement Y
 748+ 0879 32 F4 52                     ld      (SCR_CUR_NY),A  ; store new Y
 749+ 087C 3A EB 52                     ld      A,(SCR_SIZE_W)  ; load current screen width
 750+ 087F 3D                           dec     A               ; cursor to the most right position (width-0)
 751+ 0880 32 F3 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 752+ 0883 CD C3 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 753+ 0886 F1           EXITCURSORLEFT: pop     AF              ; restore A
 754+ 0887 C9                           ret                     ; return to caller
 755+ 0888
 756+ 0888              ; move cursor 1 position to the left
 757+ 0888 3A F1 52     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 758+ 088B A7                           and     A               ; is it at the most left of the screen (X=0)?
 759+ 088C 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 760+ 088E 3D                           dec     A               ; no, decrement X
 761+ 088F 32 F3 52                     ld      (SCR_CUR_NX),A  ; store new X
 762+ 0892 3A F2 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 763+ 0895 32 F4 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 764+ 0898 C9                           ret                     ; go on moving cursor
 765+ 0899 3A F2 52     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 766+ 089C A7                           and     A               ; is it at the most top of the screen (Y=0)?
 767+ 089D 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 768+ 089F 3D                           dec     A               ; no, decrement Y
 769+ 08A0 32 F4 52                     ld      (SCR_CUR_NY),A  ; store new Y
 770+ 08A3 3A EB 52                     ld      A,(SCR_SIZE_W)  ; load current screen width
 771+ 08A6 3D                           dec     A               ; cursor to the most right position (width-1)
 772+ 08A7 32 F3 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 773+ 08AA C9                           ret                     ; return to caller
 774+ 08AB
 775+ 08AB              ; move cursor up
 776+ 08AB F5           CURSORUP:       push    AF              ; store A
 777+ 08AC 3A F2 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 778+ 08AF A7                           and     A               ; is it at the most top of the screen (Y=0)?
 779+ 08B0 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 780+ 08B2 3D                           dec     A               ; no, decrement Y
 781+ 08B3 32 F4 52                     ld      (SCR_CUR_NY),A  ; store new Y
 782+ 08B6 3A F1 52                     ld      A,(SCR_CURS_X)  ; load current cursor X
 783+ 08B9 32 F3 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 784+ 08BC CD F3 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 785+ 08BF CD C3 06                     call    MOVCRS          ; move cursor into new position
 786+ 08C2 F1           EXITCURSORUP:   pop     AF              ; restore A
 787+ 08C3 C9                           ret                     ; return to caller
 788+ 08C4
 789+ 08C4
 790+ 08C4              ; move cursor to right
 791+ 08C4 F5           CURSORRIGHT:    push    AF              ; store A
 792+ 08C5 C5                           push    BC              ; store B
 793+ 08C6 3A EB 52                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 794+ 08C9 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 795+ 08CA 47                           ld      B,A             ; move A into B
 796+ 08CB 3A F1 52                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 797+ 08CE B8                           cp      B               ; is cursor at the most right position on the screen?
 798+ 08CF 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 799+ 08D1 3C                           inc     A               ; no, so increment X
 800+ 08D2 32 F3 52                     ld      (SCR_CUR_NX),A  ; store new X
 801+ 08D5 3A F2 52                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 802+ 08D8 32 F4 52                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 803+ 08DB 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 804+ 08DD 3A EC 52     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 805+ 08E0 3D                           dec     A               ; decrement it (last row can only be 23)
 806+ 08E1 47                           ld      B,A             ; move bottom into B
 807+ 08E2 3A F2 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 808+ 08E5 B8                           cp      B               ; is the cursor at the bottom of the screen?
 809+ 08E6 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 810+ 08E8 3C                           inc     A               ; no, increment Y
 811+ 08E9 32 F4 52                     ld      (SCR_CUR_NY),A  ; store new Y
 812+ 08EC AF                           xor     A               ; move cursor to top left
 813+ 08ED 32 F3 52                     ld      (SCR_CUR_NX),A  ; store new X
 814+ 08F0 CD F3 06     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 815+ 08F3 CD C3 06                     call    MOVCRS          ; move cursor into new position
 816+ 08F6 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 817+ 08F7 F1                           pop     AF              ; restore A
 818+ 08F8 C9                           ret                     ; return to caller
 819+ 08F9
 820+ 08F9
 821+ 08F9              ; move cursor down
 822+ 08F9 F5           CURSORDOWN:     push    AF              ; store A
 823+ 08FA C5                           push    BC              ; store B
 824+ 08FB 3A EC 52                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 825+ 08FE 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 826+ 08FF 47                           ld      B,A             ; move X into B
 827+ 0900 3A F2 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 828+ 0903 B8                           cp      B               ; is current cursor position < 23?
 829+ 0904 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 830+ 0906 3C                           inc     A               ; yes, increment Y
 831+ 0907 32 F4 52                     ld      (SCR_CUR_NY),A  ; store new Y
 832+ 090A 3A F1 52                     ld      A,(SCR_CURS_X)  ; load current cursor X
 833+ 090D 32 F3 52                     ld      (SCR_CUR_NX),A  ; set new cursor X
 834+ 0910 CD F3 06                     call    RSTCHRCRS       ; restore char under the cursor and print it
 835+ 0913 CD C3 06                     call    MOVCRS          ; move cursor into new position
 836+ 0916 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 837+ 0917 F1                           pop     AF              ; retrieve A
 838+ 0918 C9                           ret                     ; return to caller
 839+ 0919
 840+ 0919
 841+ 0919              ; set cursor on (visible on screen)
 842+ 0919 F5           CURSOR_ON:      push    AF              ; store AF
 843+ 091A 3A F6 52                     ld      A,(CRSR_STATE)  ; load cursor state
 844+ 091D B7                           or      A               ; is it on?
 845+ 091E 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 846+ 0920 3A EC 52                     ld      A,(SCR_SIZE_H)  ; check the video mode
 847+ 0923 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 848+ 0925 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 849+ 0927 3E 01                        ld      A,$01           ; cursor state ON
 850+ 0929 32 F6 52                     ld      (CRSR_STATE),A  ; set state
 851+ 092C F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 852+ 092D C9                           ret                     ; return to caller
 853+ 092E
 854+ 092E              ; set cursor off (invisible on screen)
 855+ 092E F5           CURSOR_OFF:     push    AF              ; store AF
 856+ 092F AF                           xor     A               ; cursor state OFF
 857+ 0930 32 F6 52                     ld      (CRSR_STATE),A  ; set state
 858+ 0933 F1                           pop     AF              ; restore AF
 859+ 0934 C9                           ret
 860+ 0935
 861+ 0935              ; scroll the screen 1 row up
 862+ 0935 AF           SCROLLUP:       xor     A
 863+ 0936 32 F8 52                     ld      (PRNTVIDEO),A
 864+ 0939 2A EF 52                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 865+ 093C 22 2C 53                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 866+ 093F 3A EB 52                     ld      A,(SCR_SIZE_W)  ; load the screen width
 867+ 0942 5F                           ld      E,A             ; move width into E
 868+ 0943 16 00                        ld      D,$00           ; reset D
 869+ 0945 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 870+ 0946 22 2E 53                     ld      (VIDTMP2),HL    ; store address of source row
 871+ 0949 3A EC 52                     ld      A,(SCR_SIZE_H)  ; load the screen height
 872+ 094C 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 873+ 094D 47                           ld      B,A             ; move # of rows into B
 874+ 094E 3A EB 52     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 875+ 0951 5F                           ld      E,A             ; move width into E
 876+ 0952 2A 2E 53                     ld      HL,(VIDTMP2)    ; load source address
 877+ 0955 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 878+ 0957 ED 69                        out     (C),L           ; low byte of source
 879+ 0959 ED 61                        out     (C),H           ; high byte of source
 880+ 095B 21 04 53                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 881+ 095E 0D                           dec     C              ; VDP data mode
 882+ 095F ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 883+ 0961 77                           ld      (HL),A          ; store char
 884+ 0962 23                           inc     HL              ; next cell of the buffer
 885+ 0963 1D                           dec     E               ; count the chars to be read
 886+ 0964 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 887+ 0966 3A EB 52                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 888+ 0969 5F                           ld      E,A             ; move # of rows into E
 889+ 096A 16 00                        ld      D,$00           ; reset D
 890+ 096C 2A 2C 53                     ld      HL,(VIDTMP1)    ; load address of destination row
 891+ 096F E5                           push    HL              ; store HL
 892+ 0970 2A 2E 53                     ld      HL,(VIDTMP2)    ; current source will be..
 893+ 0973 22 2C 53                     ld      (VIDTMP1),HL    ; ..new destination
 894+ 0976 19                           add     HL,DE           ; address of new
 895+ 0977 22 2E 53                     ld      (VIDTMP2),HL    ; source row
 896+ 097A E1                           pop     HL              ; restore address of current destination row
 897+ 097B CB F4                        set     6,H             ; writing mode
 898+ 097D 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 899+ 097F ED 69                        out     (C),L           ; low byte
 900+ 0981 ED 61                        out     (C),H           ; high byte of address
 901+ 0983 21 04 53                     ld      HL,VIDEOBUFF    ; video buffer address
 902+ 0986 0D                           dec     C              ; VDP data mode
 903+ 0987 7E           WRITEBUF:       ld      A,(HL)          ; load char
 904+ 0988 ED 79                        out     (C),A           ; send char
 905+ 098A 23                           inc     HL              ; increment buffer index
 906+ 098B 1D                           dec     E               ; next row
 907+ 098C 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 908+ 098E 10 BE                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 909+ 0990 3A EB 52                     ld      A,(SCR_SIZE_W)  ; reload screen width
 910+ 0993 47                           ld      B,A             ; cells to empty into B
 911+ 0994 AF                           xor     A               ; null char
 912+ 0995 0E 32                        ld      C,VDP_SET       ; VDP set mode
 913+ 0997 2A 2C 53                     ld      HL,(VIDTMP1)    ; load address of the last row
 914+ 099A CB F4                        set     6,H             ; writing mode
 915+ 099C ED 69                        out     (C),L           ; low byte then..
 916+ 099E ED 61                        out     (C),H           ; high byte of address
 917+ 09A0 0D                           dec     C              ; VDP data mode
 918+ 09A1 ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 919+ 09A3 00                           nop                     ; delay
 920+ 09A4 00                           nop
 921+ 09A5 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 922+ 09A7 3E 01                        ld      A,$01
 923+ 09A9 32 F8 52                     ld      (PRNTVIDEO),A   ; set print-on-video on
 924+ 09AC C9                           ret                     ; return to caller
 925+ 09AD
 926+ 09AD              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 927+ 09AD              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 928+ 09AD              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 929+ 09AD              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 930+ 09AD              CUR_POS         equ     TMPBFR1         ; cursor position
 931+ 09AD              SRTTXT          equ     TMPBFR2         ; start of text line
 932+ 09AD              ENDTXT          equ     TMPBFR3         ; end of text line
 933+ 09AD              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 934+ 09AD 3A F6 52                     ld      A,(CRSR_STATE)  ; recover cursor state
 935+ 09B0 32 02 53                     ld      (TMPBFR4),A     ; store status
 936+ 09B3 A7                           and     A               ; is cursor on?
 937+ 09B4 C4 2E 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 938+ 09B7 CD F3 06                     call    RSTCHRCRS       ; restore char under it
 939+ 09BA                              ; first, check if cursor if off, so that we just interpret return as a new line command
 940+ 09BA 3A 36 53                     ld      A,(KBDNPT)      ; check if input from keyboad
 941+ 09BD A7                           and     A               ; if 0, input is not from keyboard...
 942+ 09BE CA 13 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 943+ 09C1                              ; first part: look for the beginning of the text line on screen
 944+ 09C1 CD FC 06                     call    LOAD_CRSR_POS   ; load cursor position into HL
 945+ 09C4 22 FC 52                     ld      (CUR_POS),HL    ; store it
 946+ 09C7 ED 5B EF 52                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 947+ 09CB E5           RPTNLLSRC:      push    HL
 948+ 09CC CD B7 3F                     call    CMP16           ; check if at "home"
 949+ 09CF E1                           pop     HL
 950+ 09D0 CA DB 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 951+ 09D3 2B                           dec     HL              ; go 1 step back
 952+ 09D4 CD 7D 06                     call    READ_VIDEO_LOC  ; read char of current position
 953+ 09D7 A7                           and     A               ; is it $00 (null char)?
 954+ 09D8 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 955+ 09DA 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 956+ 09DB                              ; second part: look for the ending of the text on screen
 957+ 09DB 22 FE 52     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 958+ 09DE CD 34 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 959+ 09E1 22 00 53                     ld      (ENDTXT),HL     ; store ending of text line
 960+ 09E4 ED 5B FE 52                  ld      DE,(SRTTXT)     ; load beginning of text line
 961+ 09E8 A7                           and     A               ; clear Carry
 962+ 09E9 ED 52                        sbc     HL,DE           ; how many chars?
 963+ 09EB 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 964+ 09ED                              ;---    central part: send the text on the screen to the interpreter
 965+ 09ED 2A FE 52                     ld      HL,(SRTTXT)     ; load beginning of text line
 966+ 09F0 ED 5B 00 53                  ld      DE,(ENDTXT)     ; load ending of text line
 967+ 09F4 CD 7D 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 968+ 09F7 E5                           push    HL
 969+ 09F8 CD F4 01                     call    CHARINTOBFR     ; send char to buffer
 970+ 09FB E1                           pop     HL
 971+ 09FC 23                           inc     HL              ; go to next char
 972+ 09FD E5                           push    HL              ; store HL
 973+ 09FE CD B7 3F                     call    CMP16           ; check if DE=HL (finish chars)
 974+ 0A01 E1                           pop     HL
 975+ 0A02 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 976+ 0A04 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 977+ 0A06 CD F4 01                     call    CHARINTOBFR     ; send to buffer
 978+ 0A09 2A 00 53                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 979+ 0A0C CD 1F 07                     call    HL2XY           ; retrieve X,Y from address
 980+ 0A0F 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 981+ 0A10 32 F2 52                     ld      (SCR_CURS_Y),A  ; store new Y
 982+ 0A13                              ;---    final part: go at the beginning of a new line on the screen
 983+ 0A13 AF           PRNTRETURN:     xor     A               ; move to col 0
 984+ 0A14 32 F1 52                     ld      (SCR_CURS_X),A  ; store new X
 985+ 0A17 3A F2 52                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 986+ 0A1A 3C                           inc     A               ; new row
 987+ 0A1B 21 EC 52                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 988+ 0A1E BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 989+ 0A1F 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 990+ 0A21 3D                           dec     A               ; yes, so come back 1 row, then...
 991+ 0A22 F5                           push    AF              ; (store A)
 992+ 0A23 CD 35 09                     call    SCROLLUP        ; ...scroll the screen before to...
 993+ 0A26 F1                           pop     AF              ; (retrieve A)
 994+ 0A27 32 F2 52     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 995+ 0A2A 3A 02 53                     ld      A,(TMPBFR4)     ; retrieve cursor state
 996+ 0A2D A7                           and     A               ; was it off (A=0)?
 997+ 0A2E C4 19 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 998+ 0A31 C3 B9 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
 999+ 0A34
1000+ 0A34              ; find end of text line
1001+ 0A34              ; destroys A, DE, and HL - store address of last char of text line into HL,
1002+ 0A34              ; while DE contains the address of the bottom right cell of the screen
1003+ 0A34 3A EC 52     ENDOFLN:        ld      A,(SCR_SIZE_H)
1004+ 0A37 5F                           ld      E,A             ; load screen height into DE
1005+ 0A38 3A EB 52                     ld      A,(SCR_SIZE_W)
1006+ 0A3B 6F                           ld      L,A             ; load screen width into HL
1007+ 0A3C AF                           xor     A
1008+ 0A3D 67                           ld      H,A
1009+ 0A3E 57                           ld      D,A
1010+ 0A3F CD C2 3F                     call    MUL16           ; multiply HL times DE to get the screen size
1011+ 0A42 ED 5B EF 52                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1012+ 0A46 19                           add     HL,DE           ; get the address...
1013+ 0A47 2B                           dec     HL              ; ...of the "last" video cell
1014+ 0A48 EB                           ex      DE,HL           ; store address into DE
1015+ 0A49 2A FC 52                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1016+ 0A4C E5           RPTNLLSRC2:     push    HL
1017+ 0A4D CD B7 3F                     call    CMP16           ; check if at last position on screen (bottom right corner)
1018+ 0A50 E1                           pop     HL
1019+ 0A51 C8                           ret     Z               ; if yes, exit because these is nothing after
1020+ 0A52 23                           inc     HL              ; 1 more step forward
1021+ 0A53 CD 7D 06                     call    READ_VIDEO_LOC  ; read char of current position
1022+ 0A56 A7                           and     A               ; is it $00 (null char)?
1023+ 0A57 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1024+ 0A59 C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
1025+ 0A5A
1026+ 0A5A
1027+ 0A5A              ; ------------------------------------------------------------------------------
1028+ 0A5A                              ; this table contains the values of the offsets to be added to
1029+ 0A5A                              ; the starting address of the name table to find the correct
1030+ 0A5A                              ; value of the first cell of the corresponding row
1031+ 0A5A                              ; (by doing so, it's faster than doing a multipication)
1032+ 0A5A                              ; table for graphics 1 text mode: 32 cols
1033+ 0A5A 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1033+ 0A5E 40 00 60 00
1033+ 0A62 80 00 A0 00
1033+ 0A66 C0 00 E0 00
1034+ 0A6A 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1034+ 0A6E 40 01 60 01
1034+ 0A72 80 01 A0 01
1034+ 0A76 C0 01 E0 01
1035+ 0A7A 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1035+ 0A7E 40 02 60 02
1035+ 0A82 80 02 A0 02
1035+ 0A86 C0 02 E0 02
1036+ 0A8A                              ; table for pure text mode: 40 cols
1037+ 0A8A 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1037+ 0A8E 50 00 78 00
1037+ 0A92 A0 00 C8 00
1037+ 0A96 F0 00 18 01
1038+ 0A9A 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1038+ 0A9E 90 01 B8 01
1038+ 0AA2 E0 01 08 02
1038+ 0AA6 30 02 58 02
1039+ 0AAA 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1039+ 0AAE D0 02 F8 02
1039+ 0AB2 20 03 48 03
1039+ 0AB6 70 03 98 03
1040+ 0ABA
1041+ 0ABA              ; ------------------------------------------------------------------------------
1042+ 0ABA              ; reset VRAM
1043+ 0ABA AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1044+ 0ABB 67                           ld      H,A
1045+ 0ABC 6F                           ld      L,A             ; reset HL
1046+ 0ABD CD 5D 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1047+ 0AC0 06 40                        ld      B,$40           ; $40 pages of RAM...
1048+ 0AC2 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1049+ 0AC3 0D                           dec     C              ; VDP data mode
1050+ 0AC4 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1051+ 0AC6 14                           inc     D               ; next cell
1052+ 0AC7 00                           nop
1053+ 0AC8 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1054+ 0ACA 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1055+ 0ACC C9                           ret                     ; return to caller
1056+ 0ACD
1057+ 0ACD              ; clear video registers in SRAM
1058+ 0ACD 21 EB 52     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1059+ 0AD0 AF                           xor     A               ; $00 to clean the registers
1060+ 0AD1 06 45                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1061+ 0AD3 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1062+ 0AD4 23                           inc     HL              ; next register
1063+ 0AD5 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1064+ 0AD7 C9                           ret                     ; return to caller
1065+ 0AD8
1066+ 0AD8              ; ------------------------------------------------------------------------------
1067+ 0AD8              ; set a specific graphics mode, passed into reg. E
1068+ 0AD8 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1069+ 0ADA CB 23                        sla     E               ; multiply E by 8..
1070+ 0ADC CB 23                        sla     E               ; so that reg. E can point..
1071+ 0ADE CB 23                        sla     E               ; to the correct settings
1072+ 0AE0 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1073+ 0AE2 21 14 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1074+ 0AE5 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1075+ 0AE6 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1076+ 0AE8 0E 32                        ld      C,VDP_SET       ; VDP set
1077+ 0AEA 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1078+ 0AEB ED 51                        out     (C),D           ; send data to VDP
1079+ 0AED ED 79                        out     (C),A           ; indicate the register to send data to
1080+ 0AEF 3C                           inc     A               ; next register
1081+ 0AF0 23                           inc     HL              ; next value
1082+ 0AF1 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1083+ 0AF3 C9                           ret
1084+ 0AF4
1085+ 0AF4              ; ------------------------------------------------------------------------------
1086+ 0AF4              LOADCHARSET:    ; reg. A contains the video mode
1087+ 0AF4                              ; reg. HL contains address of pattern table into VRAM
1088+ 0AF4 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1089+ 0AF6 CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1090+ 0AF8 0E 32                        ld      C,VDP_SET       ; load VDP address into C
1091+ 0AFA ED 69                        out     (C),L           ; send low byte of address
1092+ 0AFC ED 61                        out     (C),H           ; send high byte
1093+ 0AFE 0D                           dec     C              ; VDP data mode
1094+ 0AFF 21 1A 40                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1095+ 0B02 A7                           and     A               ; is it text mode (A=0)?
1096+ 0B03 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1097+ 0B05 21 1A 48                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1098+ 0B08 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1099+ 0B0A 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1100+ 0B0B ED 79                        out     (C),A           ; write byte into VRAM
1101+ 0B0D 23                           inc     HL              ; inc byte pointer
1102+ 0B0E 15                           dec     D               ; 8 bytes sents (0 char)?
1103+ 0B0F 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1104+ 0B11 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1105+ 0B13 C9                           ret                     ; return to caller
1106+ 0B14
1107+ 0B14              ;------------------------------------------------------------------------------
1108+ 0B14              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1109+ 0B14              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1110+ 0B14              ; COLOR TABLE:      color settings for chars/tiles
1111+ 0B14
1112+ 0B14                              ; VDP register settings for a text display
1113+ 0B14 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1114+ 0B15 D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1115+ 0B16 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1116+ 0B17 00                           defb    $00             ; reg.3: not used in text mode
1117+ 0B18 00                           defb    $00             ; reg.4: pattern table set to $0000
1118+ 0B19 00                           defb    $00             ; reg.5: not used in text mode
1119+ 0B1A 00                           defb    $00             ; reg.6: not used in text mode
1120+ 0B1B F5                           defb    $f5             ; reg.7: white text on light blue background
1121+ 0B1C
1122+ 0B1C              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1123+ 0B1C 00                           defb    %00000000       ; reg.0: ext. video off
1124+ 0B1D C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1125+ 0B1E 06                           defb    $06             ; reg.2: name table address: $1800
1126+ 0B1F 80                           defb    $80             ; reg.3: color table address: $2000
1127+ 0B20 00                           defb    $00             ; reg.4: pattern table address: $0000
1128+ 0B21 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1129+ 0B22 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1130+ 0B23 05                           defb    $05             ; reg.7: backdrop color (light blue)
1131+ 0B24
1132+ 0B24              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1133+ 0B24 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1134+ 0B25 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1135+ 0B26 06                           defb    $06             ; reg.2: name table addr.: $1800
1136+ 0B27 FF                           defb    $FF             ; reg.3: color table addr.: $2000
1137+ 0B28 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1138+ 0B29 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1139+ 0B2A 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1140+ 0B2B 05                           defb    $05             ; reg.7: backdrop color: light blue
1141+ 0B2C
1142+ 0B2C              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1143+ 0B2C 00                           defb    %00000000       ; reg.0: ext. video dis.
1144+ 0B2D CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1145+ 0B2E 02                           defb    $02             ; reg.2: name table addr.: $0800
1146+ 0B2F 00                           defb    $00             ; reg.3: don't care
1147+ 0B30 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1148+ 0B31 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1149+ 0B32 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1150+ 0B33 0F                           defb    $0F             ; reg.7: backdrop color (white)
1151+ 0B34
1152+ 0B34              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1153+ 0B34 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1154+ 0B35 C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1155+ 0B36 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1156+ 0B37 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1157+ 0B38 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1158+ 0B39 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1159+ 0B3A 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1160+ 0B3B 05                           defb    $05             ; reg.7: backdrop color: light blue
1161+ 0B3C
1162+ 0B3C              LM80CLOGO:      ; patterns to compose the splash screen logo
1163+ 0B3C                              ; 1st band
1164+ 0B3C 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1164+ 0B40 00 00 00 00
1164+ 0B44 00 00 00 00
1164+ 0B48 00 00 00 00
1164+ 0B4C 00 00 00 00
1164+ 0B50 00 00 00 00
1164+ 0B54 00 00 00 00
1164+ 0B58 00 00 00 00
1165+ 0B5C 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1165+ 0B60 0B 10 00 00
1165+ 0B64 00 00 00 00
1165+ 0B68 00 00 00 00
1165+ 0B6C 00 00 00 00
1165+ 0B70 00 00 00 00
1165+ 0B74 00 00 00 00
1165+ 0B78 00 00 00 00
1166+ 0B7C                              ; 2nd band
1167+ 0B7C 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1167+ 0B80 00 0C 00 00
1167+ 0B84 00 01 00 00
1167+ 0B88 00 14 00 00
1167+ 0B8C 06 05 06 15
1167+ 0B90 16 07 06 15
1167+ 0B94 16 07 06 01
1167+ 0B98 01 07 00 00
1168+ 0B9C 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1168+ 0BA0 00 0C 00 00
1168+ 0BA4 00 01 00 00
1168+ 0BA8 00 01 14 06
1168+ 0BAC 01 05 03 05
1168+ 0BB0 03 05 03 05
1168+ 0BB4 03 05 03 05
1168+ 0BB8 03 05 00 00
1169+ 0BBC                              ; 3rd band
1170+ 0BBC 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1170+ 0BC0 00 0C 00 00
1170+ 0BC4 00 01 00 00
1170+ 0BC8 00 01 01 01
1170+ 0BCC 01 05 09 14
1170+ 0BD0 13 08 03 05
1170+ 0BD4 13 05 03 05
1170+ 0BD8 00 00 00 00
1171+ 0BDC 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1171+ 0BE0 00 0C 00 00
1171+ 0BE4 00 01 00 00
1171+ 0BE8 00 01 00 08
1171+ 0BEC 03 05 06 15
1171+ 0BF0 16 07 03 01
1171+ 0BF4 16 05 03 05
1171+ 0BF8 00 00 00 00
1172+ 0BFC                              ; 4th band
1173+ 0BFC 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1173+ 0C00 00 0C 00 00
1173+ 0C04 00 01 00 00
1173+ 0C08 00 01 00 00
1173+ 0C0C 03 05 03 05
1173+ 0C10 03 05 03 05
1173+ 0C14 03 05 03 05
1173+ 0C18 03 05 00 00
1174+ 0C1C 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1174+ 0C20 00 0C 00 00
1174+ 0C24 00 01 04 04
1174+ 0C28 00 01 00 00
1174+ 0C2C 03 05 09 14
1174+ 0C30 13 08 09 14
1174+ 0C34 13 08 09 01
1174+ 0C38 01 08 00 00
1175+ 0C3C                              ; 5th band
1176+ 0C3C 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1176+ 0C40 12 11 00 00
1176+ 0C44 00 00 00 00
1176+ 0C48 00 00 00 00
1176+ 0C4C 00 00 00 00
1176+ 0C50 00 00 00 00
1176+ 0C54 00 00 00 00
1176+ 0C58 00 00 00 00
1177+ 0C5C 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1177+ 0C60 00 00 00 00
1177+ 0C64 00 00 00 00
1177+ 0C68 00 00 00 00
1177+ 0C6C 00 00 00 00
1177+ 0C70 00 00 00 00
1177+ 0C74 00 00 00 00
1177+ 0C78 00 00 00 00
# file closed: ../include/vdp/vdp-1.3.asm
  73  0C7C
  74  0C7C              ; incude the latest version of the PSG module
  75  0C7C                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0C7C              ; ------------------------------------------------------------------------------
   2+ 0C7C              ; LM80C - PSG ROUTINES - 1.1
   3+ 0C7C              ; ------------------------------------------------------------------------------
   4+ 0C7C              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0C7C              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0C7C              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0C7C              ; kind of warranty: you can use them at your own risk.
   8+ 0C7C              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0C7C              ; maintain the copyright notices, include this advice and the note to the
  10+ 0C7C              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0C7C              ; redistribuite them.
  12+ 0C7C              ; https://www.leonardomiliani.com
  13+ 0C7C              ;
  14+ 0C7C              ; Please support me by visiting the following links:
  15+ 0C7C              ; Main project page: https://www.leonardomiliani.com
  16+ 0C7C              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0C7C              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0C7C              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0C7C              ; ------------------------------------------------------------------------------
  20+ 0C7C              ;
  21+ 0C7C              ; ------------------------------------------------------------------------------
  22+ 0C7C
  23+ 0C7C              ;------------------------------------------------------------------------------
  24+ 0C7C
  25+ 0C7C              ; configure the PSG
  26+ 0C7C 21 30 53     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0C7F 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0C81 AF                           xor     A               ; reset A
  29+ 0C82 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0C83 23                           inc     HL              ; next register
  31+ 0C84 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0C86 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0C88 21 9A 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0C8B 16 00                        ld      D,$00           ; first register
  35+ 0C8D 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0C8E CD D4 0C                     call    SETSNDREG       ; select register
  37+ 0C91 7E                           ld      A,(HL)          ; load value
  38+ 0C92 CD D9 0C                     call    WRTSNDREG       ; write to register
  39+ 0C95 14                           inc     D               ; next register
  40+ 0C96 23                           inc     HL              ; next value
  41+ 0C97 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0C99 C9                           ret                     ; return to caller
  43+ 0C9A
  44+ 0C9A 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0C9E 00 00 00 BF
  45+ 0CA2 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CA6 00 00 FF FF
  46+ 0CAA                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CAA
  48+ 0CAA
  49+ 0CAA              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CAA 21 C4 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CAD C3 B3 0C                     jp      SENDSND
  52+ 0CB0 21 CC 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CB3 C5           SENDSND:        push    BC
  54+ 0CB4 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CB6 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CB7 CD D4 0C                     call    SETSNDREG
  57+ 0CBA 23                           inc     HL              ; next cell
  58+ 0CBB 7E                           ld      A,(HL)          ; read value
  59+ 0CBC CD D9 0C                     call    WRTSNDREG
  60+ 0CBF 23                           inc     HL
  61+ 0CC0 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CC2 C1                           pop     BC
  63+ 0CC3 C9                           ret                     ; return to caller
  64+ 0CC4
  65+ 0CC4 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CC8 05 00 0A 0F
  66+ 0CCC 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CD0 0A 00 07 BF
  67+ 0CD4
  68+ 0CD4
  69+ 0CD4              ; select register on PSG
  70+ 0CD4 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CD6 ED 79                        out     (C),A           ; set register
  72+ 0CD8 C9                           ret                     ; return to caller
  73+ 0CD9
  74+ 0CD9              ; send data to PSG
  75+ 0CD9 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0CDB ED 79                        out     (C),A           ; send data
  77+ 0CDD C9                           ret                     ; return to caller
  78+ 0CDE
  79+ 0CDE              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0CDE              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0CDE              ; shut off the audio channel whose counter has reached 0.
  82+ 0CDE              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0CDE DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0CE0 DD 21 30 53                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0CE4 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0CE6 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0CE8 DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0CEB DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0CEE 7B                           ld      A,E             ; load E into A
  90+ 0CEF B2                           or      D               ; check that DE=0
  91+ 0CF0 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0CF2 1B                           dec     DE              ; no, so decrement DE
  93+ 0CF3 7B                           ld      A,E             ; reload E into A...
  94+ 0CF4 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0CF7 DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0CFA B2                           or      D               ; ...do another check to see if DE=0
  97+ 0CFB 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0CFD                                                      ; if yes, let's shut down the corresponding channel
  99+ 0CFD                                                      ; to shut down a tone we disable it into the mixer
 100+ 0CFD                                                      ; then set 0 into its tone registers
 101+ 0CFD 16 07                        ld      D,$07           ; mixer register
 102+ 0CFF 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D01 ED 51                        out     (C),D           ; set mixer register
 104+ 0D03 ED 78                        in      A,(C)           ; load current value
 105+ 0D05 B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D06 ED 51                        out     (C),D           ; select mixer register
 107+ 0D08 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D0A ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D0C 3E 03                        ld      A,$03           ; three channels
 110+ 0D0E 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D0F 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D10 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D12 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D14 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D16 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D18 ED 69                        out     (C),L           ; write 0 into register
 117+ 0D1A 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D1C 3C                           inc     A               ; next tone register
 119+ 0D1D ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D1F 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D21 ED 69                        out     (C),L           ; write 0 into register
 122+ 0D23 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D25 DD 23                        inc     IX              ; ...next channel...
 124+ 0D27 CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D29 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D2B DD E1                        pop     IX              ; restore IX
 127+ 0D2D C9                           ret                     ; return to caller
 128+ 0D2E
 129+ 0D2E              ; read a specific row of the keyboard matrix, set by A
 130+ 0D2E              ; return read into A
 131+ 0D2E C5           READKBLN:       push    BC              ; store BC
 132+ 0D2F 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D31 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D33 ED 41                        out     (C),B           ; select reg #15
 135+ 0D35 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D37 ED 79                        out     (C),A           ; activate the row
 137+ 0D39 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D3B 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D3D ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D3F ED 78                        in      A,(C)           ; read register #14
 141+ 0D41 C1                           pop     BC              ; retrieve BC
 142+ 0D42 C9                           ret
 143+ 0D43
 144+ 0D43              ; read the keyboard matrix to look for a key pressure
 145+ 0D43 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D45 06 07                        ld      B,$07           ; set register #7...
 147+ 0D47 ED 41                        out     (C),B           ; ...to work with
 148+ 0D49 ED 78                        in      A,(C)           ; read register #7
 149+ 0D4B CB FF                        set     7,A             ; port A set to output
 150+ 0D4D CB B7                        res     6,A             ; port B set to input
 151+ 0D4F ED 41                        out     (C),B           ; set register #7
 152+ 0D51 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D53 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D55                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D55 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D57 CD 2E 0D                     call    READKBLN        ; read row
 157+ 0D5A CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D5C 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D5E 21 3D 53                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D61 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D63 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D65 CD 2E 0D                     call    READKBLN        ; read ALT row
 163+ 0D68 CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D6A 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D6C 21 3D 53                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D6F 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D71 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D73 CD 2E 0D                     call    READKBLN        ; read CTRL row
 169+ 0D76 CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D78 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D7A 21 3D 53                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0D7D 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0D7F 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0D81 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0D83 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0D85 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0D87 ED 51                        out     (C),D           ; select reg. #15
 178+ 0D89 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0D8B ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0D8D 5F                           ld      E,A             ; save current line into E
 181+ 0D8E 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0D90 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0D92 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0D94 00                           nop
 185+ 0D95 ED 78                        in      A,(C)           ; read register #14
 186+ 0D97 FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0D99 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0D9B                              ; check control keys
 189+ 0D9B 32 37 53                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0D9E 78                           ld      A,B             ; copy current row (B) into A
 191+ 0D9F FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0DA1 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0DA3 3A 37 53                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0DA6 CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0DA8 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0DAA CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0DAC FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0DAE 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0DB0 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0DB2 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0DB4 3A 37 53                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0DB7 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0DB9 CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0DBB 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0DBD CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0DBF CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0DC1 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DC3 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DC5 FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DC7 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DC9 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DCA 0F                           rrca                    ; rotate right by 1
 213+ 0DCB 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DCD AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DCE 32 39 53                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DD1 32 3D 53                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DD4 32 36 53                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DD7 32 3A 53                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DDA C9                           ret                     ; ...and leave
 220+ 0DDB 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0DDD 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0DDE CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0DE0 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0DE2 3A 3D 53                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0DE5 21 FE 0E                     ld      HL,KBMAP        ; normal keymap
 226+ 0DE8 FE 01                        cp      $01             ; SHIFT flag?
 227+ 0DEA 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0DEC 21 3E 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0DEF 18 10                        jr      LOADMAP         ; and load it
 230+ 0DF1 FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0DF3 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0DF5 21 BE 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0DF8 18 07                        jr      LOADMAP         ; and load it
 234+ 0DFA FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0DFC 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0DFE 21 7E 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0E01 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0E02 48                           ld      C,B             ; move B into C and...
 239+ 0E03 CB 21                        sla     C               ; ...multiply it...
 240+ 0E05 CB 21                        sla     C               ; ...by 8 to find...
 241+ 0E07 CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0E09 06 00                        ld      B,$00           ; reset B
 243+ 0E0B 09                           add     HL,BC           ; find the address of the current row
 244+ 0E0C 50                           ld      D,B             ; reset D
 245+ 0E0D 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0E0E 3A 39 53                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0E11 BE                           cp      (HL)            ; is it the same key?
 248+ 0E12 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0E14 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0E16 2A DB 52                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0E19 ED 5B 3B 53                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0E1D 3A 3A 53                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0E20 FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E22 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E24 AF                           xor     A               ; clear Carry
 256+ 0E25 ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E27 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E29 3A D1 51                     ld      A,(KEYDEL)
 259+ 0E2C 5F                           ld      E,A
 260+ 0E2D CD B7 3F                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E30 DA A5 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E33 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E35 32 3A 53                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E38 2A DB 52                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E3B 22 3B 53                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E3E 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E40 C3 62 0E                     jp      SENDKEY         ; send key
 268+ 0E43 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E44 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E46 16 00                        ld      D,$00
 271+ 0E48 3A D2 51                     ld      A,(AUTOKE)
 272+ 0E4B 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E4C CD B7 3F                     call    CMP16           ; check if interval is greater than delay
 274+ 0E4F DA A5 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E52 C3 33 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E55 AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E56 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E57 32 3A 53                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E5A ED 4B DB 52                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E5E ED 43 3B 53                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E62 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E63 32 39 53                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E66 32 38 53                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E69 32 F9 52                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E6C FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E6E 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E70 CD F4 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E73 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E75 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E78 21 F6 0E                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0E7B BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0E7C CA AA 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0E7F 0C                           inc     C               ; next FN key
 294+ 0E80 23                           inc     HL              ; next FN key code
 295+ 0E81 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0E83 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0E85 32 36 53                     ld      (KBDNPT),A      ; to keyboard
 298+ 0E88 3A F8 52                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0E8B B7                           or      A               ; is the print-on-video disabled?
 300+ 0E8C CA 95 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0E8F 3A F6 52                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0E92 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0E93 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0E95 AF           PUTCHRBUF:      xor     A
 305+ 0E96 32 36 53                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0E99 3A 38 53                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0E9C CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0E9F C3 A5 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0EA2 CD 4E 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0EA5 AF           LVKBRDCHK2:     xor     A
 311+ 0EA6 32 3D 53                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0EA9 C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0EAA                              ; manage FN keys
 314+ 0EAA 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0EAB 2A CD 51                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0EAE 23                           inc     HL              ; -1 means direct statement
 317+ 0EAF 7C                           ld      A,H
 318+ 0EB0 B5                           or      L
 319+ 0EB1 7A                           ld      A,D             ; retrieve char
 320+ 0EB2 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0EB4 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0EB5 87                           add     A,A
 323+ 0EB6 87                           add     A,A
 324+ 0EB7 87                           add     A,A
 325+ 0EB8 87                           add     A,A             ; FN key number * 16
 326+ 0EB9 4F                           ld      C,A             ; move it into C
 327+ 0EBA 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0EBC 21 D3 51                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0EBF 09                           add     HL,BC           ; get correct text address
 330+ 0EC0 06 10                        ld      B,$10           ; 16 chars
 331+ 0EC2 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0EC3 A7                           and     A               ; null char?
 333+ 0EC4 CA A5 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0EC7 57                           ld      D,A             ; pass char into D
 335+ 0EC8 3A F8 52                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0ECB B7                           or      A               ; is the print-on-video disabled?
 337+ 0ECC CA DC 0E                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0ECF 3A F6 52                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0ED2 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0ED3 C4 E9 0E                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0ED6 23           CNTFNK:         inc     HL              ; next char
 342+ 0ED7 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0ED9 C3 A5 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0EDC AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0EDD 32 36 53                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0EE0 7A                           ld      A,D             ; retrieve char
 347+ 0EE1 E5                           push    HL              ; store HL
 348+ 0EE2 CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0EE5 E1                           pop     HL              ; retrieve HL
 350+ 0EE6 C3 D6 0E                     jp      CNTFNK          ; repeat
 351+ 0EE9 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0EEA 32 F9 52                     ld      (CHR4VID),A     ; store char for printing
 353+ 0EED 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0EEF 32 36 53                     ld      (KBDNPT),A      ; to keyboard
 355+ 0EF2 CD 4E 07                     call    CHAR2VID        ; print on screen
 356+ 0EF5 C9                           ret                     ; return to caller
 357+ 0EF6
 358+ 0EF6
 359+ 0EF6              ;-----------------------------------------------------------------------
 360+ 0EF6 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0EFA 06 16 17 18
 361+ 0EFE              ;-----------------------------------------------------------------------
 362+ 0EFE              ; key codes
 363+ 0EFE 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0F02 20 10 71 32
 364+ 0F06 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0F0A 7A 73 65 34
 365+ 0F0E 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0F12 63 66 74 36
 366+ 0F16 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0F1A 62 68 75 38
 367+ 0F1E 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F22 6D 6B 6F 30
 368+ 0F26 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F2A 2E 3A 2D 1E
 369+ 0F2E 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F32 1B 3D 2B 1D
 370+ 0F36 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F3A 01 02 04 18
 371+ 0F3E
 372+ 0F3E              ; shifted codes - not all the keys have the shifted version
 373+ 0F3E 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F42 20 10 51 22
 374+ 0F46 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F4A 5A 53 45 24
 375+ 0F4E 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F52 43 46 54 26
 376+ 0F56 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F5A 42 48 55 28
 377+ 0F5E 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F62 4D 4B 4F 5E
 378+ 0F66 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F6A 3E 5B 5F 1E
 379+ 0F6E 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F72 1B C6 2B 1D
 380+ 0F76 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F7A 05 06 16 17
 381+ 0F7E
 382+ 0F7E              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0F7E 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0F82 20 10 DE C4
 384+ 0F86 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0F8A 83 82 A5 34
 385+ 0F8E 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0F92 9D A3 A8 36
 386+ 0F96 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0F9A 9E AC D5 38
 387+ 0F9E 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0FA2 A0 D7 87 C3
 388+ 0FA6 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0FAA C0 7B 90 1E
 389+ 0FAE 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0FB2 1B D1 94 1D
 390+ 0FB6 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0FBA 05 06 16 17
 391+ 0FBE
 392+ 0FBE              ; CTRL codes - not all the keys have the control-ed version
 393+ 0FBE 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FC2 20 10 9A 32
 394+ 0FC6 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FCA 98 96 99 34
 395+ 0FCE 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FD2 B1 AF A5 36
 396+ 0FD6 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FDA B3 A9 A7 38
 397+ 0FDE 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 0FE2 AB B5 A4 30
 398+ 0FE6 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 0FEA 2E 3A BA 1E
 399+ 0FEE 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 0FF2 1B D4 B9 1D
 400+ 0FF6 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 0FFA 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  76  0FFE
  77  0FFE              ; include the latest version of the LM80C 64K BASIC interpreter
  78  0FFE                  INCLUDE "../include/basic/basic-1.03.asm"
# file opened: ../include/basic/basic-1.03.asm
   1+ 0FFE              ; ------------------------------------------------------------------------------
   2+ 0FFE              ; LM80C BASIC (32K/64K) - R3.17
   3+ 0FFE              ; ------------------------------------------------------------------------------
   4+ 0FFE              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0FFE              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0FFE              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0FFE              ; kind of warranty: you can use them at your own risk.
   8+ 0FFE              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0FFE              ; maintain the copyright notices, include this advice and the note to the
  10+ 0FFE              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0FFE              ; redistribuite them.
  12+ 0FFE              ; https://www.leonardomiliani.com
  13+ 0FFE              ;
  14+ 0FFE              ; Please support me by visiting the following links:
  15+ 0FFE              ; Main project page: https://www.leonardomiliani.com
  16+ 0FFE              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0FFE              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0FFE              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0FFE              ; ------------------------------------------------------------------------------
  20+ 0FFE              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 0FFE              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 0FFE              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 0FFE
  24+ 0FFE
  25+ 0FFE              ;------------------------------------------------------------------------------
  26+ 0FFE              ;  L M 8 0 C   B A S I C
  27+ 0FFE              ;------------------------------------------------------------------------------
  28+ 0FFE
  29+ 0FFE              ; GENERAL EQUATES
  30+ 0FFE
  31+ 0FFE              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 0FFE              CTRLC           equ     $03             ; Control "C"
  33+ 0FFE              CTRLG           equ     $07             ; Control "G"
  34+ 0FFE              BKSP            equ     $08             ; Back space
  35+ 0FFE              LF              equ     $0A             ; Line feed
  36+ 0FFE              CS              equ     $0C             ; Clear screen
  37+ 0FFE              CR              equ     $0D             ; Carriage return
  38+ 0FFE              CTRLO           equ     $0F             ; Control "O"
  39+ 0FFE              CTRLQ           equ     $11             ; Control "Q"
  40+ 0FFE              CTRLR           equ     $12             ; Control "R"
  41+ 0FFE              CTRLS           equ     $13             ; Control "S"
  42+ 0FFE              CTRLU           equ     $15             ; Control "U"
  43+ 0FFE              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 0FFE              ESC             equ     $1B             ; Escape
  45+ 0FFE              SPC             equ     $20             ; Space
  46+ 0FFE              DEL             equ     $7F             ; Delete
  47+ 0FFE              INSRT           equ     $1A             ; Insert Key
  48+ 0FFE              ; cursor ASCII codes
  49+ 0FFE              CRSLFT          equ     $1C             ; cursor left
  50+ 0FFE              CRSRGT          equ     $1D             ; cursor right
  51+ 0FFE              CRSUP           equ     $1E             ; cursor up
  52+ 0FFE              CRSDN           equ     $1F             ; cursor down
  53+ 0FFE
  54+ 0FFE
  55+ 0FFE              ;-------------------------------------------------------------------------
  56+ 0FFE              ; BASIC ERROR MESSAGES
  57+ 0FFE              ; the interpreter looks for a single-byte code in the following list,
  58+ 0FFE              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 0FFE              ; find where to retrieve the message text in "ERRORS"
  60+ 0FFE
  61+ 0FFE              ; BASIC ERROR CODE VALUES
  62+ 0FFE              ; These values act as an offset to point to the error message into the error table
  63+ 0FFE              ; must be incremented by 2 because they point to a word address jump
  64+ 0FFE              NF              equ     $00     ; NEXT without FOR
  65+ 0FFE              SN              equ     $02     ; Syntax error
  66+ 0FFE              RG              equ     $04     ; RETURN without GOSUB
  67+ 0FFE              OD              equ     $06     ; Out of DATA
  68+ 0FFE              FC              equ     $08     ; Function call error
  69+ 0FFE              OV              equ     $0A     ; Overflow
  70+ 0FFE              OM              equ     $0C     ; Out of memory
  71+ 0FFE              UL              equ     $0E     ; Undefined line number
  72+ 0FFE              BS              equ     $10     ; Bad subscript
  73+ 0FFE              DD              equ     $12     ; Re-Dimensioned array
  74+ 0FFE              DZ              equ     $14     ; Division by zero (/0)
  75+ 0FFE              ID              equ     $16     ; Illegal direct
  76+ 0FFE              TM              equ     $18     ; Type mis-match
  77+ 0FFE              OS              equ     $1A     ; Out of string space
  78+ 0FFE              LS              equ     $1C     ; String too long
  79+ 0FFE              ST              equ     $1E     ; String formula too complex
  80+ 0FFE              CN              equ     $20     ; Can't continue
  81+ 0FFE              UF              equ     $22     ; Undefined FN function
  82+ 0FFE              MO              equ     $24     ; Missing operand
  83+ 0FFE              HX              equ     $26     ; HEX error
  84+ 0FFE              BN              equ     $28     ; BIN error
  85+ 0FFE              GM              equ     $2A     ; No Graphics Mode
  86+ 0FFE              SC              equ     $2C     ; Serial configuration
  87+ 0FFE              SA              equ     $2E     ; Serial port already open
  88+ 0FFE              SO              equ     $30     ; Serial buffer overrun
  89+ 0FFE              HP              equ     $32     ; HELP call
  90+ 0FFE
  91+ 0FFE              ; BASIC ERROR POINTER TABLE
  92+ 0FFE              ERRTBL: equ $
  93+ 0FFE 32 10        NFPTR:  defw    NFMSG
  94+ 1000 43 10        SNPTR:  defw    SNMSG
  95+ 1002 4A 10        RGPTR:  defw    RGMSG
  96+ 1004 5F 10        ODPTR:  defw    ODMSG
  97+ 1006 6B 10        FCPTR:  defw    FCMSG
  98+ 1008 81 10        OVPTR:  defw    OVMSG
  99+ 100A 8A 10        OMPTR:  defw    OMMSG
 100+ 100C 98 10        ULPTR:  defw    ULMSG
 101+ 100E A7 10        BSPTR:  defw    BSMSG
 102+ 1010 B5 10        DDPTR:  defw    DDMSG
 103+ 1012 CA 10        DZPTR:  defw    DZMSG
 104+ 1014 DB 10        IDPTR:  defw    IDMSG
 105+ 1016 EA 10        TMPTR:  defw    TMMSG
 106+ 1018 F9 10        OSPTR:  defw    OSMSG
 107+ 101A 0D 11        LSPTR:  defw    LSMSG
 108+ 101C 1D 11        STPTR:  defw    STMSG
 109+ 101E 38 11        CNPTR:  defw    CNMSG
 110+ 1020 47 11        UFPTR:  defw    UFMSG
 111+ 1022 5D 11        MOPTR:  defw    MOMSG
 112+ 1024 6D 11        HXPTR:  defw    HXMSG
 113+ 1026 78 11        BNPTR:  defw    BNMSG
 114+ 1028 83 11        GMPRT:  defw    GMMSG
 115+ 102A 94 11        SCPTR:  defw    SCMSG
 116+ 102C A9 11        SAPTR:  defw    SAMSG
 117+ 102E C2 11        SOPTR:  defw    SOMSG
 118+ 1030 D8 11        HPPTR:  defw    HPMSG
 119+ 1032
 120+ 1032              ; BASIC ERROR MESSAGE LIST
 121+ 1032              ERRORS  equ $
 122+ 1032 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 122+ 1036 20 57 69 74
 122+ 103A 68 6F 75 74
 122+ 103E 20 46 4F 52
 122+ 1042 00
 123+ 1043 53 79 6E 74  SNMSG:  defb    "Syntax",0
 123+ 1047 61 78 00
 124+ 104A 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 124+ 104E 52 4E 20 77
 124+ 1052 69 74 68 6F
 124+ 1056 75 74 20 47
 124+ 105A 4F 53 55 42
 124+ 105E 00
 125+ 105F 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 125+ 1063 6F 66 20 44
 125+ 1067 41 54 41 00
 126+ 106B 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 126+ 106F 67 61 6C 20
 126+ 1073 46 75 6E 63
 126+ 1077 74 69 6F 6E
 126+ 107B 20 43 61 6C
 126+ 107F 6C 00
 127+ 1081 4F 76 65 72  OVMSG:  defb    "Overflow",0
 127+ 1085 66 6C 6F 77
 127+ 1089 00
 128+ 108A 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 128+ 108E 6F 66 20 4D
 128+ 1092 65 6D 6F 72
 128+ 1096 79 00
 129+ 1098 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 129+ 109C 66 69 6E 65
 129+ 10A0 64 20 4C 69
 129+ 10A4 6E 65 00
 130+ 10A7 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 130+ 10AB 53 75 62 73
 130+ 10AF 63 72 69 70
 130+ 10B3 74 00
 131+ 10B5 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 131+ 10B9 69 6D 65 6E
 131+ 10BD 73 69 6F 6E
 131+ 10C1 65 64 20 41
 131+ 10C5 72 72 61 79
 131+ 10C9 00
 132+ 10CA 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 132+ 10CE 73 69 6F 6E
 132+ 10D2 20 62 79 20
 132+ 10D6 5A 65 72 6F
 132+ 10DA 00
 133+ 10DB 49 6C 6C 65  IDMSG:  defb    "Illegal Direct",0
 133+ 10DF 67 61 6C 20
 133+ 10E3 44 69 72 65
 133+ 10E7 63 74 00
 134+ 10EA 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 134+ 10EE 20 4D 69 73
 134+ 10F2 2D 6D 61 74
 134+ 10F6 63 68 00
 135+ 10F9 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 135+ 10FD 6F 66 20 53
 135+ 1101 74 72 69 6E
 135+ 1105 67 20 53 70
 135+ 1109 61 63 65 00
 136+ 110D 53 74 72 69  LSMSG:  defb    "String Too Long",0
 136+ 1111 6E 67 20 54
 136+ 1115 6F 6F 20 4C
 136+ 1119 6F 6E 67 00
 137+ 111D 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 137+ 1121 6E 67 20 46
 137+ 1125 6F 72 6D 75
 137+ 1129 6C 61 20 54
 137+ 112D 6F 6F 20 43
 137+ 1131 6F 6D 70 6C
 137+ 1135 65 78 00
 138+ 1138 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 138+ 113C 74 20 43 6F
 138+ 1140 6E 74 69 6E
 138+ 1144 75 65 00
 139+ 1147 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 139+ 114B 66 69 6E 65
 139+ 114F 64 20 46 4E
 139+ 1153 20 46 75 6E
 139+ 1157 63 74 69 6F
 139+ 115B 6E 00
 140+ 115D 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 140+ 1161 69 6E 67 20
 140+ 1165 4F 70 65 72
 140+ 1169 61 6E 64 00
 141+ 116D 48 45 58 20  HXMSG:  defb    "HEX Format",0
 141+ 1171 46 6F 72 6D
 141+ 1175 61 74 00
 142+ 1178 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 142+ 117C 46 6F 72 6D
 142+ 1180 61 74 00
 143+ 1183 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 143+ 1187 72 61 70 68
 143+ 118B 69 63 73 20
 143+ 118F 4D 6F 64 65
 143+ 1193 00
 144+ 1194 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 144+ 1198 61 6C 20 43
 144+ 119C 6F 6E 66 69
 144+ 11A0 67 75 72 61
 144+ 11A4 74 69 6F 6E
 144+ 11A8 00
 145+ 11A9 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 145+ 11AD 61 6C 20 50
 145+ 11B1 6F 72 74 20
 145+ 11B5 41 6C 72 65
 145+ 11B9 61 64 79 20
 145+ 11BD 4F 70 65 6E
 145+ 11C1 00
 146+ 11C2 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 146+ 11C6 61 6C 20 42
 146+ 11CA 75 66 66 65
 146+ 11CE 72 20 4F 76
 146+ 11D2 65 72 72 75
 146+ 11D6 6E 00
 147+ 11D8 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 147+ 11DC 20 43 61 6C
 147+ 11E0 6C 00
 148+ 11E2
 149+ 11E2
 150+ 11E2              ;-----------------------------------------------------------------------------
 151+ 11E2              ; STARTING POINTS FOR BASIC BOOT
 152+ 11E2              ; COLD: reset every memory pointer, acting as a power-up boot
 153+ 11E2              ; WARM: preserve program in memory, keeping every current pointer
 154+ 11E2
 155+ 11E2 C3 E8 11     COLD:   jp      STARTB          ; Jump for cold start
 156+ 11E5 C3 96 12     WARM:   jp      WARMST          ; Jump for warm start
 157+ 11E8
 158+ 11E8 C3 EF 11     STARTB: jp      CSTART          ; Jump to initialise
 159+ 11EB A3 1C                defw    DEINT           ; Get integer -32768 to 32767
 160+ 11ED 60 24                defw    ABPASS          ; Return integer in AB
 161+ 11EF 21 7C 51     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 162+ 11F2 F9                   ld      SP,HL           ; Set up a temporary stack
 163+ 11F3 C3 A2 3F             jp      INITST          ; Go to initialise
 164+ 11F6
 165+ 11F6 21 63 15     INIT:   ld      HL,INITAB       ; Initialise workspace
 166+ 11F9 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 167+ 11FC 11 7C 51             ld      DE,WRKSPC       ; Into workspace RAM
 168+ 11FF ED B0                ldir                    ; Copy data
 169+ 1201 EB                   ex      DE,HL           ; Copy DE into HL
 170+ 1202 F9                   ld      SP,HL           ; Temporary stack
 171+ 1203 CD 16 18             call    CLREG           ; Clear registers and stack
 172+ 1206 CD BA 1E             call    PRNTCRLF        ; Output CRLF
 173+ 1209 32 AF 52             ld      (BUFFER+88+1),A ; Mark end of buffer
 174+ 120C 32 65 53             ld      (PROGST),A      ; Initialise program area
 175+ 120F 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 176+ 1211 21 FD 12     MSIZE:  ld      HL,MEMMSG       ; Point to message
 177+ 1214 CD 7E 25             call    PRS             ; Output "Memory size"
 178+ 1217 CD 33 18             call    PROMPT          ; Get input with '?'
 179+ 121A CD 19 09             call    CURSOR_ON       ; enable cursor
 180+ 121D CD ED 1B             call    GETCHR          ; Get next character
 181+ 1220 B7                   or      A               ; Set flags
 182+ 1221 C2 39 12             jp      NZ,TSTMEM       ; If number - Test if RAM there
 183+ 1224 21 C9 53     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 184+ 1227 23           MLOOP:  inc     HL              ; Next byte
 185+ 1228 7C                   ld      A,H             ; Above address FFFF ?
 186+ 1229 B5                   or      L
 187+ 122A CA 4B 12             jp      Z,SETTOP        ; Yes - 64K RAM
 188+ 122D 7E                   ld      A,(HL)          ; Get contents
 189+ 122E 47                   ld      B,A             ; Save it
 190+ 122F 2F                   cpl                     ; Flip all bits
 191+ 1230 77                   ld      (HL),A          ; Put it back
 192+ 1231 BE                   cp      (HL)            ; RAM there if same
 193+ 1232 70                   ld      (HL),B          ; Restore old contents
 194+ 1233 CA 27 12             jp      Z,MLOOP         ; If RAM - test next byte
 195+ 1236 C3 4B 12             jp      SETTOP          ; Top of RAM found
 196+ 1239
 197+ 1239 CD BD 1C     TSTMEM: call    ATOH            ; Get high memory into DE
 198+ 123C B7                   or      A               ; Set flags on last byte
 199+ 123D C2 CA 16             jp      NZ,SNERR        ; ?SN Error if bad character
 200+ 1240 EB                   ex      DE,HL           ; Address into HL
 201+ 1241 2B                   dec     HL              ; Back one byte
 202+ 1242 3E D9                ld      A,%11011001     ; Test byte
 203+ 1244 46                   ld      B,(HL)          ; Get old contents
 204+ 1245 77                   ld      (HL),A          ; Load test byte
 205+ 1246 BE                   cp      (HL)            ; RAM there if same
 206+ 1247 70                   ld      (HL),B          ; Restore old contents
 207+ 1248 C2 11 12             jp      NZ,MSIZE        ; Ask again if no RAM
 208+ 124B
 209+ 124B CD 2E 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 210+ 124E 2B                   dec     HL              ; Back one byte
 211+ 124F 11 C8 53             ld      DE,STLOOK-1     ; See if enough RAM
 212+ 1252 CD A6 19             call    CPDEHL          ; Compare DE with HL
 213+ 1255 DA 11 12             jp      C,MSIZE         ; Ask again if not enough RAM
 214+ 1258 3A 41 53             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 215+ 125B 1F                   rra                     ; is DOS disabled?
 216+ 125C 30 04                jr      NC,NODOS        ; yes, so jump over
 217+ 125E 11 00 FE             ld      DE,0-512        ; no, so reserve 512 bytes on top of RAM...
 218+ 1261 19                   add     HL,DE           ; ...for I/O buffer
 219+ 1262 11 9C FF     NODOS:  ld      DE,0-100        ; 100 Bytes string space
 220+ 1265 22 B4 52             ld      (LSTRAM),HL     ; Save last available RAM
 221+ 1268 19                   add     HL,DE           ; Allocate string space
 222+ 1269 22 CB 51             ld      (STRSPC),HL     ; Save string space
 223+ 126C CD F1 17             call    CLRPTR          ; Clear program area
 224+ 126F 2A CB 51             ld      HL,(STRSPC)     ; Get end of memory
 225+ 1272 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 226+ 1275 19                   add     HL,DE           ; Adjust HL
 227+ 1276 11 65 53             ld      DE,PROGST       ; Start of program text
 228+ 1279 7D                   ld      A,L             ; Get LSB
 229+ 127A 93                   sub     E               ; Adjust it
 230+ 127B 6F                   ld      L,A             ; Re-save
 231+ 127C 7C                   ld      A,H             ; Get MSB
 232+ 127D 9A                   sbc     A,D             ; Adjust it
 233+ 127E 67                   ld      H,A             ; Re-save
 234+ 127F E5                   push    HL              ; Save bytes free
 235+ 1280 21 BC 12             ld      HL,SIGNON       ; Sign-on message
 236+ 1283 CD 7E 25             call    PRS             ; Output string
 237+ 1286 21 A5 12             ld      HL,BLNSPC       ; Empty space
 238+ 1289 CD 7E 25             call    PRS             ; Output string
 239+ 128C E1                   pop     HL              ; Get bytes free back
 240+ 128D CD 1D 30             call    PRNTHL          ; Output amount of free memory
 241+ 1290 21 AE 12             ld      HL,BFREE        ; " Bytes free" message
 242+ 1293 CD 7E 25             call    PRS             ; Output string
 243+ 1296
 244+ 1296 31 5B 52     WARMST: ld      SP,STACK        ; Temporary stack
 245+ 1299 CD 16 18     BRKRET: call    CLREG           ; Clear registers and stack
 246+ 129C CD 39 3D             call    RESFN           ; reset FN keys and auto-repeat
 247+ 129F CD 19 09             call    CURSOR_ON       ; enable cursor
 248+ 12A2 C3 24 17             jp      PRNTOK          ; Go to get command line
 249+ 12A5
 250+ 12A5 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 250+ 12A9 20 20 20 20
 250+ 12AD 00
 251+ 12AE 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 251+ 12B2 65 73 20 66
 251+ 12B6 72 65 65 0D
 251+ 12BA 0D 00
 252+ 12BC
 253+ 12BC 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.17 ",251,"2021 L.Miliani"
 253+ 12C0 43 20 42 41
 253+ 12C4 53 49 43 20
 253+ 12C8 33 2E 31 37
 253+ 12CC 20 FB 32 30
 253+ 12D0 32 31 20 4C
 253+ 12D4 2E 4D 69 6C
 253+ 12D8 69 61 6E 69
 254+ 12DC 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 254+ 12E0 20 42 41 53
 254+ 12E4 49 43 20 34
 254+ 12E8 2E 37 20 20
 254+ 12EC FB 31 39 37
 254+ 12F0 38 20 4D 69
 254+ 12F4 63 72 6F 73
 254+ 12F8 6F 66 74 0D
 254+ 12FC 00
 255+ 12FD
 256+ 12FD 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 256+ 1301 72 79 20 74
 256+ 1305 6F 70 00
 257+ 1308
 258+ 1308              ; The following list reports all the functions supported by the interpreter.
 259+ 1308              ; To add a custom function, the user must first insert the reserved word here,
 260+ 1308              ; then into the list of the reserved words below, and finally must increment the
 261+ 1308              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 262+ 1308              ; function.
 263+ 1308
 264+ 1308              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 265+ 1308              ; this list must be coherent with the tokens' functions list. This means that every
 266+ 1308              ; entry here must have the corresponding entry in the tokens list.
 267+ 1308 92 2E        FNCTAB: defw    SGN
 268+ 130A 28 24                defw    TMR         ; added by Leonardo Miliani
 269+ 130C 56 2F                defw    INT
 270+ 130E A8 2E                defw    ABS_        ; _ necessary for assembler warning
 271+ 1310 82 51                defw    USR
 272+ 1312 3E 24                defw    FRE
 273+ 1314 B9 28                defw    INP
 274+ 1316 6C 24                defw    POS
 275+ 1318 1C 31                defw    SQR
 276+ 131A FB 31                defw    RND
 277+ 131C E6 2C                defw    LOG
 278+ 131E 6A 31                defw    EXP
 279+ 1320 70 32                defw    COS
 280+ 1322 76 32                defw    SIN
 281+ 1324 D7 32                defw    TAN
 282+ 1326 EC 32                defw    ATN
 283+ 1328 95 29                defw    PEEK
 284+ 132A 57 33                defw    DEEK
 285+ 132C 9C 29                defw    VPEEK       ; added by Leonardo Miliani
 286+ 132E 6B 2B                defw    VSTAT       ; added by Leonardo Miliani
 287+ 1330 76 2B                defw    SSTAT       ; added by Leonardo Miliani
 288+ 1332 8A 2B                defw    INKEY       ; added by Leonardo Miliani
 289+ 1334 AE 36                defw    POINT       ; added by Leonardo Miliani
 290+ 1336 50 27                defw    INSTR       ; added by Leonardo Miliani
 291+ 1338 F0 26                defw    LEN
 292+ 133A 08 25                defw    STR
 293+ 133C 80 28                defw    VAL
 294+ 133E FF 26                defw    ASC
 295+ 1340 10 27                defw    CHR
 296+ 1342 9D 3E                defw    HEX         ; added by Grant Searle
 297+ 1344 2E 3F                defw    BIN         ; added by Grant Searle
 298+ 1346 20 27                defw    LEFT
 299+ 1348 46 28                defw    RIGHT
 300+ 134A 50 28                defw    MID
 301+ 134C
 302+ 134C              ; RESERVED WORD LIST
 303+ 134C              ; Here are all the reserved words used by the interpreter
 304+ 134C              ; To add custom functions/commands, the user must insert the keyword
 305+ 134C              ; in this list, following the schematic
 306+ 134C C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 307+ 134F C6 4F 52             defb    'F'+$80,"OR"
 308+ 1352 CE 45 58 54          defb    'N'+$80,"EXT"
 309+ 1356 C4 41 54 41          defb    'D'+$80,"ATA"
 310+ 135A C9 4E 50 55          defb    'I'+$80,"NPUT"
 310+ 135E 54
 311+ 135F C4 49 4D             defb    'D'+$80,"IM"
 312+ 1362 D2 45 41 44          defb    'R'+$80,"EAD"
 313+ 1366 CC 45 54             defb    'L'+$80,"ET"
 314+ 1369 C7 4F 54 4F          defb    'G'+$80,"OTO"
 315+ 136D D2 55 4E             defb    'R'+$80,"UN"
 316+ 1370 C9 46                defb    'I'+$80,"F"
 317+ 1372 D2 45 53 54          defb    'R'+$80,"ESTORE"
 317+ 1376 4F 52 45
 318+ 1379 C7 4F 53 55          defb    'G'+$80,"OSUB"
 318+ 137D 42
 319+ 137E D2 45 54 55          defb    'R'+$80,"ETURN"
 319+ 1382 52 4E
 320+ 1384 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 321+ 1387 D3 54 4F 50          defb    'S'+$80,"TOP"
 322+ 138B CF 55 54             defb    'O'+$80,"UT"
 323+ 138E CF 4E                defb    'O'+$80,"N"
 324+ 1390 C6 49 4C 45          defb    'F'+$80,"ILES"
 324+ 1394 53
 325+ 1395 C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 325+ 1399 45
 326+ 139A D7 41 49 54          defb    'W'+$80,"AIT"
 327+ 139E C4 45 46             defb    'D'+$80,"EF"
 328+ 13A1 D0 4F 4B 45          defb    'P'+$80,"OKE"
 329+ 13A5 C4 4F 4B 45          defb    'D'+$80,"OKE"
 330+ 13A9 D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 330+ 13AD 45
 331+ 13AE D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 332+ 13B2 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 333+ 13B6 D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 333+ 13BA 45 4E
 334+ 13BC CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 334+ 13C0 54 45
 335+ 13C2 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 335+ 13C6 44
 336+ 13C7 D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 336+ 13CB 4D 45
 337+ 13CD D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 337+ 13D1 45
 338+ 13D2 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 338+ 13D6 52
 339+ 13D7 D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 340+ 13DB C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 341+ 13DF C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 341+ 13E3 4C 45
 342+ 13E5 D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 342+ 13E9 54
 343+ 13EA D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 343+ 13EE 41 4C
 344+ 13F0 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 345+ 13F4 C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 346+ 13F7 CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 347+ 13FA CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 348+ 13FD C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 348+ 1401 4E 54
 349+ 1403 D7 49 44 54          defb    'W'+$80,"IDTH"
 349+ 1407 48
 350+ 1408 D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 351+ 140B D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 351+ 140F 54
 352+ 1410 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 353+ 1414 D0 52 49 4E          defb    'P'+$80,"RINT"
 353+ 1418 54
 354+ 1419 C3 4F 4E 54          defb    'C'+$80,"ONT"
 355+ 141D CC 49 53 54          defb    'L'+$80,"IST"
 356+ 1421 C3 4C 45 41          defb    'C'+$80,"LEAR"
 356+ 1425 52
 357+ 1426 CC 4F 41 44          defb    'L'+$80,"OAD"
 358+ 142A D3 41 56 45          defb    'S'+$80,"AVE"
 359+ 142E CE 45 57             defb    'N'+$80,"EW"
 360+ 1431 D4 41 42 28          defb    'T'+$80,"AB("
 361+ 1435 D4 4F                defb    'T'+$80,"O"
 362+ 1437 C6 4E                defb    'F'+$80,"N"
 363+ 1439 D3 50 43 28          defb    'S'+$80,"PC("
 364+ 143D D4 48 45 4E          defb    'T'+$80,"HEN"
 365+ 1441 CE 4F 54             defb    'N'+$80,"OT"
 366+ 1444 D3 54 45 50          defb    'S'+$80,"TEP"
 367+ 1448                      ; from here: operators
 368+ 1448 AB                   defb    '+'+$80
 369+ 1449 AD                   defb    '-'+$80
 370+ 144A AA                   defb    '*'+$80
 371+ 144B AF                   defb    '/'+$80
 372+ 144C A5                   defb    '%'+$80
 373+ 144D A3                   defb    '#'+$80
 374+ 144E DE                   defb    '^'+$80
 375+ 144F C1 4E 44             defb    'A'+$80,"ND"
 376+ 1452 D8 4F 52             defb    'X'+$80,"OR"
 377+ 1455 CF 52                defb    'O'+$80,"R"
 378+ 1457 BE                   defb    '>'+$80
 379+ 1458 BD                   defb    '='+$80
 380+ 1459 BC                   defb    '<'+$80
 381+ 145A
 382+ 145A                      ; from here there are the tokens' FUNCTIONS list
 383+ 145A                      ; this list must be coherent with the functions list above
 384+ 145A D3 47 4E             defb    'S'+$80,"GN"
 385+ 145D D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 386+ 1460 C9 4E 54             defb    'I'+$80,"NT"
 387+ 1463 C1 42 53             defb    'A'+$80,"BS"
 388+ 1466 D5 53 52             defb    'U'+$80,"SR"
 389+ 1469 C6 52 45             defb    'F'+$80,"RE"
 390+ 146C C9 4E 50             defb    'I'+$80,"NP"
 391+ 146F D0 4F 53             defb    'P'+$80,"OS"
 392+ 1472 D3 51 52             defb    'S'+$80,"QR"
 393+ 1475 D2 4E 44             defb    'R'+$80,"ND"
 394+ 1478 CC 4F 47             defb    'L'+$80,"OG"
 395+ 147B C5 58 50             defb    'E'+$80,"XP"
 396+ 147E C3 4F 53             defb    'C'+$80,"OS"
 397+ 1481 D3 49 4E             defb    'S'+$80,"IN"
 398+ 1484 D4 41 4E             defb    'T'+$80,"AN"
 399+ 1487 C1 54 4E             defb    'A'+$80,"TN"
 400+ 148A D0 45 45 4B          defb    'P'+$80,"EEK"
 401+ 148E C4 45 45 4B          defb    'D'+$80,"EEK"
 402+ 1492 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 402+ 1496 4B
 403+ 1497 D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 403+ 149B 54
 404+ 149C D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 404+ 14A0 54
 405+ 14A1 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 405+ 14A5 59
 406+ 14A6 D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 406+ 14AA 54
 407+ 14AB C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 407+ 14AF 52
 408+ 14B0 CC 45 4E             defb    'L'+$80,"EN"
 409+ 14B3 D3 54 52 24          defb    'S'+$80,"TR$"
 410+ 14B7 D6 41 4C             defb    'V'+$80,"AL"
 411+ 14BA C1 53 43             defb    'A'+$80,"SC"
 412+ 14BD C3 48 52 24          defb    'C'+$80,"HR$"
 413+ 14C1 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 414+ 14C5 C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 415+ 14C9 CC 45 46 54          defb    'L'+$80,"EFT$"
 415+ 14CD 24
 416+ 14CE D2 49 47 48          defb    'R'+$80,"IGHT$"
 416+ 14D2 54 24
 417+ 14D4 CD 49 44 24          defb    'M'+$80,"ID$"
 418+ 14D8 80                   defb    $80                     ; End-of-list marker
 419+ 14D9
 420+ 14D9              ; KEYWORD ADDRESS TABLE
 421+ 14D9              ; this list must be coherent with the commands'
 422+ 14D9              ; tokens list above
 423+ 14D9 37 1C        WORDTB: defw    PEND
 424+ 14DB 34 1B                defw    FOR
 425+ 14DD 2B 20                defw    NEXT
 426+ 14DF 96 1D                defw    DATA
 427+ 14E1 30 1F                defw    INPUT
 428+ 14E3 80 22                defw    DIM
 429+ 14E5 62 1F                defw    READ
 430+ 14E7 AD 1D                defw    LET
 431+ 14E9 53 1D                defw    GOTO
 432+ 14EB 2E 1D                defw    RUN
 433+ 14ED 25 1E                defw    IF
 434+ 14EF FD 1B                defw    RESTOR
 435+ 14F1 42 1D                defw    GOSUB
 436+ 14F3 71 1D                defw    RETURN
 437+ 14F5 98 1D                defw    REM         ; original REM
 438+ 14F7 35 1C                defw    STOP
 439+ 14F9 C5 28                defw    POUT
 440+ 14FB 07 1E                defw    ON
 441+ 14FD 9B 3E                defw    FILES       ; changed by Leonardo Miliani - was NULL
 442+ 14FF 9C 3E                defw    ERASE       ; added by Leonardo Miliani
 443+ 1501 CB 28                defw    WAIT
 444+ 1503 74 24                defw    DEF
 445+ 1505 BF 29                defw    POKE
 446+ 1507 62 33                defw    DOKE
 447+ 1509 C4 29                defw    VPOKE       ; added by Leonardo Miliani
 448+ 150B 01 2A                defw    SREG        ; added by Leonardo Miliani
 449+ 150D 4F 2B                defw    VREG        ; added by Leonardo Miliani
 450+ 150F 98 33                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 451+ 1511 CF 29                defw    LOCATE      ; added by Leonardo Miliani
 452+ 1513 5B 2A                defw    SOUND       ; added by Leonardo Miliani
 453+ 1515 22 2A                defw    VOLUME      ; added by Leonardo Miliani
 454+ 1517 79 33                defw    PAUSE       ; added by Leonardo Miliani
 455+ 1519 13 34                defw    COLOR       ; added by Leonardo Miliani
 456+ 151B 01 37                defw    PLOT        ; added by Leonardo Miliani
 457+ 151D 94 37                defw    DRAW        ; added by Leonardo Miliani
 458+ 151F CA 38                defw    CIRCLE      ; added by Leonardo Miliani
 459+ 1521 BE 35                defw    PAINT       ; added by Leonardo Miliani
 460+ 1523 CF 3A                defw    SERIAL      ; added by Leonardo Miliani
 461+ 1525 11 3D                defw    HELP        ; changed by Leonardo Miliani - was LINES
 462+ 1527 3B 33                defw    CLS
 463+ 1529 2C 3D                defw    KEY         ; added by Leonardo Miliani
 464+ 152B 0D 29                defw    NMI         ; added by Leonardo Miliani
 465+ 152D CF 34                defw    GPRINT      ; added by Leonardo Miliani
 466+ 152F 4F 33                defw    WIDTH
 467+ 1531 67 29                defw    SYS         ; added by Leonardo Miliani
 468+ 1533 93 3F                defw    RESET       ; new behaviour: now it resets the system
 469+ 1535 9A 1D                defw    REM+2       ; ELSE: added by Leonardo Miliani
 470+ 1537 57 1E                defw    PRINT
 471+ 1539 69 1C                defw    CONT
 472+ 153B 0B 1A                defw    LIST
 473+ 153D E2 1C                defw    CLEAR
 474+ 153F 99 3E                defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
 475+ 1541 9A 3E                defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
 476+ 1543 F0 17                defw    NEW
 477+ 1545
 478+ 1545              ; RESERVED WORD TOKEN VALUES
 479+ 1545              ; if you add a function or command you must increment by 1
 480+ 1545              ; the values below. Pay attention that you must increment only the
 481+ 1545              ; values AFTER the position where you entered the function/command word
 482+ 1545              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 483+ 1545              ; DOKE and SCREEN, and since REM is the reserved work listed below
 484+ 1545              ; that is before the point where VPOKE has been entered, every entry
 485+ 1545              ; after REM has been incremented.
 486+ 1545              ; Another example: when TMR has been added, since it's a function, every
 487+ 1545              ; entry after & included ZSGN must be checked (read below)
 488+ 1545
 489+ 1545              ZEND    equ     $80             ; END        <-- from here, there are the commands
 490+ 1545              ZFOR    equ     $81             ; FOR
 491+ 1545              ZDATA   equ     $83             ; DATA
 492+ 1545              ZGOTO   equ     $88             ; GOTO
 493+ 1545              ZGOSUB  equ     $8C             ; GOSUB
 494+ 1545              ZREM    equ     $8E             ; REM
 495+ 1545              ZELSE   equ     $AE             ; ELSE
 496+ 1545              ZPRINT  equ     $AF             ; PRINT
 497+ 1545              ZNEW    equ     $B5             ; NEW
 498+ 1545
 499+ 1545              ZTAB    equ     $B6             ; TAB
 500+ 1545              ZTO     equ     $B7             ; TO
 501+ 1545              ZFN     equ     $B8             ; FN
 502+ 1545              ZSPC    equ     $B9             ; SPC
 503+ 1545              ZTHEN   equ     $BA             ; THEN
 504+ 1545              ZNOT    equ     $BB             ; NOT
 505+ 1545              ZSTEP   equ     $BC             ; STEP
 506+ 1545
 507+ 1545              ZPLUS   equ     $BD             ; +         <-- from here, there are the math operators
 508+ 1545              ZMINUS  equ     $BE             ; -
 509+ 1545              ZTIMES  equ     $BF             ; *
 510+ 1545              ZDIV    equ     $C0             ; /
 511+ 1545              ZMOD    equ     $C1             ; %
 512+ 1545              ZDINT   equ     $C2             ; #
 513+ 1545              ZOR     equ     $C6             ; OR
 514+ 1545              ZGTR    equ     $C7             ; >
 515+ 1545              ZEQUAL  equ     $C8             ; M
 516+ 1545              ZLTH    equ     $C9             ; <
 517+ 1545
 518+ 1545              ZSGN    equ     $CA             ; SGN       <-- from here, there are the functions
 519+ 1545              ZPOINT  equ     $E0             ; ZPOINT    <-- if the user enters a custom function, between
 520+ 1545                                              ;               SGN and POINT, he/she must increment this pointer by 1
 521+ 1545              ZINSTR  equ     $E1             ; ZINSTR    <-- same here
 522+ 1545              ZLEFT   equ     $E9             ; LEFT$     <-- if the user enters a custom function anywhere,
 523+ 1545                                              ;               he/she must increment this pointer by 1
 524+ 1545
 525+ 1545              ; ARITHMETIC PRECEDENCE TABLE
 526+ 1545              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 527+ 1545              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 528+ 1545 79           PRITAB: defb    $79             ; Precedence value
 529+ 1546 04 30                defw    PADD            ; FPREG = <last> + FPREG
 530+ 1548
 531+ 1548 79                   defb    $79             ; Precedence value
 532+ 1549 E7 2B                defw    PSUB            ; FPREG = <last> - FPREG
 533+ 154B
 534+ 154B 7C                   defb    $7C             ; Precedence value
 535+ 154C 25 2D                defw    MULT            ; PPREG = <last> * FPREG
 536+ 154E
 537+ 154E 7C                   defb    $7C             ; Precedence value
 538+ 154F D7 2D                defw    DIV             ; FPREG = <last> / FPREG
 539+ 1551
 540+ 1551 7C                   defb    $7C             ; Precedence value
 541+ 1552 82 2D                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 542+ 1554
 543+ 1554 7C                   defb    $7C             ; precedence value
 544+ 1555 7A 2D                defw    DINT            ; FPREG = INT(<last> / FPREG )
 545+ 1557
 546+ 1557 7F                   defb    $7F             ; Precedence value
 547+ 1558 25 31                defw    POWER           ; FPREG = <last> ^ FPREG
 548+ 155A
 549+ 155A 50                   defb    $50             ; Precedence value
 550+ 155B C9 21                defw    PAND            ; FPREG = <last> AND FPREG
 551+ 155D
 552+ 155D 4A                   defb    $4A             ; Precedence value
 553+ 155E D1 21                defw    PXOR            ; FPREG = <last> XOR FPREG
 554+ 1560
 555+ 1560 46                   defb    $46             ; Precedence value
 556+ 1561 CC 21                defw    POR             ; FPREG = <last> OR FPREG
 557+ 1563
 558+ 1563
 559+ 1563              ; INITIALISATION TABLE -------------------------------------------------------
 560+ 1563              ; these values are copied into RAM at startup
 561+ 1563 C3 96 12     INITAB: jp      WARMST          ; Warm start jump
 562+ 1566 ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 563+ 1569 C3 B8 1C             jp      FCERR           ; "USR (X)" jump (Set to Error)
 564+ 156C D3 00                out     (0),A           ; "out p,n" skeleton
 565+ 156E C9                   ret
 566+ 156F D6 00                sub     $00             ; Division support routine
 567+ 1571 6F                   ld      L,A
 568+ 1572 7C                   ld      A,H
 569+ 1573 DE 00                sbc     A,$00
 570+ 1575 67                   ld      H,A
 571+ 1576 78                   ld      A,B
 572+ 1577 DE 00                sbc     A,$00
 573+ 1579 47                   ld      B,A
 574+ 157A 3E 00                ld      A,$00
 575+ 157C C9                   ret
 576+ 157D 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 577+ 1580 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 578+ 1584 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 579+ 1588 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 580+ 158C 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 581+ 1590 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 582+ 1594 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 583+ 1598 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 584+ 159C D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 585+ 15A0 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 586+ 15A4 DB 00                in      A,($00)         ; INP (x) skeleton
 587+ 15A6 C9                   ret
 588+ 15A7 FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 589+ 15A8 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 590+ 15A9 00                   defb    $00             ; No nulls after input bytes
 591+ 15AA 00                   defb    $00             ; Output enabled (^O off)
 592+ 15AB 00 00                defw    $00             ; Array load/save check sum
 593+ 15AD 00                   defb    $00             ; Break not by NMI
 594+ 15AE 00                   defb    $00             ; Break flag
 595+ 15AF C3 2C 19             jp      TTYLIN          ; Input reflection (set to TTY)
 596+ 15B2 C9 53                defw    STLOOK          ; Temp string space
 597+ 15B4 FE FF                defw    -2              ; Current line number (cold)
 598+ 15B6 FF FF                defw    -1              ; Current line with errors (no errors)
 599+ 15B8 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 600+ 15B9 08                   defb    $08             ; auto-repeat delay
 601+ 15BA 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 601+ 15BE 0D 00 00 00
 601+ 15C2 00 00 00 00
 601+ 15C6 00 00 00 00
 602+ 15CA 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 602+ 15CE 00 00 00 00
 602+ 15D2 00 00 00 00
 602+ 15D6 00 00 00 00
 603+ 15DA 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 603+ 15DE 45 4E 31 0D
 603+ 15E2 00 00 00 00
 603+ 15E6 00 00 00 00
 604+ 15EA 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 604+ 15EE 52 31 2C 31
 604+ 15F2 35 2C 35 0D
 604+ 15F6 00 00 00 00
 605+ 15FA 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 605+ 15FE 41 4C 31 2C
 605+ 1602 33 38 34 30
 605+ 1606 30 0D 00 00
 606+ 160A 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 606+ 160E 45 4E 32 0D
 606+ 1612 00 00 00 00
 606+ 1616 00 00 00 00
 607+ 161A 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 607+ 161E 0D 00 00 00
 607+ 1622 00 00 00 00
 607+ 1626 00 00 00 00
 608+ 162A 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 608+ 162E 0D 00 00 00
 608+ 1632 00 00 00 00
 608+ 1636 00 00 00 00
 609+ 163A 66 53                defw    PROGST+1        ; Start of program text
 610+ 163C              INITBE:
 611+ 163C
 612+ 163C              ; END OF INITIALISATION TABLE ---------------------------------------------------
 613+ 163C
 614+ 163C 20 45 72 72  ERRMSG: defb    " Error",0
 614+ 1640 6F 72 00
 615+ 1643 20 69 6E 20  INMSG:  defb    " in ",0
 615+ 1647 00
 616+ 1648              ZERBYT  equ     $-1             ; A zero byte
 617+ 1648 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 617+ 164C 00
 618+ 164D 42 72 65 61  BRKMSG: defb    "Break",0
 618+ 1651 6B 00
 619+ 1653
 620+ 1653 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 621+ 1656 39                   add     HL,SP           ; same index as specified
 622+ 1657 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 623+ 1658 23                   inc     HL              ; Point to index address
 624+ 1659 FE 81                cp      ZFOR            ; Is it a "FOR" token
 625+ 165B C0                   ret     NZ              ; No - exit
 626+ 165C 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 627+ 165D 23                   inc     HL
 628+ 165E 46                   ld      B,(HL)
 629+ 165F 23                   inc     HL              ; Point to sign of STEP
 630+ 1660 E5                   push    HL              ; Save pointer to sign
 631+ 1661 69                   ld      L,C             ; HL = address of "FOR" index
 632+ 1662 60                   ld      H,B
 633+ 1663 7A                   ld      A,D             ; See if an index was specified
 634+ 1664 B3                   or      E               ; DE = 0 if no index specified
 635+ 1665 EB                   ex      DE,HL           ; Specified index into HL
 636+ 1666 CA 6D 16             jp      Z,INDFND        ; Skip if no index given
 637+ 1669 EB                   ex      DE,HL           ; Index back into DE
 638+ 166A CD A6 19             call    CPDEHL          ; Compare index with one given
 639+ 166D 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 640+ 1670 E1                   pop     HL              ; Restore pointer to sign
 641+ 1671 C8                   ret     Z               ; Return if block found
 642+ 1672 09                   add     HL,BC           ; Point to next block
 643+ 1673 C3 57 16             jp      LOKFOR          ; Keep on looking
 644+ 1676
 645+ 1676 CD 90 16     MOVUP:  call    ENFMEM          ; See if enough memory
 646+ 1679 C5           MOVSTR: push    BC              ; Save end of source
 647+ 167A E3                   ex      (SP),HL         ; Swap source and dest" end
 648+ 167B C1                   pop     BC              ; Get end of destination
 649+ 167C CD A6 19     MOVLP:  call    CPDEHL          ; See if list moved
 650+ 167F 7E                   ld      A,(HL)          ; Get byte
 651+ 1680 02                   ld      (BC),A          ; Move it
 652+ 1681 C8                   ret     Z               ; Exit if all done
 653+ 1682 0B                   dec     BC              ; Next byte to move to
 654+ 1683 2B                   dec     HL              ; Next byte to move
 655+ 1684 C3 7C 16             jp      MOVLP           ; Loop until all bytes moved
 656+ 1687
 657+ 1687 E5           CHKSTK: push    HL              ; Save code string address
 658+ 1688 2A 46 53             ld      HL,(ARREND)     ; Lowest free memory
 659+ 168B 06 00                ld      B,$00           ; BC = Number of levels to test
 660+ 168D 09                   add     HL,BC           ; 2 Bytes for each level
 661+ 168E 09                   add     HL,BC
 662+ 168F 3E                   defb    $3E             ; Skip "push HL"
 663+ 1690 E5           ENFMEM: push    HL              ; Save code string address
 664+ 1691 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 665+ 1693 95                   sub     L
 666+ 1694 6F                   ld      L,A
 667+ 1695 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 668+ 1697 9C                   sbc     A,H
 669+ 1698 DA 9F 16             jp      C,OMERR         ; Not enough - ?OM Error
 670+ 169B 67                   ld      H,A
 671+ 169C 39                   add     HL,SP           ; Test if stack is overflowed
 672+ 169D E1                   pop     HL              ; Restore code string address
 673+ 169E D8                   ret     C               ; Return if enough memory
 674+ 169F 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 675+ 16A1 C3 DE 16             jp      ERROR
 676+ 16A4
 677+ 16A4
 678+ 16A4              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 679+ 16A4 F5           EXITGM: push    AF              ; store AF
 680+ 16A5 3A ED 52             ld      A,(SCR_MODE)    ; check screen mode
 681+ 16A8 FE 02                cp      $02             ; G2?
 682+ 16AA CA B1 16             jp      Z,LDG1          ; yes, back to G1
 683+ 16AD FE 03                cp      $03             ; G3?
 684+ 16AF 20 11                jr      NZ,LDG1ND       ; no, so return
 685+ 16B1 E5           LDG1:   push    HL              ; store HL
 686+ 16B2 D5                   push    DE              ; store DE
 687+ 16B3 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 688+ 16B6 F3                   di                      ; disable INTs
 689+ 16B7 CD D3 03             call    initVDP         ; initialize VDP with mode pointed by E
 690+ 16BA FB                   ei                      ; re-enable INTs
 691+ 16BB 3E 01                ld      A,$01           ; activate the...
 692+ 16BD 32 F8 52             ld      (PRNTVIDEO),A   ; ...video buffer...
 693+ 16C0 D1                   pop     DE              ; retrieve DE
 694+ 16C1 E1                   pop     HL              ; retrieve HL
 695+ 16C2 F1           LDG1ND: pop     AF              ; retrieve AF
 696+ 16C3 C9                   ret                     ; return to caller
 697+ 16C4
 698+ 16C4
 699+ 16C4 2A CE 52     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 700+ 16C7 22 CD 51             ld      (LINEAT),HL     ; Save as current line
 701+ 16CA 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 702+ 16CC 01                   defb    $01             ; Skip "ld E,DZ"
 703+ 16CD 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 704+ 16CF 01                   defb    $01             ; Skip "ld E,NF"
 705+ 16D0 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 706+ 16D2 01                   defb    $01             ; Skip "ld E,DD"
 707+ 16D3 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 708+ 16D5 01                   defb    $01             ; Skip "ld E,UF"
 709+ 16D6 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 710+ 16D8 01                   defb    $01             ; Skip "ld E,OV
 711+ 16D9 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 712+ 16DB 01                   defb    $01             ; Skip "ld E,TM"
 713+ 16DC 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 714+ 16DE
 715+ 16DE CD 16 18     ERROR:  call    CLREG           ; Clear registers and stack
 716+ 16E1 CD A4 16             call    EXITGM          ; exit from graphic modes
 717+ 16E4 32 C3 51             ld      (CTLOFG),A      ; Enable output (A is 0)
 718+ 16E7 CD 19 09             call    CURSOR_ON       ; enable cursor
 719+ 16EA CD A8 1E             call    STTLIN          ; Start new line
 720+ 16ED 21 FE 0F             ld      HL,ERRTBL       ; Point to error codes
 721+ 16F0 57                   ld      D,A             ; D = 0 (A is 0)
 722+ 16F1 3E 3F                ld      A,'?'
 723+ 16F3 CD B7 19             call    OUTC            ; Output '?'
 724+ 16F6 19                   add     HL,DE           ; Offset to correct error code
 725+ 16F7 5E                   ld      E,(HL)          ; load pointer to error message
 726+ 16F8 23                   inc     HL              ; by loading LSB,
 727+ 16F9 56                   ld      D,(HL)          ; then MSB
 728+ 16FA 62 6B                ld      HL,DE           ; load pointer to HL
 729+ 16FC CD 7E 25             call    PRS             ; Output error message
 730+ 16FF 21 3C 16             ld      HL,ERRMSG       ; "Error" message
 731+ 1702 CD 7E 25     ERRIN:  call    PRS             ; Output message
 732+ 1705 2A CD 51             ld      HL,(LINEAT)     ; Get line of error
 733+ 1708 11 FE FF             ld      DE,-2           ; Cold start error if -2
 734+ 170B CD A6 19             call    CPDEHL          ; See if cold start error
 735+ 170E CA EF 11             jp      Z,CSTART        ; Cold start error - Restart
 736+ 1711 7C                   ld      A,H             ; Was it a direct error?
 737+ 1712 A5                   and     L               ; Line = -1 if direct error
 738+ 1713 3C                   inc     A
 739+ 1714 CA 1F 17             jp      Z,PTLN          ; Yes, jump over
 740+ 1717 E5                   push    HL              ; indirect mode - store HL
 741+ 1718 2A CD 51             ld      HL,(LINEAT)     ; copy current line number
 742+ 171B 22 CF 51             ld      (HLPLN),HL      ; save in HELP line register
 743+ 171E E1                   pop     HL              ; retrieve HL
 744+ 171F C4 15 30     PTLN:   call    NZ,LINEIN       ; No - output line of error
 745+ 1722
 746+ 1722 3E                   defb    $3E             ; Skip "pop BC"
 747+ 1723 C1           POPNOK: pop     BC              ; Drop address in input buffer
 748+ 1724
 749+ 1724              ; run into direct mode: print OK and get command
 750+ 1724 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 751+ 1725 32 C3 51             ld      (CTLOFG),A      ; Enable output
 752+ 1728 CD A8 1E             call    STTLIN          ; Start new line
 753+ 172B 21 48 16             ld      HL,OKMSG        ; "Ok" message
 754+ 172E CD 7E 25             call    PRS             ; Output "Ok"
 755+ 1731 CD 19 09     GETCMD: call    CURSOR_ON       ; enable cursor
 756+ 1734 21 FF FF             ld      HL,-1           ; Flag direct mode
 757+ 1737 22 CD 51             ld      (LINEAT),HL     ; Save as current line
 758+ 173A CD 2C 19             call    GETLIN          ; Get an input line
 759+ 173D DA 31 17             jp      C,GETCMD        ; Get line again if break
 760+ 1740 CD ED 1B             call    GETCHR          ; Get first character
 761+ 1743 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 762+ 1744 DA CA 16             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 763+ 1747 1F                   rra                     ; recover original char and Carry
 764+ 1748 3C                   inc     A               ; Test if end of line
 765+ 1749 3D                   dec     A               ; Without affecting Carry
 766+ 174A CA 31 17             jp      Z,GETCMD        ; Nothing entered - Get another
 767+ 174D F5                   push    AF              ; Save Carry status
 768+ 174E CD 2E 09             call    CURSOR_OFF      ; cursor disabled
 769+ 1751 CD BD 1C             call    ATOH            ; Get line number into DE
 770+ 1754 D5                   push    DE              ; Save line number
 771+ 1755 CD 43 18             call    CRUNCH          ; Tokenise rest of line
 772+ 1758 47                   ld      B,A             ; Length of tokenised line
 773+ 1759 D1                   pop     DE              ; Restore line number
 774+ 175A F1                   pop     AF              ; Restore Carry
 775+ 175B D2 CD 1B             jp      NC,EXCUTE       ; No line number - Direct mode
 776+ 175E D5                   push    DE              ; Save line number
 777+ 175F C5                   push    BC              ; Save length of tokenised line
 778+ 1760 AF                   xor     A
 779+ 1761 32 D1 52             ld      (LSTBIN),A      ; Clear last byte input
 780+ 1764 CD ED 1B             call    GETCHR          ; Get next character
 781+ 1767 B7                   or      A               ; Set flags
 782+ 1768 F5                   push    AF              ; And save them
 783+ 1769 CD D0 17             call    SRCHLN          ; Search for line number in DE
 784+ 176C DA 75 17             jp      C,LINFND        ; Jump if line found
 785+ 176F F1                   pop     AF              ; Get status
 786+ 1770 F5                   push    AF              ; And re-save
 787+ 1771 CA 6C 1D             jp      Z,ULERR         ; Nothing after number - Error
 788+ 1774 B7                   or      A               ; Clear Carry
 789+ 1775 C5           LINFND: push    BC              ; Save address of line in prog
 790+ 1776 D2 8C 17             jp      NC,INEWLN       ; Line not found - Insert new
 791+ 1779 EB                   ex      DE,HL           ; Next line address in DE
 792+ 177A 2A 42 53             ld      HL,(PROGND)     ; End of program
 793+ 177D 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 794+ 177E 02                   ld      (BC),A
 795+ 177F 03                   inc     BC              ; Next destination
 796+ 1780 13                   inc     DE              ; Next source
 797+ 1781 CD A6 19             call    CPDEHL          ; All done?
 798+ 1784 C2 7D 17             jp      NZ,SFTPRG       ; More to do
 799+ 1787 60                   ld      H,B             ; HL - New end of program
 800+ 1788 69                   ld      L,C
 801+ 1789 22 42 53             ld      (PROGND),HL     ; Update end of program
 802+ 178C
 803+ 178C D1           INEWLN: pop     DE              ; Get address of line,
 804+ 178D F1                   pop     AF              ; Get status
 805+ 178E CA B3 17             jp      Z,SETPTR        ; No text - Set up pointers
 806+ 1791 2A 42 53             ld      HL,(PROGND)     ; Get end of program
 807+ 1794 E3                   ex      (SP),HL         ; Get length of input line
 808+ 1795 C1                   pop     BC              ; End of program to BC
 809+ 1796 09                   add     HL,BC           ; Find new end
 810+ 1797 E5                   push    HL              ; Save new end
 811+ 1798 CD 76 16             call    MOVUP           ; Make space for line
 812+ 179B E1                   pop     HL              ; Restore new end
 813+ 179C 22 42 53             ld      (PROGND),HL     ; Update end of program pointer
 814+ 179F EB                   ex      DE,HL           ; Get line to move up in HL
 815+ 17A0 74                   ld      (HL),H          ; Save MSB
 816+ 17A1 D1                   pop     DE              ; Get new line number
 817+ 17A2 23                   inc     HL              ; Skip pointer
 818+ 17A3 23                   inc     HL
 819+ 17A4 73                   ld      (HL),E          ; Save LSB of line number
 820+ 17A5 23                   inc     HL
 821+ 17A6 72                   ld      (HL),D          ; Save MSB of line number
 822+ 17A7 23                   inc     HL              ; To first byte in line
 823+ 17A8 11 56 52             ld      DE,BUFFER       ; Copy buffer to program
 824+ 17AB 1A           MOVBUF: ld      A,(DE)          ; Get source
 825+ 17AC 77                   ld      (HL),A          ; Save destinations
 826+ 17AD 23                   inc     HL              ; Next source
 827+ 17AE 13                   inc     DE              ; Next destination
 828+ 17AF B7                   or      A               ; Done?
 829+ 17B0 C2 AB 17             jp      NZ,MOVBUF       ; No - Repeat
 830+ 17B3 CD FC 17     SETPTR: call    RUNFST          ; Set line pointers
 831+ 17B6 23                   inc     HL              ; To LSB of pointer
 832+ 17B7 EB                   ex      DE,HL           ; Address to DE
 833+ 17B8 62           PTRLP:  ld      H,D             ; Address to HL
 834+ 17B9 6B                   ld      L,E
 835+ 17BA 7E                   ld      A,(HL)          ; Get LSB of pointer
 836+ 17BB 23                   inc     HL              ; To MSB of pointer
 837+ 17BC B6                   or      (HL)            ; Compare with MSB pointer
 838+ 17BD CA 31 17             jp      Z,GETCMD        ; Get command line if end
 839+ 17C0 23                   inc     HL              ; To LSB of line number
 840+ 17C1 23                   inc     HL              ; Skip line number
 841+ 17C2 23                   inc     HL              ; Point to first byte in line
 842+ 17C3 AF                   xor     A               ; Looking for 00 byte
 843+ 17C4 BE           FNDEND: cp      (HL)            ; Found end of line?
 844+ 17C5 23                   inc     HL              ; Move to next byte
 845+ 17C6 C2 C4 17             jp      NZ,FNDEND       ; No - Keep looking
 846+ 17C9 EB                   ex      DE,HL           ; Next line address to HL
 847+ 17CA 73                   ld      (HL),E          ; Save LSB of pointer
 848+ 17CB 23                   inc     HL
 849+ 17CC 72                   ld      (HL),D          ; Save MSB of pointer
 850+ 17CD C3 B8 17             jp      PTRLP           ; Do next line
 851+ 17D0
 852+ 17D0 2A 53 52     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 853+ 17D3 44           SRCHLP: ld      B,H             ; BC = Address to look at
 854+ 17D4 4D                   ld      C,L
 855+ 17D5 7E                   ld      A,(HL)          ; Get address of next line
 856+ 17D6 23                   inc     HL
 857+ 17D7 B6                   or      (HL)            ; End of program found?
 858+ 17D8 2B                   dec     HL
 859+ 17D9 C8                   ret     Z               ; Yes - Line not found
 860+ 17DA 23                   inc     HL
 861+ 17DB 23                   inc     HL
 862+ 17DC 7E                   ld      A,(HL)          ; Get LSB of line number
 863+ 17DD 23                   inc     HL
 864+ 17DE 66                   ld      H,(HL)          ; Get MSB of line number
 865+ 17DF 6F                   ld      L,A
 866+ 17E0 CD A6 19             call    CPDEHL          ; Compare with line in DE
 867+ 17E3 60                   ld      H,B             ; HL = Start of this line
 868+ 17E4 69                   ld      L,C
 869+ 17E5 7E                   ld      A,(HL)          ; Get LSB of next line address
 870+ 17E6 23                   inc     HL
 871+ 17E7 66                   ld      H,(HL)          ; Get MSB of next line address
 872+ 17E8 6F                   ld      L,A             ; Next line to HL
 873+ 17E9 3F                   ccf
 874+ 17EA C8                   ret     Z               ; Lines found - Exit
 875+ 17EB 3F                   ccf
 876+ 17EC D0                   ret     NC              ; Line not found,at line after
 877+ 17ED C3 D3 17             jp      SRCHLP          ; Keep looking
 878+ 17F0
 879+ 17F0 C0           NEW:    ret     NZ              ; Return if any more on line
 880+ 17F1 2A 53 52     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 881+ 17F4 AF                   xor     A               ; Set program area to empty
 882+ 17F5 77                   ld      (HL),A          ; Save LSB = 00
 883+ 17F6 23                   inc     HL
 884+ 17F7 77                   ld      (HL),A          ; Save MSB = 00
 885+ 17F8 23                   inc     HL
 886+ 17F9 22 42 53             ld      (PROGND),HL     ; Set program end
 887+ 17FC
 888+ 17FC 2A 53 52     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 889+ 17FF 2B                   dec     HL
 890+ 1800
 891+ 1800 22 D3 52     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 892+ 1803 2A B4 52             ld      HL,(LSTRAM)     ; Get end of RAM
 893+ 1806 22 C8 52             ld      (STRBOT),HL     ; Clear string space
 894+ 1809 AF                   xor     A
 895+ 180A CD FD 1B             call    RESTOR          ; Reset DATA pointers
 896+ 180D 2A 42 53             ld      HL,(PROGND)     ; Get end of program
 897+ 1810 22 44 53             ld      (VAREND),HL     ; Clear variables
 898+ 1813 22 46 53             ld      (ARREND),HL     ; Clear arrays
 899+ 1816
 900+ 1816 C1           CLREG:  pop     BC              ; Save return address
 901+ 1817 2A CB 51             ld      HL,(STRSPC)     ; Get end of working RAM
 902+ 181A F9                   ld      SP,HL           ; Set stack
 903+ 181B 21 B8 52             ld      HL,TMSTPL       ; Temporary string pool
 904+ 181E 22 B6 52             ld      (TMSTPT),HL     ; Reset temporary string ptr
 905+ 1821 AF                   xor     A               ; A = 00
 906+ 1822 6F                   ld      L,A             ; HL = 0000
 907+ 1823 67                   ld      H,A
 908+ 1824 22 D9 52             ld      (CONTAD),HL     ; No CONTinue
 909+ 1827 32 D0 52             ld      (FORFLG),A      ; Clear FOR flag
 910+ 182A 22 4A 53             ld      (FNRGNM),HL     ; Clear FN argument
 911+ 182D E5                   push    HL              ; HL = 0000
 912+ 182E C5                   push    BC              ; Put back return
 913+ 182F 2A D3 52     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 914+ 1832 C9                   ret                     ; Return to execution driver
 915+ 1833
 916+ 1833 3E 3F        PROMPT: ld      A,'?'           ; '?'
 917+ 1835 CD B7 19             call    OUTC            ; Output character
 918+ 1838 3E 00                ld      A,NLLCR         ; null char
 919+ 183A CD B7 19             call    OUTC            ; Output character
 920+ 183D CD 19 09             call    CURSOR_ON       ; enable cursor
 921+ 1840 C3 C8 51             jp      RINPUT          ; Get input line
 922+ 1843
 923+ 1843 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 924+ 1844 32 B3 52             ld      (DATFLG),A      ; Reset literal flag
 925+ 1847 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 926+ 1849 11 56 52             ld      DE,BUFFER       ; Start of input buffer
 927+ 184C 7E           CRNCLP: ld      A,(HL)          ; Get byte
 928+ 184D FE 20                cp      SPC             ; Is it a space?
 929+ 184F CA CB 18             jp      Z,MOVDIR        ; Yes - Copy direct
 930+ 1852 47                   ld      B,A             ; Save character
 931+ 1853 FE 22                cp      $22             ; '"'             ; Is it a quote?
 932+ 1855 CA EB 18             jp      Z,CPYLIT        ; Yes - Copy literal string
 933+ 1858 B7                   or      A               ; Is it end of buffer?
 934+ 1859 CA F2 18             jp      Z,ENDBUF        ; Yes - End buffer
 935+ 185C 3A B3 52             ld      A,(DATFLG)      ; Get data type
 936+ 185F B7                   or      A               ; Literal?
 937+ 1860 7E                   ld      A,(HL)          ; Get byte to copy
 938+ 1861 C2 CB 18             jp      NZ,MOVDIR       ; Literal - Copy direct
 939+ 1864 FE 3F                cp      '?'             ; Is it '?' short for PRINT
 940+ 1866 3E AF                ld      A,ZPRINT        ; "PRINT" token
 941+ 1868 CA CB 18             jp      Z,MOVDIR        ; Yes - replace it
 942+ 186B 7E                   ld      A,(HL)          ; Get byte again
 943+ 186C FE 30                cp      '0'             ; Is it less than '0'
 944+ 186E DA 76 18             jp      C,FNDWRD        ; Yes - Look for reserved words
 945+ 1871 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
 946+ 1873 DA CB 18             jp      C,MOVDIR        ; Yes - copy it direct
 947+ 1876 D5           FNDWRD: push    DE              ; Look for reserved words
 948+ 1877 11 4B 13             ld      DE,WORDS-1      ; Point to table
 949+ 187A C5                   push    BC              ; Save count
 950+ 187B 01 C7 18             ld      BC,RETNAD       ; Where to return to
 951+ 187E C5                   push    BC              ; Save return address
 952+ 187F 06 7F                ld      B,ZEND-1        ; First token value -1
 953+ 1881 7E                   ld      A,(HL)          ; Get byte
 954+ 1882 FE 61                cp      'a'             ; Less than 'a' ?
 955+ 1884 DA 8F 18             jp      C,SEARCH        ; Yes - search for words
 956+ 1887 FE 7B                cp      'z'+1           ; Greater than 'z' ?
 957+ 1889 D2 8F 18             jp      NC,SEARCH       ; Yes - search for words
 958+ 188C E6 5F                and     %01011111       ; Force upper case
 959+ 188E 77                   ld      (HL),A          ; Replace byte
 960+ 188F 4E           SEARCH: ld      C,(HL)          ; Search for a word
 961+ 1890 EB                   ex      DE,HL
 962+ 1891 23           GETNXT: inc     HL              ; Get next reserved word
 963+ 1892 B6                   or      (HL)            ; Start of word?
 964+ 1893 F2 91 18             jp      P,GETNXT        ; No - move on
 965+ 1896 04                   inc     B               ; Increment token value
 966+ 1897 7E                   ld      A,(HL)          ; Get byte from table
 967+ 1898 E6 7F                and     %01111111       ; Strip bit 7
 968+ 189A C8                   ret     Z               ; Return if end of list
 969+ 189B B9                   cp      C               ; Same character as in buffer?
 970+ 189C C2 91 18             jp      NZ,GETNXT       ; No - get next word
 971+ 189F EB                   ex      DE,HL
 972+ 18A0 E5                   push    HL              ; Save start of word
 973+ 18A1
 974+ 18A1 13           NXTBYT: inc     DE              ; Look through rest of word
 975+ 18A2 1A                   ld      A,(DE)          ; Get byte from table
 976+ 18A3 B7                   or      A               ; End of word ?
 977+ 18A4 FA C3 18             jp      M,MATCH         ; Yes - Match found
 978+ 18A7 4F                   ld      C,A             ; Save it
 979+ 18A8 78                   ld      A,B             ; Get token value
 980+ 18A9 FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
 981+ 18AB C2 B2 18             jp      NZ,NOSPC        ; No - Don't allow spaces
 982+ 18AE CD ED 1B             call    GETCHR          ; Get next character
 983+ 18B1 2B                   dec     HL              ; Cancel increment from GETCHR
 984+ 18B2 23           NOSPC:  inc     HL              ; Next byte
 985+ 18B3 7E                   ld      A,(HL)          ; Get byte
 986+ 18B4 FE 61                cp      'a'             ; Less than 'a' ?
 987+ 18B6 DA BB 18             jp      C,NOCHNG        ; Yes - don't change
 988+ 18B9 E6 5F                and     %01011111       ; Make upper case
 989+ 18BB B9           NOCHNG: cp      C               ; Same as in buffer ?
 990+ 18BC CA A1 18             jp      Z,NXTBYT        ; Yes - keep testing
 991+ 18BF E1                   pop     HL              ; Get back start of word
 992+ 18C0 C3 8F 18             jp      SEARCH          ; Look at next word
 993+ 18C3
 994+ 18C3 48           MATCH:  ld      C,B             ; Word found - Save token value
 995+ 18C4 F1                   pop     AF              ; Throw away return
 996+ 18C5 EB                   ex      DE,HL
 997+ 18C6 C9                   ret                     ; Return to "RETNAD"
 998+ 18C7 EB           RETNAD: ex      DE,HL           ; Get address in string
 999+ 18C8 79                   ld      A,C             ; Get token value
1000+ 18C9 C1                   pop     BC              ; Restore buffer length
1001+ 18CA D1                   pop     DE              ; Get destination address
1002+ 18CB 23           MOVDIR: inc     HL              ; Next source in buffer
1003+ 18CC 12                   ld      (DE),A          ; Put byte in buffer
1004+ 18CD 13                   inc     DE              ; Move up buffer
1005+ 18CE 0C                   inc     C               ; Increment length of buffer
1006+ 18CF D6 3A                sub     ':'             ; End of statement?
1007+ 18D1 CA D9 18             jp      Z,SETLIT        ; Jump if multi-statement line
1008+ 18D4 FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1009+ 18D6 C2 DC 18             jp      NZ,TSTREM       ; No - see if REM
1010+ 18D9 32 B3 52     SETLIT: ld      (DATFLG),A      ; Set literal flag
1011+ 18DC D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1012+ 18DE C2 4C 18             jp      NZ,CRNCLP       ; No - Leave flag
1013+ 18E1 47                   ld      B,A             ; Copy rest of buffer
1014+ 18E2 7E           NXTCHR: ld      A,(HL)          ; Get byte
1015+ 18E3 B7                   or      A               ; End of line ?
1016+ 18E4 CA F2 18             jp      Z,ENDBUF        ; Yes - Terminate buffer
1017+ 18E7 B8                   cp      B               ; End of statement ?
1018+ 18E8 CA CB 18             jp      Z,MOVDIR        ; Yes - Get next one
1019+ 18EB 23           CPYLIT: inc     HL              ; Move up source string
1020+ 18EC 12                   ld      (DE),A          ; Save in destination
1021+ 18ED 0C                   inc     C               ; Increment length
1022+ 18EE 13                   inc     DE              ; Move up destination
1023+ 18EF C3 E2 18             jp      NXTCHR          ; Repeat
1024+ 18F2
1025+ 18F2 21 55 52     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1026+ 18F5 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1027+ 18F6 13                   inc     DE
1028+ 18F7 12                   ld      (DE),A          ; A = 00
1029+ 18F8 13                   inc     DE
1030+ 18F9 12                   ld      (DE),A          ; A = 00
1031+ 18FA C9                   ret
1032+ 18FB
1033+ 18FB 3A C2 51     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1034+ 18FE B7                   or      A               ; Is it zero?
1035+ 18FF 3E 00                ld      A,$00           ; Zero A - Leave flags
1036+ 1901 32 C2 51             ld      (NULFLG),A      ; Zero null flag
1037+ 1904 C2 0F 19             jp      NZ,ECHDEL       ; Set - Echo it
1038+ 1907 05                   dec     B               ; Decrement length
1039+ 1908 CA 2C 19             jp      Z,GETLIN        ; Get line again if empty
1040+ 190B CD B7 19             call    OUTC            ; Output null character
1041+ 190E 3E                   defb    $3E             ; Skip "dec B"
1042+ 190F 05           ECHDEL: dec     B               ; Count bytes in buffer
1043+ 1910 2B                   dec     HL              ; Back space buffer
1044+ 1911 CA 23 19             jp      Z,OTKLN         ; No buffer - Try again
1045+ 1914 7E                   ld      A,(HL)          ; Get deleted byte
1046+ 1915 CD B7 19             call    OUTC            ; Echo it
1047+ 1918 C3 35 19             jp      MORINP          ; Get more input
1048+ 191B
1049+ 191B 05           DELCHR: dec     B               ; Count bytes in buffer
1050+ 191C 2B                   dec     HL              ; Back space buffer
1051+ 191D CD B7 19             call    OUTC            ; Output character in A
1052+ 1920 C2 35 19             jp      NZ,MORINP       ; Not end - Get more
1053+ 1923 CD B7 19     OTKLN:  call    OUTC            ; Output character in A
1054+ 1926 CD BA 1E     KILIN:  call    PRNTCRLF        ; Output CRLF
1055+ 1929 C3 2C 19             jp      TTYLIN          ; Get line again
1056+ 192C
1057+ 192C              GETLIN:
1058+ 192C 21 56 52     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1059+ 192F 06 01                ld      B,$01           ; Set buffer as empty
1060+ 1931 AF                   xor     A
1061+ 1932 32 C2 51             ld      (NULFLG),A      ; Clear null flag
1062+ 1935 CD F8 19     MORINP: call    CLOTST          ; Get character and test ^O
1063+ 1938 4F                   ld      C,A             ; Save character in C
1064+ 1939 FE 7F                cp      DEL             ; Delete character?
1065+ 193B CA FB 18             jp      Z,DODEL         ; Yes - Process it
1066+ 193E 3A C2 51             ld      A,(NULFLG)      ; Get null flag
1067+ 1941 B7                   or      A               ; Test null flag status
1068+ 1942 CA 4E 19             jp      Z,PROCES        ; Reset - Process character
1069+ 1945 3E 00                ld      A,$00           ; Set a null
1070+ 1947 CD B7 19             call    OUTC            ; Output null
1071+ 194A AF                   xor     A               ; Clear A
1072+ 194B 32 C2 51             ld      (NULFLG),A      ; Reset null flag
1073+ 194E 79           PROCES: ld      A,C             ; Get character
1074+ 194F FE 07                cp      CTRLG           ; Bell?
1075+ 1951 CA 8E 19             jp      Z,PUTCTL        ; Yes - Save it
1076+ 1954 FE 03                cp      CTRLC           ; Is it control "C"?
1077+ 1956 CC 83 19             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1078+ 1959 37                   scf                     ; Flag break
1079+ 195A C8                   ret     Z               ; Return if control "C"
1080+ 195B FE 0D                cp      CR              ; Is it enter?
1081+ 195D CA B0 1E             jp      Z,ENDINP        ; Yes - Terminate input
1082+ 1960 FE 15                cp      CTRLU           ; Is it control "U"?
1083+ 1962 CA 26 19             jp      Z,KILIN         ; Yes - Get another line
1084+ 1965 FE 08                cp      BKSP            ; Is it backspace?
1085+ 1967 CA 1B 19             jp      Z,DELCHR        ; Yes - Delete character
1086+ 196A FE 12                cp      CTRLR           ; Is it control "R"?
1087+ 196C C2 89 19             jp      NZ,PUTBUF       ; No - Put in buffer
1088+ 196F C5                   push    BC              ; Save buffer length
1089+ 1970 D5                   push    DE              ; Save DE
1090+ 1971 E5                   push    HL              ; Save buffer address
1091+ 1972 36 00                ld      (HL),$00        ; Mark end of buffer
1092+ 1974 CD B1 3F             call    OUTNCR          ; Output and do CRLF
1093+ 1977 21 56 52             ld      HL,BUFFER       ; Point to buffer start
1094+ 197A CD 7E 25             call    PRS             ; Output buffer
1095+ 197D E1                   pop     HL              ; Restore buffer address
1096+ 197E D1                   pop     DE              ; Restore DE
1097+ 197F C1                   pop     BC              ; Restore buffer length
1098+ 1980 C3 35 19             jp      MORINP          ; Get another character
1099+ 1983 CD A4 16     GMNCR:  call    EXITGM          ; exit from graphic mode
1100+ 1986 C3 BA 1E             jp      PRNTCRLF        ; output CRLF
1101+ 1989
1102+ 1989 FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1103+ 198B DA 35 19             jp      C,MORINP        ; Yes - Ignore
1104+ 198E 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1105+ 198F FE 59                cp      $58+$01         ; Test for line overflow
1106+ 1991 3E 08                ld      A,BKSP          ; Set a bell
1107+ 1993 D2 A0 19             jp      NC,OUTNBS       ; Ring bell if buffer full
1108+ 1996 79                   ld      A,C             ; Get character
1109+ 1997 71                   ld      (HL),C          ; Save in buffer
1110+ 1998 32 D1 52             ld      (LSTBIN),A      ; Save last input byte
1111+ 199B 23                   inc     HL              ; Move up buffer
1112+ 199C 04                   inc     B               ; Increment length
1113+ 199D C3 35 19     OUTIT:  jp      MORINP          ; Get another character
1114+ 19A0
1115+ 19A0 CD B7 19     OUTNBS: call    OUTC            ; Output bell and back over it
1116+ 19A3 C3 9D 19             jp      OUTIT           ; get more chars
1117+ 19A6
1118+ 19A6 7C           CPDEHL: ld      A,H             ; Get H
1119+ 19A7 92                   sub     D               ; Compare with D
1120+ 19A8 C0                   ret     NZ              ; Different - Exit
1121+ 19A9 7D                   ld      A,L             ; Get L
1122+ 19AA 93                   sub     E               ; Compare with E
1123+ 19AB C9                   ret                     ; Return status
1124+ 19AC
1125+ 19AC 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1126+ 19AD E3                   ex      (SP),HL         ; Address of test byte
1127+ 19AE BE                   cp      (HL)            ; Same as in code string?
1128+ 19AF 23                   inc     HL              ; Return address
1129+ 19B0 E3                   ex      (SP),HL         ; Put it back
1130+ 19B1 CA ED 1B             jp      Z,GETCHR        ; Yes - Get next character
1131+ 19B4 C3 CA 16             jp      SNERR           ; Different - ?SN Error
1132+ 19B7
1133+ 19B7 F5           OUTC:   push    AF              ; Save character
1134+ 19B8 3A C3 51             ld      A,(CTLOFG)      ; Get control "O" flag
1135+ 19BB B7                   or      A               ; Is it set?
1136+ 19BC C2 B3 25             jp      NZ,POPAF        ; Yes - don't output
1137+ 19BF F1                   pop     AF              ; Restore character
1138+ 19C0 C5                   push    BC              ; Save buffer length
1139+ 19C1 F5                   push    AF              ; Save character
1140+ 19C2 FE 20                cp      SPC             ; Is it a control code?
1141+ 19C4 DA DB 19             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1142+ 19C7 3A C0 51             ld      A,(LWIDTH)      ; Get line width
1143+ 19CA 47                   ld      B,A             ; To B
1144+ 19CB 3A B0 52             ld      A,(CURPOS)      ; Get cursor position
1145+ 19CE 04                   inc     B               ; Width 255?
1146+ 19CF CA D7 19             jp      Z,INCLEN        ; Yes - No width limit
1147+ 19D2 05                   dec     B               ; Restore width
1148+ 19D3 B8                   cp      B               ; At end of line?
1149+ 19D4 CC BA 1E             call    Z,PRNTCRLF      ; Yes - output CRLF
1150+ 19D7 3C           INCLEN: inc     A               ; Move on one character
1151+ 19D8 32 B0 52             ld      (CURPOS),A      ; Save new position
1152+ 19DB AF           DINPOS: xor     A
1153+ 19DC 32 36 53             ld      (KBDNPT),A      ; set flag for no char from keyboard
1154+ 19DF F1                   pop     AF              ; Restore character
1155+ 19E0 C1                   pop     BC              ; Restore buffer length
1156+ 19E1 F5                   push    AF
1157+ 19E2 CD EA 19             call    SND2VID         ; send char to video
1158+ 19E5 F1                   pop     AF
1159+ 19E6 CD 90 3F             call    MONOUT          ; send char to serial if enabled
1160+ 19E9 C9                   ret
1161+ 19EA
1162+ 19EA              ; print char to video if cursor is on
1163+ 19EA 32 F9 52     SND2VID:ld      (CHR4VID),A     ; store A
1164+ 19ED 3A F8 52             ld      A,(PRNTVIDEO)   ; check print-on-video
1165+ 19F0 B7                   or      A               ; is it off?
1166+ 19F1 C8                   ret     Z               ; yes, so return
1167+ 19F2 F3                   di                      ; disable INTs
1168+ 19F3 CD 4E 07             call    CHAR2VID        ; cursor is on, so print char on screen
1169+ 19F6 FB                   ei                      ; re-enable INTs
1170+ 19F7 C9                   ret                     ; return to caller
1171+ 19F8
1172+ 19F8 CD 39 33     CLOTST: call    GETINP          ; Get input character
1173+ 19FB FE 0F                cp      CTRLO           ; Is it control "O"?
1174+ 19FD C0                   ret     NZ              ; No don't flip flag
1175+ 19FE 3A C3 51             ld      A,(CTLOFG)      ; Get flag
1176+ 1A01 2F                   cpl                     ; Flip it
1177+ 1A02 32 C3 51             ld      (CTLOFG),A      ; Put it back
1178+ 1A05 A7                   and     A               ; is output enabled?
1179+ 1A06 CC 19 09             call    Z,CURSOR_ON     ; yes, so cursor on
1180+ 1A09 AF                   xor     A               ; Null character
1181+ 1A0A C9                   ret
1182+ 1A0B
1183+ 1A0B              ; LIST: list the program stored into memory
1184+ 1A0B C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1185+ 1A0C 2B                   dec     HL              ; dec 'cos GETCHR INCs
1186+ 1A0D CD ED 1B             call    GETCHR          ; Get next character
1187+ 1A10 CA 66 1A             jp      Z,LSTALL        ; list all if nothing follows
1188+ 1A13 FE BE                cp      ZMINUS          ; is it '-'?
1189+ 1A15 20 20                jr      NZ,LST01        ; no, look for a line number
1190+ 1A17 11 00 00             ld      DE,$0000        ; yes, set search from 0
1191+ 1A1A CD 07 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1192+ 1A1D ED 43 FC 52          ld      (TMPBFR1),BC    ; store address of starting line
1193+ 1A21 CD AC 19             call    CHKSYN          ; skip '-'
1194+ 1A24 BE                   defb    ZMINUS
1195+ 1A25 CD BD 1C             call    ATOH            ; now, look for another number (ASCII number to DE)
1196+ 1A28 CD 0D 1B             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1197+ 1A2B ED 43 FE 52          ld      (TMPBFR2),BC    ; store address of ending line
1198+ 1A2F ED 4B FC 52          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1199+ 1A33 C5                   push    BC              ; store address of line for later use
1200+ 1A34 C3 9E 1A             jp      LISTLP          ; go listing
1201+ 1A37 CD BD 1C     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1202+ 1A3A ED 53 02 53  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1203+ 1A3E CD 07 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1204+ 1A41 ED 43 FC 52          ld      (TMPBFR1),BC    ; store address of starting line
1205+ 1A45 ED 43 FE 52          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1206+ 1A49 2B                   dec     HL              ; dec 'cos GETCHR INCs
1207+ 1A4A CD ED 1B             call    GETCHR          ; Get next character
1208+ 1A4D CA 59 1A             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1209+ 1A50 FE BE                cp      ZMINUS          ; is it '-'?
1210+ 1A52 CA 7E 1A             jp      Z,LST03         ; yes, read ending line
1211+ 1A55 C5           LST06:  push    BC              ; store address for later use
1212+ 1A56 C3 9E 1A             jp      LISTLP          ; jump to list
1213+ 1A59 ED 5B 02 53  LSTNOT: ld      DE,(TMPBFR4)
1214+ 1A5D CD 07 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1215+ 1A60 DA 55 1A             jp      C,LST06
1216+ 1A63 C3 24 17             jp      PRNTOK
1217+ 1A66 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1218+ 1A69 CD 07 1B             call    SRCHLIN         ; get address of last line
1219+ 1A6C ED 43 FE 52          ld      (TMPBFR2),BC    ; store it
1220+ 1A70 11 00 00             ld      DE,$0000        ; set start to first line in memory
1221+ 1A73 CD 07 1B             call    SRCHLIN         ; get address of first line
1222+ 1A76 ED 43 FC 52          ld      (TMPBFR1),BC    ; store it
1223+ 1A7A C5                   push    BC              ; store address of starting line for later use
1224+ 1A7B C3 9E 1A             jp      LISTLP          ; start printing
1225+ 1A7E CD AC 19     LST03:  call    CHKSYN          ; skip '-'
1226+ 1A81 BE                   defb    ZMINUS
1227+ 1A82 CD BD 1C             call    ATOH            ; look for another number (return into DE)
1228+ 1A85 7A                   ld      A,D
1229+ 1A86 B3                   or      E               ; is line=0?
1230+ 1A87 20 09                jr      NZ,LST05        ; no, jump over
1231+ 1A89 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1232+ 1A8C CD 07 1B             call    SRCHLIN         ; get address of last line
1233+ 1A8F C3 95 1A             jp      LST02
1234+ 1A92 CD 0D 1B     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1235+ 1A95 ED 43 FE 52  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1236+ 1A99 ED 4B FC 52          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1237+ 1A9D C5                   push    BC              ; store it for later use
1238+ 1A9E E1           LISTLP: pop     HL              ; Restore address of line
1239+ 1A9F 4E                   ld      C,(HL)          ; Get LSB of next line
1240+ 1AA0 23                   inc     HL
1241+ 1AA1 46                   ld      B,(HL)          ; Get MSB of next line
1242+ 1AA2 23                   inc     HL
1243+ 1AA3 78                   ld      A,B             ; BC = 0 (End of program)?
1244+ 1AA4 B1                   or      C
1245+ 1AA5 CA 24 17             jp      Z,PRNTOK        ; Yes - Go to command mode
1246+ 1AA8 CD 18 1C             call    TSTBRK          ; Test for break key
1247+ 1AAB CD 1B 1B             call    TSTSPC          ; test for space
1248+ 1AAE C5                   push    BC              ; Save address of next line
1249+ 1AAF 3A F1 52             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1250+ 1AB2 A7                   and     A               ; is it at the beginning of a new line?
1251+ 1AB3 20 0B                jr      NZ,LST08        ; No, jump over
1252+ 1AB5 3E 0D                ld      A,CR            ; yes, so just send a CR
1253+ 1AB7 CD 90 3F             call    MONOUT          ; to serial if it's open
1254+ 1ABA AF                   xor     A               ; then, set cursor
1255+ 1ABB 32 B0 52             ld      (CURPOS),A      ; to position 0
1256+ 1ABE 18 03                jr      LST07           ; and continue
1257+ 1AC0 CD BA 1E     LST08:  call    PRNTCRLF        ; output CRLF
1258+ 1AC3 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1259+ 1AC4 23                   inc     HL
1260+ 1AC5 56                   ld      D,(HL)          ; Get MSB of line number
1261+ 1AC6 23                   inc     HL
1262+ 1AC7 E5                   push    HL              ; Save address of line start
1263+ 1AC8 EB                   ex      DE,HL           ; Line number to HL
1264+ 1AC9 CD 1D 30             call    PRNTHL          ; Output line number in decimal
1265+ 1ACC 3E 20                ld      A,SPC           ; Space after line number
1266+ 1ACE E1                   pop     HL              ; Restore start of line address
1267+ 1ACF CD B7 19     LSTLP2: call    OUTC            ; Output character in A
1268+ 1AD2 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1269+ 1AD3 B7                   or      A               ; End of line?
1270+ 1AD4 23                   inc     HL              ; To next byte in line
1271+ 1AD5 CA F9 1A             jp      Z,NXTLN         ; Yes - check next line
1272+ 1AD8 F2 CF 1A             jp      P,LSTLP2        ; No token - output it
1273+ 1ADB D6 7F                sub     ZEND-1          ; Find and output word
1274+ 1ADD 4F                   ld      C,A             ; Token offset+1 to C
1275+ 1ADE 11 4C 13             ld      DE,WORDS        ; Reserved word list
1276+ 1AE1 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1277+ 1AE2 13                   inc     DE              ; Move on to next
1278+ 1AE3 B7                   or      A               ; Is it start of word?
1279+ 1AE4 F2 E1 1A             jp      P,FNDTOK        ; No - Keep looking for word
1280+ 1AE7 0D                   dec     C               ; Count words
1281+ 1AE8 C2 E1 1A             jp      NZ,FNDTOK       ; Not there - keep looking
1282+ 1AEB E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1283+ 1AED CD B7 19             call    OUTC            ; Output character
1284+ 1AF0 1A                   ld      A,(DE)          ; Get next character
1285+ 1AF1 13                   inc     DE              ; Move on to next
1286+ 1AF2 B7                   or      A               ; Is it end of word?
1287+ 1AF3 F2 EB 1A             jp      P,OUTWRD        ; No - output the rest
1288+ 1AF6 C3 D2 1A             jp      LSTLP3          ; Next byte in line
1289+ 1AF9 D1           NXTLN:  pop     DE              ; recover address of current line
1290+ 1AFA 2A FE 52             ld      HL,(TMPBFR2)    ; address of last line to print
1291+ 1AFD CD B7 3F             call    CMP16           ; check if current line is over last printable line
1292+ 1B00 DA 24 17             jp      C,PRNTOK        ; finish - leave & print OK
1293+ 1B03 D5                   push    DE              ; store address of current line
1294+ 1B04 C3 9E 1A             jp      LISTLP          ; continue listing
1295+ 1B07              ; look for the address of a program line
1296+ 1B07 E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1297+ 1B08 CD D0 17             call    SRCHLN          ; search for line number in DE
1298+ 1B0B E1                   pop     HL              ; retrieve HL
1299+ 1B0C C9                   ret                     ; return to caller
1300+ 1B0D              ; look for the address of a program line - if the line isn't found,
1301+ 1B0D              ; it look backward for the previous line
1302+ 1B0D E5           SRCLN:  push    HL              ; store HL
1303+ 1B0E CD D0 17     SRCLN1: call    SRCHLN          ; search for line in DE
1304+ 1B11 DA 19 1B             jp      C,LVSRLN        ; found it, leave loop
1305+ 1B14 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1306+ 1B15 7B                   ld      A,E
1307+ 1B16 B2                   or      D               ; is line number zero?
1308+ 1B17 20 F5                jr      NZ,SRCLN1       ; no, continue
1309+ 1B19 E1           LVSRLN: pop     HL              ; retrieve HL
1310+ 1B1A C9                   ret                     ; return to caller
1311+ 1B1B
1312+ 1B1B              ; during LISTing, check if PAUSE is pressed, then pause listing and
1313+ 1B1B              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1314+ 1B1B 3A 38 53     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1315+ 1B1E FE 20                cp      SPC             ; Is it SPACE?
1316+ 1B20 C0                   ret     NZ              ; No, return
1317+ 1B21 CD 39 33     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1318+ 1B24 FE 20                cp      SPC             ; is it SPACE?
1319+ 1B26 20 05                jr      NZ,CNTWTSP      ; no, continue
1320+ 1B28 AF                   xor     A
1321+ 1B29 32 38 53             ld      (TMPKEYBFR),A   ; reset key
1322+ 1B2C C9                   ret                     ; return to caller
1323+ 1B2D FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1324+ 1B2F 20 F0                jr      NZ,WTSPC        ; no, loop
1325+ 1B31 C3 99 12             jp      BRKRET          ; exit and output "Ok"
1326+ 1B34
1327+ 1B34
1328+ 1B34 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1329+ 1B36 32 D0 52             ld      (FORFLG),A      ; Save "FOR" flag
1330+ 1B39 CD AD 1D             call    LET             ; Set up initial index
1331+ 1B3C C1                   pop     BC              ; Drop RETurn address
1332+ 1B3D E5                   push    HL              ; Save code string address
1333+ 1B3E CD 96 1D             call    DATA            ; Get next statement address
1334+ 1B41 22 CC 52             ld      (LOOPST),HL     ; Save it for start of loop
1335+ 1B44 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1336+ 1B47 39                   add     HL,SP           ; Point to it
1337+ 1B48 CD 57 16     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1338+ 1B4B D1                   pop     DE              ; Get code string address
1339+ 1B4C C2 64 1B             jp      NZ,FORFND       ; No nesting found
1340+ 1B4F 09                   add     HL,BC           ; Move into "FOR" block
1341+ 1B50 D5                   push    DE              ; Save code string address
1342+ 1B51 2B                   dec     HL
1343+ 1B52 56                   ld      D,(HL)          ; Get MSB of loop statement
1344+ 1B53 2B                   dec     HL
1345+ 1B54 5E                   ld      E,(HL)          ; Get LSB of loop statement
1346+ 1B55 23                   inc     HL
1347+ 1B56 23                   inc     HL
1348+ 1B57 E5                   push    HL              ; Save block address
1349+ 1B58 2A CC 52             ld      HL,(LOOPST)     ; Get address of loop statement
1350+ 1B5B CD A6 19             call    CPDEHL          ; Compare the FOR loops
1351+ 1B5E E1                   pop     HL              ; Restore block address
1352+ 1B5F C2 48 1B             jp      NZ,FORSLP       ; Different FORs - Find another
1353+ 1B62 D1                   pop     DE              ; Restore code string address
1354+ 1B63 F9                   ld      SP,HL           ; Remove all nested loops
1355+ 1B64
1356+ 1B64 EB           FORFND: ex      DE,HL           ; Code string address to HL
1357+ 1B65 0E 08                ld      C,$08
1358+ 1B67 CD 87 16             call    CHKSTK          ; Check for 8 levels of stack
1359+ 1B6A E5                   push    HL              ; Save code string address
1360+ 1B6B 2A CC 52             ld      HL,(LOOPST)     ; Get first statement of loop
1361+ 1B6E E3                   ex      (SP),HL         ; Save and restore code string
1362+ 1B6F E5                   push    HL              ; Re-save code string address
1363+ 1B70 2A CD 51             ld      HL,(LINEAT)     ; Get current line number
1364+ 1B73 E3                   ex      (SP),HL         ; Save and restore code string
1365+ 1B74 CD 79 20             call    TSTNUM          ; Make sure it's a number
1366+ 1B77 CD AC 19             call    CHKSYN          ; Make sure "TO" is next
1367+ 1B7A B7                   defb    ZTO             ; "TO" token
1368+ 1B7B CD 76 20             call    GETNUM          ; Get "TO" expression value
1369+ 1B7E E5                   push    HL              ; Save code string address
1370+ 1B7F CD CF 2E             call    BCDEFP          ; Move "TO" value to BCDE
1371+ 1B82 E1                   pop     HL              ; Restore code string address
1372+ 1B83 C5                   push    BC              ; Save "TO" value in block
1373+ 1B84 D5                   push    DE
1374+ 1B85 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1375+ 1B88 51                   ld      D,C             ; C=0
1376+ 1B89 5A                   ld      E,D             ; D=0
1377+ 1B8A 7E                   ld      A,(HL)          ; Get next byte in code string
1378+ 1B8B FE BC                cp      ZSTEP           ; See if "STEP" is stated
1379+ 1B8D 3E 01                ld      A,$01           ; Sign of step = 1
1380+ 1B8F C2 A0 1B             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1381+ 1B92 CD ED 1B             call    GETCHR          ; Jump over "STEP" token
1382+ 1B95 CD 76 20             call    GETNUM          ; Get step value
1383+ 1B98 E5                   push    HL              ; Save code string address
1384+ 1B99 CD CF 2E             call    BCDEFP          ; Move STEP to BCDE
1385+ 1B9C CD 83 2E             call    TSTSGN          ; Test sign of FPREG
1386+ 1B9F E1                   pop     HL              ; Restore code string address
1387+ 1BA0 C5           SAVSTP: push    BC              ; Save the STEP value in block
1388+ 1BA1 D5                   push    DE
1389+ 1BA2 F5                   push    AF              ; Save sign of STEP
1390+ 1BA3 33                   inc     SP              ; Don't save flags
1391+ 1BA4 E5                   push    HL              ; Save code string address
1392+ 1BA5 2A D3 52             ld      HL,(BRKLIN)     ; Get address of index variable
1393+ 1BA8 E3                   ex      (SP),HL         ; Save and restore code string
1394+ 1BA9 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1395+ 1BAB C5                   push    BC              ; Save it
1396+ 1BAC 33                   inc     SP              ; Don't save C
1397+ 1BAD
1398+ 1BAD CD 18 1C     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1399+ 1BB0 22 D3 52             ld      (BRKLIN),HL     ; Save code address for break
1400+ 1BB3 7E                   ld      A,(HL)          ; Get next byte in code string
1401+ 1BB4 FE 3A                cp      ':'             ; Multi statement line?
1402+ 1BB6 CA CD 1B             jp      Z,EXCUTE        ; Yes - Execute it
1403+ 1BB9 B7                   or      A               ; End of line?
1404+ 1BBA C2 CA 16             jp      NZ,SNERR        ; No - Syntax error
1405+ 1BBD 23                   inc     HL              ; Point to address of next line
1406+ 1BBE 7E                   ld      A,(HL)          ; Get LSB of line pointer
1407+ 1BBF 23                   inc     HL
1408+ 1BC0 B6                   or      (HL)            ; Is it zero (End of prog)?
1409+ 1BC1 CA 3F 1C             jp      Z,ENDPRG        ; Yes - Terminate execution
1410+ 1BC4 23                   inc     HL              ; Point to line number
1411+ 1BC5 5E                   ld      E,(HL)          ; Get LSB of line number
1412+ 1BC6 23                   inc     HL
1413+ 1BC7 56                   ld      D,(HL)          ; Get MSB of line number
1414+ 1BC8 EB                   ex      DE,HL           ; Line number to HL
1415+ 1BC9 22 CD 51             ld      (LINEAT),HL     ; Save as current line number
1416+ 1BCC EB                   ex      DE,HL           ; Line number back to DE
1417+ 1BCD CD ED 1B     EXCUTE: call    GETCHR          ; Get key word
1418+ 1BD0 11 AD 1B             ld      DE,RUNCNT       ; Where to RETurn to
1419+ 1BD3 D5                   push    DE              ; Save for RETurn
1420+ 1BD4 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1421+ 1BD5
1422+ 1BD5 D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1423+ 1BD7 DA AD 1D             jp      C,LET           ; No - try to assign it
1424+ 1BDA FE 36                cp      ZNEW+1-ZEND     ; END to NEW ?
1425+ 1BDC D2 CA 16             jp      NC,SNERR        ; Not a key word - ?SN Error
1426+ 1BDF 07                   rlca                    ; Double it
1427+ 1BE0 4F                   ld      C,A             ; BC = Offset into table
1428+ 1BE1 06 00                ld      B,0
1429+ 1BE3 EB                   ex      DE,HL           ; Save code string address
1430+ 1BE4 21 D9 14             ld      HL,WORDTB       ; Keyword address table
1431+ 1BE7 09                   add     HL,BC           ; Point to routine address
1432+ 1BE8 4E                   ld      C,(HL)          ; Get LSB of routine address
1433+ 1BE9 23                   inc     HL
1434+ 1BEA 46                   ld      B,(HL)          ; Get MSB of routine address
1435+ 1BEB C5                   push    BC              ; Save routine address
1436+ 1BEC EB                   ex      DE,HL           ; Restore code string address
1437+ 1BED
1438+ 1BED              ; get a char from input buffer: exit with NC if character found is
1439+ 1BED              ; not a number; exit with Z if nothing found; char is into A
1440+ 1BED 23           GETCHR: inc     HL              ; Point to next character
1441+ 1BEE 7E                   ld      A,(HL)          ; Get next code string byte
1442+ 1BEF FE 3A                cp      ':'             ; Z if ':'
1443+ 1BF1 D0                   ret     NC              ; NC if > "9"
1444+ 1BF2 FE 20                cp      SPC
1445+ 1BF4 CA ED 1B             jp      Z,GETCHR        ; Skip over spaces
1446+ 1BF7 FE 30                cp      '0'
1447+ 1BF9 3F                   ccf                     ; NC if < '0'
1448+ 1BFA 3C                   inc     A               ; Test for zero - Leave carry
1449+ 1BFB 3D                   dec     A               ; Z if Null
1450+ 1BFC C9                   ret
1451+ 1BFD
1452+ 1BFD EB           RESTOR: ex      DE,HL           ; Save code string address
1453+ 1BFE 2A 53 52             ld      HL,(BASTXT)     ; Point to start of program
1454+ 1C01 CA 12 1C             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1455+ 1C04 EB                   ex      DE,HL           ; Restore code string address
1456+ 1C05 CD BD 1C             call    ATOH            ; Get line number to DE
1457+ 1C08 E5                   push    HL              ; Save code string address
1458+ 1C09 CD D0 17             call    SRCHLN          ; Search for line number in DE
1459+ 1C0C 60                   ld      H,B             ; HL = Address of line
1460+ 1C0D 69                   ld      L,C
1461+ 1C0E D1                   pop     DE              ; Restore code string address
1462+ 1C0F D2 6C 1D             jp      NC,ULERR        ; ?UL Error if not found
1463+ 1C12 2B           RESTNL: dec     HL              ; Byte before DATA statement
1464+ 1C13 22 48 53     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1465+ 1C16 EB                   ex      DE,HL           ; Restore code string address
1466+ 1C17 C9                   ret
1467+ 1C18
1468+ 1C18
1469+ 1C18              ; check if CTRL-C is into input buffer
1470+ 1C18 DF           TSTBRK: rst     $18             ; Check input status
1471+ 1C19 C8                   ret     Z               ; No key, go back
1472+ 1C1A D7                   rst     $10             ; Get the key into A
1473+ 1C1B FE 1B                cp      ESC             ; Escape key?
1474+ 1C1D 28 11                jr      Z,BRK           ; Yes, break
1475+ 1C1F FE 03                cp      CTRLC           ; <Ctrl-C>
1476+ 1C21 28 0D                jr      Z,BRK           ; Yes, break
1477+ 1C23 FE 13                cp      CTRLS           ; Stop scrolling?
1478+ 1C25 C0                   ret     NZ              ; Other key, ignore
1479+ 1C26
1480+ 1C26
1481+ 1C26              ; wait for a key while listing
1482+ 1C26 D7           STALL:  rst     $10             ; Wait for key
1483+ 1C27 FE 11                cp      CTRLQ           ; Resume scrolling?
1484+ 1C29 C8                   ret     Z               ; Release the chokehold
1485+ 1C2A FE 03                cp      CTRLC           ; Second break?
1486+ 1C2C 28 07                jr      Z,STOP          ; Break during hold exits prog
1487+ 1C2E 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1488+ 1C30
1489+ 1C30 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1490+ 1C32 32 C7 51             ld      (BRKFLG),A      ; Store it
1491+ 1C35
1492+ 1C35 C0           STOP:   ret     NZ              ; Exit if anything else
1493+ 1C36 F6                   defb    $F6             ; Flag "STOP"
1494+ 1C37 C0           PEND:   ret     NZ              ; Exit if anything else
1495+ 1C38 22 D3 52             ld      (BRKLIN),HL     ; Save point of break
1496+ 1C3B 21                   defb    $21             ; Skip "OR 11111111B"
1497+ 1C3C F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1498+ 1C3E C1                   pop     BC              ; Return not needed and more
1499+ 1C3F 2A CD 51     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1500+ 1C42 F5                   push    AF              ; Save STOP / END status
1501+ 1C43 7D                   ld      A,L             ; Is it direct break?
1502+ 1C44 A4                   and     H
1503+ 1C45 3C                   inc     A               ; Line is -1 if direct break
1504+ 1C46 CA 52 1C             jp      Z,NOLIN         ; Yes - No line number
1505+ 1C49 22 D7 52             ld      (ERRLIN),HL     ; Save line of break
1506+ 1C4C 2A D3 52             ld      HL,(BRKLIN)     ; Get point of break
1507+ 1C4F 22 D9 52             ld      (CONTAD),HL     ; Save point to CONTinue
1508+ 1C52 AF           NOLIN:  xor     A
1509+ 1C53 32 C3 51             ld      (CTLOFG),A      ; Enable output
1510+ 1C56 CD A8 1E             call    STTLIN          ; Start a new line
1511+ 1C59 F1                   pop     AF              ; Restore STOP / END status
1512+ 1C5A 21 4D 16             ld      HL,BRKMSG       ; "Break" message
1513+ 1C5D C2 63 1C             jp      NZ,ERRINT       ; "in line" wanted?
1514+ 1C60 C3 24 17             jp      PRNTOK          ; Go to command mode
1515+ 1C63 CD A4 16     ERRINT: call    EXITGM          ; exit from graphics mode
1516+ 1C66 C3 02 17             jp      ERRIN           ; print message
1517+ 1C69
1518+ 1C69
1519+ 1C69              ; CONTinue after a break/error
1520+ 1C69 21 FF FF     CONT:   ld      HL,-1           ; reset...
1521+ 1C6C 22 CF 51             ld      (HLPLN),HL      ; ...HELP line register
1522+ 1C6F 2A D9 52             ld      HL,(CONTAD)     ; Get CONTinue address
1523+ 1C72 7C                   ld      A,H             ; Is it zero?
1524+ 1C73 B5                   or      L
1525+ 1C74 1E 20                ld      E,CN            ; ?CN Error
1526+ 1C76 CA DE 16             jp      Z,ERROR         ; Yes - output "?CN Error"
1527+ 1C79 EB                   ex      DE,HL           ; Save code string address
1528+ 1C7A 2A D7 52             ld      HL,(ERRLIN)     ; Get line of last break
1529+ 1C7D 22 CD 51             ld      (LINEAT),HL     ; Set up current line number
1530+ 1C80 EB                   ex      DE,HL           ; Restore code string address
1531+ 1C81 C9                   ret                     ; CONTinue where left off
1532+ 1C82
1533+ 1C82 E5           ACCSUM: push    HL              ; Save address in array
1534+ 1C83 2A C4 51             ld      HL,(CHKSUM)     ; Get check sum
1535+ 1C86 06 00                ld      B,$00           ; BC - Value of byte
1536+ 1C88 4F                   ld      C,A
1537+ 1C89 09                   add     HL,BC           ; Add byte to check sum
1538+ 1C8A 22 C4 51             ld      (CHKSUM),HL     ; Re-save check sum
1539+ 1C8D E1                   pop     HL              ; Restore address in array
1540+ 1C8E C9                   ret
1541+ 1C8F
1542+ 1C8F 7E           CHKLTR: ld      A,(HL)          ; Get byte
1543+ 1C90 FE 41                cp      'A'             ; < 'a' ?
1544+ 1C92 D8                   ret     C               ; Carry set if not letter
1545+ 1C93 FE 5B                cp      'Z'+1           ; > 'z' ?
1546+ 1C95 3F                   ccf
1547+ 1C96 C9                   ret                     ; Carry set if not letter
1548+ 1C97
1549+ 1C97 CD ED 1B     FPSINT: call    GETCHR          ; Get next character
1550+ 1C9A CD 76 20     POSINT: call    GETNUM          ; Get integer 0 to 32767
1551+ 1C9D CD 83 2E     DEPINT: call    TSTSGN          ; Test sign of FPREG
1552+ 1CA0 FA B8 1C             jp      M,FCERR         ; Negative - ?FC Error
1553+ 1CA3 3A 53 53     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1554+ 1CA6 FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1555+ 1CA8 DA 2B 2F             jp      C,FPINT         ; Yes - convert it
1556+ 1CAB 01 80 90             ld      BC,$9080        ; BCDE = -32768
1557+ 1CAE 11 00 00             ld      DE,$0000
1558+ 1CB1 E5                   push    HL              ; Save code string address
1559+ 1CB2 CD FE 2E             call    CMPNUM          ; Compare FPREG with BCDE
1560+ 1CB5 E1                   pop     HL              ; Restore code string address
1561+ 1CB6 51                   ld      D,C             ; MSB to D
1562+ 1CB7 C8                   ret     Z               ; Return if in range
1563+ 1CB8 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1564+ 1CBA C3 DE 16             jp      ERROR           ; Output error-
1565+ 1CBD
1566+ 1CBD
1567+ 1CBD              ; convert a number in ASCII chars into an integer into DE
1568+ 1CBD 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1569+ 1CBE 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1570+ 1CC1 CD ED 1B     GTLNLP: call    GETCHR          ; Get next character
1571+ 1CC4 D0                   ret     NC              ; Exit if not a digit
1572+ 1CC5 E5                   push    HL              ; Save code string address
1573+ 1CC6 F5                   push    AF              ; Save digit
1574+ 1CC7 21 98 19             ld      HL,65529/10     ; Largest number 65529
1575+ 1CCA CD A6 19             call    CPDEHL          ; Number in range?
1576+ 1CCD DA CA 16             jp      C,SNERR         ; No - ?SN Error
1577+ 1CD0 62                   ld      H,D             ; HL = Number
1578+ 1CD1 6B                   ld      L,E
1579+ 1CD2 19                   add     HL,DE           ; Times 2
1580+ 1CD3 29                   add     HL,HL           ; Times 4
1581+ 1CD4 19                   add     HL,DE           ; Times 5
1582+ 1CD5 29                   add     HL,HL           ; Times 10
1583+ 1CD6 F1                   pop     AF              ; Restore digit
1584+ 1CD7 D6 30                sub     '0'             ; Make it 0 to 9
1585+ 1CD9 5F                   ld      E,A             ; DE = Value of digit
1586+ 1CDA 16 00                ld      D,0
1587+ 1CDC 19                   add     HL,DE           ; Add to number
1588+ 1CDD EB                   ex      DE,HL           ; Number to DE
1589+ 1CDE E1                   pop     HL              ; Restore code string address
1590+ 1CDF C3 C1 1C             jp      GTLNLP          ; Go to next character
1591+ 1CE2
1592+ 1CE2 CA 00 18     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1593+ 1CE5 CD 76 20             call    GETNUM          ; Evaluate a number
1594+ 1CE8 CD A3 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1595+ 1CEB 2B                   dec     HL              ; Cancel increment
1596+ 1CEC CD ED 1B             call    GETCHR          ; Get next character
1597+ 1CEF E5                   push    HL              ; Save code string address
1598+ 1CF0 2A B4 52             ld      HL,(LSTRAM)     ; Get end of RAM
1599+ 1CF3 CA 0B 1D             jp      Z,STORED        ; No value given - Use stored
1600+ 1CF6 E1                   pop     HL              ; Restore code string address
1601+ 1CF7 CD AC 19             call    CHKSYN          ; Check for comma
1602+ 1CFA 2C                   defb    ','
1603+ 1CFB D5                   push    DE              ; Save number
1604+ 1CFC CD 76 20             call    GETNUM          ; Evaluate a number
1605+ 1CFF CD A3 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1606+ 1D02 2B                   dec     HL              ; Cancel increment
1607+ 1D03 CD ED 1B             call    GETCHR          ; Get next character
1608+ 1D06 C2 CA 16             jp      NZ,SNERR        ; ?SN Error if more on line
1609+ 1D09 E3                   ex      (SP),HL         ; Save code string address
1610+ 1D0A EB                   ex      DE,HL           ; Number to DE
1611+ 1D0B 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1612+ 1D0C 93                   sub     E               ; Subtract LSB of string space
1613+ 1D0D 5F                   ld      E,A             ; Save LSB
1614+ 1D0E 7C                   ld      A,H             ; Get MSB of new RAM top
1615+ 1D0F 9A                   sbc     A,D             ; Subtract MSB of string space
1616+ 1D10 57                   ld      D,A             ; Save MSB
1617+ 1D11 DA 9F 16             jp      C,OMERR         ; ?OM Error if not enough mem
1618+ 1D14 E5                   push    HL              ; Save RAM top
1619+ 1D15 2A 42 53             ld      HL,(PROGND)     ; Get program end
1620+ 1D18 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1621+ 1D1B 09                   add     HL,BC           ; Get lowest address
1622+ 1D1C CD A6 19             call    CPDEHL          ; Enough memory?
1623+ 1D1F D2 9F 16             jp      NC,OMERR        ; No - ?OM Error
1624+ 1D22 EB                   ex      DE,HL           ; RAM top to HL
1625+ 1D23 22 CB 51             ld      (STRSPC),HL     ; Set new string space
1626+ 1D26 E1                   pop     HL              ; End of memory to use
1627+ 1D27 22 B4 52             ld      (LSTRAM),HL     ; Set new top of RAM
1628+ 1D2A E1                   pop     HL              ; Restore code string address
1629+ 1D2B C3 00 18             jp      INTVAR          ; Initialise variables
1630+ 1D2E
1631+ 1D2E E5           RUN:    push    HL              ; store HL
1632+ 1D2F 21 FF FF             ld      HL,-1           ; reset...
1633+ 1D32 22 CF 51             ld      (HLPLN),HL      ; ...HELP line register
1634+ 1D35 E1                   pop     HL              ; retrieve HL
1635+ 1D36 CA FC 17             jp      Z,RUNFST        ; RUN from start if just RUN
1636+ 1D39 CD 00 18             call    INTVAR          ; Initialise variables
1637+ 1D3C 01 AD 1B             ld      BC,RUNCNT       ; Execution driver loop
1638+ 1D3F C3 52 1D             jp      RUNLIN          ; RUN from line number
1639+ 1D42
1640+ 1D42 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1641+ 1D44 CD 87 16             call    CHKSTK          ; Check for 3 levels of stack
1642+ 1D47 C1                   pop     BC              ; Get return address
1643+ 1D48 E5                   push    HL              ; Save code string for RETURN
1644+ 1D49 E5                   push    HL              ; And for GOSUB routine
1645+ 1D4A 2A CD 51             ld      HL,(LINEAT)     ; Get current line
1646+ 1D4D E3                   ex      (SP),HL         ; Into stack - Code string out
1647+ 1D4E 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1648+ 1D50 F5                   push    AF              ; Save token
1649+ 1D51 33                   inc     SP              ; Don't save flags
1650+ 1D52
1651+ 1D52 C5           RUNLIN: push    BC              ; Save return address
1652+ 1D53 CD BD 1C     GOTO:   call    ATOH            ; ASCII number to DE binary
1653+ 1D56 CD 98 1D             call    REM             ; Get end of line
1654+ 1D59 E5                   push    HL              ; Save end of line
1655+ 1D5A 2A CD 51             ld      HL,(LINEAT)     ; Get current line
1656+ 1D5D CD A6 19             call    CPDEHL          ; Line after current?
1657+ 1D60 E1                   pop     HL              ; Restore end of line
1658+ 1D61 23                   inc     HL              ; Start of next line
1659+ 1D62 DC D3 17             call    C,SRCHLP        ; Line is after current line
1660+ 1D65 D4 D0 17             call    NC,SRCHLN       ; Line is before current line
1661+ 1D68 60                   ld      H,B             ; Set up code string address
1662+ 1D69 69                   ld      L,C
1663+ 1D6A 2B                   dec     HL              ; Incremented after
1664+ 1D6B D8                   ret     C               ; Line found
1665+ 1D6C 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1666+ 1D6E C3 DE 16             jp      ERROR           ; Output error message
1667+ 1D71
1668+ 1D71 C0           RETURN: ret     NZ              ; Return if not just RETURN
1669+ 1D72 16 FF                ld      D,-1            ; Flag "GOSUB" search
1670+ 1D74 CD 53 16             call    BAKSTK          ; Look "GOSUB" block
1671+ 1D77 F9                   ld      SP,HL           ; Kill all FORs in subroutine
1672+ 1D78 FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1673+ 1D7A 1E 04                ld      E,RG            ; ?RG Error
1674+ 1D7C C2 DE 16             jp      NZ,ERROR        ; Error if no "GOSUB" found
1675+ 1D7F E1                   pop     HL              ; Get RETURN line number
1676+ 1D80 22 CD 51             ld      (LINEAT),HL     ; Save as current
1677+ 1D83 23                   inc     HL              ; Was it from direct statement?
1678+ 1D84 7C                   ld      A,H
1679+ 1D85 B5                   or      L               ; Return to line
1680+ 1D86 C2 90 1D             jp      NZ,RETLIN       ; No - Return to line
1681+ 1D89 3A D1 52             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1682+ 1D8C B7                   or      A               ; If so buffer is corrupted
1683+ 1D8D C2 23 17             jp      NZ,POPNOK       ; Yes - Go to command mode
1684+ 1D90 21 AD 1B     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1685+ 1D93 E3                   ex      (SP),HL         ; Into stack - Code string out
1686+ 1D94 3E                   defb    $3E             ; Skip "pop HL"
1687+ 1D95 E1           NXTDTA: pop     HL              ; Restore code string address
1688+ 1D96
1689+ 1D96 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1690+ 1D98 0E 00        REM:    ld      C,$00           ; 00  End of statement
1691+ 1D9A 06 00                ld      B,$00
1692+ 1D9C 79           NXTSTL: ld      A,C             ; Statement and byte
1693+ 1D9D 48                   ld      C,B
1694+ 1D9E 47                   ld      B,A             ; Statement end byte
1695+ 1D9F 7E           NXTSTT: ld      A,(HL)          ; Get byte
1696+ 1DA0 B7                   or      A               ; End of line?
1697+ 1DA1 C8                   ret     Z               ; Yes - Exit
1698+ 1DA2 B8                   cp      B               ; End of statement?
1699+ 1DA3 C8                   ret     Z               ; Yes - Exit
1700+ 1DA4 23                   inc     HL              ; Next byte
1701+ 1DA5 FE 22                cp      $22             ; '"'             ; Literal string?
1702+ 1DA7 CA 9C 1D             jp      Z,NXTSTL        ; Yes - Look for another '"'
1703+ 1DAA C3 9F 1D             jp      NXTSTT          ; Keep looking
1704+ 1DAD
1705+ 1DAD CD 85 22     LET:    call    GETVAR          ; Get variable name
1706+ 1DB0 CD AC 19             call    CHKSYN          ; Make sure "=" follows
1707+ 1DB3 C8                   defb    ZEQUAL          ; "=" token
1708+ 1DB4 D5                   push    DE              ; Save address of variable
1709+ 1DB5 3A B2 52             ld      A,(TYPE)        ; Get data type
1710+ 1DB8 F5                   push    AF              ; Save type
1711+ 1DB9 CD 88 20             call    EVAL            ; Evaluate expression
1712+ 1DBC F1                   pop     AF              ; Restore type
1713+ 1DBD E3                   ex      (SP),HL         ; Save code - Get var addr
1714+ 1DBE 22 D3 52             ld      (BRKLIN),HL     ; Save address of variable
1715+ 1DC1 1F                   rra                     ; Adjust type
1716+ 1DC2 CD 7B 20             call    CHKTYP          ; Check types are the same
1717+ 1DC5 CA 00 1E             jp      Z,LETNUM        ; Numeric - Move value
1718+ 1DC8 E5           LETSTR: push    HL              ; Save address of string var
1719+ 1DC9 2A 50 53             ld      HL,(FPREG)      ; Pointer to string entry
1720+ 1DCC E5                   push    HL              ; Save it on stack
1721+ 1DCD 23                   inc     HL              ; Skip over length
1722+ 1DCE 23                   inc     HL
1723+ 1DCF 5E                   ld      E,(HL)          ; LSB of string address
1724+ 1DD0 23                   inc     HL
1725+ 1DD1 56                   ld      D,(HL)          ; MSB of string address
1726+ 1DD2 2A 53 52             ld      HL,(BASTXT)     ; Point to start of program
1727+ 1DD5 CD A6 19             call    CPDEHL          ; Is string before program?
1728+ 1DD8 D2 EF 1D             jp      NC,CRESTR       ; Yes - Create string entry
1729+ 1DDB 2A CB 51             ld      HL,(STRSPC)     ; Point to string space
1730+ 1DDE CD A6 19             call    CPDEHL          ; Is string literal in program?
1731+ 1DE1 D1                   pop     DE              ; Restore address of string
1732+ 1DE2 D2 F7 1D             jp      NC,MVSTPT       ; Yes - Set up pointer
1733+ 1DE5 21 C4 52             ld      HL,TMPSTR       ; Temporary string pool
1734+ 1DE8 CD A6 19             call    CPDEHL          ; Is string in temporary pool?
1735+ 1DEB D2 F7 1D             jp      NC,MVSTPT       ; No - Set up pointer
1736+ 1DEE 3E                   defb    $3E             ; Skip "pop DE"
1737+ 1DEF D1           CRESTR: pop     DE              ; Restore address of string
1738+ 1DF0 CD DF 26             call    BAKTMP          ; Back to last tmp-str entry
1739+ 1DF3 EB                   ex      DE,HL           ; Address of string entry
1740+ 1DF4 CD 18 25             call    SAVSTR          ; Save string in string area
1741+ 1DF7 CD DF 26     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1742+ 1DFA E1                   pop     HL              ; Get string pointer
1743+ 1DFB CD DE 2E             call    DETHL4          ; Move string pointer to var
1744+ 1DFE E1                   pop     HL              ; Restore code string address
1745+ 1DFF C9                   ret
1746+ 1E00
1747+ 1E00 E5           LETNUM: push    HL              ; Save address of variable
1748+ 1E01 CD DB 2E             call    FPTHL           ; Move value to variable
1749+ 1E04 D1                   pop     DE              ; Restore address of variable
1750+ 1E05 E1                   pop     HL              ; Restore code string address
1751+ 1E06 C9                   ret
1752+ 1E07
1753+ 1E07 CD FC 28     ON:     call    GETINT          ; Get integer 0-255
1754+ 1E0A 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1755+ 1E0B 47                   ld      B,A             ; Save in B
1756+ 1E0C FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1757+ 1E0E CA 16 1E             jp      Z,ONGO          ; Yes - Find line number
1758+ 1E11 CD AC 19             call    CHKSYN          ; Make sure it's "GOTO"
1759+ 1E14 88                   defb    ZGOTO           ; "GOTO" token
1760+ 1E15 2B                   dec     HL              ; Cancel increment
1761+ 1E16 4B           ONGO:   ld      C,E             ; Integer of branch value
1762+ 1E17 0D           ONGOLP: dec     C               ; Count branches
1763+ 1E18 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1764+ 1E19 CA D5 1B             jp      Z,ONJMP         ; Go to that line if right one
1765+ 1E1C CD BE 1C             call    GETLN           ; Get line number to DE
1766+ 1E1F FE 2C                cp      ','             ; Another line number?
1767+ 1E21 C0                   ret     NZ              ; No - Drop through
1768+ 1E22 C3 17 1E             jp      ONGOLP          ; Yes - loop
1769+ 1E25
1770+ 1E25 CD 88 20     IF:     call    EVAL            ; Evaluate expression
1771+ 1E28 7E                   ld      A,(HL)          ; Get token
1772+ 1E29 FE 88                cp      ZGOTO           ; "GOTO" token?
1773+ 1E2B CA 33 1E             jp      Z,IFGO          ; Yes - Get line
1774+ 1E2E CD AC 19             call    CHKSYN          ; Make sure it's "THEN"
1775+ 1E31 BA                   defb    ZTHEN           ; "THEN" token
1776+ 1E32 2B                   dec     HL              ; Cancel increment
1777+ 1E33 CD 79 20     IFGO:   call    TSTNUM          ; Make sure it's numeric
1778+ 1E36 CD 83 2E             call    TSTSGN          ; Test state of expression
1779+ 1E39 CA 45 1E             jp      Z,IF1           ; False - Jump over
1780+ 1E3C CD ED 1B     IF0:    call    GETCHR          ; Get next character
1781+ 1E3F DA 53 1D             jp      C,GOTO          ; Number - GOTO that line
1782+ 1E42 C3 D4 1B             jp      IFJMP           ; Otherwise do statement
1783+ 1E45 0E AE        IF1:    ld      C,ZELSE
1784+ 1E47 CD 9A 1D             call    REM+2           ; check statement
1785+ 1E4A B7                   or      A               ; end of line?
1786+ 1E4B C8                   ret     Z               ; yes, leave
1787+ 1E4C FE AE                cp      ZELSE
1788+ 1E4E 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1789+ 1E50 C3 3C 1E             jp      IF0             ; return to IF
1790+ 1E53
1791+ 1E53
1792+ 1E53 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1793+ 1E54 CD ED 1B             call    GETCHR          ; Get next character
1794+ 1E57 CA BA 1E     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1795+ 1E5A C8           PRNTLP: ret     Z               ; End of list - Exit
1796+ 1E5B FE B6                cp      ZTAB            ; "TAB(" token?
1797+ 1E5D CA E2 1E             jp      Z,DOTAB         ; Yes - Do TAB routine
1798+ 1E60 FE B9                cp      ZSPC            ; "SPC(" token?
1799+ 1E62 CA E2 1E             jp      Z,DOTAB         ; Yes - Do SPC routine
1800+ 1E65 E5                   push    HL              ; Save code string address
1801+ 1E66 FE 2C                cp      ','             ; Comma?
1802+ 1E68 CA C9 1E             jp      Z,DOCOM         ; Yes - Move to next zone
1803+ 1E6B FE 3B                cp      ';'             ; Semi-colon?
1804+ 1E6D CA 06 1F             jp      Z,NEXITM        ; Do semi-colon routine
1805+ 1E70 C1                   pop     BC              ; Code string address to BC
1806+ 1E71 CD 88 20             call    EVAL            ; Evaluate expression
1807+ 1E74 E5                   push    HL              ; Save code string address
1808+ 1E75 3A B2 52             ld      A,(TYPE)        ; Get variable type
1809+ 1E78 B7                   or      A               ; Is it a string variable?
1810+ 1E79 C2 A1 1E             jp      NZ,PRNTST       ; Yes - Output string contents
1811+ 1E7C CD 28 30             call    NUMASC          ; Convert number to text
1812+ 1E7F CD 3C 25             call    CRTST           ; Create temporary string
1813+ 1E82 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1814+ 1E84 2A 50 53             ld      HL,(FPREG)      ; Get length of output
1815+ 1E87 34                   inc     (HL)            ; Plus 1 for the space
1816+ 1E88 2A 50 53             ld      HL,(FPREG)      ; < Not needed >
1817+ 1E8B 3A C0 51             ld      A,(LWIDTH)      ; Get width of line
1818+ 1E8E 47                   ld      B,A             ; To B
1819+ 1E8F 04                   inc     B               ; Width 255 (No limit)?
1820+ 1E90 CA 9D 1E             jp      Z,PRNTNB        ; Yes - Output number string
1821+ 1E93 04                   inc     B               ; Adjust it
1822+ 1E94 3A B0 52             ld      A,(CURPOS)      ; Get cursor position
1823+ 1E97 86                   add     A,(HL)          ; Add length of string
1824+ 1E98 3D                   dec     A               ; Adjust it
1825+ 1E99 B8                   cp      B               ; Will output fit on this line?
1826+ 1E9A D4 BA 1E             call    NC,PRNTCRLF     ; No - CRLF first
1827+ 1E9D CD 81 25     PRNTNB: call    PRS1            ; Output string at (HL)
1828+ 1EA0 AF                   xor     A               ; Skip call by setting 'z' flag
1829+ 1EA1 C4 81 25     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1830+ 1EA4 E1                   pop     HL              ; Restore code string address
1831+ 1EA5 C3 53 1E             jp      MRPRNT          ; See if more to PRINT
1832+ 1EA8
1833+ 1EA8 3A B0 52     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1834+ 1EAB B7                   or      A               ; Already at start?
1835+ 1EAC C8                   ret     Z               ; Yes - Do nothing
1836+ 1EAD C3 BA 1E             jp      PRNTCRLF        ; Start a new line
1837+ 1EB0
1838+ 1EB0 AF           ENDINP: xor     A
1839+ 1EB1 32 36 53             ld      (KBDNPT),A      ; char is not from keyboard
1840+ 1EB4 77                   ld      (HL),A          ; Mark end of buffer
1841+ 1EB5 21 55 52             ld      HL,BUFFER-1     ; Point to buffer
1842+ 1EB8 18 0A                jr      CNTEND
1843+ 1EBA 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1844+ 1EBC CD B7 19             call    OUTC            ; Output character
1845+ 1EBF 3E 0A                ld      A,LF            ; Load a LF
1846+ 1EC1 CD B7 19             call    OUTC            ; Output character
1847+ 1EC4 AF           CNTEND: xor     A               ; Set to position 0
1848+ 1EC5 32 B0 52             ld      (CURPOS),A      ; Store it
1849+ 1EC8 C9                   ret                     ; return to caller
1850+ 1EC9
1851+ 1EC9 3A C1 51     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1852+ 1ECC 47                   ld      B,A             ; Save in B
1853+ 1ECD 3A F1 52             ld      A,(SCR_CURS_X)  ; Get current position
1854+ 1ED0 B8                   cp      B               ; Within the limit?
1855+ 1ED1 D4 BA 1E             call    NC,PRNTCRLF     ; No - output CRLF
1856+ 1ED4 D2 06 1F             jp      NC,NEXITM       ; Get next item
1857+ 1ED7 D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1858+ 1ED9 D2 D7 1E             jp      NC,ZONELP       ; Repeat if more zones
1859+ 1EDC 2F                   cpl                     ; Number of null chars to output
1860+ 1EDD 0E 00                ld      C,NLLCR         ; null char
1861+ 1EDF C3 FC 1E             jp      ASPCS           ; Output them
1862+ 1EE2
1863+ 1EE2 F5           DOTAB:  push    AF              ; Save token
1864+ 1EE3 CD F9 28             call    FNDNUM          ; Evaluate expression
1865+ 1EE6 CD AC 19             call    CHKSYN          ; Make sure ")" follows
1866+ 1EE9 29                   defb    ')'
1867+ 1EEA 2B                   dec     HL              ; Back space on to ")"
1868+ 1EEB F1                   pop     AF              ; Restore token
1869+ 1EEC 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1870+ 1EEE D6 B9                sub     ZSPC            ; Was it "SPC(" ?
1871+ 1EF0 E5                   push    HL              ; Save code string address
1872+ 1EF1 CA F7 1E             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1873+ 1EF4 3A F1 52             ld      A,(SCR_CURS_X)  ; Get current X position
1874+ 1EF7 2F           DOSPC:  cpl                     ; Number of spaces to print to
1875+ 1EF8 83                   add     A,E             ; Total number to print
1876+ 1EF9 D2 06 1F             jp      NC,NEXITM       ; TAB < Current POS(X)
1877+ 1EFC 3C           ASPCS:  inc     A               ; Output A spaces
1878+ 1EFD 47                   ld      B,A             ; Save number to print
1879+ 1EFE 79           SPCLP:  ld      A,C             ; char to print
1880+ 1EFF CD B7 19             call    OUTC            ; Output character in A
1881+ 1F02 05                   dec     B               ; Count them
1882+ 1F03 C2 FE 1E             jp      NZ,SPCLP        ; Repeat if more
1883+ 1F06 E1           NEXITM: pop     HL              ; Restore code string address
1884+ 1F07 CD ED 1B             call    GETCHR          ; Get next character
1885+ 1F0A C3 5A 1E             jp      PRNTLP          ; More to print
1886+ 1F0D
1887+ 1F0D 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1887+ 1F11 6F 20 66 72
1887+ 1F15 6F 6D 20 73
1887+ 1F19 74 61 72 74
1887+ 1F1D 0D 00
1888+ 1F1F
1889+ 1F1F 3A D2 52     BADINP: ld      A,(READFG)      ; READ or INPUT?
1890+ 1F22 B7                   or      A
1891+ 1F23 C2 C4 16             jp      NZ,DATSNR       ; READ - ?SN Error
1892+ 1F26 C1                   pop     BC              ; Throw away code string addr
1893+ 1F27 21 0D 1F             ld      HL,REDO         ; "Redo from start" message
1894+ 1F2A CD 7E 25             call    PRS             ; Output string
1895+ 1F2D C3 2F 18             jp      DOAGN           ; Do last INPUT again
1896+ 1F30
1897+ 1F30 CD E9 24     INPUT:  call    IDTEST          ; Test for illegal direct
1898+ 1F33 7E                   ld      A,(HL)          ; Get character after "INPUT"
1899+ 1F34 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1900+ 1F36 3E 00                ld      A,$00           ; Clear A and leave flags
1901+ 1F38 32 C3 51             ld      (CTLOFG),A      ; Enable output
1902+ 1F3B C2 4A 1F             jp      NZ,NOPMPT       ; No prompt - get input
1903+ 1F3E CD 3D 25             call    QTSTR           ; Get string terminated by '"'
1904+ 1F41 CD AC 19             call    CHKSYN          ; Check for ';' after prompt
1905+ 1F44 3B                   defb    ";"
1906+ 1F45 E5                   push    HL              ; Save code string address
1907+ 1F46 CD 81 25             call    PRS1            ; Output prompt string
1908+ 1F49 3E                   defb    $3E             ; Skip "push HL"
1909+ 1F4A E5           NOPMPT: push    HL              ; Save code string address
1910+ 1F4B CD 33 18             call    PROMPT          ; Get input with "? " prompt
1911+ 1F4E C1                   pop     BC              ; Restore code string address
1912+ 1F4F DA 3C 1C             jp      C,INPBRK        ; Break pressed - Exit
1913+ 1F52 23                   inc     HL              ; Next byte
1914+ 1F53 7E                   ld      A,(HL)          ; Get it
1915+ 1F54 B7                   or      A               ; End of line?
1916+ 1F55 2B                   dec     HL              ; Back again
1917+ 1F56 C5                   push    BC              ; Re-save code string address
1918+ 1F57 CD 2E 09             call    CURSOR_OFF      ; disable cursor
1919+ 1F5A CA 95 1D             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1920+ 1F5D 36 2C                ld      (HL),','        ; Store comma as separator
1921+ 1F5F C3 67 1F             jp      NXTITM          ; Get next item
1922+ 1F62
1923+ 1F62 E5           READ:   push    HL              ; Save code string address
1924+ 1F63 2A 48 53             ld      HL,(NXTDAT)     ; Next DATA statement
1925+ 1F66 F6                   defb    $F6             ; Flag "READ"
1926+ 1F67 AF           NXTITM: xor     A               ; Flag "INPUT"
1927+ 1F68 32 D2 52             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1928+ 1F6B E3                   ex      (SP),HL         ; Get code str' , Save pointer
1929+ 1F6C C3 73 1F             jp      GTVLUS          ; Get values
1930+ 1F6F
1931+ 1F6F CD AC 19     NEDMOR: call    CHKSYN          ; Check for comma between items
1932+ 1F72 2C                   defb    ','
1933+ 1F73 CD 85 22     GTVLUS: call    GETVAR          ; Get variable name
1934+ 1F76 E3                   ex      (SP),HL         ; Save code str" , Get pointer
1935+ 1F77 D5                   push    DE              ; Save variable address
1936+ 1F78 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1937+ 1F79 FE 2C                cp      ','             ; Comma?
1938+ 1F7B CA 9B 1F             jp      Z,ANTVLU        ; Yes - Get another value
1939+ 1F7E 3A D2 52             ld      A,(READFG)      ; Is it READ?
1940+ 1F81 B7                   or      A
1941+ 1F82 C2 07 20             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1942+ 1F85 3E 3F                ld      A,'?'           ; More INPUT needed
1943+ 1F87 CD B7 19             call    OUTC            ; Output character
1944+ 1F8A CD 33 18             call    PROMPT          ; Get INPUT with prompt
1945+ 1F8D D1                   pop     DE              ; Variable address
1946+ 1F8E C1                   pop     BC              ; Code string address
1947+ 1F8F DA 3C 1C             jp      C,INPBRK        ; Break pressed
1948+ 1F92 23                   inc     HL              ; Point to next DATA byte
1949+ 1F93 7E                   ld      A,(HL)          ; Get byte
1950+ 1F94 B7                   or      A               ; Is it zero (No input) ?
1951+ 1F95 2B                   dec     HL              ; Back space INPUT pointer
1952+ 1F96 C5                   push    BC              ; Save code string address
1953+ 1F97 CA 95 1D             jp      Z,NXTDTA        ; Find end of buffer
1954+ 1F9A D5                   push    DE              ; Save variable address
1955+ 1F9B 3A B2 52     ANTVLU: ld      A,(TYPE)        ; Check data type
1956+ 1F9E B7                   or      A               ; Is it numeric?
1957+ 1F9F CA C5 1F             jp      Z,INPBIN        ; Yes - Convert to binary
1958+ 1FA2 CD ED 1B             call    GETCHR          ; Get next character
1959+ 1FA5 57                   ld      D,A             ; Save input character
1960+ 1FA6 47                   ld      B,A             ; Again
1961+ 1FA7 FE 22                cp      $22             ; '"'     ; Start of literal sting?
1962+ 1FA9 CA B9 1F             jp      Z,STRENT        ; Yes - Create string entry
1963+ 1FAC 3A D2 52             ld      A,(READFG)      ; "READ" or "INPUT" ?
1964+ 1FAF B7                   or      A
1965+ 1FB0 57                   ld      D,A             ; Save 00 if "INPUT"
1966+ 1FB1 CA B6 1F             jp      Z,ITMSEP        ; "INPUT" - End with 00
1967+ 1FB4 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
1968+ 1FB6 06 2C        ITMSEP: ld      B,','           ; Item separator
1969+ 1FB8 2B                   dec     HL              ; Back space for DTSTR
1970+ 1FB9 CD 40 25     STRENT: call    DTSTR           ; Get string terminated by D
1971+ 1FBC EB                   ex      DE,HL           ; String address to DE
1972+ 1FBD 21 D0 1F             ld      HL,LTSTND       ; Where to go after LETSTR
1973+ 1FC0 E3                   ex      (SP),HL         ; Save HL , get input pointer
1974+ 1FC1 D5                   push    DE              ; Save address of string
1975+ 1FC2 C3 C8 1D             jp      LETSTR          ; Assign string to variable
1976+ 1FC5
1977+ 1FC5 CD ED 1B     INPBIN: call    GETCHR          ; Get next character
1978+ 1FC8 CD 8A 2F             call    ASCTFP          ; Convert ASCII to FP number
1979+ 1FCB E3                   ex      (SP),HL         ; Save input ptr, Get var addr
1980+ 1FCC CD DB 2E             call    FPTHL           ; Move FPREG to variable
1981+ 1FCF E1                   pop     HL              ; Restore input pointer
1982+ 1FD0 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1983+ 1FD1 CD ED 1B             call    GETCHR          ; Get next character
1984+ 1FD4 CA DC 1F             jp      Z,MORDT         ; End of line - More needed?
1985+ 1FD7 FE 2C                cp      ','             ; Another value?
1986+ 1FD9 C2 1F 1F             jp      NZ,BADINP       ; No - Bad input
1987+ 1FDC E3           MORDT:  ex      (SP),HL         ; Get code string address
1988+ 1FDD 2B                   dec     HL              ; dec 'cos GETCHR INCs
1989+ 1FDE CD ED 1B             call    GETCHR          ; Get next character
1990+ 1FE1 C2 6F 1F             jp      NZ,NEDMOR       ; More needed - Get it
1991+ 1FE4 D1                   pop     DE              ; Restore DATA pointer
1992+ 1FE5 3A D2 52             ld      A,(READFG)      ; "READ" or "INPUT" ?
1993+ 1FE8 B7                   or      A
1994+ 1FE9 EB                   ex      DE,HL           ; DATA pointer to HL
1995+ 1FEA C2 13 1C             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1996+ 1FED D5                   push    DE              ; Save code string address
1997+ 1FEE B6                   or      (HL)            ; More input given?
1998+ 1FEF 21 F7 1F             ld      HL,EXTIG        ; "?Extra ignored" message
1999+ 1FF2 C4 7E 25             call    NZ,PRS          ; Output string if extra given
2000+ 1FF5 E1                   pop     HL              ; Restore code string address
2001+ 1FF6 C9                   ret
2002+ 1FF7
2003+ 1FF7 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2003+ 1FFB 72 61 20 69
2003+ 1FFF 67 6E 6F 72
2003+ 2003 65 64 0D 00
2004+ 2007
2005+ 2007 CD 96 1D     FDTLP:  call    DATA            ; Get next statement
2006+ 200A B7                   or      A               ; End of line?
2007+ 200B C2 20 20             jp      NZ,FANDT        ; No - See if DATA statement
2008+ 200E 23                   inc     HL
2009+ 200F 7E                   ld      A,(HL)          ; End of program?
2010+ 2010 23                   inc     HL
2011+ 2011 B6                   or      (HL)            ; 00 00 Ends program
2012+ 2012 1E 06                ld      E,OD            ; ?OD Error
2013+ 2014 CA DE 16             jp      Z,ERROR         ; Yes - Out of DATA
2014+ 2017 23                   inc     HL
2015+ 2018 5E                   ld      E,(HL)          ; LSB of line number
2016+ 2019 23                   inc     HL
2017+ 201A 56                   ld      D,(HL)          ; MSB of line number
2018+ 201B EB                   ex      DE,HL
2019+ 201C 22 CE 52             ld      (DATLIN),HL     ; Set line of current DATA item
2020+ 201F EB                   ex      DE,HL
2021+ 2020 CD ED 1B     FANDT:  call    GETCHR          ; Get next character
2022+ 2023 FE 83                cp      ZDATA           ; "DATA" token
2023+ 2025 C2 07 20             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2024+ 2028 C3 9B 1F             jp      ANTVLU          ; Found - Convert input
2025+ 202B
2026+ 202B 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2027+ 202E C4 85 22     NEXT1:  call    NZ,GETVAR       ; Get index address
2028+ 2031 22 D3 52             ld      (BRKLIN),HL     ; Save code string address
2029+ 2034 CD 53 16             call    BAKSTK          ; Look for "FOR" block
2030+ 2037 C2 D0 16             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2031+ 203A F9                   ld      SP,HL           ; Clear nested loops
2032+ 203B D5                   push    DE              ; Save index address
2033+ 203C 7E                   ld      A,(HL)          ; Get sign of STEP
2034+ 203D 23                   inc     HL
2035+ 203E F5                   push    AF              ; Save sign of STEP
2036+ 203F D5                   push    DE              ; Save index address
2037+ 2040 CD C1 2E             call    PHLTFP          ; Move index value to FPREG
2038+ 2043 E3                   ex      (SP),HL         ; Save address of TO value
2039+ 2044 E5                   push    HL              ; Save address of index
2040+ 2045 CD DD 2B             call    ADDPHL          ; Add STEP to index value
2041+ 2048 E1                   pop     HL              ; Restore address of index
2042+ 2049 CD DB 2E             call    FPTHL           ; Move value to index variable
2043+ 204C E1                   pop     HL              ; Restore address of TO value
2044+ 204D CD D2 2E             call    LOADFP          ; Move TO value to BCDE
2045+ 2050 E5                   push    HL              ; Save address of line of FOR
2046+ 2051 CD FE 2E             call    CMPNUM          ; Compare index with TO value
2047+ 2054 E1                   pop     HL              ; Restore address of line num
2048+ 2055 C1                   pop     BC              ; Address of sign of STEP
2049+ 2056 90                   sub     B               ; Compare with expected sign
2050+ 2057 CD D2 2E             call    LOADFP          ; BC = Loop stmt,DE = Line num
2051+ 205A CA 66 20             jp      Z,KILFOR        ; Loop finished - Terminate it
2052+ 205D EB                   ex      DE,HL           ; Loop statement line number
2053+ 205E 22 CD 51             ld      (LINEAT),HL     ; Set loop line number
2054+ 2061 69                   ld      L,C             ; Set code string to loop
2055+ 2062 60                   ld      H,B
2056+ 2063 C3 A9 1B             jp      PUTFID          ; Put back "FOR" and continue
2057+ 2066
2058+ 2066 F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2059+ 2067 2A D3 52             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2060+ 206A 7E                   ld      A,(HL)          ; Get next byte in code string
2061+ 206B FE 2C                cp      ','             ; More NEXTs ?
2062+ 206D C2 AD 1B             jp      NZ,RUNCNT       ; No - Do next statement
2063+ 2070 CD ED 1B             call    GETCHR          ; Position to index name
2064+ 2073 CD 2E 20             call    NEXT1           ; Re-enter NEXT routine
2065+ 2076              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2066+ 2076
2067+ 2076 CD 88 20     GETNUM: call    EVAL            ; Get a numeric expression
2068+ 2079 F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2069+ 207A 37           TSTSTR: scf                     ; Set carry (string)
2070+ 207B 3A B2 52     CHKTYP: ld      A,(TYPE)        ; Check types match
2071+ 207E 8F                   adc     A,A             ; Expected + actual
2072+ 207F B7                   or      A               ; Clear carry , set parity
2073+ 2080 E8                   ret     PE              ; Even parity - Types match
2074+ 2081 C3 DC 16             jp      TMERR           ; Different types - Error
2075+ 2084
2076+ 2084 CD AC 19     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2077+ 2087 28                   defb    '('
2078+ 2088 2B           EVAL:   dec     HL              ; Evaluate expression & save
2079+ 2089 16 00                ld      D,$00           ; Precedence value
2080+ 208B D5           EVAL1:  push    DE              ; Save precedence
2081+ 208C 0E 01                ld      C,$01
2082+ 208E CD 87 16             call    CHKSTK          ; Check for 1 level of stack
2083+ 2091 CD FF 20             call    OPRND           ; Get next expression value
2084+ 2094 22 D5 52     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2085+ 2097 2A D5 52     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2086+ 209A C1                   pop     BC              ; Precedence value and operator
2087+ 209B 78                   ld      A,B             ; Get precedence value
2088+ 209C FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2089+ 209E D4 79 20             call    NC,TSTNUM       ; No - Make sure it's a number
2090+ 20A1 7E                   ld      A,(HL)          ; Get next operator / function
2091+ 20A2 16 00                ld      D,$00           ; Clear Last relation
2092+ 20A4 D6 C7        RLTLP:  sub     ZGTR            ; ">" Token
2093+ 20A6 DA C0 20             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2094+ 20A9 FE 03                cp      ZLTH+1-ZGTR     ; < = >
2095+ 20AB D2 C0 20             jp      NC,FOPRND       ; Function - Call it
2096+ 20AE FE 01                cp      ZEQUAL-ZGTR     ; "="
2097+ 20B0 17                   rla                     ; <- Test for legal
2098+ 20B1 AA                   xor     D               ; <- combinations of < = >
2099+ 20B2 BA                   cp      D               ; <- by combining last token
2100+ 20B3 57                   ld      D,A             ; <- with current one
2101+ 20B4 DA CA 16             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2102+ 20B7 22 CA 52             ld      (CUROPR),HL     ; Save address of current token
2103+ 20BA CD ED 1B             call    GETCHR          ; Get next character
2104+ 20BD C3 A4 20             jp      RLTLP           ; Treat the two as one
2105+ 20C0
2106+ 20C0 7A           FOPRND: ld      A,D             ; < = > found ?
2107+ 20C1 B7                   or      A
2108+ 20C2 C2 00 22             jp      NZ,TSTRED       ; Yes - Test for reduction
2109+ 20C5 7E                   ld      A,(HL)          ; Get operator token
2110+ 20C6 22 CA 52             ld      (CUROPR),HL     ; Save operator address
2111+ 20C9 D6 BD                sub     ZPLUS           ; Operator or function?
2112+ 20CB D8                   ret     C               ; Neither - Exit
2113+ 20CC FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2114+ 20CE D0                   ret     NC              ; No - Exit
2115+ 20CF 5F                   ld      E,A             ; Coded operator
2116+ 20D0 3A B2 52             ld      A,(TYPE)        ; Get data type
2117+ 20D3 3D                   dec     A               ; FF = numeric , 00 = string
2118+ 20D4 B3                   or      E               ; Combine with coded operator
2119+ 20D5 7B                   ld      A,E             ; Get coded operator
2120+ 20D6 CA 74 26             jp      Z,CONCAT        ; String concatenation
2121+ 20D9 07                   rlca                    ; Times 2
2122+ 20DA 83                   add     A,E             ; Times 3
2123+ 20DB 5F                   ld      E,A             ; To DE (D is 0)
2124+ 20DC 21 45 15             ld      HL,PRITAB       ; Precedence table
2125+ 20DF 19                   add     HL,DE           ; To the operator concerned
2126+ 20E0 78                   ld      A,B             ; Last operator precedence
2127+ 20E1 56                   ld      D,(HL)          ; Get evaluation precedence
2128+ 20E2 BA                   cp      D               ; Compare with eval precedence
2129+ 20E3 D0                   ret     NC              ; Exit if higher precedence
2130+ 20E4 23                   inc     HL              ; Point to routine address
2131+ 20E5 CD 79 20             call    TSTNUM          ; Make sure it's a number
2132+ 20E8
2133+ 20E8 C5           STKTHS: push    BC              ; Save last precedence & token
2134+ 20E9 01 97 20             ld      BC,EVAL3        ; Where to go on prec' break
2135+ 20EC C5                   push    BC              ; Save on stack for return
2136+ 20ED 43                   ld      B,E             ; Save operator
2137+ 20EE 4A                   ld      C,D             ; Save precedence
2138+ 20EF CD B4 2E             call    STAKFP          ; Move value to stack
2139+ 20F2 58                   ld      E,B             ; Restore operator
2140+ 20F3 51                   ld      D,C             ; Restore precedence
2141+ 20F4 4E                   ld      C,(HL)          ; Get LSB of routine address
2142+ 20F5 23                   inc     HL
2143+ 20F6 46                   ld      B,(HL)          ; Get MSB of routine address
2144+ 20F7 23                   inc     HL
2145+ 20F8 C5                   push    BC              ; Save routine address
2146+ 20F9 2A CA 52             ld      HL,(CUROPR)     ; Address of current operator
2147+ 20FC C3 8B 20             jp      EVAL1           ; Loop until prec' break
2148+ 20FF
2149+ 20FF AF           OPRND:  xor     A               ; Get operand routine
2150+ 2100 32 B2 52             ld      (TYPE),A        ; Set numeric expected
2151+ 2103 CD ED 1B             call    GETCHR          ; Get next character
2152+ 2106 1E 24                ld      E,MO            ; ?MO Error
2153+ 2108 CA DE 16             jp      Z,ERROR         ; No operand - Error
2154+ 210B DA 8A 2F             jp      C,ASCTFP        ; Number - Get value
2155+ 210E CD 8F 1C             call    CHKLTR          ; See if a letter
2156+ 2111 D2 66 21             jp      NC,CONVAR       ; Letter - Find variable
2157+ 2114 FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2158+ 2116 20 12                jr      NZ,NOTAMP
2159+ 2118 CD ED 1B             call    GETCHR          ; Get next character
2160+ 211B FE 48                cp      'H'             ; Hex number indicated? [function added]
2161+ 211D CA F0 3E             jp      Z,HEXTFP        ; Convert Hex to FPREG
2162+ 2120 FE 42                cp      'B'             ; Binary number indicated? [function added]
2163+ 2122 CA 60 3F             jp      Z,BINTFP        ; Convert Bin to FPREG
2164+ 2125 1E 02                ld      E,SN            ; If neither then a ?SN Error
2165+ 2127 CA DE 16             jp      Z,ERROR         ;
2166+ 212A FE BD        NOTAMP: cp      ZPLUS           ; '+' Token ?
2167+ 212C CA FF 20             jp      Z,OPRND         ; Yes - Look for operand
2168+ 212F FE 2E                cp      '.'             ; '.' ?
2169+ 2131 CA 8A 2F             jp      Z,ASCTFP        ; Yes - Create FP number
2170+ 2134 FE BE                cp      ZMINUS          ; '-' Token ?
2171+ 2136 CA 55 21             jp      Z,MINUS         ; Yes - Do minus
2172+ 2139 FE 22                cp      $22             ; '"'             ; Literal string ?
2173+ 213B CA 3D 25             jp      Z,QTSTR         ; Get string terminated by '"'
2174+ 213E FE BB                cp      ZNOT            ; "NOT" Token ?
2175+ 2140 CA 60 22             jp      Z,EVNOT         ; Yes - Eval NOT expression
2176+ 2143 FE B8                cp      ZFN             ; "FN" Token ?
2177+ 2145 CA A1 24             jp      Z,DOFN          ; Yes - Do FN routine
2178+ 2148 D6 CA                sub     ZSGN            ; Is it a function?
2179+ 214A D2 77 21             jp      NC,FNOFST       ; Yes - Evaluate function
2180+ 214D CD 84 20     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2181+ 2150 CD AC 19             call    CHKSYN          ; Make sure ")" follows
2182+ 2153 29                   defb    ')'
2183+ 2154 C9                   ret
2184+ 2155
2185+ 2155 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2186+ 2157 CD 8B 20             call    EVAL1           ; Evaluate until prec' break
2187+ 215A 2A D5 52             ld      HL,(NXTOPR)     ; Get next operator address
2188+ 215D E5                   push    HL              ; Save next operator address
2189+ 215E CD AC 2E             call    INVSGN          ; Negate value
2190+ 2161 CD 79 20     RETNUM: call    TSTNUM          ; Make sure it's a number
2191+ 2164 E1                   pop     HL              ; Restore next operator address
2192+ 2165 C9                   ret
2193+ 2166
2194+ 2166 CD 85 22     CONVAR: call    GETVAR          ; Get variable address to DE
2195+ 2169 E5           FRMEVL: push    HL              ; Save code string address
2196+ 216A EB                   ex      DE,HL           ; Variable address to HL
2197+ 216B 22 50 53             ld      (FPREG),HL      ; Save address of variable
2198+ 216E 3A B2 52             ld      A,(TYPE)        ; Get type
2199+ 2171 B7                   or      A               ; Numeric?
2200+ 2172 CC C1 2E             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2201+ 2175 E1                   pop     HL              ; Restore code string address
2202+ 2176 C9                   ret
2203+ 2177
2204+ 2177 06 00        FNOFST: ld      B,$00           ; Get address of function
2205+ 2179 07                   rlca                    ; Double function offset
2206+ 217A 4F                   ld      C,A             ; BC = Offset in function table
2207+ 217B C5                   push    BC              ; Save adjusted token value
2208+ 217C CD ED 1B             call    GETCHR          ; Get next character
2209+ 217F 79                   ld      A,C             ; Get adjusted token value
2210+ 2180 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2211+ 2182 CA AE 36             jp      Z,POINT         ; Yes, do "POINT"
2212+ 2185 FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2213+ 2187 CA 50 27             jp      Z,INSTR         ; Yes, do "INSTR"
2214+ 218A FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2215+ 218C DA A8 21             jp      C,FNVAL         ; No - Do function
2216+ 218F CD 84 20             call    OPNPAR          ; Evaluate expression  (X,...
2217+ 2192 CD AC 19             call    CHKSYN          ; Make sure ',' follows
2218+ 2195 2C                   defb    ','
2219+ 2196 CD 7A 20             call    TSTSTR          ; Make sure it's a string
2220+ 2199 EB                   ex      DE,HL           ; Save code string address
2221+ 219A 2A 50 53             ld      HL,(FPREG)      ; Get address of string
2222+ 219D E3                   ex      (SP),HL         ; Save address of string
2223+ 219E E5                   push    HL              ; Save adjusted token value
2224+ 219F EB                   ex      DE,HL           ; Restore code string address
2225+ 21A0 CD FC 28             call    GETINT          ; Get integer 0-255
2226+ 21A3 EB                   ex      DE,HL           ; Save code string address
2227+ 21A4 E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2228+ 21A5 C3 B0 21             jp      GOFUNC          ; Jump to string function
2229+ 21A8
2230+ 21A8 CD 4D 21     FNVAL:  call    EVLPAR          ; Evaluate expression
2231+ 21AB E3                   ex      (SP),HL         ; HL = Adjusted token value
2232+ 21AC 11 61 21             ld      DE,RETNUM       ; Return number from function
2233+ 21AF D5                   push    DE              ; Save on stack
2234+ 21B0 01 08 13     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2235+ 21B3 09                   add     HL,BC           ; Point to right address
2236+ 21B4 4E                   ld      C,(HL)          ; Get LSB of address
2237+ 21B5 23                   inc     HL              ;
2238+ 21B6 66                   ld      H,(HL)          ; Get MSB of address
2239+ 21B7 69                   ld      L,C             ; Address to HL
2240+ 21B8 E9                   jp      (HL)            ; Jump to function
2241+ 21B9
2242+ 21B9 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2243+ 21BA FE BE                cp      ZMINUS          ; '-' token ?
2244+ 21BC C8                   ret     Z               ; Yes - Return
2245+ 21BD FE 2D                cp      '-'             ; '-' ASCII ?
2246+ 21BF C8                   ret     Z               ; Yes - Return
2247+ 21C0 14                   inc     D               ; Inc to flag positive exponent
2248+ 21C1 FE 2B                cp      '+'             ; '+' ASCII ?
2249+ 21C3 C8                   ret     Z               ; Yes - Return
2250+ 21C4 FE BD                cp      ZPLUS           ; '+' token ?
2251+ 21C6 C8                   ret     Z               ; Yes - Return
2252+ 21C7 2B                   dec     HL              ; dec 'cos GETCHR INCs
2253+ 21C8 C9                   ret                     ; Return "NZ"
2254+ 21C9
2255+ 21C9              ; execute OR, AND, and XOR operations
2256+ 21C9 AF           PAND:   xor     A               ; for AND, Z=1
2257+ 21CA 18 07                jr      CNTLGC
2258+ 21CC AF           POR:    xor     A               ; for OR, Z=0, S=1
2259+ 21CD D6 01                sub     $01
2260+ 21CF 18 02                jr      CNTLGC
2261+ 21D1 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2262+ 21D2 3C                   inc     A
2263+ 21D3 F5           CNTLGC: push    AF              ; store operand's flags
2264+ 21D4 CD 79 20             call    TSTNUM          ; Make sure it's a number
2265+ 21D7 CD A3 1C             call    DEINT           ; Get integer -32768 to 32767
2266+ 21DA F1                   pop     AF              ; retrieve operand's flags
2267+ 21DB EB                   ex      DE,HL           ; <- Get last
2268+ 21DC C1                   pop     BC              ; <-  value
2269+ 21DD E3                   ex      (SP),HL         ; <-  from
2270+ 21DE EB                   ex      DE,HL           ; <-  stack
2271+ 21DF CD C4 2E             call    FPBCDE          ; Move last value to FPREG
2272+ 21E2 F5                   push    AF              ; store operand's flags
2273+ 21E3 CD A3 1C             call    DEINT           ; Get integer -32768 to 32767
2274+ 21E6 F1                   pop     AF              ; retrieve operand's flags
2275+ 21E7 C1                   pop     BC              ; Get value
2276+ 21E8 79                   ld      A,C             ; Get LSB
2277+ 21E9 21 5F 24             ld      HL,ACPASS       ; Address of save AC as current
2278+ 21EC 20 05                jr      NZ,POR1         ; if X/OR, jump over
2279+ 21EE A3           PAND1:  and     E               ; "AND" LSBs
2280+ 21EF 4F                   ld      C,A             ; Save LSB
2281+ 21F0 78                   ld      A,B             ; Get MSB
2282+ 21F1 A2                   and     D               ; "AND" MSBs
2283+ 21F2 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2284+ 21F3 F2 FB 21     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2285+ 21F6 B3                   or      E               ; "OR" LSBs
2286+ 21F7 4F                   ld      C,A             ; Save LSB
2287+ 21F8 78                   ld      A,B             ; Get MSB
2288+ 21F9 B2                   or      D               ; "OR" MSBs
2289+ 21FA E9                   jp      (HL)            ; Save AC as current (ACPASS)
2290+ 21FB AB           PXOR1:  xor     E               ; "XOR" LSBs
2291+ 21FC 4F                   ld      C,A             ; Save LSB
2292+ 21FD 78                   ld      A,B             ; Get MSB
2293+ 21FE AA                   xor     D               ; "XOR" MSBs
2294+ 21FF E9                   jp      (HL)            ; Save AC as current (ACPASS)
2295+ 2200
2296+ 2200 21 12 22     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2297+ 2203 3A B2 52             ld      A,(TYPE)        ; Get data type
2298+ 2206 1F                   rra                     ; Carry set = string
2299+ 2207 7A                   ld      A,D             ; Get last precedence value
2300+ 2208 17                   rla                     ; Times 2 plus carry
2301+ 2209 5F                   ld      E,A             ; To E
2302+ 220A 16 64                ld      D,$64           ; Relational precedence
2303+ 220C 78                   ld      A,B             ; Get current precedence
2304+ 220D BA                   cp      D               ; Compare with last
2305+ 220E D0                   ret     NC              ; Eval if last was rel' or log'
2306+ 220F C3 E8 20             jp      STKTHS          ; Stack this one and get next
2307+ 2212
2308+ 2212 14 22        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2309+ 2214 79           CMPLG1: ld      A,C             ; Get data type
2310+ 2215 B7                   or      A
2311+ 2216 1F                   rra
2312+ 2217 C1                   pop     BC              ; Get last expression to BCDE
2313+ 2218 D1                   pop     DE
2314+ 2219 F5                   push    AF              ; Save status
2315+ 221A CD 7B 20             call    CHKTYP          ; Check that types match
2316+ 221D 21 56 22             ld      HL,CMPRES       ; Result to comparison
2317+ 2220 E5                   push    HL              ; Save for RETurn
2318+ 2221 CA FE 2E             jp      Z,CMPNUM        ; Compare values if numeric
2319+ 2224 AF                   xor     A               ; Compare two strings
2320+ 2225 32 B2 52             ld      (TYPE),A        ; Set type to numeric
2321+ 2228 D5                   push    DE              ; Save string name
2322+ 2229 CD C1 26             call    GSTRCU          ; Get current string
2323+ 222C 7E                   ld      A,(HL)          ; Get length of string
2324+ 222D 23                   inc     HL
2325+ 222E 23                   inc     HL
2326+ 222F 4E                   ld      C,(HL)          ; Get LSB of address
2327+ 2230 23                   inc     HL
2328+ 2231 46                   ld      B,(HL)          ; Get MSB of address
2329+ 2232 D1                   pop     DE              ; Restore string name
2330+ 2233 C5                   push    BC              ; Save address of string
2331+ 2234 F5                   push    AF              ; Save length of string
2332+ 2235 CD C5 26             call    GSTRDE          ; Get second string
2333+ 2238 CD D2 2E             call    LOADFP          ; Get address of second string
2334+ 223B F1                   pop     AF              ; Restore length of string 1
2335+ 223C 57                   ld      D,A             ; Length to D
2336+ 223D E1                   pop     HL              ; Restore address of string 1
2337+ 223E 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2338+ 223F B2                   or      D               ; Bytes of string 1 to do
2339+ 2240 C8                   ret     Z               ; Exit if all bytes compared
2340+ 2241 7A                   ld      A,D             ; Get bytes of string 1 to do
2341+ 2242 D6 01                sub     $01
2342+ 2244 D8                   ret     C               ; Exit if end of string 1
2343+ 2245 AF                   xor     A
2344+ 2246 BB                   cp      E               ; Bytes of string 2 to do
2345+ 2247 3C                   inc     A
2346+ 2248 D0                   ret     NC              ; Exit if end of string 2
2347+ 2249 15                   dec     D               ; Count bytes in string 1
2348+ 224A 1D                   dec     E               ; Count bytes in string 2
2349+ 224B 0A                   ld      A,(BC)          ; Byte in string 2
2350+ 224C BE                   cp      (HL)            ; Compare to byte in string 1
2351+ 224D 23                   inc     HL              ; Move up string 1
2352+ 224E 03                   inc     BC              ; Move up string 2
2353+ 224F CA 3E 22             jp      Z,CMPSTR        ; Same - Try next bytes
2354+ 2252 3F                   ccf                     ; Flag difference (">" or "<")
2355+ 2253 C3 8E 2E             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2356+ 2256
2357+ 2256 3C           CMPRES: inc     A               ; Increment current value
2358+ 2257 8F                   adc     A,A             ; Double plus carry
2359+ 2258 C1                   pop     BC              ; Get other value
2360+ 2259 A0                   and     B               ; Combine them
2361+ 225A C6 FF                add     A,-1            ; Carry set if different
2362+ 225C 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2363+ 225D C3 95 2E             jp      FLGREL          ; Set current value & continue
2364+ 2260
2365+ 2260 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2366+ 2262 CD 8B 20             call    EVAL1           ; Eval until precedence break
2367+ 2265 CD 79 20             call    TSTNUM          ; Make sure it's a number
2368+ 2268 CD A3 1C             call    DEINT           ; Get integer -32768 - 32767
2369+ 226B 7B                   ld      A,E             ; Get LSB
2370+ 226C 2F                   cpl                     ; Invert LSB
2371+ 226D 4F                   ld      C,A             ; Save "NOT" of LSB
2372+ 226E 7A                   ld      A,D             ; Get MSB
2373+ 226F 2F                   cpl                     ; Invert MSB
2374+ 2270 CD 5F 24             call    ACPASS          ; Save AC as current
2375+ 2273 C1                   pop     BC              ; Clean up stack
2376+ 2274 C3 97 20             jp      EVAL3           ; Continue evaluation
2377+ 2277
2378+ 2277 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2379+ 2278 CD ED 1B             call    GETCHR          ; Get next character
2380+ 227B C8                   ret     Z               ; End of DIM statement
2381+ 227C CD AC 19             call    CHKSYN          ; Make sure ',' follows
2382+ 227F 2C                   defb    ','
2383+ 2280 01 77 22     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2384+ 2283 C5                   push    BC              ; Save on stack
2385+ 2284 F6                   defb    $F6             ; Flag "Create" variable
2386+ 2285 AF           GETVAR: xor     A               ; Find variable address,to DE
2387+ 2286 32 B1 52             ld      (LCRFLG),A      ; Set locate / create flag
2388+ 2289 46                   ld      B,(HL)          ; Get First byte of name
2389+ 228A CD 8F 1C     GTFNAM: call    CHKLTR          ; See if a letter
2390+ 228D DA CA 16             jp      C,SNERR         ; ?SN Error if not a letter
2391+ 2290 AF                   xor     A
2392+ 2291 4F                   ld      C,A             ; Clear second byte of name
2393+ 2292 32 B2 52             ld      (TYPE),A        ; Set type to numeric
2394+ 2295 CD ED 1B             call    GETCHR          ; Get next character
2395+ 2298 DA A1 22             jp      C,SVNAM2        ; Numeric - Save in name
2396+ 229B CD 8F 1C             call    CHKLTR          ; See if a letter
2397+ 229E DA AE 22             jp      C,CHARTY        ; Not a letter - Check type
2398+ 22A1 4F           SVNAM2: ld      C,A             ; Save second byte of name
2399+ 22A2 CD ED 1B     ENDNAM: call    GETCHR          ; Get next character
2400+ 22A5 DA A2 22             jp      C,ENDNAM        ; Numeric - Get another
2401+ 22A8 CD 8F 1C             call    CHKLTR          ; See if a letter
2402+ 22AB D2 A2 22             jp      NC,ENDNAM       ; Letter - Get another
2403+ 22AE D6 24        CHARTY: sub     '$'             ; String variable?
2404+ 22B0 C2 BD 22             jp      NZ,NOTSTR       ; No - Numeric variable
2405+ 22B3 3C                   inc     A               ; A = 1 (string type)
2406+ 22B4 32 B2 52             ld      (TYPE),A        ; Set type to string
2407+ 22B7 0F                   rrca                    ; A = 80H , Flag for string
2408+ 22B8 81                   add     A,C             ; 2nd byte of name has bit 7 on
2409+ 22B9 4F                   ld      C,A             ; Resave second byte on name
2410+ 22BA CD ED 1B             call    GETCHR          ; Get next character
2411+ 22BD 3A D0 52     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2412+ 22C0 3D                   dec     A
2413+ 22C1 CA 6A 23             jp      Z,ARLDSV        ; Yes - Get array name
2414+ 22C4 F2 CD 22             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2415+ 22C7 7E                   ld      A,(HL)          ; Get byte again
2416+ 22C8 D6 28                sub     '('             ; Subscripted variable?
2417+ 22CA CA 42 23             jp      Z,SBSCPT        ; Yes - Sort out subscript
2418+ 22CD
2419+ 22CD AF           NSCFOR: xor     A               ; Simple variable
2420+ 22CE 32 D0 52             ld      (FORFLG),A      ; Clear "FOR" flag
2421+ 22D1 E5                   push    HL              ; Save code string address
2422+ 22D2 50                   ld      D,B             ; DE = Variable name to find
2423+ 22D3 59                   ld      E,C
2424+ 22D4 2A 4A 53             ld      HL,(FNRGNM)     ; FN argument name
2425+ 22D7 CD A6 19             call    CPDEHL          ; Is it the FN argument?
2426+ 22DA 11 4C 53             ld      DE,FNARG        ; Point to argument value
2427+ 22DD CA 73 2D             jp      Z,POPHRT        ; Yes - Return FN argument value
2428+ 22E0 2A 44 53             ld      HL,(VAREND)     ; End of variables
2429+ 22E3 EB                   ex      DE,HL           ; Address of end of search
2430+ 22E4 2A 42 53             ld      HL,(PROGND)     ; Start of variables address
2431+ 22E7 CD A6 19     FNDVAR: call    CPDEHL          ; End of variable list table?
2432+ 22EA CA 00 23             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2433+ 22ED 79                   ld      A,C             ; Get second byte of name
2434+ 22EE 96                   sub     (HL)            ; Compare with name in list
2435+ 22EF 23                   inc     HL              ; Move on to first byte
2436+ 22F0 C2 F5 22             jp      NZ,FNTHR        ; Different - Find another
2437+ 22F3 78                   ld      A,B             ; Get first byte of name
2438+ 22F4 96                   sub     (HL)            ; Compare with name in list
2439+ 22F5 23           FNTHR:  inc     HL              ; Move on to LSB of value
2440+ 22F6 CA 34 23             jp      Z,RETADR        ; Found - Return address
2441+ 22F9 23                   inc     HL              ; <- Skip
2442+ 22FA 23                   inc     HL              ; <- over
2443+ 22FB 23                   inc     HL              ; <- F.P.
2444+ 22FC 23                   inc     HL              ; <- value
2445+ 22FD C3 E7 22             jp      FNDVAR          ; Keep looking
2446+ 2300
2447+ 2300 E1           CFEVAL: pop     HL              ; Restore code string address
2448+ 2301 E3                   ex      (SP),HL         ; Get return address
2449+ 2302 D5                   push    DE              ; Save address of variable
2450+ 2303 11 69 21             ld      DE,FRMEVL       ; Return address in EVAL
2451+ 2306 CD A6 19             call    CPDEHL          ; Called from EVAL ?
2452+ 2309 D1                   pop     DE              ; Restore address of variable
2453+ 230A CA 37 23             jp      Z,RETNUL        ; Yes - Return null variable
2454+ 230D E3                   ex      (SP),HL         ; Put back return
2455+ 230E E5                   push    HL              ; Save code string address
2456+ 230F C5                   push    BC              ; Save variable name
2457+ 2310 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2458+ 2313 2A 46 53             ld      HL,(ARREND)     ; End of arrays
2459+ 2316 E5                   push    HL              ; Save end of arrays
2460+ 2317 09                   add     HL,BC           ; Move up 6 bytes
2461+ 2318 C1                   pop     BC              ; Source address in BC
2462+ 2319 E5                   push    HL              ; Save new end address
2463+ 231A CD 76 16             call    MOVUP           ; Move arrays up
2464+ 231D E1                   pop     HL              ; Restore new end address
2465+ 231E 22 46 53             ld      (ARREND),HL     ; Set new end address
2466+ 2321 60                   ld      H,B             ; End of variables to HL
2467+ 2322 69                   ld      L,C
2468+ 2323 22 44 53             ld      (VAREND),HL     ; Set new end address
2469+ 2326
2470+ 2326 2B           ZEROLP: dec     HL              ; Back through to zero variable
2471+ 2327 36 00                ld      (HL),$00        ; Zero byte in variable
2472+ 2329 CD A6 19             call    CPDEHL          ; Done them all?
2473+ 232C C2 26 23             jp      NZ,ZEROLP       ; No - Keep on going
2474+ 232F D1                   pop     DE              ; Get variable name
2475+ 2330 73                   ld      (HL),E          ; Store second character
2476+ 2331 23                   inc     HL
2477+ 2332 72                   ld      (HL),D          ; Store first character
2478+ 2333 23                   inc     HL
2479+ 2334 EB           RETADR: ex      DE,HL           ; Address of variable in DE
2480+ 2335 E1                   pop     HL              ; Restore code string address
2481+ 2336 C9                   ret
2482+ 2337
2483+ 2337 32 53 53     RETNUL: ld      (FPEXP),A       ; Set result to zero
2484+ 233A 21 47 16             ld      HL,ZERBYT       ; Also set a null string
2485+ 233D 22 50 53             ld      (FPREG),HL      ; Save for EVAL
2486+ 2340 E1                   pop     HL              ; Restore code string address
2487+ 2341 C9                   ret
2488+ 2342
2489+ 2342 E5           SBSCPT: push    HL              ; Save code string address
2490+ 2343 2A B1 52             ld      HL,(LCRFLG)     ; Locate/Create and Type
2491+ 2346 E3                   ex      (SP),HL         ; Save and get code string
2492+ 2347 57                   ld      D,A             ; Zero number of dimensions
2493+ 2348 D5           SCPTLP: push    DE              ; Save number of dimensions
2494+ 2349 C5                   push    BC              ; Save array name
2495+ 234A CD 97 1C             call    FPSINT          ; Get subscript (0-32767)
2496+ 234D C1                   pop     BC              ; Restore array name
2497+ 234E F1                   pop     AF              ; Get number of dimensions
2498+ 234F EB                   ex      DE,HL
2499+ 2350 E3                   ex      (SP),HL         ; Save subscript value
2500+ 2351 E5                   push    HL              ; Save LCRFLG and TYPE
2501+ 2352 EB                   ex      DE,HL
2502+ 2353 3C                   inc     A               ; Count dimensions
2503+ 2354 57                   ld      D,A             ; Save in D
2504+ 2355 7E                   ld      A,(HL)          ; Get next byte in code string
2505+ 2356 FE 2C                cp      ','             ; Comma (more to come)?
2506+ 2358 CA 48 23             jp      Z,SCPTLP        ; Yes - More subscripts
2507+ 235B CD AC 19             call    CHKSYN          ; Make sure ")" follows
2508+ 235E 29                   defb    ')'
2509+ 235F 22 D5 52             ld      (NXTOPR),HL     ; Save code string address
2510+ 2362 E1                   pop     HL              ; Get LCRFLG and TYPE
2511+ 2363 22 B1 52             ld      (LCRFLG),HL     ; Restore Locate/create & type
2512+ 2366 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2513+ 2368 D5                   push    DE              ; Save number of dimensions (D)
2514+ 2369 11                   defb    $11             ; Skip "push HL" and "push AF'
2515+ 236A
2516+ 236A E5           ARLDSV: push    HL              ; Save code string address
2517+ 236B F5                   push    AF              ; A = 00 , Flags set = Z,N
2518+ 236C 2A 44 53             ld      HL,(VAREND)     ; Start of arrays
2519+ 236F 3E                   defb    $3E             ; Skip "add HL,DE"
2520+ 2370 19           FNDARY: add     HL,DE           ; Move to next array start
2521+ 2371 EB                   ex      DE,HL
2522+ 2372 2A 46 53             ld      HL,(ARREND)     ; End of arrays
2523+ 2375 EB                   ex      DE,HL           ; Current array pointer
2524+ 2376 CD A6 19             call    CPDEHL          ; End of arrays found?
2525+ 2379 CA A2 23             jp      Z,CREARY        ; Yes - Create array
2526+ 237C 7E                   ld      A,(HL)          ; Get second byte of name
2527+ 237D B9                   cp      C               ; Compare with name given
2528+ 237E 23                   inc     HL              ; Move on
2529+ 237F C2 84 23             jp      NZ,NXTARY       ; Different - Find next array
2530+ 2382 7E                   ld      A,(HL)          ; Get first byte of name
2531+ 2383 B8                   cp      B               ; Compare with name given
2532+ 2384 23           NXTARY: inc     HL              ; Move on
2533+ 2385 5E                   ld      E,(HL)          ; Get LSB of next array address
2534+ 2386 23                   inc     HL
2535+ 2387 56                   ld      D,(HL)          ; Get MSB of next array address
2536+ 2388 23                   inc     HL
2537+ 2389 C2 70 23             jp      NZ,FNDARY       ; Not found - Keep looking
2538+ 238C 3A B1 52             ld      A,(LCRFLG)      ; Found Locate or Create it?
2539+ 238F B7                   or      A
2540+ 2390 C2 D3 16             jp      NZ,DDERR        ; Create - ?DD Error
2541+ 2393 F1                   pop     AF              ; Locate - Get number of dim'ns
2542+ 2394 44                   ld      B,H             ; BC Points to array dim'ns
2543+ 2395 4D                   ld      C,L
2544+ 2396 CA 73 2D             jp      Z,POPHRT        ; Jump if array load/save
2545+ 2399 96                   sub     (HL)            ; Same number of dimensions?
2546+ 239A CA 00 24             jp      Z,FINDEL        ; Yes - Find element
2547+ 239D 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2548+ 239F C3 DE 16             jp      ERROR           ; Output error
2549+ 23A2
2550+ 23A2 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2551+ 23A5 F1                   pop     AF              ; Array to save or 0 dim'ns?
2552+ 23A6 CA B8 1C             jp      Z,FCERR         ; Yes - ?FC Error
2553+ 23A9 71                   ld      (HL),C          ; Save second byte of name
2554+ 23AA 23                   inc     HL
2555+ 23AB 70                   ld      (HL),B          ; Save first byte of name
2556+ 23AC 23                   inc     HL
2557+ 23AD 4F                   ld      C,A             ; Number of dimensions to C
2558+ 23AE CD 87 16             call    CHKSTK          ; Check if enough memory
2559+ 23B1 23                   inc     HL              ; Point to number of dimensions
2560+ 23B2 23                   inc     HL
2561+ 23B3 22 CA 52             ld      (CUROPR),HL     ; Save address of pointer
2562+ 23B6 71                   ld      (HL),C          ; Set number of dimensions
2563+ 23B7 23                   inc     HL
2564+ 23B8 3A B1 52             ld      A,(LCRFLG)      ; Locate of Create?
2565+ 23BB 17                   rla                     ; Carry set = Create
2566+ 23BC 79                   ld      A,C             ; Get number of dimensions
2567+ 23BD 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2568+ 23C0 D2 C5 23             jp      NC,DEFSIZ       ; Locate - Set default size
2569+ 23C3 C1                   pop     BC              ; Get specified dimension size
2570+ 23C4 03                   inc     BC              ; Include zero element
2571+ 23C5 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2572+ 23C6 23                   inc     HL
2573+ 23C7 70                   ld      (HL),B          ; Save MSB of dimension size
2574+ 23C8 23                   inc     HL
2575+ 23C9 F5                   push    AF              ; Save num' of dim'ns an status
2576+ 23CA E5                   push    HL              ; Save address of dim'n size
2577+ 23CB CD 6F 2F             call    MLDEBC          ; Multiply DE by BC to find
2578+ 23CE EB                   ex      DE,HL           ; amount of mem needed (to DE)
2579+ 23CF E1                   pop     HL              ; Restore address of dimension
2580+ 23D0 F1                   pop     AF              ; Restore number of dimensions
2581+ 23D1 3D                   dec     A               ; Count them
2582+ 23D2 C2 BD 23             jp      NZ,CRARLP       ; Do next dimension if more
2583+ 23D5 F5                   push    AF              ; Save locate/create flag
2584+ 23D6 42                   ld      B,D             ; MSB of memory needed
2585+ 23D7 4B                   ld      C,E             ; LSB of memory needed
2586+ 23D8 EB                   ex      DE,HL
2587+ 23D9 19                   add     HL,DE           ; Add bytes to array start
2588+ 23DA DA 9F 16             jp      C,OMERR         ; Too big - Error
2589+ 23DD CD 90 16             call    ENFMEM          ; See if enough memory
2590+ 23E0 22 46 53             ld      (ARREND),HL     ; Save new end of array
2591+ 23E3
2592+ 23E3 2B           ZERARY: dec     HL              ; Back through array data
2593+ 23E4 36 00                ld      (HL),$00        ; Set array element to zero
2594+ 23E6 CD A6 19             call    CPDEHL          ; All elements zeroed?
2595+ 23E9 C2 E3 23             jp      NZ,ZERARY       ; No - Keep on going
2596+ 23EC 03                   inc     BC              ; Number of bytes + 1
2597+ 23ED 57                   ld      D,A             ; A=0
2598+ 23EE 2A CA 52             ld      HL,(CUROPR)     ; Get address of array
2599+ 23F1 5E                   ld      E,(HL)          ; Number of dimensions
2600+ 23F2 EB                   ex      DE,HL           ; To HL
2601+ 23F3 29                   add     HL,HL           ; Two bytes per dimension size
2602+ 23F4 09                   add     HL,BC           ; Add number of bytes
2603+ 23F5 EB                   ex      DE,HL           ; Bytes needed to DE
2604+ 23F6 2B                   dec     HL
2605+ 23F7 2B                   dec     HL
2606+ 23F8 73                   ld      (HL),E          ; Save LSB of bytes needed
2607+ 23F9 23                   inc     HL
2608+ 23FA 72                   ld      (HL),D          ; Save MSB of bytes needed
2609+ 23FB 23                   inc     HL
2610+ 23FC F1                   pop     AF              ; Locate / Create?
2611+ 23FD DA 24 24             jp      C,ENDDIM        ; A is 0 , End if create
2612+ 2400 47           FINDEL: ld      B,A             ; Find array element
2613+ 2401 4F                   ld      C,A
2614+ 2402 7E                   ld      A,(HL)          ; Number of dimensions
2615+ 2403 23                   inc     HL
2616+ 2404 16                   defb    $16             ; Skip "pop HL"
2617+ 2405 E1           FNDELP: pop     HL              ; Address of next dim' size
2618+ 2406 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2619+ 2407 23                   inc     HL
2620+ 2408 56                   ld      D,(HL)          ; Get MSB of dim'n size
2621+ 2409 23                   inc     HL
2622+ 240A E3                   ex      (SP),HL         ; Save address - Get index
2623+ 240B F5                   push    AF              ; Save number of dim'ns
2624+ 240C CD A6 19             call    CPDEHL          ; Dimension too large?
2625+ 240F D2 9D 23             jp      NC,BSERR        ; Yes - ?BS Error
2626+ 2412 E5                   push    HL              ; Save index
2627+ 2413 CD 6F 2F             call    MLDEBC          ; Multiply previous by size
2628+ 2416 D1                   pop     DE              ; Index supplied to DE
2629+ 2417 19                   add     HL,DE           ; Add index to pointer
2630+ 2418 F1                   pop     AF              ; Number of dimensions
2631+ 2419 3D                   dec     A               ; Count them
2632+ 241A 44                   ld      B,H             ; MSB of pointer
2633+ 241B 4D                   ld      C,L             ; LSB of pointer
2634+ 241C C2 05 24             jp      NZ,FNDELP       ; More - Keep going
2635+ 241F 29                   add     HL,HL           ; 4 Bytes per element
2636+ 2420 29                   add     HL,HL
2637+ 2421 C1                   pop     BC              ; Start of array
2638+ 2422 09                   add     HL,BC           ; Point to element
2639+ 2423 EB                   ex      DE,HL           ; Address of element to DE
2640+ 2424 2A D5 52     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2641+ 2427 C9                   ret
2642+ 2428
2643+ 2428
2644+ 2428              ; returns the value of the 32-bit system tick counter as
2645+ 2428              ; two 16-bit words
2646+ 2428 CD 79 20     TMR:    call    TSTNUM          ; Make sure it's a number
2647+ 242B CD A3 1C             call    DEINT           ; Get integer (-32768 to 32767)
2648+ 242E 2A DB 52             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2649+ 2431 7B                   ld      A,E
2650+ 2432 B2                   or      D               ; is it 0?
2651+ 2433 CA 39 24             jp      Z,ENDTMR        ; yes, jump over
2652+ 2436 2A DD 52             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2653+ 2439 45           ENDTMR: ld      B,L             ; move bytes...
2654+ 243A 7C                   ld      A,H             ; ...into AB
2655+ 243B C3 60 24             jp      ABPASS          ; return word into AB
2656+ 243E
2657+ 243E
2658+ 243E              ; returns the free space for BASIC or into the string pool
2659+ 243E 2A 46 53     FRE:    ld      HL,(ARREND)     ; Start of free memory
2660+ 2441 EB                   ex      DE,HL           ; To DE
2661+ 2442 21 00 00             ld      HL,$0000        ; End of free memory
2662+ 2445 39                   add     HL,SP           ; Current stack value
2663+ 2446 3A B2 52             ld      A,(TYPE)        ; Dummy argument type
2664+ 2449 B7                   or      A
2665+ 244A CA 5A 24             jp      Z,FRENUM        ; Numeric - Free variable space
2666+ 244D CD C1 26             call    GSTRCU          ; Current string to pool
2667+ 2450 CD C1 25             call    GARBGE          ; Garbage collection
2668+ 2453 2A CB 51             ld      HL,(STRSPC)     ; Bottom of string space in use
2669+ 2456 EB                   ex      DE,HL           ; To DE
2670+ 2457 2A C8 52             ld      HL,(STRBOT)     ; Bottom of string space
2671+ 245A 7D           FRENUM: ld      A,L             ; Get LSB of end
2672+ 245B 93                   sub     E               ; Subtract LSB of beginning
2673+ 245C 4F                   ld      C,A             ; Save difference if C
2674+ 245D 7C                   ld      A,H             ; Get MSB of end
2675+ 245E 9A                   sbc     A,D             ; Subtract MSB of beginning
2676+ 245F 41           ACPASS: ld      B,C             ; Return integer AC
2677+ 2460 50           ABPASS: ld      D,B             ; Return integer AB
2678+ 2461 1E 00                ld      E,$00
2679+ 2463 21 B2 52             ld      HL,TYPE         ; Point to type
2680+ 2466 73                   ld      (HL),E          ; Set type to numeric
2681+ 2467 06 90                ld      B,$80+$10       ; 16 bit integer
2682+ 2469 C3 9A 2E             jp      RETINT          ; Return the integer
2683+ 246C
2684+ 246C              ; returns the X position of the cursor during a print
2685+ 246C 3A B0 52     POS:    ld      A,(CURPOS)      ; Get cursor position
2686+ 246F 47           PASSA:  ld      B,A             ; Put A into AB
2687+ 2470 AF                   xor     A               ; Zero A
2688+ 2471 C3 60 24             jp      ABPASS          ; Return integer AB
2689+ 2474
2690+ 2474 CD F7 24     DEF:    call    CHEKFN          ; Get "FN" and name
2691+ 2477 CD E9 24             call    IDTEST          ; Test for illegal direct
2692+ 247A 01 96 1D             ld      BC,DATA         ; To get next statement
2693+ 247D C5                   push    BC              ; Save address for RETurn
2694+ 247E D5                   push    DE              ; Save address of function ptr
2695+ 247F CD AC 19             call    CHKSYN          ; Make sure "(" follows
2696+ 2482 28                   defb    '('
2697+ 2483 CD 85 22             call    GETVAR          ; Get argument variable name
2698+ 2486 E5                   push    HL              ; Save code string address
2699+ 2487 EB                   ex      DE,HL           ; Argument address to HL
2700+ 2488 2B                   dec     HL
2701+ 2489 56                   ld      D,(HL)          ; Get first byte of arg name
2702+ 248A 2B                   dec     HL
2703+ 248B 5E                   ld      E,(HL)          ; Get second byte of arg name
2704+ 248C E1                   pop     HL              ; Restore code string address
2705+ 248D CD 79 20             call    TSTNUM          ; Make sure numeric argument
2706+ 2490 CD AC 19             call    CHKSYN          ; Make sure ")" follows
2707+ 2493 29                   defb    ')'
2708+ 2494 CD AC 19             call    CHKSYN          ; Make sure "=" follows
2709+ 2497 C8                   defb    ZEQUAL          ; "=" token
2710+ 2498 44                   ld      B,H             ; Code string address to BC
2711+ 2499 4D                   ld      C,L
2712+ 249A E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2713+ 249B 71                   ld      (HL),C          ; Save LSB of FN code string
2714+ 249C 23                   inc     HL
2715+ 249D 70                   ld      (HL),B          ; Save MSB of FN code string
2716+ 249E C3 36 25             jp      SVSTAD          ; Save address and do function
2717+ 24A1
2718+ 24A1 CD F7 24     DOFN:   call    CHEKFN          ; Make sure FN follows
2719+ 24A4 D5                   push    DE              ; Save function pointer address
2720+ 24A5 CD 4D 21             call    EVLPAR          ; Evaluate expression in "()"
2721+ 24A8 CD 79 20             call    TSTNUM          ; Make sure numeric result
2722+ 24AB E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2723+ 24AC 5E                   ld      E,(HL)          ; Get LSB of FN code string
2724+ 24AD 23                   inc     HL
2725+ 24AE 56                   ld      D,(HL)          ; Get MSB of FN code string
2726+ 24AF 23                   inc     HL
2727+ 24B0 7A                   ld      A,D             ; And function DEFined?
2728+ 24B1 B3                   or      E
2729+ 24B2 CA D6 16             jp      Z,UFERR         ; No - ?UF Error
2730+ 24B5 7E                   ld      A,(HL)          ; Get LSB of argument address
2731+ 24B6 23                   inc     HL
2732+ 24B7 66                   ld      H,(HL)          ; Get MSB of argument address
2733+ 24B8 6F                   ld      L,A             ; HL = Arg variable address
2734+ 24B9 E5                   push    HL              ; Save it
2735+ 24BA 2A 4A 53             ld      HL,(FNRGNM)     ; Get old argument name
2736+ 24BD E3                   ex      (SP),HL         ; Save old , Get new
2737+ 24BE 22 4A 53             ld      (FNRGNM),HL     ; Set new argument name
2738+ 24C1 2A 4E 53             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2739+ 24C4 E5                   push    HL              ; Save it
2740+ 24C5 2A 4C 53             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2741+ 24C8 E5                   push    HL              ; Save it
2742+ 24C9 21 4C 53             ld      HL,FNARG        ; HL = Value of argument
2743+ 24CC D5                   push    DE              ; Save FN code string address
2744+ 24CD CD DB 2E             call    FPTHL           ; Move FPREG to argument
2745+ 24D0 E1                   pop     HL              ; Get FN code string address
2746+ 24D1 CD 76 20             call    GETNUM          ; Get value from function
2747+ 24D4 2B                   dec     HL              ; dec 'cos GETCHR INCs
2748+ 24D5 CD ED 1B             call    GETCHR          ; Get next character
2749+ 24D8 C2 CA 16             jp      NZ,SNERR        ; Bad character in FN - Error
2750+ 24DB E1                   pop     HL              ; Get MSB,EXP of old arg
2751+ 24DC 22 4C 53             ld      (FNARG),HL      ; Restore it
2752+ 24DF E1                   pop     HL              ; Get LSB,NLSB of old arg
2753+ 24E0 22 4E 53             ld      (FNARG+2),HL    ; Restore it
2754+ 24E3 E1                   pop     HL              ; Get name of old arg
2755+ 24E4 22 4A 53             ld      (FNRGNM),HL     ; Restore it
2756+ 24E7 E1                   pop     HL              ; Restore code string address
2757+ 24E8 C9                   ret
2758+ 24E9
2759+ 24E9 E5           IDTEST: push    HL              ; Save code string address
2760+ 24EA 2A CD 51             ld      HL,(LINEAT)     ; Get current line number
2761+ 24ED 23                   inc     HL              ; -1 means direct statement
2762+ 24EE 7C                   ld      A,H
2763+ 24EF B5                   or      L
2764+ 24F0 E1                   pop     HL              ; Restore code string address
2765+ 24F1 C0                   ret     NZ              ; Return if in program
2766+ 24F2 1E 16                ld      E,ID            ; ?ID Error
2767+ 24F4 C3 DE 16             jp      ERROR
2768+ 24F7
2769+ 24F7 CD AC 19     CHEKFN: call    CHKSYN          ; Make sure FN follows
2770+ 24FA B8                   defb    ZFN             ; "FN" token
2771+ 24FB 3E 80                ld      A,$80
2772+ 24FD 32 D0 52             ld      (FORFLG),A      ; Flag FN name to find
2773+ 2500 B6                   or      (HL)            ; FN name has bit 7 set
2774+ 2501 47                   ld      B,A             ; in first byte of name
2775+ 2502 CD 8A 22             call    GTFNAM          ; Get FN name
2776+ 2505 C3 79 20             jp      TSTNUM          ; Make sure numeric function
2777+ 2508
2778+ 2508 CD 79 20     STR:    call    TSTNUM          ; Make sure it's a number
2779+ 250B CD 28 30             call    NUMASC          ; Turn number into text
2780+ 250E CD 3C 25     STR1:   call    CRTST           ; Create string entry for it
2781+ 2511 CD C1 26             call    GSTRCU          ; Current string to pool
2782+ 2514 01 1C 27             ld      BC,TOPOOL       ; Save in string pool
2783+ 2517 C5                   push    BC              ; Save address on stack
2784+ 2518
2785+ 2518 7E           SAVSTR: ld      A,(HL)          ; Get string length
2786+ 2519 23                   inc     HL
2787+ 251A 23                   inc     HL
2788+ 251B E5                   push    HL              ; Save pointer to string
2789+ 251C CD 97 25             call    TESTR           ; See if enough string space
2790+ 251F E1                   pop     HL              ; Restore pointer to string
2791+ 2520 4E                   ld      C,(HL)          ; Get LSB of address
2792+ 2521 23                   inc     HL
2793+ 2522 46                   ld      B,(HL)          ; Get MSB of address
2794+ 2523 CD 30 25             call    CRTMST          ; Create string entry
2795+ 2526 E5                   push    HL              ; Save pointer to MSB of addr
2796+ 2527 6F                   ld      L,A             ; Length of string
2797+ 2528 CD B4 26             call    TOSTRA          ; Move to string area
2798+ 252B D1                   pop     DE              ; Restore pointer to MSB
2799+ 252C C9                   ret
2800+ 252D
2801+ 252D CD 97 25     MKTMST: call    TESTR           ; See if enough string space
2802+ 2530 21 C4 52     CRTMST: ld      HL,TMPSTR       ; Temporary string
2803+ 2533 E5                   push    HL              ; Save it
2804+ 2534 77                   ld      (HL),A          ; Save length of string
2805+ 2535 23                   inc     HL
2806+ 2536 23           SVSTAD: inc     HL
2807+ 2537 73                   ld      (HL),E          ; Save LSB of address
2808+ 2538 23                   inc     HL
2809+ 2539 72                   ld      (HL),D          ; Save MSB of address
2810+ 253A E1                   pop     HL              ; Restore pointer
2811+ 253B C9                   ret
2812+ 253C
2813+ 253C 2B           CRTST:  dec     HL              ; dec - INCed after
2814+ 253D 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2815+ 253F 50                   ld      D,B             ; Quote to D
2816+ 2540 E5           DTSTR:  push    HL              ; Save start
2817+ 2541 0E FF                ld      C,-1            ; Set counter to -1
2818+ 2543 23           QTSTLP: inc     HL              ; Move on
2819+ 2544 7E                   ld      A,(HL)          ; Get byte
2820+ 2545 0C                   inc     C               ; Count bytes
2821+ 2546 B7                   or      A               ; End of line?
2822+ 2547 CA 52 25             jp      Z,CRTSTE        ; Yes - Create string entry
2823+ 254A BA                   cp      D               ; Terminator D found?
2824+ 254B CA 52 25             jp      Z,CRTSTE        ; Yes - Create string entry
2825+ 254E B8                   cp      B               ; Terminator B found?
2826+ 254F C2 43 25             jp      NZ,QTSTLP       ; No - Keep looking
2827+ 2552 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2828+ 2554 CC ED 1B             call    Z,GETCHR        ; Yes - Get next character
2829+ 2557 E3                   ex      (SP),HL         ; Starting quote
2830+ 2558 23                   inc     HL              ; First byte of string
2831+ 2559 EB                   ex      DE,HL           ; To DE
2832+ 255A 79                   ld      A,C             ; Get length
2833+ 255B CD 30 25             call    CRTMST          ; Create string entry
2834+ 255E 11 C4 52     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2835+ 2561 2A B6 52             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2836+ 2564 22 50 53             ld      (FPREG),HL      ; Save address of string ptr
2837+ 2567 3E 01                ld      A,$01
2838+ 2569 32 B2 52             ld      (TYPE),A        ; Set type to string
2839+ 256C CD DE 2E             call    DETHL4          ; Move string to pool
2840+ 256F CD A6 19             call    CPDEHL          ; Out of string pool?
2841+ 2572 22 B6 52             ld      (TMSTPT),HL     ; Save new pointer
2842+ 2575 E1                   pop     HL              ; Restore code string address
2843+ 2576 7E                   ld      A,(HL)          ; Get next code byte
2844+ 2577 C0                   ret     NZ              ; Return if pool OK
2845+ 2578 1E 1E                ld      E,ST            ; ?ST Error
2846+ 257A C3 DE 16             jp      ERROR           ; String pool overflow
2847+ 257D
2848+ 257D 23           PRNUMS: inc     HL              ; Skip leading space
2849+ 257E CD 3C 25     PRS:    call    CRTST           ; Create string entry for it
2850+ 2581 CD C1 26     PRS1:   call    GSTRCU          ; Current string to pool
2851+ 2584 CD D2 2E             call    LOADFP          ; Move string block to BCDE
2852+ 2587 1C                   inc     E               ; Length + 1
2853+ 2588 1D           PRSLP:  dec     E               ; Count characters
2854+ 2589 C8                   ret     Z               ; End of string
2855+ 258A 0A                   ld      A,(BC)          ; Get byte to output
2856+ 258B CD B7 19             call    OUTC            ; Output character in A
2857+ 258E FE 0D                cp      CR              ; Return?
2858+ 2590 CC C4 1E             call    Z,CNTEND        ; Yes - Position cursor to 0
2859+ 2593 03                   inc     BC              ; Next byte in string
2860+ 2594 C3 88 25             jp      PRSLP           ; More characters to output
2861+ 2597
2862+ 2597 B7           TESTR:  or      A               ; Test if enough room
2863+ 2598 0E                   defb    $0E             ; No garbage collection done
2864+ 2599 F1           GRBDON: pop     AF              ; Garbage collection done
2865+ 259A F5                   push    AF              ; Save status
2866+ 259B 2A CB 51             ld      HL,(STRSPC)     ; Bottom of string space in use
2867+ 259E EB                   ex      DE,HL           ; To DE
2868+ 259F 2A C8 52             ld      HL,(STRBOT)     ; Bottom of string area
2869+ 25A2 2F                   cpl                     ; Negate length (Top down)
2870+ 25A3 4F                   ld      C,A             ; -Length to BC
2871+ 25A4 06 FF                ld      B,-1            ; BC = -ve length of string
2872+ 25A6 09                   add     HL,BC           ; Add to bottom of space in use
2873+ 25A7 23                   inc     HL              ; Plus one for 2's complement
2874+ 25A8 CD A6 19             call    CPDEHL          ; Below string RAM area?
2875+ 25AB DA B5 25             jp      C,TESTOS        ; Tidy up if not done else err
2876+ 25AE 22 C8 52             ld      (STRBOT),HL     ; Save new bottom of area
2877+ 25B1 23                   inc     HL              ; Point to first byte of string
2878+ 25B2 EB                   ex      DE,HL           ; Address to DE
2879+ 25B3 F1           POPAF:  pop     AF              ; Throw away status push
2880+ 25B4 C9                   ret
2881+ 25B5
2882+ 25B5 F1           TESTOS: pop     AF              ; Garbage collect been done?
2883+ 25B6 1E 1A                ld      E,OS            ; ?OS Error
2884+ 25B8 CA DE 16             jp      Z,ERROR         ; Yes - Not enough string space
2885+ 25BB BF                   cp      A               ; Flag garbage collect done
2886+ 25BC F5                   push    AF              ; Save status
2887+ 25BD 01 99 25             ld      BC,GRBDON       ; Garbage collection done
2888+ 25C0 C5                   push    BC              ; Save for RETurn
2889+ 25C1 2A B4 52     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2890+ 25C4 22 C8 52     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2891+ 25C7 21 00 00             ld      HL,$0000
2892+ 25CA E5                   push    HL              ; Flag no string found
2893+ 25CB 2A CB 51             ld      HL,(STRSPC)     ; Get bottom of string space
2894+ 25CE E5                   push    HL              ; Save bottom of string space
2895+ 25CF 21 B8 52             ld      HL,TMSTPL       ; Temporary string pool
2896+ 25D2 EB           GRBLP:  ex      DE,HL
2897+ 25D3 2A B6 52             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2898+ 25D6 EB                   ex      DE,HL
2899+ 25D7 CD A6 19             call    CPDEHL          ; Temporary string pool done?
2900+ 25DA 01 D2 25             ld      BC,GRBLP        ; Loop until string pool done
2901+ 25DD C2 26 26             jp      NZ,STPOOL       ; No - See if in string area
2902+ 25E0 2A 42 53             ld      HL,(PROGND)     ; Start of simple variables
2903+ 25E3 EB           SMPVAR: ex      DE,HL
2904+ 25E4 2A 44 53             ld      HL,(VAREND)     ; End of simple variables
2905+ 25E7 EB                   ex      DE,HL
2906+ 25E8 CD A6 19             call    CPDEHL          ; All simple strings done?
2907+ 25EB CA F9 25             jp      Z,ARRLP         ; Yes - Do string arrays
2908+ 25EE 7E                   ld      A,(HL)          ; Get type of variable
2909+ 25EF 23                   inc     HL
2910+ 25F0 23                   inc     HL
2911+ 25F1 B7                   or      A               ; "S" flag set if string
2912+ 25F2 CD 29 26             call    STRADD          ; See if string in string area
2913+ 25F5 C3 E3 25             jp      SMPVAR          ; Loop until simple ones done
2914+ 25F8
2915+ 25F8 C1           GNXARY: pop     BC              ; Scrap address of this array
2916+ 25F9 EB           ARRLP:  ex      DE,HL
2917+ 25FA 2A 46 53             ld      HL,(ARREND)     ; End of string arrays
2918+ 25FD EB                   ex      DE,HL
2919+ 25FE CD A6 19             call    CPDEHL          ; All string arrays done?
2920+ 2601 CA 4F 26             jp      Z,SCNEND        ; Yes - Move string if found
2921+ 2604 CD D2 2E             call    LOADFP          ; Get array name to BCDE
2922+ 2607 7B                   ld      A,E             ; Get type of array
2923+ 2608 E5                   push    HL              ; Save address of num of dim'ns
2924+ 2609 09                   add     HL,BC           ; Start of next array
2925+ 260A B7                   or      A               ; Test type of array
2926+ 260B F2 F8 25             jp      P,GNXARY        ; Numeric array - Ignore it
2927+ 260E 22 CA 52             ld      (CUROPR),HL     ; Save address of next array
2928+ 2611 E1                   pop     HL              ; Get address of num of dim'ns
2929+ 2612 4E                   ld      C,(HL)          ; BC = Number of dimensions
2930+ 2613 06 00                ld      B,$00
2931+ 2615 09                   add     HL,BC           ; Two bytes per dimension size
2932+ 2616 09                   add     HL,BC
2933+ 2617 23                   inc     HL              ; Plus one for number of dim'ns
2934+ 2618 EB           GRBARY: ex      DE,HL
2935+ 2619 2A CA 52             ld      HL,(CUROPR)     ; Get address of next array
2936+ 261C EB                   ex      DE,HL
2937+ 261D CD A6 19             call    CPDEHL          ; Is this array finished?
2938+ 2620 CA F9 25             jp      Z,ARRLP         ; Yes - Get next one
2939+ 2623 01 18 26             ld      BC,GRBARY       ; Loop until array all done
2940+ 2626 C5           STPOOL: push    BC              ; Save return address
2941+ 2627 F6 80                or      $80             ; Flag string type
2942+ 2629 7E           STRADD: ld      A,(HL)          ; Get string length
2943+ 262A 23                   inc     HL
2944+ 262B 23                   inc     HL
2945+ 262C 5E                   ld      E,(HL)          ; Get LSB of string address
2946+ 262D 23                   inc     HL
2947+ 262E 56                   ld      D,(HL)          ; Get MSB of string address
2948+ 262F 23                   inc     HL
2949+ 2630 F0                   ret     P               ; Not a string - Return
2950+ 2631 B7                   or      A               ; Set flags on string length
2951+ 2632 C8                   ret     Z               ; Null string - Return
2952+ 2633 44                   ld      B,H             ; Save variable pointer
2953+ 2634 4D                   ld      C,L
2954+ 2635 2A C8 52             ld      HL,(STRBOT)     ; Bottom of new area
2955+ 2638 CD A6 19             call    CPDEHL          ; String been done?
2956+ 263B 60                   ld      H,B             ; Restore variable pointer
2957+ 263C 69                   ld      L,C
2958+ 263D D8                   ret     C               ; String done - Ignore
2959+ 263E E1                   pop     HL              ; Return address
2960+ 263F E3                   ex      (SP),HL         ; Lowest available string area
2961+ 2640 CD A6 19             call    CPDEHL          ; String within string area?
2962+ 2643 E3                   ex      (SP),HL         ; Lowest available string area
2963+ 2644 E5                   push    HL              ; Re-save return address
2964+ 2645 60                   ld      H,B             ; Restore variable pointer
2965+ 2646 69                   ld      L,C
2966+ 2647 D0                   ret     NC              ; Outside string area - Ignore
2967+ 2648 C1                   pop     BC              ; Get return , Throw 2 away
2968+ 2649 F1                   pop     AF              ;
2969+ 264A F1                   pop     AF              ;
2970+ 264B E5                   push    HL              ; Save variable pointer
2971+ 264C D5                   push    DE              ; Save address of current
2972+ 264D C5                   push    BC              ; Put back return address
2973+ 264E C9                   ret                     ; Go to it
2974+ 264F
2975+ 264F D1           SCNEND: pop     DE              ; Addresses of strings
2976+ 2650 E1                   pop     HL              ;
2977+ 2651 7D                   ld      A,L             ; HL = 0 if no more to do
2978+ 2652 B4                   or      H
2979+ 2653 C8                   ret     Z               ; No more to do - Return
2980+ 2654 2B                   dec     HL
2981+ 2655 46                   ld      B,(HL)          ; MSB of address of string
2982+ 2656 2B                   dec     HL
2983+ 2657 4E                   ld      C,(HL)          ; LSB of address of string
2984+ 2658 E5                   push    HL              ; Save variable address
2985+ 2659 2B                   dec     HL
2986+ 265A 2B                   dec     HL
2987+ 265B 6E                   ld      L,(HL)          ; HL = Length of string
2988+ 265C 26 00                ld      H,$00
2989+ 265E 09                   add     HL,BC           ; Address of end of string+1
2990+ 265F 50                   ld      D,B             ; String address to DE
2991+ 2660 59                   ld      E,C
2992+ 2661 2B                   dec     HL              ; Last byte in string
2993+ 2662 44                   ld      B,H             ; Address to BC
2994+ 2663 4D                   ld      C,L
2995+ 2664 2A C8 52             ld      HL,(STRBOT)     ; Current bottom of string area
2996+ 2667 CD 79 16             call    MOVSTR          ; Move string to new address
2997+ 266A E1                   pop     HL              ; Restore variable address
2998+ 266B 71                   ld      (HL),C          ; Save new LSB of address
2999+ 266C 23                   inc     HL
3000+ 266D 70                   ld      (HL),B          ; Save new MSB of address
3001+ 266E 69                   ld      L,C             ; Next string area+1 to HL
3002+ 266F 60                   ld      H,B
3003+ 2670 2B                   dec     HL              ; Next string area address
3004+ 2671 C3 C4 25             jp      GARBLP          ; Look for more strings
3005+ 2674
3006+ 2674 C5           CONCAT: push    BC              ; Save prec' opr & code string
3007+ 2675 E5                   push    HL              ;
3008+ 2676 2A 50 53             ld      HL,(FPREG)      ; Get first string
3009+ 2679 E3                   ex      (SP),HL         ; Save first string
3010+ 267A CD FF 20             call    OPRND           ; Get second string
3011+ 267D E3                   ex      (SP),HL         ; Restore first string
3012+ 267E CD 7A 20             call    TSTSTR          ; Make sure it's a string
3013+ 2681 7E                   ld      A,(HL)          ; Get length of second string
3014+ 2682 E5                   push    HL              ; Save first string
3015+ 2683 2A 50 53             ld      HL,(FPREG)      ; Get second string
3016+ 2686 E5                   push    HL              ; Save second string
3017+ 2687 86                   add     A,(HL)          ; Add length of second string
3018+ 2688 1E 1C                ld      E,LS            ; ?LS Error
3019+ 268A DA DE 16             jp      C,ERROR         ; String too long - Error
3020+ 268D CD 2D 25             call    MKTMST          ; Make temporary string
3021+ 2690 D1                   pop     DE              ; Get second string to DE
3022+ 2691 CD C5 26             call    GSTRDE          ; Move to string pool if needed
3023+ 2694 E3                   ex      (SP),HL         ; Get first string
3024+ 2695 CD C4 26             call    GSTRHL          ; Move to string pool if needed
3025+ 2698 E5                   push    HL              ; Save first string
3026+ 2699 2A C6 52             ld      HL,(TMPSTR+2)   ; Temporary string address
3027+ 269C EB                   ex      DE,HL           ; To DE
3028+ 269D CD AB 26             call    SSTSA           ; First string to string area
3029+ 26A0 CD AB 26             call    SSTSA           ; Second string to string area
3030+ 26A3 21 94 20             ld      HL,EVAL2        ; Return to evaluation loop
3031+ 26A6 E3                   ex      (SP),HL         ; Save return,get code string
3032+ 26A7 E5                   push    HL              ; Save code string address
3033+ 26A8 C3 5E 25             jp      TSTOPL          ; To temporary string to pool
3034+ 26AB
3035+ 26AB E1           SSTSA:  pop     HL              ; Return address
3036+ 26AC E3                   ex      (SP),HL         ; Get string block,save return
3037+ 26AD 7E                   ld      A,(HL)          ; Get length of string
3038+ 26AE 23                   inc     HL
3039+ 26AF 23                   inc     HL
3040+ 26B0 4E                   ld      C,(HL)          ; Get LSB of string address
3041+ 26B1 23                   inc     HL
3042+ 26B2 46                   ld      B,(HL)          ; Get MSB of string address
3043+ 26B3 6F                   ld      L,A             ; Length to L
3044+ 26B4 2C           TOSTRA: inc     L               ; inc - DECed after
3045+ 26B5 2D           TSALP:  dec     L               ; Count bytes moved
3046+ 26B6 C8                   ret     Z               ; End of string - Return
3047+ 26B7 0A                   ld      A,(BC)          ; Get source
3048+ 26B8 12                   ld      (DE),A          ; Save destination
3049+ 26B9 03                   inc     BC              ; Next source
3050+ 26BA 13                   inc     DE              ; Next destination
3051+ 26BB C3 B5 26             jp      TSALP           ; Loop until string moved
3052+ 26BE
3053+ 26BE CD 7A 20     GETSTR: call    TSTSTR          ; Make sure it's a string
3054+ 26C1 2A 50 53     GSTRCU: ld      HL,(FPREG)      ; Get current string
3055+ 26C4 EB           GSTRHL: ex      DE,HL           ; Save DE
3056+ 26C5 CD DF 26     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3057+ 26C8 EB                   ex      DE,HL           ; Restore DE
3058+ 26C9 C0                   ret     NZ              ; No - Return
3059+ 26CA D5                   push    DE              ; Save string
3060+ 26CB 50                   ld      D,B             ; String block address to DE
3061+ 26CC 59                   ld      E,C
3062+ 26CD 1B                   dec     DE              ; Point to length
3063+ 26CE 4E                   ld      C,(HL)          ; Get string length
3064+ 26CF 2A C8 52             ld      HL,(STRBOT)     ; Current bottom of string area
3065+ 26D2 CD A6 19             call    CPDEHL          ; Last one in string area?
3066+ 26D5 C2 DD 26             jp      NZ,POPHL        ; No - Return
3067+ 26D8 47                   ld      B,A             ; Clear B (A=0)
3068+ 26D9 09                   add     HL,BC           ; Remove string from str' area
3069+ 26DA 22 C8 52             ld      (STRBOT),HL     ; Save new bottom of str' area
3070+ 26DD E1           POPHL:  pop     HL              ; Restore string
3071+ 26DE C9                   ret
3072+ 26DF
3073+ 26DF 2A B6 52     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3074+ 26E2 2B                   dec     HL              ; Back
3075+ 26E3 46                   ld      B,(HL)          ; Get MSB of address
3076+ 26E4 2B                   dec     HL              ; Back
3077+ 26E5 4E                   ld      C,(HL)          ; Get LSB of address
3078+ 26E6 2B                   dec     HL              ; Back
3079+ 26E7 2B                   dec     HL              ; Back
3080+ 26E8 CD A6 19             call    CPDEHL          ; String last in string pool?
3081+ 26EB C0                   ret     NZ              ; Yes - Leave it
3082+ 26EC 22 B6 52             ld      (TMSTPT),HL     ; Save new string pool top
3083+ 26EF C9                   ret
3084+ 26F0
3085+ 26F0 01 6F 24     LEN:    ld      BC,PASSA        ; To return integer A
3086+ 26F3 C5                   push    BC              ; Save address
3087+ 26F4 CD BE 26     GETLEN: call    GETSTR          ; Get string and its length
3088+ 26F7 AF                   xor     A
3089+ 26F8 57                   ld      D,A             ; Clear D
3090+ 26F9 32 B2 52             ld      (TYPE),A        ; Set type to numeric
3091+ 26FC 7E                   ld      A,(HL)          ; Get length of string
3092+ 26FD B7                   or      A               ; Set status flags
3093+ 26FE C9                   ret
3094+ 26FF
3095+ 26FF 01 6F 24     ASC:    ld      BC,PASSA        ; To return integer A
3096+ 2702 C5                   push    BC              ; Save address
3097+ 2703 CD F4 26     GTFLNM: call    GETLEN          ; Get length of string
3098+ 2706 CA B8 1C             jp      Z,FCERR         ; Null string - Error
3099+ 2709 23                   inc     HL
3100+ 270A 23                   inc     HL
3101+ 270B 5E                   ld      E,(HL)          ; Get LSB of address
3102+ 270C 23                   inc     HL
3103+ 270D 56                   ld      D,(HL)          ; Get MSB of address
3104+ 270E 1A                   ld      A,(DE)          ; Get first byte of string
3105+ 270F C9                   ret
3106+ 2710
3107+ 2710 3E 01        CHR:    ld      A,$01           ; One character string
3108+ 2712 CD 2D 25             call    MKTMST          ; Make a temporary string
3109+ 2715 CD FF 28             call    MAKINT          ; Make it integer A
3110+ 2718 2A C6 52             ld      HL,(TMPSTR+2)   ; Get address of string
3111+ 271B 73                   ld      (HL),E          ; Save character
3112+ 271C C1           TOPOOL: pop     BC              ; Clean up stack
3113+ 271D C3 5E 25             jp      TSTOPL          ; Temporary string to pool
3114+ 2720
3115+ 2720 CD AF 28     LEFT:   call    LFRGNM          ; Get number and ending ")"
3116+ 2723 AF                   xor     A               ; Start at first byte in string
3117+ 2724 E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3118+ 2725 4F                   ld      C,A             ; Starting position in string
3119+ 2726 E5           MID1:   push    HL              ; Save string block address
3120+ 2727 7E                   ld      A,(HL)          ; Get length of string
3121+ 2728 B8                   cp      B               ; Compare with number given
3122+ 2729 DA 2E 27             jp      C,ALLFOL        ; All following bytes required
3123+ 272C 78                   ld      A,B             ; Get new length
3124+ 272D 11                   defb    $11             ; Skip "ld C,0"
3125+ 272E 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3126+ 2730 C5                   push    BC              ; Save position in string
3127+ 2731 CD 97 25             call    TESTR           ; See if enough string space
3128+ 2734 C1                   pop     BC              ; Get position in string
3129+ 2735 E1                   pop     HL              ; Restore string block address
3130+ 2736 E5                   push    HL              ; And re-save it
3131+ 2737 23                   inc     HL
3132+ 2738 23                   inc     HL
3133+ 2739 46                   ld      B,(HL)          ; Get LSB of address
3134+ 273A 23                   inc     HL
3135+ 273B 66                   ld      H,(HL)          ; Get MSB of address
3136+ 273C 68                   ld      L,B             ; HL = address of string
3137+ 273D 06 00                ld      B,$00           ; BC = starting address
3138+ 273F 09                   add     HL,BC           ; Point to that byte
3139+ 2740 44                   ld      B,H             ; BC = source string
3140+ 2741 4D                   ld      C,L
3141+ 2742 CD 30 25             call    CRTMST          ; Create a string entry
3142+ 2745 6F                   ld      L,A             ; Length of new string
3143+ 2746 CD B4 26             call    TOSTRA          ; Move string to string area
3144+ 2749 D1                   pop     DE              ; Clear stack
3145+ 274A CD C5 26             call    GSTRDE          ; Move to string pool if needed
3146+ 274D C3 5E 25             jp      TSTOPL          ; Temporary string to pool
3147+ 2750
3148+ 2750
3149+ 2750              ; INSTR statement - look for a string inside another string
3150+ 2750              ; usage: INSTR(A$,B$) -> search for B$ into A$
3151+ 2750              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3152+ 2750              ; return 1~255 to indicate the starting position of B$ into A$
3153+ 2750              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3154+ 2750              LNS1    equ     TMPBFR1
3155+ 2750              ADRS1   equ     TMPBFR2
3156+ 2750              LNS2    equ     TMPBFR3
3157+ 2750              ADRS2   equ     TMPBFR4
3158+ 2750              PT      equ     VIDEOBUFF
3159+ 2750              PT1     equ     VIDEOBUFF+2
3160+ 2750              PT2     equ     VIDEOBUFF+4
3161+ 2750              TP      equ     VIDEOBUFF+6
3162+ 2750              TF      equ     VIDEOBUFF+8
3163+ 2750 CD AC 19     INSTR:  call    CHKSYN          ; make sure "(" follows
3164+ 2753 28                   defb    '('
3165+ 2754 2B                   dec     HL              ; dec 'cause GETCHR increments
3166+ 2755 CD ED 1B             call    GETCHR          ; check if something follows
3167+ 2758 CA CA 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3168+ 275B CD 88 20             call    EVAL            ; Evaluate expression
3169+ 275E CD 7A 20             call    TSTSTR          ; Make sure it's a string
3170+ 2761 22 04 53             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3171+ 2764 CD C1 26             call    GSTRCU          ; check that a string follows
3172+ 2767 CD D2 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3173+ 276A ED 53 FC 52          ld      (LNS1),DE       ; store values into
3174+ 276E ED 43 FE 52          ld      (ADRS1),BC      ; temp buffers
3175+ 2772 2A 04 53             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3176+ 2775 CD AC 19             call    CHKSYN          ; Make sure ',' follows
3177+ 2778 2C                   defb    ','
3178+ 2779 2B                   dec     HL              ; dec 'cause GETCHR increments
3179+ 277A CD ED 1B             call    GETCHR          ; check if something follows
3180+ 277D CA CA 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3181+ 2780 CD 88 20             call    EVAL            ; Evaluate expression
3182+ 2783 CD 7A 20             call    TSTSTR          ; Make sure it's a string
3183+ 2786 22 04 53             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3184+ 2789 CD C1 26             call    GSTRCU          ; check that a string follows
3185+ 278C CD D2 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3186+ 278F ED 53 00 53          ld      (LNS2),DE       ; store values into
3187+ 2793 ED 43 02 53          ld      (ADRS2),BC      ; temp buffers
3188+ 2797 2A 04 53             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3189+ 279A CD AC 19             call    CHKSYN          ; make sure ")" follows
3190+ 279D 29                   defb    ')'
3191+ 279E E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3192+ 279F FD E1                pop     IY              ; ...into IY
3193+ 27A1 AF                   xor     A               ; reset 10 RAM cells
3194+ 27A2 06 0A                ld      B,$0A           ; (INSTR registers)
3195+ 27A4 21 04 53             ld      HL,PT           ; first cell
3196+ 27A7 77           EMPTINS:ld      (HL),A          ; reset cell
3197+ 27A8 23                   inc     HL              ; next cell
3198+ 27A9 10 FC                djnz    EMPTINS         ; repeat
3199+ 27AB ED 5B 00 53          ld      DE,(LNS2)       ; load len(S2) into DE
3200+ 27AF 2A FC 52             ld      HL,(LNS1)       ; load len(S1) into HL
3201+ 27B2 CD B7 3F             call    CMP16           ; check that len(S1)>=len(S2)
3202+ 27B5 DA 2A 28             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3203+ 27B8 AF           RPTINST:xor     A               ; reset...
3204+ 27B9 32 0A 53             ld      (TP),A          ; ...TP...
3205+ 27BC 32 0C 53             ld      (TF),A          ; ...and TF
3206+ 27BF ED 4B 04 53          ld      BC,(PT)         ; pointer to S1
3207+ 27C3 2A FE 52             ld      HL,(ADRS1)      ; first cell of S1
3208+ 27C6 09                   add     HL,BC           ; get current position into RAM
3209+ 27C7 7E                   ld      A,(HL)          ; load S1(PT)
3210+ 27C8 2A 02 53             ld      HL,(ADRS2)      ; pointer to first char of S2
3211+ 27CB BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3212+ 27CC 20 3A                jr      NZ,CNT1INS      ; no, continue
3213+ 27CE 3A 04 53             ld      A,(PT)          ; load current PT
3214+ 27D1 32 0A 53             ld      (TP),A          ; TP=PT
3215+ 27D4 32 06 53             ld      (PT1),A         ; P1=PT
3216+ 27D7 AF                   xor     A               ; set...
3217+ 27D8 32 08 53             ld      (PT2),A         ; ...PT2=0
3218+ 27DB 3C                   inc     A               ;
3219+ 27DC 32 0C 53             ld      (TF),A          ; set TF=1
3220+ 27DF ED 4B 06 53  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3221+ 27E3 2A FE 52             ld      HL,(ADRS1)      ; load address of S1
3222+ 27E6 09                   add     HL,BC           ; find char of S1 pointed by PT1
3223+ 27E7 7E                   ld      A,(HL)          ; load S1(PT1)
3224+ 27E8 ED 4B 08 53          ld      BC,(PT2)        ; load pointer PT2
3225+ 27EC 2A 02 53             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3226+ 27EF 09                   add     HL,BC           ; find S2(PT2)
3227+ 27F0 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3228+ 27F1 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3229+ 27F3 21 06 53             ld      HL,PT1
3230+ 27F6 34                   inc     (HL)            ; increment PT1
3231+ 27F7 3A 08 53             ld      A,(PT2)
3232+ 27FA 3C                   inc     A               ; increment PT2
3233+ 27FB 32 08 53             ld      (PT2),A
3234+ 27FE CA 08 28             jp      Z,CNT1INS       ; if PT2>255 then exit
3235+ 2801 21 00 53             ld      HL,LNS2         ; len(S2)
3236+ 2804 BE                   cp      (HL)            ; PT2=len(S2)?
3237+ 2805 DA DF 27             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3238+ 2808 3A 0C 53     CNT1INS:ld      A,(TF)          ; check TF
3239+ 280B A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3240+ 280C 20 1C                jr      NZ,RZINSTR      ; no, exit
3241+ 280E 2A FC 52             ld      HL,(LNS1)       ; load len(S1)
3242+ 2811 ED 4B 00 53          ld      BC,(LNS2)       ; load len(S2)
3243+ 2815 ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3244+ 2817 ED 5B 04 53          ld      DE,(PT)         ; load pointer
3245+ 281B 1C                   inc     E               ; PT=PT+1
3246+ 281C ED 53 04 53          ld      (PT),DE         ; store new value
3247+ 2820 EB                   ex      DE,HL           ; invert registers
3248+ 2821 CD B7 3F             call    CMP16           ; check if PT>len(S1)-len(S2)
3249+ 2824 DA B8 27             jp      C,RPTINST       ; repeat if <
3250+ 2827 CA B8 27             jp      Z,RPTINST       ; repeat if =
3251+ 282A 3A 0C 53     RZINSTR:ld      A,(TF)          ; current value of TF
3252+ 282D A7                   and     A               ; is it 0?
3253+ 282E CA 35 28             jp      Z,LVINSTR       ; yes, return 0
3254+ 2831 3A 0A 53             ld      A,(TP)          ; return TP...
3255+ 2834 3C                   inc     A               ; ...incremented by 1
3256+ 2835 E1           LVINSTR:pop     HL              ; drop original return point
3257+ 2836 FD E5                push    IY              ; load current string address from IY into stack
3258+ 2838 11 61 21             ld      DE,RETNUM       ; Address of Return number from function...
3259+ 283B D5                   push    DE              ; ...saved on stack
3260+ 283C C3 6F 24             jp      PASSA           ; return TP
3261+ 283F AF           CNTZIN: xor     A               ; set...
3262+ 2840 32 0C 53             ld      (TF),A          ; TF=0
3263+ 2843 C3 08 28             jp      CNT1INS         ; continue
3264+ 2846
3265+ 2846
3266+ 2846              ; returns the right portion of a string
3267+ 2846 CD AF 28     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3268+ 2849 D1                   pop     DE              ; Get string length
3269+ 284A D5                   push    DE              ; And re-save
3270+ 284B 1A                   ld      A,(DE)          ; Get length
3271+ 284C 90                   sub     B               ; Move back N bytes
3272+ 284D C3 24 27             jp      RIGHT1          ; Go and get sub-string
3273+ 2850
3274+ 2850              ; returns a piece of a string
3275+ 2850 EB           MID:    ex      DE,HL           ; Get code string address
3276+ 2851 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3277+ 2852 CD B4 28             call    MIDNUM          ; Get number supplied
3278+ 2855 04                   inc     B               ; Is it character zero?
3279+ 2856 05                   dec     B
3280+ 2857 CA B8 1C             jp      Z,FCERR         ; Yes - Error
3281+ 285A C5                   push    BC              ; Save starting position
3282+ 285B 1E FF                ld      E,$FF           ; All of string
3283+ 285D FE 29                cp      ')'             ; Any length given?
3284+ 285F CA 69 28             jp      Z,RSTSTR        ; No - Rest of string
3285+ 2862 CD AC 19             call    CHKSYN          ; Make sure ',' follows
3286+ 2865 2C                   defb    ','
3287+ 2866 CD FC 28             call    GETINT          ; Get integer 0-255
3288+ 2869 CD AC 19     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3289+ 286C 29                   defb    ')'
3290+ 286D F1                   pop     AF              ; Restore starting position
3291+ 286E E3                   ex      (SP),HL         ; Get string,save code string
3292+ 286F 01 26 27             ld      BC,MID1         ; Continuation of MID$ routine
3293+ 2872 C5                   push    BC              ; Save for return
3294+ 2873 3D                   dec     A               ; Starting position-1
3295+ 2874 BE                   cp      (HL)            ; Compare with length
3296+ 2875 06 00                ld      B,$00           ; Zero bytes length
3297+ 2877 D0                   ret     NC              ; Null string if start past end
3298+ 2878 4F                   ld      C,A             ; Save starting position-1
3299+ 2879 7E                   ld      A,(HL)          ; Get length of string
3300+ 287A 91                   sub     C               ; Subtract start
3301+ 287B BB                   cp      E               ; Enough string for it?
3302+ 287C 47                   ld      B,A             ; Save maximum length available
3303+ 287D D8                   ret     C               ; Truncate string if needed
3304+ 287E 43                   ld      B,E             ; Set specified length
3305+ 287F C9                   ret                     ; Go and create string
3306+ 2880
3307+ 2880
3308+ 2880              ; return the value of a numeric string
3309+ 2880 CD F4 26     VAL:    call    GETLEN          ; Get length of string
3310+ 2883 CA 52 2C             jp      Z,RESZER        ; Result zero
3311+ 2886 5F                   ld      E,A             ; Save length
3312+ 2887 23                   inc     HL
3313+ 2888 23                   inc     HL
3314+ 2889 7E                   ld      A,(HL)          ; Get LSB of address
3315+ 288A 23                   inc     HL
3316+ 288B 66                   ld      H,(HL)          ; Get MSB of address
3317+ 288C 6F                   ld      L,A             ; HL = String address
3318+ 288D E5                   push    HL              ; Save string address
3319+ 288E 19                   add     HL,DE
3320+ 288F 46                   ld      B,(HL)          ; Get end of string+1 byte
3321+ 2890 72                   ld      (HL),D          ; Zero it to terminate
3322+ 2891 E3                   ex      (SP),HL         ; Save string end,get start
3323+ 2892 C5                   push    BC              ; Save end+1 byte
3324+ 2893 7E                   ld      A,(HL)          ; Get starting byte
3325+ 2894 FE 24                cp      '$'             ; Hex number indicated? [function added]
3326+ 2896 C2 9E 28             jp      NZ,VAL1
3327+ 2899 CD F0 3E             call    HEXTFP          ; Convert Hex to FPREG
3328+ 289C 18 0D                jr      VAL3
3329+ 289E FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3330+ 28A0 C2 A8 28             jp      NZ,VAL2
3331+ 28A3 CD 60 3F             call    BINTFP          ; Convert Bin to FPREG
3332+ 28A6 18 03                jr      VAL3
3333+ 28A8 CD 8A 2F     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3334+ 28AB C1           VAL3:   pop     BC              ; Restore end+1 byte
3335+ 28AC E1                   pop     HL              ; Restore end+1 address
3336+ 28AD 70                   ld      (HL),B          ; Put back original byte
3337+ 28AE C9                   ret
3338+ 28AF
3339+ 28AF EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3340+ 28B0 CD AC 19             call    CHKSYN          ; Make sure ")" follows
3341+ 28B3 29                   defb    ')'
3342+ 28B4 C1           MIDNUM: pop     BC              ; Get return address
3343+ 28B5 D1                   pop     DE              ; Get number supplied
3344+ 28B6 C5                   push    BC              ; Re-save return address
3345+ 28B7 43                   ld      B,E             ; Number to B
3346+ 28B8 C9                   ret
3347+ 28B9
3348+ 28B9 CD FF 28     INP:    call    MAKINT          ; Make it integer A
3349+ 28BC 32 BE 51             ld      (INPORT),A      ; Set input port
3350+ 28BF CD BD 51             call    INPSUB          ; Get input from port
3351+ 28C2 C3 6F 24             jp      PASSA           ; Return integer A
3352+ 28C5
3353+ 28C5 CD E9 28     POUT:   call    SETIO           ; Set up port number
3354+ 28C8 C3 85 51             jp      OUTSUB          ; Output data and return
3355+ 28CB
3356+ 28CB CD E9 28     WAIT:   call    SETIO           ; Set up port number
3357+ 28CE F5                   push    AF              ; Save AND mask
3358+ 28CF 1E 00                ld      E,$00           ; Assume zero if none given
3359+ 28D1 2B                   dec     HL              ; dec 'cos GETCHR INCs
3360+ 28D2 CD ED 1B             call    GETCHR          ; Get next character
3361+ 28D5 CA DF 28             jp      Z,NOXOR         ; No XOR byte given
3362+ 28D8 CD AC 19             call    CHKSYN          ; Make sure ',' follows
3363+ 28DB 2C                   defb    ','
3364+ 28DC CD FC 28             call    GETINT          ; Get integer 0-255 to XOR with
3365+ 28DF C1           NOXOR:  pop     BC              ; Restore AND mask
3366+ 28E0 CD BD 51     WAITLP: call    INPSUB          ; Get input
3367+ 28E3 AB                   xor     E               ; Flip selected bits
3368+ 28E4 A0                   and     B               ; Result non-zero?
3369+ 28E5 CA E0 28             jp      Z,WAITLP        ; No = keep waiting
3370+ 28E8 C9                   ret
3371+ 28E9
3372+ 28E9 CD FC 28     SETIO:  call    GETINT          ; Get integer 0-255
3373+ 28EC 32 BE 51             ld      (INPORT),A      ; Set input port
3374+ 28EF 32 86 51             ld      (OTPORT),A      ; Set output port
3375+ 28F2 CD AC 19             call    CHKSYN          ; Make sure ',' follows
3376+ 28F5 2C                   defb    ','
3377+ 28F6 C3 FC 28             jp      GETINT          ; Get integer 0-255 and return
3378+ 28F9
3379+ 28F9 CD ED 1B     FNDNUM: call    GETCHR          ; Get next character
3380+ 28FC CD 76 20     GETINT: call    GETNUM          ; Get a number from 0 to 255
3381+ 28FF CD 9D 1C     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3382+ 2902 7A                   ld      A,D             ; Get MSB of number
3383+ 2903 B7                   or      A               ; Zero?
3384+ 2904 C2 B8 1C             jp      NZ,FCERR        ; No - Error
3385+ 2907 2B                   dec     HL              ; dec 'cos GETCHR INCs
3386+ 2908 CD ED 1B             call    GETCHR          ; Get next character
3387+ 290B 7B                   ld      A,E             ; Get number to A
3388+ 290C C9                   ret
3389+ 290D
3390+ 290D
3391+ 290D              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3392+ 290D              ; address must point to an ISR routine that terminates with EI/RETN instructions
3393+ 290D CD 76 20     NMI:    call    GETNUM          ; Get memory address
3394+ 2910 CD A3 1C             call    DEINT           ; get integer -32768 to 32767
3395+ 2913 7B                   ld      A,E             ; check if address is 0
3396+ 2914 B2                   or      D
3397+ 2915 20 11                jr      NZ,NM1          ; no, so jump over
3398+ 2917 F3           DISNMI: di                      ; disable INTs
3399+ 2918 CD 44 29             call    NMIDINT         ; disable VDP INT
3400+ 291B E5                   push    HL              ; store HL
3401+ 291C 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3402+ 291F 22 7F 51             ld      (NMIUSR),HL     ; store RETN
3403+ 2922 AF                   xor     A
3404+ 2923 32 81 51             ld      (NMIUSR+2),A    ; "NOP"
3405+ 2926 18 11                jr      NMI2            ; execute the last part of code
3406+ 2928 E5           NM1:    push    HL              ; store current HL
3407+ 2929 EB                   ex      DE,HL           ; move address argument into HL
3408+ 292A F3                   di                      ; disable INTs
3409+ 292B CD 44 29             call    NMIDINT         ; disable VDP INT, if enabled
3410+ 292E 3E C3                ld      A,$C3           ; "jp" instruction
3411+ 2930 32 7F 51             ld      (NMIUSR),A      ; store it
3412+ 2933 22 80 51             ld      (NMIUSR+1),HL   ; store address
3413+ 2936 CD 3D 29             call    NMIEINT         ; re-enable VDP INT
3414+ 2939 FB           NMI2:   ei                      ; re-enable INTS
3415+ 293A 00                   nop                     ; wait for INTs
3416+ 293B E1                   pop    HL               ; retrieve HL
3417+ 293C C9                   ret                     ; return to caller
3418+ 293D              ; enable VDP INT
3419+ 293D CD 53 29     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3420+ 2940 F6 20                or      %00100000       ; enable VDP INT
3421+ 2942 18 03                jr      NMIINT          ; rest of code is shared
3422+ 2944              ; disable VDP INT
3423+ 2944 CD 53 29     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3424+ 2947 D5           NMIINT: push    DE              ; store DE
3425+ 2948 5F                   ld      E,A             ; move value into E
3426+ 2949 3E 01                ld      A,$01           ; VREG #1
3427+ 294B F3                   di                      ; disable INTs
3428+ 294C CD A7 06             call    WRITE_VREG      ; disable VDP INT
3429+ 294F FB                   ei                      ; re-enable INTs
3430+ 2950 00                   nop                     ; wait for INTs being enabled
3431+ 2951 D1                   pop     DE              ; retrieve DE
3432+ 2952 C9                   ret                     ; return to caller
3433+ 2953
3434+ 2953              ; load VREG #1 setting for current screen mode and return it into A
3435+ 2953 E5           NMIVR1: push    HL              ; store HL
3436+ 2954 D5                   push    DE              ; store DE
3437+ 2955 3A ED 52             ld      A,(SCR_MODE)    ; check screen mode
3438+ 2958 87                   add     A,A             ; multiply A by 8...
3439+ 2959 87                   add     A,A             ; ...so that reg. A can points..
3440+ 295A 87                   add     A,A             ; to the correct settings
3441+ 295B 3C                   inc     A               ; need to change VREG 1
3442+ 295C 5F                   ld      E,A             ; copy A into E
3443+ 295D 16 00                ld      D,$00           ; reset D
3444+ 295F 21 14 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3445+ 2962 19                   add     HL,DE           ; ...for current screen mode
3446+ 2963 7E                   ld      A,(HL)          ; load current setting
3447+ 2964 D1                   pop     DE              ; retrieve DE
3448+ 2965 E1                   pop     HL              ; retrieve HL
3449+ 2966 C9                   ret                     ; return to caller
3450+ 2967
3451+ 2967              ; execute a machine language routine, eventually passing a param into A
3452+ 2967 CD 76 20     SYS:    call    GETNUM          ; Get memory address
3453+ 296A CD A3 1C             call    DEINT           ; Get integer -32768 to 32767
3454+ 296D ED 53 FE 52          ld      (TMPBFR2),DE    ; store user routine's address
3455+ 2971 AF                   xor     A               ; reset A
3456+ 2972 32 FC 52             ld      (TMPBFR1),A     ; store into temp buffer
3457+ 2975 2B                   dec     HL              ; dec 'cos GETCHR INCs
3458+ 2976 CD ED 1B             call    GETCHR          ; check next character
3459+ 2979 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3460+ 297B CD AC 19             call    CHKSYN          ; Make sure ',' follows
3461+ 297E 2C                   defb    ','
3462+ 297F CD FC 28             call    GETINT          ; get byte value (0~255) if something follows
3463+ 2982 32 FC 52             ld      (TMPBFR1),A     ; store into temp buffer
3464+ 2985 3A FC 52     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3465+ 2988 ED 5B FE 52          ld      DE,(TMPBFR2)    ; recover user routine's address
3466+ 298C E5                   push    HL              ; save code string address
3467+ 298D EB                   ex      DE,HL           ; move user routine's address into HL
3468+ 298E 11 93 29             ld      DE,SYSRET       ; set point of return after the user routine
3469+ 2991 D5                   push    DE              ; store into stack
3470+ 2992 E9                   jp      (HL)            ; call user routine
3471+ 2993 E1           SYSRET: pop     HL              ; retrieve code string address
3472+ 2994 C9                   ret                     ; return to caller
3473+ 2995
3474+ 2995
3475+ 2995              ; read the contents of a RAM location
3476+ 2995 CD A3 1C     PEEK:   call    DEINT           ; Get memory address into DE
3477+ 2998 1A                   ld      A,(DE)          ; Read value of memory cell
3478+ 2999 C3 6F 24             jp      PASSA           ; Return into A
3479+ 299C
3480+ 299C              ; read the contents of a VRAM location
3481+ 299C CD A3 1C     VPEEK:  call    DEINT           ; Get VRAM address into DE
3482+ 299F EB                   ex      DE,HL           ; Copy param into HL
3483+ 29A0 F3                   di                      ; Disable interrupts
3484+ 29A1 CD 7D 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3485+ 29A4 FB                   ei                      ; Re-enable interrupts
3486+ 29A5 EB                   ex      DE,HL           ; Restore HL
3487+ 29A6 C3 6F 24             jp      PASSA           ; Return value into A
3488+ 29A9
3489+ 29A9              ; recover params for POKE/VPOKE commands
3490+ 29A9              ; returns address into DE and byte to be written into A
3491+ 29A9 CD 76 20     PKEPRMS:call    GETNUM          ; Get memory address
3492+ 29AC CD A3 1C             call    DEINT           ; Get integer -32768 to 32767
3493+ 29AF ED 53 FC 52          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3494+ 29B3 CD AC 19             call    CHKSYN          ; Make sure ',' follows
3495+ 29B6 2C                   defb    ','
3496+ 29B7 CD FC 28             call    GETINT          ; Get integer 0-255
3497+ 29BA ED 5B FC 52          ld      DE,(TMPBFR1)    ; Restore memory address
3498+ 29BE C9                   ret                     ; Return to caller
3499+ 29BF
3500+ 29BF              ; write a byte into a RAM location
3501+ 29BF CD A9 29     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3502+ 29C2 12                   ld      (DE),A          ; Load it into memory
3503+ 29C3 C9                   ret
3504+ 29C4
3505+ 29C4              ; write a byte into a VRAM location
3506+ 29C4 CD A9 29     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3507+ 29C7 EB                   ex      DE,HL           ; Copy address into HL
3508+ 29C8 F3                   di                      ; Disable interrupts
3509+ 29C9 CD 92 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3510+ 29CC FB                   ei                      ; Re-enable interrupts
3511+ 29CD EB                   ex      DE,HL           ; Restore HL
3512+ 29CE C9                   ret                     ; Return to caller
3513+ 29CF
3514+ 29CF              ; position the cursor at a specific X,Y location onto screen
3515+ 29CF CD FC 28     LOCATE: call    GETINT          ; get the first param into A
3516+ 29D2 E5                   push    HL              ; store HL
3517+ 29D3 21 EB 52             ld      HL,SCR_SIZE_W   ; load address of screen width
3518+ 29D6 5E                   ld      E,(HL)          ; load screen width into E
3519+ 29D7 E1                   pop     HL              ; restore HL
3520+ 29D8 BB                   cp      E               ; compare witdh with param
3521+ 29D9 D2 B8 1C             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3522+ 29DC 32 FC 52             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3523+ 29DF CD AC 19             call    CHKSYN          ; Make sure ',' follows
3524+ 29E2 2C                   defb    ','
3525+ 29E3 CD FC 28             call    GETINT          ; Get the second param into A
3526+ 29E6 E5                   push    HL              ; store HL
3527+ 29E7 21 EC 52             ld      HL,SCR_SIZE_H   ; load address of screen width
3528+ 29EA 5E                   ld      E,(HL)          ; load screen width into A
3529+ 29EB E1                   pop     HL              ; restore HL
3530+ 29EC BB                   cp      E               ; compare witdh with param
3531+ 29ED D2 B8 1C             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3532+ 29F0 32 F4 52             ld      (SCR_CUR_NY),A  ; store new Y
3533+ 29F3 3A FC 52             ld      A,(TMPBFR1)     ; recover the new X
3534+ 29F6 32 F3 52             ld      (SCR_CUR_NX),A  ; store new X
3535+ 29F9 E5                   push    HL              ; store HL
3536+ 29FA F3                   di                      ; disable INTs
3537+ 29FB CD C3 06             call    MOVCRS          ; move cursor to new location
3538+ 29FE FB                   ei                      ; re-enable INTs
3539+ 29FF E1                   pop     HL              ; restore HL
3540+ 2A00 C9                   ret                     ; return to caller
3541+ 2A01
3542+ 2A01              ; write a byte into one of the PSG registers
3543+ 2A01 CD FC 28     SREG:   call    GETINT          ; Get register number back into A
3544+ 2A04 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3545+ 2A06 D2 B8 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3546+ 2A09 32 FC 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3547+ 2A0C CD AC 19             call    CHKSYN          ; Make sure ',' follows
3548+ 2A0F 2C                   defb    ','
3549+ 2A10 CD FC 28             call    GETINT          ; get second value (0-255), returned into A
3550+ 2A13 5F                   ld      E,A             ; store value into E
3551+ 2A14 3A FC 52             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3552+ 2A17 F3                   di                      ; disable INTs
3553+ 2A18 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3554+ 2A1A ED 79                out     (C),A           ; send register # to PSG
3555+ 2A1C 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3556+ 2A1E ED 59                out     (C),E           ; send byte to write into selected register
3557+ 2A20 FB                   ei                      ; re-enable INTs
3558+ 2A21 C9                   ret                     ; return to caller
3559+ 2A22
3560+ 2A22              ; VOLUME ch,vol
3561+ 2A22              ; set the volume for the audio channels
3562+ 2A22              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3563+ 2A22 CD FC 28     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3564+ 2A25 FE 04                cp      $04             ; check if it's in the range 0~3
3565+ 2A27 D2 B8 1C             jp      NC,FCERR        ; if not, exit with Illegal function call error
3566+ 2A2A 32 FC 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3567+ 2A2D CD AC 19             call    CHKSYN          ; Make sure ',' follows
3568+ 2A30 2C                   defb    ','
3569+ 2A31 CD FC 28             call    GETINT          ; get integer 0-255 (recover channel)
3570+ 2A34 FE 10                cp      $10             ; check if it's in the range 0~15
3571+ 2A36 D2 B8 1C             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3572+ 2A39 57                   ld      D,A             ; store volume into D
3573+ 2A3A 3A FC 52             ld      A,(TMPBFR1)     ; retrieve channel
3574+ 2A3D A7                   and     A               ; is it 0? (0=every channel)
3575+ 2A3E 20 10                jr      NZ,VOLCH        ; no, jump over
3576+ 2A40 06 03                ld      B,$03           ; yes, set every channel
3577+ 2A42 1E 08                ld      E,$08           ; register volume of first channel
3578+ 2A44 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3579+ 2A46 ED 59                out     (C),E           ; set register #
3580+ 2A48 0E 41                ld      C,PSG_DAT       ; PSG data port
3581+ 2A4A ED 51                out     (C),D           ; send volume
3582+ 2A4C 1C                   inc     E               ; next register
3583+ 2A4D 10 F5                djnz    RPVOLCG         ; repeat for each channel
3584+ 2A4F C9                   ret                     ; return to caller
3585+ 2A50 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3586+ 2A52 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3587+ 2A54 ED 79                out     (C),A           ; set register
3588+ 2A56 0E 41                ld      C,PSG_DAT       ; PSG data port
3589+ 2A58 ED 51                out     (C),D           ; send volume level
3590+ 2A5A C9                   ret                     ; return to caller
3591+ 2A5B
3592+ 2A5B              ; SOUND ch,tone,dur
3593+ 2A5B              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3594+ 2A5B              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3595+ 2A5B              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3596+ 2A5B CD FC 28     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3597+ 2A5E A7                   and     A               ; is it zero?
3598+ 2A5F 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3599+ 2A61 E5                   push    HL              ; store HL
3600+ 2A62 F3                   di                      ; disable INTs
3601+ 2A63 CD 86 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3602+ 2A66 FB                   ei                      ; re-enable INTs
3603+ 2A67 E1                   pop     HL              ; retrieve HL
3604+ 2A68 C9                   ret                     ; return to caller
3605+ 2A69 32 FC 52     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3606+ 2A6C FE 04                cp      $04             ; is channel >3?
3607+ 2A6E D2 ED 2A             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3608+ 2A71 CD AC 19             call    CHKSYN          ; No, continue checking by making sure ',' follows
3609+ 2A74 2C                   defb    ','
3610+ 2A75 CD 76 20             call    GETNUM          ; Get tone frequency
3611+ 2A78 CD A3 1C             call    DEINT           ; Get integer -32768 to 32767
3612+ 2A7B ED 53 FE 52          ld      (TMPBFR2),DE    ; Store frequency
3613+ 2A7F CD AC 19             call    CHKSYN          ; Make sure ',' follows
3614+ 2A82 2C                   defb    ','
3615+ 2A83 CD 76 20             call    GETNUM          ; Get duration
3616+ 2A86 CD A3 1C             call    DEINT           ; Get integer -32768 to 32767
3617+ 2A89 ED 53 00 53          ld      (TMPBFR3),DE    ; Store duration
3618+ 2A8D                                              ; CHECK CHANNEL
3619+ 2A8D 3A FC 52             ld      A,(TMPBFR1)     ; recover channel
3620+ 2A90 FE 01                cp      $01             ; is channel <1?
3621+ 2A92 DA B8 1C             jp      C,FCERR         ; Yes - Illegal function call error
3622+ 2A95                                              ; CHECK FREQUENCY
3623+ 2A95 ED 5B FE 52          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3624+ 2A99 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3625+ 2A9A FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3626+ 2A9C D2 B8 1C             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3627+ 2A9F                                              ; CHECK DURATION
3628+ 2A9F ED 5B 00 53          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3629+ 2AA3 7A                   ld      A,D             ; check if it is in the range 0~16383...
3630+ 2AA4 E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3631+ 2AA6 C2 B8 1C             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3632+ 2AA9                                              ;
3633+ 2AA9                                              ; SET TONE:
3634+ 2AA9                                              ; let's start by setting up the channel
3635+ 2AA9 3A FC 52             ld      A,(TMPBFR1)     ; restore channel value
3636+ 2AAC FE 03                cp      $03             ; is it 3?
3637+ 2AAE 20 02                jr      NZ,SND1         ; no, jump over
3638+ 2AB0 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3639+ 2AB2 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3640+ 2AB3 CD 3A 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3641+ 2AB6                                              ; SET FREQUENCY
3642+ 2AB6                                              ; we simply get frequency and subtract from 4096. The result
3643+ 2AB6                                              ; is put into register pair of the corresponding freq tone channel
3644+ 2AB6 ED 5B FE 52          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3645+ 2ABA E5                   push    HL              ; store HL (it will be used by the subroutine)
3646+ 2ABB 21 00 10             ld      HL,$1000        ; load 4096 into HL
3647+ 2ABE A7                   and     A               ; reset C flag
3648+ 2ABF ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3649+ 2AC1 3A FC 52             ld      A,(TMPBFR1)     ; restore channel value
3650+ 2AC4 3D                   dec     A               ; set A into the range 0~2
3651+ 2AC5 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3652+ 2AC6 0E 40                ld      C,PSG_REG       ; PSG register port
3653+ 2AC8 ED 79                out     (C),A           ; select first register of the pair
3654+ 2ACA 0E 41                ld      C,PSG_DAT       ; PSG data port
3655+ 2ACC ED 69                out     (C),L           ; send high byte
3656+ 2ACE 0E 40                ld      C,PSG_REG       ; PSG register support
3657+ 2AD0 3C                   inc     A               ; second register of the pair
3658+ 2AD1 ED 79                out     (C),A           ; select register
3659+ 2AD3 0E 41                ld      C,PSG_DAT       ; PSG data port
3660+ 2AD5 ED 61                out     (C),H           ; send low byte
3661+ 2AD7 ED 5B 00 53          ld      DE,(TMPBFR3)    ; recover duration
3662+ 2ADB 3A FC 52             ld      A,(TMPBFR1)     ; recover channel value
3663+ 2ADE 3D                   dec     A               ; set channel into the range 0~2
3664+ 2ADF 87                   add     A,A             ; double A to find the correct offset
3665+ 2AE0 21 30 53             ld      HL,CHASNDDTN    ; set duration into...
3666+ 2AE3 85                   add     A,L             ; ...the proper...
3667+ 2AE4 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3668+ 2AE6 24                   inc     H               ; yes, increment H)
3669+ 2AE7 6F           SNDOVR: ld      L,A             ; ...register pair...
3670+ 2AE8 73                   ld      (HL),E          ; ...and store the value
3671+ 2AE9 23                   inc     HL
3672+ 2AEA 72                   ld      (HL),D
3673+ 2AEB E1                   pop     HL              ; retrieve HL
3674+ 2AEC C9                   ret                     ; Return to caller
3675+ 2AED FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3676+ 2AEF D2 B8 1C             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3677+ 2AF2 CD AC 19             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3678+ 2AF5 2C                   defb    ','
3679+ 2AF6 CD FC 28             call    GETINT          ; get integer 0-255 (frequency)
3680+ 2AF9 FE 20                cp      $20             ; make sure it's in range 0~31
3681+ 2AFB D2 B8 1C             jp      NC,FCERR        ; no, so Illegal function call
3682+ 2AFE 32 FE 52             ld      (TMPBFR2),A     ; store freq.
3683+ 2B01 2B                   dec     HL              ; dec 'cos GETCHR INCs
3684+ 2B02 CD ED 1B             call    GETCHR          ; check that nothing follows
3685+ 2B05 C2 CA 16             jp      NZ,SNERR        ; error if no empty line
3686+ 2B08 3A FE 52             ld      A,(TMPBFR2)     ; retrieve freq.
3687+ 2B0B 5F                   ld      E,A             ; store freq into E
3688+ 2B0C 3A FC 52             ld      A,(TMPBFR1)     ; retrieve channel
3689+ 2B0F D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3690+ 2B11 FE 03                cp      $03             ; is it 3?
3691+ 2B13 20 02                jr      NZ,NOS1         ; no, jump over
3692+ 2B15 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3693+ 2B17 87           NOS1:   add     A,A
3694+ 2B18 87                   add     A,A
3695+ 2B19 87                   add     A,A             ; let's move A 3 bits to left
3696+ 2B1A 47                   ld      B,A             ; store channel into B
3697+ 2B1B 7B                   ld      A,E             ; check if
3698+ 2B1C A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3699+ 2B1D F3                   di                      ; disable INts
3700+ 2B1E 20 0A                jr      NZ,NOS2         ; no, so jump over
3701+ 2B20 3E 07                ld      A,$07           ; mixer register
3702+ 2B22 CD D4 0C             call    SETSNDREG       ; set mixer register
3703+ 2B25 ED 78                in      A,(C)           ; load current mixer value
3704+ 2B27 B0                   or      B               ; disable noise
3705+ 2B28 18 19                jr      NOS3            ; continue over
3706+ 2B2A 78           NOS2:   ld      A,B             ; recover channel
3707+ 2B2B 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3708+ 2B2C CD 3A 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3709+ 2B2F 3E 06                ld      A,$06           ; write into noise register
3710+ 2B31 CD D4 0C             call    SETSNDREG       ; set register into PSG
3711+ 2B34 7B                   ld      A,E             ; load value for noise frequency
3712+ 2B35 CD D9 0C             call    WRTSNDREG       ; write data into register $06
3713+ 2B38 FB                   ei                      ; re-enable INTs
3714+ 2B39 C9                   ret
3715+ 2B3A                      ; enable line into mixer of channel stored in A
3716+ 2B3A 47           WRTSND: ld      B,A             ; move channel into B
3717+ 2B3B 3E 07                ld      A,$07           ; mixer register
3718+ 2B3D CD D4 0C             call    SETSNDREG       ; set mixer register
3719+ 2B40 ED 78                in      A,(C)           ; load current value
3720+ 2B42 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3721+ 2B43                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3722+ 2B43                                              ; the register is still unchanged after reset) is 11111111 and
3723+ 2B43                                              ; 11111111 AND 11111110 is equal to 11111110
3724+ 2B43                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3725+ 2B43 47           NOS3:   ld      B,A             ; store new mixer value into B
3726+ 2B44 3E 07                ld      A,$07           ; mixer address
3727+ 2B46 CD D4 0C             call    SETSNDREG       ; set register
3728+ 2B49 78                   ld      A,B             ; retrieve new mixer value from B
3729+ 2B4A CD D9 0C             call    WRTSNDREG       ; send new value for the mixer
3730+ 2B4D FB                   ei                      ; re-enable INTs
3731+ 2B4E C9                   ret                     ; return to caller
3732+ 2B4F
3733+ 2B4F              ; write a byte into one of the VDP registers
3734+ 2B4F CD FC 28     VREG:   call    GETINT          ; Get register number back into A
3735+ 2B52 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3736+ 2B54 D2 B8 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3737+ 2B57 32 FC 52             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3738+ 2B5A CD AC 19             call    CHKSYN          ; Make sure ',' follows
3739+ 2B5D 2C                   defb    ','
3740+ 2B5E CD FC 28             call    GETINT          ; get value (0-255)
3741+ 2B61 5F                   ld      E,A             ; store value into E
3742+ 2B62 3A FC 52             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3743+ 2B65 F3                   di                      ; disable INTs
3744+ 2B66 CD A7 06             call    WRITE_VREG      ; write value into VDP register
3745+ 2B69 FB                   ei                      ; re-enable INTs
3746+ 2B6A C9                   ret                     ; return to caller
3747+ 2B6B
3748+ 2B6B              ; read the VDP status register and return it into A
3749+ 2B6B CD A3 1C     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3750+ 2B6E F3                   di                      ; disable INTs
3751+ 2B6F CD B2 06             call    READ_VSTAT      ; read VDP register status
3752+ 2B72 FB                   ei                      ; re-enable INTs
3753+ 2B73 C3 6F 24             jp      PASSA           ; Return integer A
3754+ 2B76
3755+ 2B76              ; read from PSG register and return it into A
3756+ 2B76 CD A3 1C     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3757+ 2B79 7B                   ld      A,E             ; consider LSB
3758+ 2B7A FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3759+ 2B7C D2 B8 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3760+ 2B7F F3                   di                      ; disable INts
3761+ 2B80 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3762+ 2B82 ED 79                out     (C),A           ; send register to read from
3763+ 2B84 ED 78                in      A,(C)           ; read register's contents and store into A
3764+ 2B86 FB                   ei                      ; re-enable INTs
3765+ 2B87 C3 6F 24             jp      PASSA           ; return A
3766+ 2B8A
3767+ 2B8A              ; read the temp key buffer and return the value of the current key being pressed
3768+ 2B8A              ; can wait for the number of 100thds of second before to return
3769+ 2B8A CD E9 24     INKEY:  call    IDTEST          ; Test for illegal direct
3770+ 2B8D CD A3 1C             call    DEINT           ; get number param (100thds of second to wait) into DE
3771+ 2B90 C5                   push    BC              ; store BC
3772+ 2B91 3A DB 52             ld      A,(TMRCNT)      ; Load current value of system timer
3773+ 2B94 47                   ld      B,A             ; move it into B
3774+ 2B95 3A DB 52     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3775+ 2B98 B8                   cp      B               ; ...to let the sniffer collect...
3776+ 2B99 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3777+ 2B9B 7A                   ld      A,D             ; check the param
3778+ 2B9C B3                   or      E               ; if DE<>0 then...
3779+ 2B9D 20 05                jr      NZ,INKEY2       ; ...jump over...
3780+ 2B9F 3A 38 53             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3781+ 2BA2 18 2A                jr      ENDINK          ; ...return it
3782+ 2BA4 7A           INKEY2: ld      A,D             ; check if param>1023
3783+ 2BA5 FE 04                cp      $04             ; to do this we check if MSB>3
3784+ 2BA7 D2 B8 1C             jp      NC,FCERR        ; if MSB >=4 then error
3785+ 2BAA E5                   push    HL              ; store HL
3786+ 2BAB 21 09 00             ld      HL,$0009        ; check if value
3787+ 2BAE CD B7 3F             call    CMP16           ; is < 10
3788+ 2BB1 E1                   pop     HL              ; retrieve HL
3789+ 2BB2 DA B8 2B             jp      C,SRTINK        ; if value >= 10 then jump over
3790+ 2BB5 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3791+ 2BB8 3A DB 52     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3792+ 2BBB 47                   ld      B,A             ; move it into B
3793+ 2BBC 3A 38 53     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3794+ 2BBF A7                   and     A               ; is it 0?
3795+ 2BC0 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3796+ 2BC2 3A DB 52             ld      A,(TMRCNT)      ; load the first byte of the system timer
3797+ 2BC5 B8                   cp      B               ; is it the same value?
3798+ 2BC6 28 F4                jr      Z,CHKINK        ; yes, so read again
3799+ 2BC8 47                   ld      B,A             ; store new value
3800+ 2BC9 1B                   dec     DE              ; no, decrement timer
3801+ 2BCA 7A                   ld      A,D             ; check if zero reached
3802+ 2BCB B3                   or      E               ; by ORing D and E
3803+ 2BCC 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3804+ 2BCE C1           ENDINK: pop     BC              ; restore BC
3805+ 2BCF F5                   push    AF              ; store A
3806+ 2BD0 F3                   di                      ; disable INTs
3807+ 2BD1 AF                   xor     A               ; clear the...
3808+ 2BD2 32 38 53             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3809+ 2BD5 FB                   ei                      ; re-enable INTs
3810+ 2BD6 F1                   pop     AF              ; retrieve A
3811+ 2BD7 C3 6F 24     ENDINK2:jp      PASSA           ; return A as ASCII value
3812+ 2BDA
3813+ 2BDA
3814+ 2BDA 21 01 31     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3815+ 2BDD CD D2 2E     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3816+ 2BE0 C3 EC 2B             jp      FPADD           ; Add BCDE to FPREG
3817+ 2BE3
3818+ 2BE3
3819+ 2BE3 CD D2 2E     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3820+ 2BE6 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3821+ 2BE7 C1           PSUB:   pop     BC              ; Get FP number from stack
3822+ 2BE8 D1                   pop     DE
3823+ 2BE9 CD AC 2E     SUBCDE: call    INVSGN          ; Negate FPREG
3824+ 2BEC 78           FPADD:  ld      A,B             ; Get FP exponent
3825+ 2BED B7                   or      A               ; Is number zero?
3826+ 2BEE C8                   ret     Z               ; Yes - Nothing to add
3827+ 2BEF 3A 53 53             ld      A,(FPEXP)       ; Get FPREG exponent
3828+ 2BF2 B7                   or      A               ; Is this number zero?
3829+ 2BF3 CA C4 2E             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3830+ 2BF6 90                   sub     B               ; BCDE number larger?
3831+ 2BF7 D2 06 2C             jp      NC,NOSWAP       ; No - Don't swap them
3832+ 2BFA 2F                   cpl                     ; Two's complement
3833+ 2BFB 3C                   inc     A               ;  FP exponent
3834+ 2BFC EB                   ex      DE,HL
3835+ 2BFD CD B4 2E             call    STAKFP          ; Put FPREG on stack
3836+ 2C00 EB                   ex      DE,HL
3837+ 2C01 CD C4 2E             call    FPBCDE          ; Move BCDE to FPREG
3838+ 2C04 C1                   pop     BC              ; Restore number from stack
3839+ 2C05 D1                   pop     DE
3840+ 2C06 FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3841+ 2C08 D0                   ret     NC              ; Yes - First number is result
3842+ 2C09 F5                   push    AF              ; Save number of bits to scale
3843+ 2C0A CD E9 2E             call    SIGNS           ; Set MSBs & sign of result
3844+ 2C0D 67                   ld      H,A             ; Save sign of result
3845+ 2C0E F1                   pop     AF              ; Restore scaling factor
3846+ 2C0F CD B1 2C             call    SCALE           ; Scale BCDE to same exponent
3847+ 2C12 B4                   or      H               ; Result to be positive?
3848+ 2C13 21 50 53             ld      HL,FPREG        ; Point to FPREG
3849+ 2C16 F2 2C 2C             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3850+ 2C19 CD 91 2C             call    PLUCDE          ; Add FPREG to CDE
3851+ 2C1C D2 72 2C             jp      NC,RONDUP       ; No overflow - Round it up
3852+ 2C1F 23                   inc     HL              ; Point to exponent
3853+ 2C20 34                   inc     (HL)            ; Increment it
3854+ 2C21 CA D9 16             jp      Z,OVERR         ; Number overflowed - Error
3855+ 2C24 2E 01                ld      L,$01           ; 1 bit to shift right
3856+ 2C26 CD C7 2C             call    SHRT1           ; Shift result right
3857+ 2C29 C3 72 2C             jp      RONDUP          ; Round it up
3858+ 2C2C
3859+ 2C2C AF           MINCDE: xor     A               ; Clear A and carry
3860+ 2C2D 90                   sub     B               ; Negate exponent
3861+ 2C2E 47                   ld      B,A             ; Re-save exponent
3862+ 2C2F 7E                   ld      A,(HL)          ; Get LSB of FPREG
3863+ 2C30 9B                   sbc     A, E            ; Subtract LSB of BCDE
3864+ 2C31 5F                   ld      E,A             ; Save LSB of BCDE
3865+ 2C32 23                   inc     HL
3866+ 2C33 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3867+ 2C34 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3868+ 2C35 57                   ld      D,A             ; Save NMSB of BCDE
3869+ 2C36 23                   inc     HL
3870+ 2C37 7E                   ld      A,(HL)          ; Get MSB of FPREG
3871+ 2C38 99                   sbc     A,C             ; Subtract MSB of BCDE
3872+ 2C39 4F                   ld      C,A             ; Save MSB of BCDE
3873+ 2C3A DC 9D 2C     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3874+ 2C3D
3875+ 2C3D 68           BNORM:  ld      L,B             ; L = Exponent
3876+ 2C3E 63                   ld      H,E             ; H = LSB
3877+ 2C3F AF                   xor     A
3878+ 2C40 47           BNRMLP: ld      B,A             ; Save bit count
3879+ 2C41 79                   ld      A,C             ; Get MSB
3880+ 2C42 B7                   or      A               ; Is it zero?
3881+ 2C43 C2 5F 2C             jp      NZ,PNORM        ; No - Do it bit at a time
3882+ 2C46 4A                   ld      C,D             ; MSB = NMSB
3883+ 2C47 54                   ld      D,H             ; NMSB= LSB
3884+ 2C48 65                   ld      H,L             ; LSB = VLSB
3885+ 2C49 6F                   ld      L,A             ; VLSB= 0
3886+ 2C4A 78                   ld      A,B             ; Get exponent
3887+ 2C4B D6 08                sub     $08             ; Count 8 bits
3888+ 2C4D FE E0                cp      -24-8           ; Was number zero?
3889+ 2C4F C2 40 2C             jp      NZ,BNRMLP       ; No - Keep normalising
3890+ 2C52 AF           RESZER: xor     A               ; Result is zero
3891+ 2C53 32 53 53     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3892+ 2C56 C9                   ret
3893+ 2C57
3894+ 2C57 05           NORMAL: dec     B               ; Count bits
3895+ 2C58 29                   add     HL,HL           ; Shift HL left
3896+ 2C59 7A                   ld      A,D             ; Get NMSB
3897+ 2C5A 17                   rla                     ; Shift left with last bit
3898+ 2C5B 57                   ld      D,A             ; Save NMSB
3899+ 2C5C 79                   ld      A,C             ; Get MSB
3900+ 2C5D 8F                   adc     A,A             ; Shift left with last bit
3901+ 2C5E 4F                   ld      C,A             ; Save MSB
3902+ 2C5F F2 57 2C     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3903+ 2C62 78                   ld      A,B             ; Number of bits shifted
3904+ 2C63 5C                   ld      E,H             ; Save HL in EB
3905+ 2C64 45                   ld      B,L
3906+ 2C65 B7                   or      A               ; Any shifting done?
3907+ 2C66 CA 72 2C             jp      Z,RONDUP        ; No - Round it up
3908+ 2C69 21 53 53             ld      HL,FPEXP        ; Point to exponent
3909+ 2C6C 86                   add     A,(HL)          ; Add shifted bits
3910+ 2C6D 77                   ld      (HL),A          ; Re-save exponent
3911+ 2C6E D2 52 2C             jp      NC,RESZER       ; Underflow - Result is zero
3912+ 2C71 C8                   ret     Z               ; Result is zero
3913+ 2C72 78           RONDUP: ld      A,B             ; Get VLSB of number
3914+ 2C73 21 53 53     RONDB:  ld      HL,FPEXP        ; Point to exponent
3915+ 2C76 B7                   or      A               ; Any rounding?
3916+ 2C77 FC 84 2C             call    M,FPROND        ; Yes - Round number up
3917+ 2C7A 46                   ld      B,(HL)          ; B = Exponent
3918+ 2C7B 23                   inc     HL
3919+ 2C7C 7E                   ld      A,(HL)          ; Get sign of result
3920+ 2C7D E6 80                and     %10000000       ; Only bit 7 needed
3921+ 2C7F A9                   xor     C               ; Set correct sign
3922+ 2C80 4F                   ld      C,A             ; Save correct sign in number
3923+ 2C81 C3 C4 2E             jp      FPBCDE          ; Move BCDE to FPREG
3924+ 2C84
3925+ 2C84 1C           FPROND: inc     E               ; Round LSB
3926+ 2C85 C0                   ret     NZ              ; Return if ok
3927+ 2C86 14                   inc     D               ; Round NMSB
3928+ 2C87 C0                   ret     NZ              ; Return if ok
3929+ 2C88 0C                   inc     C               ; Round MSB
3930+ 2C89 C0                   ret     NZ              ; Return if ok
3931+ 2C8A 0E 80                ld      C,$80           ; Set normal value
3932+ 2C8C 34                   inc     (HL)            ; Increment exponent
3933+ 2C8D C0                   ret     NZ              ; Return if ok
3934+ 2C8E C3 D9 16             jp      OVERR           ; Overflow error
3935+ 2C91
3936+ 2C91 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
3937+ 2C92 83                   add     A,E             ; Add LSB of BCDE
3938+ 2C93 5F                   ld      E,A             ; Save LSB of BCDE
3939+ 2C94 23                   inc     HL
3940+ 2C95 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3941+ 2C96 8A                   adc     A,D             ; Add NMSB of BCDE
3942+ 2C97 57                   ld      D,A             ; Save NMSB of BCDE
3943+ 2C98 23                   inc     HL
3944+ 2C99 7E                   ld      A,(HL)          ; Get MSB of FPREG
3945+ 2C9A 89                   adc     A,C             ; Add MSB of BCDE
3946+ 2C9B 4F                   ld      C,A             ; Save MSB of BCDE
3947+ 2C9C C9                   ret
3948+ 2C9D
3949+ 2C9D 21 54 53     COMPL:  ld      HL,SGNRES       ; Sign of result
3950+ 2CA0 7E                   ld      A,(HL)          ; Get sign of result
3951+ 2CA1 2F                   cpl                     ; Negate it
3952+ 2CA2 77                   ld      (HL),A          ; Put it back
3953+ 2CA3 AF                   xor     A
3954+ 2CA4 6F                   ld      L,A             ; Set L to zero
3955+ 2CA5 90                   sub     B               ; Negate exponent,set carry
3956+ 2CA6 47                   ld      B,A             ; Re-save exponent
3957+ 2CA7 7D                   ld      A,L             ; Load zero
3958+ 2CA8 9B                   sbc     A,E             ; Negate LSB
3959+ 2CA9 5F                   ld      E,A             ; Re-save LSB
3960+ 2CAA 7D                   ld      A,L             ; Load zero
3961+ 2CAB 9A                   sbc     A,D             ; Negate NMSB
3962+ 2CAC 57                   ld      D,A             ; Re-save NMSB
3963+ 2CAD 7D                   ld      A,L             ; Load zero
3964+ 2CAE 99                   sbc     A,C             ; Negate MSB
3965+ 2CAF 4F                   ld      C,A             ; Re-save MSB
3966+ 2CB0 C9                   ret
3967+ 2CB1
3968+ 2CB1 06 00        SCALE:  ld      B,$00           ; Clear underflow
3969+ 2CB3 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
3970+ 2CB5 DA C0 2C             jp      C,SHRITE        ; No - Shift right A bits
3971+ 2CB8 43                   ld      B,E             ; <- Shift
3972+ 2CB9 5A                   ld      E,D             ; <- right
3973+ 2CBA 51                   ld      D,C             ; <- eight
3974+ 2CBB 0E 00                ld      C,$00           ; <- bits
3975+ 2CBD C3 B3 2C             jp      SCALLP          ; More bits to shift
3976+ 2CC0
3977+ 2CC0 C6 09        SHRITE: add     A,8+1           ; Adjust count
3978+ 2CC2 6F                   ld      L,A             ; Save bits to shift
3979+ 2CC3 AF           SHRLP:  xor     A               ; Flag for all done
3980+ 2CC4 2D                   dec     L               ; All shifting done?
3981+ 2CC5 C8                   ret     Z               ; Yes - Return
3982+ 2CC6 79                   ld      A,C             ; Get MSB
3983+ 2CC7 1F           SHRT1:  rra                     ; Shift it right
3984+ 2CC8 4F                   ld      C,A             ; Re-save
3985+ 2CC9 7A                   ld      A,D             ; Get NMSB
3986+ 2CCA 1F                   rra                     ; Shift right with last bit
3987+ 2CCB 57                   ld      D,A             ; Re-save it
3988+ 2CCC 7B                   ld      A,E             ; Get LSB
3989+ 2CCD 1F                   rra                     ; Shift right with last bit
3990+ 2CCE 5F                   ld      E,A             ; Re-save it
3991+ 2CCF 78                   ld      A,B             ; Get underflow
3992+ 2CD0 1F                   rra                     ; Shift right with last bit
3993+ 2CD1 47                   ld      B,A             ; Re-save underflow
3994+ 2CD2 C3 C3 2C             jp      SHRLP           ; More bits to do
3995+ 2CD5
3996+ 2CD5 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
3997+ 2CD9
3998+ 2CD9 03           LOGTAB: defb    $03             ; Table used by LOG
3999+ 2CDA AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4000+ 2CDE F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4001+ 2CE2 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4002+ 2CE6
4003+ 2CE6 CD 83 2E     LOG:    call    TSTSGN          ; Test sign of value
4004+ 2CE9 B7                   or      A
4005+ 2CEA EA B8 1C             jp      PE,FCERR        ; ?FC Error if <= zero
4006+ 2CED 21 53 53             ld      HL,FPEXP        ; Point to exponent
4007+ 2CF0 7E                   ld      A,(HL)          ; Get exponent
4008+ 2CF1 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4009+ 2CF4 11 F3 04             ld      DE,$04F3
4010+ 2CF7 90                   sub     B               ; Scale value to be < 1
4011+ 2CF8 F5                   push    AF              ; Save scale factor
4012+ 2CF9 70                   ld      (HL),B          ; Save new exponent
4013+ 2CFA D5                   push    DE              ; Save SQR(1/2)
4014+ 2CFB C5                   push    BC
4015+ 2CFC CD EC 2B             call    FPADD           ; Add SQR(1/2) to value
4016+ 2CFF C1                   pop     BC              ; Restore SQR(1/2)
4017+ 2D00 D1                   pop     DE
4018+ 2D01 04                   inc     B               ; Make it SQR(2)
4019+ 2D02 CD D9 2D             call    DVBCDE          ; Divide by SQR(2)
4020+ 2D05 21 D5 2C             ld      HL,UNITY        ; Point to 1.
4021+ 2D08 CD E3 2B             call    SUBPHL          ; Subtract FPREG from 1
4022+ 2D0B 21 D9 2C             ld      HL,LOGTAB       ; Coefficient table
4023+ 2D0E CD CB 31             call    SUMSER          ; Evaluate sum of series
4024+ 2D11 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4025+ 2D14 11 00 00             ld      DE,$0000
4026+ 2D17 CD EC 2B             call    FPADD           ; Subtract 0.5 from FPREG
4027+ 2D1A F1                   pop     AF              ; Restore scale factor
4028+ 2D1B CD FE 2F             call    RSCALE          ; Re-scale number
4029+ 2D1E 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4030+ 2D21 11 18 72             ld      DE,$7218
4031+ 2D24 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4032+ 2D25
4033+ 2D25 C1           MULT:   pop     BC              ; Get number from stack
4034+ 2D26 D1                   pop     DE
4035+ 2D27 CD 83 2E     FPMULT: call    TSTSGN          ; Test sign of FPREG
4036+ 2D2A C8                   ret     Z               ; Return zero if zero
4037+ 2D2B 2E 00                ld      L,$00           ; Flag add exponents
4038+ 2D2D CD 41 2E             call    ADDEXP          ; Add exponents
4039+ 2D30 79                   ld      A,C             ; Get MSB of multiplier
4040+ 2D31 32 62 53             ld      (MULVAL),A      ; Save MSB of multiplier
4041+ 2D34 EB                   ex      DE,HL
4042+ 2D35 22 63 53             ld      (MULVAL+1),HL   ; Save rest of multiplier
4043+ 2D38 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4044+ 2D3B 50                   ld      D,B
4045+ 2D3C 58                   ld      E,B
4046+ 2D3D 21 3D 2C             ld      HL,BNORM        ; Address of normalise
4047+ 2D40 E5                   push    HL              ; Save for return
4048+ 2D41 21 49 2D             ld      HL,MULT8        ; Address of 8 bit multiply
4049+ 2D44 E5                   push    HL              ; Save for NMSB,MSB
4050+ 2D45 E5                   push    HL              ;
4051+ 2D46 21 50 53             ld      HL,FPREG        ; Point to number
4052+ 2D49 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4053+ 2D4A 23                   inc     HL              ; Point to NMSB
4054+ 2D4B B7                   or      A               ; Test LSB
4055+ 2D4C CA 75 2D             jp      Z,BYTSFT        ; Zero - shift to next byte
4056+ 2D4F E5                   push    HL              ; Save address of number
4057+ 2D50 2E 08                ld      L,$08           ; 8 bits to multiply by
4058+ 2D52 1F           MUL8LP: rra                     ; Shift LSB right
4059+ 2D53 67                   ld      H,A             ; Save LSB
4060+ 2D54 79                   ld      A,C             ; Get MSB
4061+ 2D55 D2 63 2D             jp      NC,NOMADD       ; Bit was zero - Don't add
4062+ 2D58 E5                   push    HL              ; Save LSB and count
4063+ 2D59 2A 63 53             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4064+ 2D5C 19                   add     HL,DE           ; Add NMSB and LSB
4065+ 2D5D EB                   ex      DE,HL           ; Leave sum in DE
4066+ 2D5E E1                   pop     HL              ; Restore MSB and count
4067+ 2D5F 3A 62 53             ld      A,(MULVAL)      ; Get MSB of multiplier
4068+ 2D62 89                   adc     A,C             ; Add MSB
4069+ 2D63 1F           NOMADD: rra                     ; Shift MSB right
4070+ 2D64 4F                   ld      C,A             ; Re-save MSB
4071+ 2D65 7A                   ld      A,D             ; Get NMSB
4072+ 2D66 1F                   rra                     ; Shift NMSB right
4073+ 2D67 57                   ld      D,A             ; Re-save NMSB
4074+ 2D68 7B                   ld      A,E             ; Get LSB
4075+ 2D69 1F                   rra                     ; Shift LSB right
4076+ 2D6A 5F                   ld      E,A             ; Re-save LSB
4077+ 2D6B 78                   ld      A,B             ; Get VLSB
4078+ 2D6C 1F                   rra                     ; Shift VLSB right
4079+ 2D6D 47                   ld      B,A             ; Re-save VLSB
4080+ 2D6E 2D                   dec     L               ; Count bits multiplied
4081+ 2D6F 7C                   ld      A,H             ; Get LSB of multiplier
4082+ 2D70 C2 52 2D             jp      NZ,MUL8LP       ; More - Do it
4083+ 2D73 E1           POPHRT: pop     HL              ; Restore address of number
4084+ 2D74 C9                   ret
4085+ 2D75
4086+ 2D75 43           BYTSFT: ld      B,E             ; Shift partial product left
4087+ 2D76 5A                   ld      E,D
4088+ 2D77 51                   ld      D,C
4089+ 2D78 4F                   ld      C,A
4090+ 2D79 C9                   ret
4091+ 2D7A
4092+ 2D7A
4093+ 2D7A              ; WORKING ââ
4094+ 2D7A C1           DINT:   pop     BC              ; Get number from stack
4095+ 2D7B D1                   pop     DE
4096+ 2D7C CD D9 2D             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4097+ 2D7F C3 56 2F             jp      INT             ; return INT(FPREG)
4098+ 2D82
4099+ 2D82
4100+ 2D82              ; A MODULO B - return remainder of the integer division A/B where:
4101+ 2D82              ; A is in stack; B is in FPREG
4102+ 2D82              ; math is:
4103+ 2D82              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4104+ 2D82 CD 56 2F     MOD:    call    INT             ; B=INT(B)
4105+ 2D85 CD CF 2E             call    BCDEFP          ; copy B (from FPREG) into BCDE
4106+ 2D88 ED 53 00 53          ld      (TMPBFR3),DE    ; store B into...
4107+ 2D8C ED 43 02 53          ld      (TMPBFR4),BC    ; ...a temp buffer
4108+ 2D90 C1                   pop     BC              ; recover A...
4109+ 2D91 D1                   pop     DE              ; ...from stack
4110+ 2D92 CD C4 2E             call    FPBCDE          ; store A into FPREG
4111+ 2D95 CD 56 2F             call    INT             ; get integer part: A=INT(A)
4112+ 2D98 CD CF 2E             call    BCDEFP          ; copy A (from FPREG) into BCDE
4113+ 2D9B ED 53 FC 52          ld      (TMPBFR1),DE    ; store A into...
4114+ 2D9F ED 43 FE 52          ld      (TMPBFR2),BC    ; ...a temp buffer
4115+ 2DA3                                              ; begin calculation
4116+ 2DA3 2A 00 53             ld      HL,(TMPBFR3)    ; move B...
4117+ 2DA6 22 50 53             ld      (FPREG),HL      ; ...from...
4118+ 2DA9 2A 02 53             ld      HL,(TMPBFR4)    ; ...temp buffer...
4119+ 2DAC 22 52 53             ld      (FPREG+2),HL    ; ...into FPREG
4120+ 2DAF CD D9 2D             call    DVBCDE          ; compute A/B and store into FPREG
4121+ 2DB2 CD 56 2F             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4122+ 2DB5 ED 5B 00 53          ld      DE,(TMPBFR3)    ; load B...
4123+ 2DB9 ED 4B 02 53          ld      BC,(TMPBFR4)    ; ...into BCDE
4124+ 2DBD CD 27 2D             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4125+ 2DC0 ED 5B FC 52          ld      DE,(TMPBFR1)    ; retrieve A from...
4126+ 2DC4 ED 4B FE 52          ld      BC,(TMPBFR2)    ; ...temp buffer
4127+ 2DC8 C3 E9 2B             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4128+ 2DCB
4129+ 2DCB
4130+ 2DCB CD B4 2E     DIV10:  call    STAKFP          ; Save FPREG on stack
4131+ 2DCE 01 20 84             ld      BC,$8420        ; BCDE = 10.
4132+ 2DD1 11 00 00             ld      DE,$0000
4133+ 2DD4 CD C4 2E             call    FPBCDE          ; Move 10 to FPREG
4134+ 2DD7
4135+ 2DD7 C1           DIV:    pop     BC              ; Get number from stack
4136+ 2DD8 D1                   pop     DE
4137+ 2DD9 CD 83 2E     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4138+ 2DDC CA CD 16             jp      Z,DZERR         ; Error if division by zero
4139+ 2DDF 2E FF                ld      L,-1            ; Flag subtract exponents
4140+ 2DE1 CD 41 2E             call    ADDEXP          ; Subtract exponents
4141+ 2DE4 34                   inc     (HL)            ; Add 2 to exponent to adjust
4142+ 2DE5 34                   inc     (HL)
4143+ 2DE6 2B                   dec     HL              ; Point to MSB
4144+ 2DE7 7E                   ld      A,(HL)          ; Get MSB of dividend
4145+ 2DE8 32 91 51             ld      (DIV3),A        ; Save for subtraction
4146+ 2DEB 2B                   dec     HL
4147+ 2DEC 7E                   ld      A,(HL)          ; Get NMSB of dividend
4148+ 2DED 32 8D 51             ld      (DIV2),A        ; Save for subtraction
4149+ 2DF0 2B                   dec     HL
4150+ 2DF1 7E                   ld      A,(HL)          ; Get MSB of dividend
4151+ 2DF2 32 89 51             ld      (DIV1),A        ; Save for subtraction
4152+ 2DF5 41                   ld      B,C             ; Get MSB
4153+ 2DF6 EB                   ex      DE,HL           ; NMSB,LSB to HL
4154+ 2DF7 AF                   xor     A
4155+ 2DF8 4F                   ld      C,A             ; Clear MSB of quotient
4156+ 2DF9 57                   ld      D,A             ; Clear NMSB of quotient
4157+ 2DFA 5F                   ld      E,A             ; Clear LSB of quotient
4158+ 2DFB 32 94 51             ld      (DIV4),A        ; Clear overflow count
4159+ 2DFE E5           DIVLP:  push    HL              ; Save divisor
4160+ 2DFF C5                   push    BC
4161+ 2E00 7D                   ld      A,L             ; Get LSB of number
4162+ 2E01 CD 88 51             call    DIVSUP          ; Subt' divisor from dividend
4163+ 2E04 DE 00                sbc     A,$00           ; Count for overflows
4164+ 2E06 3F                   ccf
4165+ 2E07 D2 11 2E             jp      NC,RESDIV       ; Restore divisor if borrow
4166+ 2E0A 32 94 51             ld      (DIV4),A        ; Re-save overflow count
4167+ 2E0D F1                   pop     AF              ; Scrap divisor
4168+ 2E0E F1                   pop     AF
4169+ 2E0F 37                   scf                     ; Set carry to
4170+ 2E10 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4171+ 2E11
4172+ 2E11 C1           RESDIV: pop     BC              ; Restore divisor
4173+ 2E12 E1                   pop     HL
4174+ 2E13 79                   ld      A,C             ; Get MSB of quotient
4175+ 2E14 3C                   inc     A
4176+ 2E15 3D                   dec     A
4177+ 2E16 1F                   rra                     ; Bit 0 to bit 7
4178+ 2E17 FA 73 2C             jp      M,RONDB         ; Done - Normalise result
4179+ 2E1A 17                   rla                     ; Restore carry
4180+ 2E1B 7B                   ld      A,E             ; Get LSB of quotient
4181+ 2E1C 17                   rla                     ; Double it
4182+ 2E1D 5F                   ld      E,A             ; Put it back
4183+ 2E1E 7A                   ld      A,D             ; Get NMSB of quotient
4184+ 2E1F 17                   rla                     ; Double it
4185+ 2E20 57                   ld      D,A             ; Put it back
4186+ 2E21 79                   ld      A,C             ; Get MSB of quotient
4187+ 2E22 17                   rla                     ; Double it
4188+ 2E23 4F                   ld      C,A             ; Put it back
4189+ 2E24 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4190+ 2E25 78                   ld      A,B             ; Get MSB of divisor
4191+ 2E26 17                   rla                     ; Double it
4192+ 2E27 47                   ld      B,A             ; Put it back
4193+ 2E28 3A 94 51             ld      A,(DIV4)        ; Get VLSB of quotient
4194+ 2E2B 17                   rla                     ; Double it
4195+ 2E2C 32 94 51             ld      (DIV4),A        ; Put it back
4196+ 2E2F 79                   ld      A,C             ; Get MSB of quotient
4197+ 2E30 B2                   or      D               ; Merge NMSB
4198+ 2E31 B3                   or      E               ; Merge LSB
4199+ 2E32 C2 FE 2D             jp      NZ,DIVLP        ; Not done - Keep dividing
4200+ 2E35 E5                   push    HL              ; Save divisor
4201+ 2E36 21 53 53             ld      HL,FPEXP        ; Point to exponent
4202+ 2E39 35                   dec     (HL)            ; Divide by 2
4203+ 2E3A E1                   pop     HL              ; Restore divisor
4204+ 2E3B C2 FE 2D             jp      NZ,DIVLP        ; Ok - Keep going
4205+ 2E3E C3 D9 16             jp      OVERR           ; Overflow error
4206+ 2E41
4207+ 2E41
4208+ 2E41 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4209+ 2E42 B7                   or      A               ; Test it
4210+ 2E43 CA 65 2E             jp      Z,OVTST3        ; Zero - Result zero
4211+ 2E46 7D                   ld      A,L             ; Get add/subtract flag
4212+ 2E47 21 53 53             ld      HL,FPEXP        ; Point to exponent
4213+ 2E4A AE                   xor     (HL)            ; Add or subtract it
4214+ 2E4B 80                   add     A,B             ; Add the other exponent
4215+ 2E4C 47                   ld      B,A             ; Save new exponent
4216+ 2E4D 1F                   rra                     ; Test exponent for overflow
4217+ 2E4E A8                   xor     B
4218+ 2E4F 78                   ld      A,B             ; Get exponent
4219+ 2E50 F2 64 2E             jp      P,OVTST2        ; Positive - Test for overflow
4220+ 2E53 C6 80                add     A,$80           ; Add excess 128
4221+ 2E55 77                   ld      (HL),A          ; Save new exponent
4222+ 2E56 CA 73 2D             jp      Z,POPHRT        ; Zero - Result zero
4223+ 2E59 CD E9 2E             call    SIGNS           ; Set MSBs and sign of result
4224+ 2E5C 77                   ld      (HL),A          ; Save new exponent
4225+ 2E5D 2B                   dec     HL              ; Point to MSB
4226+ 2E5E C9                   ret
4227+ 2E5F
4228+ 2E5F CD 83 2E     OVTST1: call    TSTSGN          ; Test sign of FPREG
4229+ 2E62 2F                   cpl                     ; Invert sign
4230+ 2E63 E1                   pop     HL              ; Clean up stack
4231+ 2E64 B7           OVTST2: or      A               ; Test if new exponent zero
4232+ 2E65 E1           OVTST3: pop     HL              ; Clear off return address
4233+ 2E66 F2 52 2C             jp      P,RESZER        ; Result zero
4234+ 2E69 C3 D9 16             jp      OVERR           ; Overflow error
4235+ 2E6C
4236+ 2E6C CD CF 2E     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4237+ 2E6F 78                   ld      A,B             ; Get exponent
4238+ 2E70 B7                   or      A               ; Is it zero?
4239+ 2E71 C8                   ret     Z               ; Yes - Result is zero
4240+ 2E72 C6 02                add     A,$02           ; Multiply by 4
4241+ 2E74 DA D9 16             jp      C,OVERR         ; Overflow - ?OV Error
4242+ 2E77 47                   ld      B,A             ; Re-save exponent
4243+ 2E78 CD EC 2B             call    FPADD           ; Add BCDE to FPREG (Times 5)
4244+ 2E7B 21 53 53             ld      HL,FPEXP        ; Point to exponent
4245+ 2E7E 34                   inc     (HL)            ; Double number (Times 10)
4246+ 2E7F C0                   ret     NZ              ; Ok - Return
4247+ 2E80 C3 D9 16             jp      OVERR           ; Overflow error
4248+ 2E83
4249+ 2E83 3A 53 53     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4250+ 2E86 B7                   or      A
4251+ 2E87 C8                   ret     Z               ; RETurn if number is zero
4252+ 2E88 3A 52 53             ld      A,(FPREG+2)     ; Get MSB of FPREG
4253+ 2E8B FE                   defb    0FEH            ; Test sign
4254+ 2E8C 2F           RETREL: cpl                     ; Invert sign
4255+ 2E8D 17                   rla                     ; Sign bit to carry
4256+ 2E8E 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4257+ 2E8F C0                   ret     NZ              ; Return -1 if negative
4258+ 2E90 3C                   inc     A               ; Bump to +1
4259+ 2E91 C9                   ret                     ; Positive - Return +1
4260+ 2E92
4261+ 2E92 CD 83 2E     SGN:    call    TSTSGN          ; Test sign of FPREG
4262+ 2E95 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4263+ 2E97 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4264+ 2E9A 21 53 53     RETINT: ld      HL,FPEXP        ; Point to exponent
4265+ 2E9D 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4266+ 2E9E 70                   ld      (HL),B          ; Save exponent
4267+ 2E9F 06 00                ld      B,0             ; CDE = integer to normalise
4268+ 2EA1 23                   inc     HL              ; Point to sign of result
4269+ 2EA2 36 80                ld      (HL),$80        ; Set sign of result
4270+ 2EA4 17                   rla                     ; Carry = sign of integer
4271+ 2EA5 C3 3A 2C             jp      CONPOS          ; Set sign of result
4272+ 2EA8
4273+ 2EA8 CD 83 2E     ABS_:   call    TSTSGN          ; Test sign of FPREG
4274+ 2EAB F0                   ret     P               ; Return if positive
4275+ 2EAC 21 52 53     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4276+ 2EAF 7E                   ld      A,(HL)          ; Get sign of mantissa
4277+ 2EB0 EE 80                xor     $80             ; Invert sign of mantissa
4278+ 2EB2 77                   ld      (HL),A          ; Re-save sign of mantissa
4279+ 2EB3 C9                   ret
4280+ 2EB4
4281+ 2EB4 EB           STAKFP: ex      DE,HL           ; Save code string address
4282+ 2EB5 2A 50 53             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4283+ 2EB8 E3                   ex      (SP),HL         ; Stack them,get return
4284+ 2EB9 E5                   push    HL              ; Re-save return
4285+ 2EBA 2A 52 53             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4286+ 2EBD E3                   ex      (SP),HL         ; Stack them,get return
4287+ 2EBE E5                   push    HL              ; Re-save return
4288+ 2EBF EB                   ex      DE,HL           ; Restore code string address
4289+ 2EC0 C9                   ret
4290+ 2EC1
4291+ 2EC1              ; store F.P. number from BCDE into (FPREG)
4292+ 2EC1 CD D2 2E     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4293+ 2EC4 EB           FPBCDE: ex      DE,HL           ; Save code string address
4294+ 2EC5 22 50 53             ld      (FPREG),HL      ; Save LSB,NLSB of number
4295+ 2EC8 60                   ld      H,B             ; Exponent of number
4296+ 2EC9 69                   ld      L,C             ; MSB of number
4297+ 2ECA 22 52 53             ld      (FPREG+2),HL    ; Save MSB and exponent
4298+ 2ECD EB                   ex      DE,HL           ; Restore code string address
4299+ 2ECE C9                   ret
4300+ 2ECF
4301+ 2ECF              ; load F.P. number from (FPREG) into BCDE
4302+ 2ECF 21 50 53     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4303+ 2ED2 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4304+ 2ED3 23                   inc     HL
4305+ 2ED4 56                   ld      D,(HL)          ; Get NMSB of number
4306+ 2ED5 23                   inc     HL
4307+ 2ED6 4E                   ld      C,(HL)          ; Get MSB of number
4308+ 2ED7 23                   inc     HL
4309+ 2ED8 46                   ld      B,(HL)          ; Get exponent of number
4310+ 2ED9 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4311+ 2EDA C9                   ret
4312+ 2EDB
4313+ 2EDB              ; move floating point from (FPREG) into (HL)
4314+ 2EDB 11 50 53     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4315+ 2EDE 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4316+ 2EE0 1A           DETHLB: ld      A,(DE)          ; Get source
4317+ 2EE1 77                   ld      (HL),A          ; Save destination
4318+ 2EE2 13                   inc     DE              ; Next source
4319+ 2EE3 23                   inc     HL              ; Next destination
4320+ 2EE4 05                   dec     B               ; Count bytes
4321+ 2EE5 C2 E0 2E             jp      NZ,DETHLB       ; Loop if more
4322+ 2EE8 C9                   ret
4323+ 2EE9
4324+ 2EE9 21 52 53     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4325+ 2EEC 7E                   ld      A,(HL)          ; Get MSB
4326+ 2EED 07                   rlca                    ; Old sign to carry
4327+ 2EEE 37                   scf                     ; Set MSBit
4328+ 2EEF 1F                   rra                     ; Set MSBit of MSB
4329+ 2EF0 77                   ld      (HL),A          ; Save new MSB
4330+ 2EF1 3F                   ccf                     ; Complement sign
4331+ 2EF2 1F                   rra                     ; Old sign to carry
4332+ 2EF3 23                   inc     HL
4333+ 2EF4 23                   inc     HL
4334+ 2EF5 77                   ld      (HL),A          ; Set sign of result
4335+ 2EF6 79                   ld      A,C             ; Get MSB
4336+ 2EF7 07                   rlca                    ; Old sign to carry
4337+ 2EF8 37                   scf                     ; Set MSBit
4338+ 2EF9 1F                   rra                     ; Set MSBit of MSB
4339+ 2EFA 4F                   ld      C,A             ; Save MSB
4340+ 2EFB 1F                   rra
4341+ 2EFC AE                   xor     (HL)            ; New sign of result
4342+ 2EFD C9                   ret
4343+ 2EFE
4344+ 2EFE 78           CMPNUM: ld      A,B             ; Get exponent of number
4345+ 2EFF B7                   or      A
4346+ 2F00 CA 83 2E             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4347+ 2F03 21 8C 2E             ld      HL,RETREL       ; Return relation routine
4348+ 2F06 E5                   push    HL              ; Save for return
4349+ 2F07 CD 83 2E             call    TSTSGN          ; Test sign of FPREG
4350+ 2F0A 79                   ld      A,C             ; Get MSB of number
4351+ 2F0B C8                   ret     Z               ; FPREG zero - Number's MSB
4352+ 2F0C 21 52 53             ld      HL,FPREG+2      ; MSB of FPREG
4353+ 2F0F AE                   xor     (HL)            ; Combine signs
4354+ 2F10 79                   ld      A,C             ; Get MSB of number
4355+ 2F11 F8                   ret     M               ; Exit if signs different
4356+ 2F12 CD 18 2F             call    CMPFP           ; Compare FP numbers
4357+ 2F15 1F                   rra                     ; Get carry to sign
4358+ 2F16 A9                   xor     C               ; Combine with MSB of number
4359+ 2F17 C9                   ret
4360+ 2F18
4361+ 2F18 23           CMPFP:  inc     HL              ; Point to exponent
4362+ 2F19 78                   ld      A,B             ; Get exponent
4363+ 2F1A BE                   cp      (HL)            ; Compare exponents
4364+ 2F1B C0                   ret     NZ              ; Different
4365+ 2F1C 2B                   dec     HL              ; Point to MBS
4366+ 2F1D 79                   ld      A,C             ; Get MSB
4367+ 2F1E BE                   cp      (HL)            ; Compare MSBs
4368+ 2F1F C0                   ret     NZ              ; Different
4369+ 2F20 2B                   dec     HL              ; Point to NMSB
4370+ 2F21 7A                   ld      A,D             ; Get NMSB
4371+ 2F22 BE                   cp      (HL)            ; Compare NMSBs
4372+ 2F23 C0                   ret     NZ              ; Different
4373+ 2F24 2B                   dec     HL              ; Point to LSB
4374+ 2F25 7B                   ld      A,E             ; Get LSB
4375+ 2F26 96                   sub     (HL)            ; Compare LSBs
4376+ 2F27 C0                   ret     NZ              ; Different
4377+ 2F28 E1                   pop     HL              ; Drop RETurn
4378+ 2F29 E1                   pop     HL              ; Drop another RETurn
4379+ 2F2A C9                   ret
4380+ 2F2B
4381+ 2F2B 47           FPINT:  ld      B,A             ; <- Move
4382+ 2F2C 4F                   ld      C,A             ; <- exponent
4383+ 2F2D 57                   ld      D,A             ; <- to all
4384+ 2F2E 5F                   ld      E,A             ; <- bits
4385+ 2F2F B7                   or      A               ; Test exponent
4386+ 2F30 C8                   ret     Z               ; Zero - Return zero
4387+ 2F31 E5                   push    HL              ; Save pointer to number
4388+ 2F32 CD CF 2E             call    BCDEFP          ; Move FPREG to BCDE
4389+ 2F35 CD E9 2E             call    SIGNS           ; Set MSBs & sign of result
4390+ 2F38 AE                   xor     (HL)            ; Combine with sign of FPREG
4391+ 2F39 67                   ld      H,A             ; Save combined signs
4392+ 2F3A FC 4F 2F             call    M,DCBCDE        ; Negative - Decrement BCDE
4393+ 2F3D 3E 98                ld      A,$80+24        ; 24 bits
4394+ 2F3F 90                   sub     B               ; Bits to shift
4395+ 2F40 CD B1 2C             call    SCALE           ; Shift BCDE
4396+ 2F43 7C                   ld      A,H             ; Get combined sign
4397+ 2F44 17                   rla                     ; Sign to carry
4398+ 2F45 DC 84 2C             call    C,FPROND        ; Negative - Round number up
4399+ 2F48 06 00                ld      B,$00           ; Zero exponent
4400+ 2F4A DC 9D 2C             call    C,COMPL         ; If negative make positive
4401+ 2F4D E1                   pop     HL              ; Restore pointer to number
4402+ 2F4E C9                   ret
4403+ 2F4F
4404+ 2F4F 1B           DCBCDE: dec     DE              ; Decrement BCDE
4405+ 2F50 7A                   ld      A,D             ; Test LSBs
4406+ 2F51 A3                   and     E
4407+ 2F52 3C                   inc     A
4408+ 2F53 C0                   ret     NZ              ; Exit if LSBs not FFFF
4409+ 2F54 0B                   dec     BC              ; Decrement MSBs
4410+ 2F55 C9                   ret
4411+ 2F56
4412+ 2F56 21 53 53     INT:    ld      HL,FPEXP        ; Point to exponent
4413+ 2F59 7E                   ld      A,(HL)          ; Get exponent
4414+ 2F5A FE 98                cp      $80+24          ; Integer accuracy only?
4415+ 2F5C 3A 50 53             ld      A,(FPREG)       ; Get LSB
4416+ 2F5F D0                   ret     NC              ; Yes - Already integer
4417+ 2F60 7E                   ld      A,(HL)          ; Get exponent
4418+ 2F61 CD 2B 2F             call    FPINT           ; F.P to integer
4419+ 2F64 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4420+ 2F66 7B                   ld      A,E             ; Get LSB of number
4421+ 2F67 F5                   push    AF              ; Save LSB
4422+ 2F68 79                   ld      A,C             ; Get MSB of number
4423+ 2F69 17                   rla                     ; Sign to carry
4424+ 2F6A CD 3A 2C             call    CONPOS          ; Set sign of result
4425+ 2F6D F1                   pop     AF              ; Restore LSB of number
4426+ 2F6E C9                   ret
4427+ 2F6F
4428+ 2F6F 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4429+ 2F72 78                   ld      A,B             ; Test multiplier
4430+ 2F73 B1                   or      C
4431+ 2F74 C8                   ret     Z               ; Return zero if zero
4432+ 2F75 3E 10                ld      A,$10           ; 16 bits
4433+ 2F77 29           MLDBLP: add     HL,HL           ; Shift P.P left
4434+ 2F78 DA 9D 23             jp      C,BSERR         ; ?BS Error if overflow
4435+ 2F7B EB                   ex      DE,HL
4436+ 2F7C 29                   add     HL,HL           ; Shift multiplier left
4437+ 2F7D EB                   ex      DE,HL
4438+ 2F7E D2 85 2F             jp      NC,NOMLAD       ; Bit was zero - No add
4439+ 2F81 09                   add     HL,BC           ; Add multiplicand
4440+ 2F82 DA 9D 23             jp      C,BSERR         ; ?BS Error if overflow
4441+ 2F85 3D           NOMLAD: dec     A               ; Count bits
4442+ 2F86 C2 77 2F             jp      NZ,MLDBLP       ; More
4443+ 2F89 C9                   ret
4444+ 2F8A
4445+ 2F8A FE 2D        ASCTFP: cp      '-'             ; Negative?
4446+ 2F8C F5                   push    AF              ; Save it and flags
4447+ 2F8D CA 96 2F             jp      Z,CNVNUM        ; Yes - Convert number
4448+ 2F90 FE 2B                cp      '+'             ; Positive?
4449+ 2F92 CA 96 2F             jp      Z,CNVNUM        ; Yes - Convert number
4450+ 2F95 2B                   dec     HL              ; dec 'cos GETCHR INCs
4451+ 2F96 CD 52 2C     CNVNUM: call    RESZER          ; Set result to zero
4452+ 2F99 47                   ld      B,A             ; Digits after point counter
4453+ 2F9A 57                   ld      D,A             ; Sign of exponent
4454+ 2F9B 5F                   ld      E,A             ; Exponent of ten
4455+ 2F9C 2F                   cpl
4456+ 2F9D 4F                   ld      C,A             ; Before or after point flag
4457+ 2F9E CD ED 1B     MANLP:  call    GETCHR          ; Get next character
4458+ 2FA1 DA E7 2F             jp      C,ADDIG         ; Digit - Add to number
4459+ 2FA4 FE 2E                cp      '.'
4460+ 2FA6 CA C2 2F             jp      Z,DPOINT        ; '.' - Flag point
4461+ 2FA9 FE 45                cp      'E'
4462+ 2FAB C2 C6 2F             jp      NZ,CONEXP       ; Not 'E' - Scale number
4463+ 2FAE CD ED 1B             call    GETCHR          ; Get next character
4464+ 2FB1 CD B9 21             call    SGNEXP          ; Get sign of exponent
4465+ 2FB4 CD ED 1B     EXPLP:  call    GETCHR          ; Get next character
4466+ 2FB7 DA 09 30             jp      C,EDIGIT        ; Digit - Add to exponent
4467+ 2FBA 14                   inc     D               ; Is sign negative?
4468+ 2FBB C2 C6 2F             jp      NZ,CONEXP       ; No - Scale number
4469+ 2FBE AF                   xor     A
4470+ 2FBF 93                   sub     E               ; Negate exponent
4471+ 2FC0 5F                   ld      E,A             ; And re-save it
4472+ 2FC1 0C                   inc     C               ; Flag end of number
4473+ 2FC2 0C           DPOINT: inc     C               ; Flag point passed
4474+ 2FC3 CA 9E 2F             jp      Z,MANLP         ; Zero - Get another digit
4475+ 2FC6 E5           CONEXP: push    HL              ; Save code string address
4476+ 2FC7 7B                   ld      A,E             ; Get exponent
4477+ 2FC8 90                   sub     B               ; Subtract digits after point
4478+ 2FC9 F4 DF 2F     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4479+ 2FCC F2 D5 2F             jp      P,ENDCON        ; Positive - All done
4480+ 2FCF F5                   push    AF              ; Save number of times to /10
4481+ 2FD0 CD CB 2D             call    DIV10           ; Divide by 10
4482+ 2FD3 F1                   pop     AF              ; Restore count
4483+ 2FD4 3C                   inc     A               ; Count divides
4484+ 2FD5
4485+ 2FD5 C2 C9 2F     ENDCON: jp      NZ,SCALMI       ; More to do
4486+ 2FD8 D1                   pop     DE              ; Restore code string address
4487+ 2FD9 F1                   pop     AF              ; Restore sign of number
4488+ 2FDA CC AC 2E             call    Z,INVSGN        ; Negative - Negate number
4489+ 2FDD EB                   ex      DE,HL           ; Code string address to HL
4490+ 2FDE C9                   ret
4491+ 2FDF
4492+ 2FDF C8           SCALPL: ret     Z               ; Exit if no scaling needed
4493+ 2FE0 F5           MULTEN: push    AF              ; Save count
4494+ 2FE1 CD 6C 2E             call    MLSP10          ; Multiply number by 10
4495+ 2FE4 F1                   pop     AF              ; Restore count
4496+ 2FE5 3D                   dec     A               ; Count multiplies
4497+ 2FE6 C9                   ret
4498+ 2FE7
4499+ 2FE7 D5           ADDIG:  push    DE              ; Save sign of exponent
4500+ 2FE8 57                   ld      D,A             ; Save digit
4501+ 2FE9 78                   ld      A,B             ; Get digits after point
4502+ 2FEA 89                   adc     A,C             ; Add one if after point
4503+ 2FEB 47                   ld      B,A             ; Re-save counter
4504+ 2FEC C5                   push    BC              ; Save point flags
4505+ 2FED E5                   push    HL              ; Save code string address
4506+ 2FEE D5                   push    DE              ; Save digit
4507+ 2FEF CD 6C 2E             call    MLSP10          ; Multiply number by 10
4508+ 2FF2 F1                   pop     AF              ; Restore digit
4509+ 2FF3 D6 30                sub     '0'             ; Make it absolute
4510+ 2FF5 CD FE 2F             call    RSCALE          ; Re-scale number
4511+ 2FF8 E1                   pop     HL              ; Restore code string address
4512+ 2FF9 C1                   pop     BC              ; Restore point flags
4513+ 2FFA D1                   pop     DE              ; Restore sign of exponent
4514+ 2FFB C3 9E 2F             jp      MANLP           ; Get another digit
4515+ 2FFE
4516+ 2FFE CD B4 2E     RSCALE: call    STAKFP          ; Put number on stack
4517+ 3001 CD 95 2E             call    FLGREL          ; Digit to add to FPREG
4518+ 3004 C1           PADD:   pop     BC              ; Restore number
4519+ 3005 D1                   pop     DE
4520+ 3006 C3 EC 2B             jp      FPADD           ; Add BCDE to FPREG and return
4521+ 3009
4522+ 3009 7B           EDIGIT: ld      A,E             ; Get digit
4523+ 300A 07                   rlca                    ; Times 2
4524+ 300B 07                   rlca                    ; Times 4
4525+ 300C 83                   add     A,E             ; Times 5
4526+ 300D 07                   rlca                    ; Times 10
4527+ 300E 86                   add     A,(HL)          ; Add next digit
4528+ 300F D6 30                sub     '0'             ; Make it absolute
4529+ 3011 5F                   ld      E,A             ; Save new digit
4530+ 3012 C3 B4 2F             jp      EXPLP           ; Look for another digit
4531+ 3015
4532+ 3015 E5           LINEIN: push    HL              ; Save code string address
4533+ 3016 21 43 16             ld      HL,INMSG        ; Output " in "
4534+ 3019 CD 7E 25             call    PRS             ; Output string at HL
4535+ 301C E1                   pop     HL              ; Restore code string address
4536+ 301D EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4537+ 301E AF                   xor     A
4538+ 301F 06 98                ld      B,$80+24        ; 24 bits
4539+ 3021 CD 9A 2E             call    RETINT          ; Return the integer
4540+ 3024 21 7D 25             ld      HL,PRNUMS       ; Print number string
4541+ 3027 E5                   push    HL              ; Save for return
4542+ 3028 21 55 53     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4543+ 302B E5                   push    HL              ; Save for return
4544+ 302C CD 83 2E             call    TSTSGN          ; Test sign of FPREG
4545+ 302F 36 20                ld      (HL),SPC        ; Space at start
4546+ 3031 F2 36 30             jp      P,SPCFST        ; Positive - Space to start
4547+ 3034 36 2D                ld      (HL),'-'        ; '-' sign at start
4548+ 3036 23           SPCFST: inc     HL              ; First byte of number
4549+ 3037 36 30                ld      (HL),'0'        ; '0' if zero
4550+ 3039 CA EC 30             jp      Z,JSTZER        ; Return '0' if zero
4551+ 303C E5                   push    HL              ; Save buffer address
4552+ 303D FC AC 2E             call    M,INVSGN        ; Negate FPREG if negative
4553+ 3040 AF                   xor     A               ; Zero A
4554+ 3041 F5                   push    AF              ; Save it
4555+ 3042 CD F2 30             call    RNGTST          ; Test number is in range
4556+ 3045 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4557+ 3048 11 F8 4F             ld      DE,$4FF8
4558+ 304B CD FE 2E             call    CMPNUM          ; Compare numbers
4559+ 304E B7                   or      A
4560+ 304F E2 63 30             jp      PO,INRNG        ; > 99999.9 - Sort it out
4561+ 3052 F1                   pop     AF              ; Restore count
4562+ 3053 CD E0 2F             call    MULTEN          ; Multiply by ten
4563+ 3056 F5                   push    AF              ; Re-save count
4564+ 3057 C3 45 30             jp      SIXDIG          ; Test it again
4565+ 305A
4566+ 305A CD CB 2D     GTSIXD: call    DIV10           ; Divide by 10
4567+ 305D F1                   pop     AF              ; Get count
4568+ 305E 3C                   inc     A               ; Count divides
4569+ 305F F5                   push    AF              ; Re-save count
4570+ 3060 CD F2 30             call    RNGTST          ; Test number is in range
4571+ 3063 CD DA 2B     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4572+ 3066 3C                   inc     A
4573+ 3067 CD 2B 2F             call    FPINT           ; F.P to integer
4574+ 306A CD C4 2E             call    FPBCDE          ; Move BCDE to FPREG
4575+ 306D 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4576+ 3070 F1                   pop     AF              ; Restore count
4577+ 3071 81                   add     A,C             ; 6 digits before point
4578+ 3072 3C                   inc     A               ; Add one
4579+ 3073 FA 7F 30             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4580+ 3076 FE 08                cp      6+1+1           ; More than 999999 ?
4581+ 3078 D2 7F 30             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4582+ 307B 3C                   inc     A               ; Adjust for exponent
4583+ 307C 47                   ld      B,A             ; Exponent of number
4584+ 307D 3E 02                ld      A,2             ; Make it zero after
4585+ 307F
4586+ 307F 3D           MAKNUM: dec     A               ; Adjust for digits to do
4587+ 3080 3D                   dec     A
4588+ 3081 E1                   pop     HL              ; Restore buffer address
4589+ 3082 F5                   push    AF              ; Save count
4590+ 3083 11 05 31             ld      DE,POWERS       ; Powers of ten
4591+ 3086 05                   dec     B               ; Count digits before point
4592+ 3087 C2 90 30             jp      NZ,DIGTXT       ; Not zero - Do number
4593+ 308A 36 2E                ld      (HL),'.'        ; Save point
4594+ 308C 23                   inc     HL              ; Move on
4595+ 308D 36 30                ld      (HL),'0'        ; Save zero
4596+ 308F 23                   inc     HL              ; Move on
4597+ 3090 05           DIGTXT: dec     B               ; Count digits before point
4598+ 3091 36 2E                ld      (HL),'.'        ; Save point in case
4599+ 3093 CC D9 2E             call    Z,INCHL         ; Last digit - move on
4600+ 3096 C5                   push    BC              ; Save digits before point
4601+ 3097 E5                   push    HL              ; Save buffer address
4602+ 3098 D5                   push    DE              ; Save powers of ten
4603+ 3099 CD CF 2E             call    BCDEFP          ; Move FPREG to BCDE
4604+ 309C E1                   pop     HL              ; Powers of ten table
4605+ 309D 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4606+ 309F 04           TRYAGN: inc     B               ; Count subtractions
4607+ 30A0 7B                   ld      A,E             ; Get LSB
4608+ 30A1 96                   sub     (HL)            ; Subtract LSB
4609+ 30A2 5F                   ld      E,A             ; Save LSB
4610+ 30A3 23                   inc     HL
4611+ 30A4 7A                   ld      A,D             ; Get NMSB
4612+ 30A5 9E                   sbc     A,(HL)          ; Subtract NMSB
4613+ 30A6 57                   ld      D,A             ; Save NMSB
4614+ 30A7 23                   inc     HL
4615+ 30A8 79                   ld      A,C             ; Get MSB
4616+ 30A9 9E                   sbc     A,(HL)          ; Subtract MSB
4617+ 30AA 4F                   ld      C,A             ; Save MSB
4618+ 30AB 2B                   dec     HL              ; Point back to start
4619+ 30AC 2B                   dec     HL
4620+ 30AD D2 9F 30             jp      NC,TRYAGN       ; No overflow - Try again
4621+ 30B0 CD 91 2C             call    PLUCDE          ; Restore number
4622+ 30B3 23                   inc     HL              ; Start of next number
4623+ 30B4 CD C4 2E             call    FPBCDE          ; Move BCDE to FPREG
4624+ 30B7 EB                   ex      DE,HL           ; Save point in table
4625+ 30B8 E1                   pop     HL              ; Restore buffer address
4626+ 30B9 70                   ld      (HL),B          ; Save digit in buffer
4627+ 30BA 23                   inc     HL              ; And move on
4628+ 30BB C1                   pop     BC              ; Restore digit count
4629+ 30BC 0D                   dec     C               ; Count digits
4630+ 30BD C2 90 30             jp      NZ,DIGTXT       ; More - Do them
4631+ 30C0 05                   dec     B               ; Any decimal part?
4632+ 30C1 CA D0 30             jp      Z,DOEBIT        ; No - Do 'E' bit
4633+ 30C4 2B           SUPTLZ: dec     HL              ; Move back through buffer
4634+ 30C5 7E                   ld      A,(HL)          ; Get character
4635+ 30C6 FE 30                cp      '0'             ; '0' character?
4636+ 30C8 CA C4 30             jp      Z,SUPTLZ        ; Yes - Look back for more
4637+ 30CB FE 2E                cp      '.'             ; A decimal point?
4638+ 30CD C4 D9 2E             call    NZ,INCHL        ; Move back over digit
4639+ 30D0
4640+ 30D0 F1           DOEBIT: pop     AF              ; Get 'E' flag
4641+ 30D1 CA EF 30             jp      Z,NOENED        ; No 'E' needed - End buffer
4642+ 30D4 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4643+ 30D6 23                   inc     HL              ; And move on
4644+ 30D7 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4645+ 30D9 F2 E0 30             jp      P,OUTEXP        ; Positive - Output exponent
4646+ 30DC 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4647+ 30DE 2F                   cpl                     ; Negate exponent
4648+ 30DF 3C                   inc     A
4649+ 30E0 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4650+ 30E2 04           EXPTEN: inc     B               ; Count subtractions
4651+ 30E3 D6 0A                sub     $0A             ; Tens digit
4652+ 30E5 D2 E2 30             jp      NC,EXPTEN       ; More to do
4653+ 30E8 C6 3A                add     A,'0'+10        ; Restore and make ASCII
4654+ 30EA 23                   inc     HL              ; Move on
4655+ 30EB 70                   ld      (HL),B          ; Save MSB of exponent
4656+ 30EC 23           JSTZER: inc     HL              ;
4657+ 30ED 77                   ld      (HL),A          ; Save LSB of exponent
4658+ 30EE 23                   inc     HL
4659+ 30EF 71           NOENED: ld      (HL),C          ; Mark end of buffer
4660+ 30F0 E1                   pop     HL              ; Restore code string address
4661+ 30F1 C9                   ret
4662+ 30F2
4663+ 30F2 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4664+ 30F5 11 F7 23             ld      DE,$23F7
4665+ 30F8 CD FE 2E             call    CMPNUM          ; Compare numbers
4666+ 30FB B7                   or      A
4667+ 30FC E1                   pop     HL              ; Return address to HL
4668+ 30FD E2 5A 30             jp      PO,GTSIXD       ; Too big - Divide by ten
4669+ 3100 E9                   jp      (HL)            ; Otherwise return to caller
4670+ 3101
4671+ 3101 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4672+ 3105
4673+ 3105 A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4674+ 3108 10 27 00             defb    $10,$27,$00  ;  10000
4675+ 310B E8 03 00             defb    $E8,$03,$00  ;   1000
4676+ 310E 64 00 00             defb    $64,$00,$00  ;    100
4677+ 3111 0A 00 00             defb    $0A,$00,$00  ;     10
4678+ 3114 01 00 00             defb    $01,$00,$00  ;      1
4679+ 3117
4680+ 3117 21 AC 2E     NEGAFT: ld      HL,INVSGN       ; Negate result
4681+ 311A E3                   ex      (SP),HL         ; To be done after caller
4682+ 311B E9                   jp      (HL)            ; Return to caller
4683+ 311C
4684+ 311C CD B4 2E     SQR:    call    STAKFP          ; Put value on stack
4685+ 311F 21 01 31             ld      HL,HALF         ; Set power to 1/2
4686+ 3122 CD C1 2E             call    PHLTFP          ; Move 1/2 to FPREG
4687+ 3125
4688+ 3125 C1           POWER:  pop     BC              ; Get base
4689+ 3126 D1                   pop     DE
4690+ 3127 CD 83 2E             call    TSTSGN          ; Test sign of power
4691+ 312A 78                   ld      A,B             ; Get exponent of base
4692+ 312B CA 6A 31             jp      Z,EXP           ; Make result 1 if zero
4693+ 312E F2 35 31             jp      P,POWER1        ; Positive base - Ok
4694+ 3131 B7                   or      A               ; Zero to negative power?
4695+ 3132 CA CD 16             jp      Z,DZERR         ; Yes - ?/0 Error
4696+ 3135 B7           POWER1: or      A               ; Base zero?
4697+ 3136 CA 53 2C             jp      Z,SAVEXP        ; Yes - Return zero
4698+ 3139 D5                   push    DE              ; Save base
4699+ 313A C5                   push    BC
4700+ 313B 79                   ld      A,C             ; Get MSB of base
4701+ 313C F6 7F                or      %01111111       ; Get sign status
4702+ 313E CD CF 2E             call    BCDEFP          ; Move power to BCDE
4703+ 3141 F2 52 31             jp      P,POWER2        ; Positive base - Ok
4704+ 3144 D5                   push    DE              ; Save power
4705+ 3145 C5                   push    BC
4706+ 3146 CD 56 2F             call    INT             ; Get integer of power
4707+ 3149 C1                   pop     BC              ; Restore power
4708+ 314A D1                   pop     DE
4709+ 314B F5                   push    AF              ; MSB of base
4710+ 314C CD FE 2E             call    CMPNUM          ; Power an integer?
4711+ 314F E1                   pop     HL              ; Restore MSB of base
4712+ 3150 7C                   ld      A,H             ; but don't affect flags
4713+ 3151 1F                   rra                     ; Exponent odd or even?
4714+ 3152 E1           POWER2: pop     HL              ; Restore MSB and exponent
4715+ 3153 22 52 53             ld      (FPREG+2),HL    ; Save base in FPREG
4716+ 3156 E1                   pop     HL              ; LSBs of base
4717+ 3157 22 50 53             ld      (FPREG),HL      ; Save in FPREG
4718+ 315A DC 17 31             call    C,NEGAFT        ; Odd power - Negate result
4719+ 315D CC AC 2E             call    Z,INVSGN        ; Negative base - Negate it
4720+ 3160 D5                   push    DE              ; Save power
4721+ 3161 C5                   push    BC
4722+ 3162 CD E6 2C             call    LOG             ; Get LOG of base
4723+ 3165 C1                   pop     BC              ; Restore power
4724+ 3166 D1                   pop     DE
4725+ 3167 CD 27 2D             call    FPMULT          ; Multiply LOG by power
4726+ 316A
4727+ 316A CD B4 2E     EXP:    call    STAKFP          ; Put value on stack
4728+ 316D 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4729+ 3170 11 3B AA             ld      DE,$AA3B
4730+ 3173 CD 27 2D             call    FPMULT          ; Multiply value by 1/LN(2)
4731+ 3176 3A 53 53             ld      A,(FPEXP)       ; Get exponent
4732+ 3179 FE 88                cp      $80+8           ; Is it in range?
4733+ 317B D2 5F 2E             jp      NC,OVTST1       ; No - Test for overflow
4734+ 317E CD 56 2F             call    INT             ; Get INT of FPREG
4735+ 3181 C6 80                add     A,$80           ; For excess 128
4736+ 3183 C6 02                add     A,$02           ; Exponent > 126?
4737+ 3185 DA 5F 2E             jp      C,OVTST1        ; Yes - Test for overflow
4738+ 3188 F5                   push    AF              ; Save scaling factor
4739+ 3189 21 D5 2C             ld      HL,UNITY        ; Point to 1.
4740+ 318C CD DD 2B             call    ADDPHL          ; Add 1 to FPREG
4741+ 318F CD 1E 2D             call    MULLN2          ; Multiply by LN(2)
4742+ 3192 F1                   pop     AF              ; Restore scaling factor
4743+ 3193 C1                   pop     BC              ; Restore exponent
4744+ 3194 D1                   pop     DE
4745+ 3195 F5                   push    AF              ; Save scaling factor
4746+ 3196 CD E9 2B             call    SUBCDE          ; Subtract exponent from FPREG
4747+ 3199 CD AC 2E             call    INVSGN          ; Negate result
4748+ 319C 21 AA 31             ld      HL,EXPTAB       ; Coefficient table
4749+ 319F CD DA 31             call    SMSER1          ; Sum the series
4750+ 31A2 11 00 00             ld      DE,$0000        ; Zero LSBs
4751+ 31A5 C1                   pop     BC              ; Scaling factor
4752+ 31A6 4A                   ld      C,D             ; Zero MSB
4753+ 31A7 C3 27 2D             jp      FPMULT          ; Scale result to correct value
4754+ 31AA
4755+ 31AA 08           EXPTAB: defb    $08             ; Table used by EXP
4756+ 31AB 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4757+ 31AF 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4758+ 31B3 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4759+ 31B7 E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4760+ 31BB 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4761+ 31BF FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4762+ 31C3 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4763+ 31C7 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4764+ 31CB
4765+ 31CB CD B4 2E     SUMSER: call    STAKFP          ; Put FPREG on stack
4766+ 31CE 11 25 2D             ld      DE,MULT         ; Multiply by "X"
4767+ 31D1 D5                   push    DE              ; To be done after
4768+ 31D2 E5                   push    HL              ; Save address of table
4769+ 31D3 CD CF 2E             call    BCDEFP          ; Move FPREG to BCDE
4770+ 31D6 CD 27 2D             call    FPMULT          ; Square the value
4771+ 31D9 E1                   pop     HL              ; Restore address of table
4772+ 31DA CD B4 2E     SMSER1: call    STAKFP          ; Put value on stack
4773+ 31DD 7E                   ld      A,(HL)          ; Get number of coefficients
4774+ 31DE 23                   inc     HL              ; Point to start of table
4775+ 31DF CD C1 2E             call    PHLTFP          ; Move coefficient to FPREG
4776+ 31E2 06                   defb    06H             ; Skip "pop AF"
4777+ 31E3 F1           SUMLP:  pop     AF              ; Restore count
4778+ 31E4 C1                   pop     BC              ; Restore number
4779+ 31E5 D1                   pop     DE
4780+ 31E6 3D                   dec     A               ; Cont coefficients
4781+ 31E7 C8                   ret     Z               ; All done
4782+ 31E8 D5                   push    DE              ; Save number
4783+ 31E9 C5                   push    BC
4784+ 31EA F5                   push    AF              ; Save count
4785+ 31EB E5                   push    HL              ; Save address in table
4786+ 31EC CD 27 2D             call    FPMULT          ; Multiply FPREG by BCDE
4787+ 31EF E1                   pop     HL              ; Restore address in table
4788+ 31F0 CD D2 2E             call    LOADFP          ; Number at HL to BCDE
4789+ 31F3 E5                   push    HL              ; Save address in table
4790+ 31F4 CD EC 2B             call    FPADD           ; Add coefficient to FPREG
4791+ 31F7 E1                   pop     HL              ; Restore address in table
4792+ 31F8 C3 E3 31             jp      SUMLP           ; More coefficients
4793+ 31FB
4794+ 31FB
4795+ 31FB              ; random number generator
4796+ 31FB              ; a negative argument is used as a seed for the RNG
4797+ 31FB              ; 0 is used to repeat the last random number
4798+ 31FB              ; a positive argument generates a new random number
4799+ 31FB CD 83 2E     RND:    call    TSTSGN          ; Test sign of FPREG
4800+ 31FE 21 98 51             ld      HL,SEED+2       ; Random number seed
4801+ 3201 FA 5C 32             jp      M,RESEED        ; Negative - Re-seed
4802+ 3204 21 B9 51             ld      HL,LSTRND       ; Last random number
4803+ 3207 CD C1 2E             call    PHLTFP          ; Move last RND to FPREG
4804+ 320A 21 98 51             ld      HL,SEED+2       ; Random number seed
4805+ 320D C8                   ret     Z               ; Return if RND(0)
4806+ 320E 86                   add     A,(HL)          ; Add (SEED)+2)
4807+ 320F E6 07                and     %00000111       ; 0 to 7
4808+ 3211 06 00                ld      B,$00
4809+ 3213 77                   ld      (HL),A          ; Re-save seed
4810+ 3214 23                   inc     HL              ; Move to coefficient table
4811+ 3215 87                   add     A,A             ; 4 bytes
4812+ 3216 87                   add     A,A             ; per entry
4813+ 3217 4F                   ld      C,A             ; BC = Offset into table
4814+ 3218 09                   add     HL,BC           ; Point to coefficient
4815+ 3219 CD D2 2E             call    LOADFP          ; Coefficient to BCDE
4816+ 321C CD 27 2D             call    FPMULT  ;       ; Multiply FPREG by coefficient
4817+ 321F 3A 97 51             ld      A,(SEED+1)      ; Get (SEED+1)
4818+ 3222 3C                   inc     A               ; Add 1
4819+ 3223 E6 03                and     %00000011       ; 0 to 3
4820+ 3225 06 00                ld      B,$00
4821+ 3227 FE 01                cp      $01             ; Is it zero?
4822+ 3229 88                   adc     A,B             ; Yes - Make it 1
4823+ 322A 32 97 51             ld      (SEED+1),A      ; Re-save seed
4824+ 322D 21 60 32             ld      HL,RNDTAB-4     ; Addition table
4825+ 3230 87                   add     A,A             ; 4 bytes
4826+ 3231 87                   add     A,A             ; per entry
4827+ 3232 4F                   ld      C,A             ; BC = Offset into table
4828+ 3233 09                   add     HL,BC           ; Point to value
4829+ 3234 CD DD 2B             call    ADDPHL          ; Add value to FPREG
4830+ 3237 CD CF 2E     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4831+ 323A 7B                   ld      A,E             ; Get LSB
4832+ 323B 59                   ld      E,C             ; LSB = MSB
4833+ 323C EE 4F                xor     %01001111       ; Fiddle around
4834+ 323E 4F                   ld      C,A             ; New MSB
4835+ 323F 36 80                ld      (HL),$80        ; Set exponent
4836+ 3241 2B                   dec     HL              ; Point to MSB
4837+ 3242 46                   ld      B,(HL)          ; Get MSB
4838+ 3243 36 80                ld      (HL),$80        ; Make value -0.5
4839+ 3245 21 96 51             ld      HL,SEED         ; Random number seed
4840+ 3248 34                   inc     (HL)            ; Count seed
4841+ 3249 7E                   ld      A,(HL)          ; Get seed
4842+ 324A D6 AB                sub     $AB             ; Do it modulo 171
4843+ 324C C2 53 32             jp      NZ,RND2         ; Non-zero - Ok
4844+ 324F 77                   ld      (HL),A          ; Zero seed
4845+ 3250 0C                   inc     C               ; Fillde about
4846+ 3251 15                   dec     D               ; with the
4847+ 3252 1C                   inc     E               ; number
4848+ 3253 CD 3D 2C     RND2:   call    BNORM           ; Normalise number
4849+ 3256 21 B9 51             ld      HL,LSTRND       ; Save random number
4850+ 3259 C3 DB 2E             jp      FPTHL           ; Move FPREG to last and return
4851+ 325C
4852+ 325C 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4853+ 325D 2B                   dec     HL
4854+ 325E 77                   ld      (HL),A
4855+ 325F 2B                   dec     HL
4856+ 3260 77                   ld      (HL),A
4857+ 3261 C3 37 32             jp      RND1            ; Return RND seed
4858+ 3264
4859+ 3264 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4860+ 3268 99 E9 92 69          defb    $99,$E9,$92,$69
4861+ 326C 10 D1 75 68          defb    $10,$D1,$75,$68
4862+ 3270
4863+ 3270              ; COS and SIN functions
4864+ 3270 21 BA 32     COS:    ld      HL,HALFPI       ; Point to PI/2
4865+ 3273 CD DD 2B             call    ADDPHL          ; Add it to PPREG
4866+ 3276 CD B4 2E     SIN:    call    STAKFP          ; Put angle on stack
4867+ 3279 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4868+ 327C 11 DB 0F             ld      DE,$0FDB
4869+ 327F CD C4 2E             call    FPBCDE          ; Move 2 PI to FPREG
4870+ 3282 C1                   pop     BC              ; Restore angle
4871+ 3283 D1                   pop     DE
4872+ 3284 CD D9 2D             call    DVBCDE          ; Divide angle by 2 PI
4873+ 3287 CD B4 2E             call    STAKFP          ; Put it on stack
4874+ 328A CD 56 2F             call    INT             ; Get INT of result
4875+ 328D C1                   pop     BC              ; Restore number
4876+ 328E D1                   pop     DE
4877+ 328F CD E9 2B             call    SUBCDE          ; Make it 0 <= value < 1
4878+ 3292 21 BE 32             ld      HL,QUARTR       ; Point to 0.25
4879+ 3295 CD E3 2B             call    SUBPHL          ; Subtract value from 0.25
4880+ 3298 CD 83 2E             call    TSTSGN          ; Test sign of value
4881+ 329B 37                   scf                     ; Flag positive
4882+ 329C F2 A6 32             jp      P,SIN1          ; Positive - Ok
4883+ 329F CD DA 2B             call    ROUND           ; Add 0.5 to value
4884+ 32A2 CD 83 2E             call    TSTSGN          ; Test sign of value
4885+ 32A5 B7                   or      A               ; Flag negative
4886+ 32A6 F5           SIN1:   push    AF              ; Save sign
4887+ 32A7 F4 AC 2E             call    P,INVSGN        ; Negate value if positive
4888+ 32AA 21 BE 32             ld      HL,QUARTR       ; Point to 0.25
4889+ 32AD CD DD 2B             call    ADDPHL          ; Add 0.25 to value
4890+ 32B0 F1                   pop     AF              ; Restore sign
4891+ 32B1 D4 AC 2E             call    NC,INVSGN       ; Negative - Make positive
4892+ 32B4 21 C2 32             ld      HL,SINTAB       ; Coefficient table
4893+ 32B7 C3 CB 31             jp      SUMSER          ; Evaluate sum of series
4894+ 32BA
4895+ 32BA DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4896+ 32BE
4897+ 32BE 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4898+ 32C2
4899+ 32C2 05           SINTAB: defb    $05             ; Table used by SIN
4900+ 32C3 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4901+ 32C7 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4902+ 32CB 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4903+ 32CF E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4904+ 32D3 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4905+ 32D7
4906+ 32D7 CD B4 2E     TAN:    call    STAKFP          ; Put angle on stack
4907+ 32DA CD 76 32             call    SIN             ; Get SIN of angle
4908+ 32DD C1                   pop     BC              ; Restore angle
4909+ 32DE E1                   pop     HL
4910+ 32DF CD B4 2E             call    STAKFP          ; Save SIN of angle
4911+ 32E2 EB                   ex      DE,HL           ; BCDE = Angle
4912+ 32E3 CD C4 2E             call    FPBCDE          ; Angle to FPREG
4913+ 32E6 CD 70 32             call    COS             ; Get COS of angle
4914+ 32E9 C3 D7 2D             jp      DIV             ; TAN = SIN / COS
4915+ 32EC
4916+ 32EC CD 83 2E     ATN:    call    TSTSGN          ; Test sign of value
4917+ 32EF FC 17 31             call    M,NEGAFT        ; Negate result after if -ve
4918+ 32F2 FC AC 2E             call    M,INVSGN        ; Negate value if -ve
4919+ 32F5 3A 53 53             ld      A,(FPEXP)       ; Get exponent
4920+ 32F8 FE 81                cp      81H             ; Number less than 1?
4921+ 32FA DA 09 33             jp      C,ATN1          ; Yes - Get arc tangnt
4922+ 32FD 01 00 81             ld      BC,$8100        ; BCDE = 1
4923+ 3300 51                   ld      D,C
4924+ 3301 59                   ld      E,C
4925+ 3302 CD D9 2D             call    DVBCDE          ; Get reciprocal of number
4926+ 3305 21 E3 2B             ld      HL,SUBPHL       ; Sub angle from PI/2
4927+ 3308 E5                   push    HL              ; Save for angle > 1
4928+ 3309 21 13 33     ATN1:   ld      HL,ATNTAB       ; Coefficient table
4929+ 330C CD CB 31             call    SUMSER          ; Evaluate sum of series
4930+ 330F 21 BA 32             ld      HL,HALFPI       ; PI/2 - angle in case > 1
4931+ 3312 C9                   ret                     ; Number > 1 - Sub from PI/2
4932+ 3313
4933+ 3313 09           ATNTAB: defb    $09             ; Table used by ATN
4934+ 3314 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
4935+ 3318 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
4936+ 331C FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
4937+ 3320 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
4938+ 3324 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
4939+ 3328 C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
4940+ 332C E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
4941+ 3330 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
4942+ 3334 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
4943+ 3338
4944+ 3338
4945+ 3338 C9           ARET:   ret                     ; A RETurn instruction
4946+ 3339
4947+ 3339 D7           GETINP: rst     $10             ; input a character
4948+ 333A C9                   ret
4949+ 333B
4950+ 333B E5           CLS:    push    HL
4951+ 333C D5                   push    DE
4952+ 333D 3A ED 52             ld      A,(SCR_MODE)    ; check screen mode
4953+ 3340 FE 02                cp      $02             ; G2 mode?
4954+ 3342 CC CE 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
4955+ 3345 D1                   pop     DE
4956+ 3346 E1                   pop     HL
4957+ 3347 3E 0C                ld      A,CS            ; ASCII Clear screen
4958+ 3349 CD EA 19             call    SND2VID         ; send to screen
4959+ 334C C3 90 3F             jp      MONOUT          ; Output character
4960+ 334F
4961+ 334F CD FC 28     WIDTH:  call    GETINT          ; Get integer 0-255
4962+ 3352 7B                   ld      A,E             ; Width to A
4963+ 3353 32 C0 51             ld      (LWIDTH),A      ; Set width
4964+ 3356 C9                   ret
4965+ 3357
4966+ 3357
4967+ 3357              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
4968+ 3357              ; i.e., the first location is the LSB, while the second one is the MSB
4969+ 3357 CD A3 1C     DEEK:   call    DEINT           ; Get integer -32768 to 32767
4970+ 335A D5                   push    DE              ; Save number
4971+ 335B E1                   pop     HL              ; Number to HL
4972+ 335C 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
4973+ 335D 23                   inc     HL
4974+ 335E 7E                   ld      A,(HL)          ; Get MSB of contents
4975+ 335F C3 60 24             jp      ABPASS          ; Return integer AB
4976+ 3362
4977+ 3362              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
4978+ 3362              ; i.e., the LSB will go into the first location, while the MSB into the second one
4979+ 3362 CD 76 20     DOKE:   call    GETNUM          ; Get a number
4980+ 3365 CD A3 1C             call    DEINT           ; Get integer -32768 to 32767
4981+ 3368 D5                   push    DE              ; Save address
4982+ 3369 CD AC 19             call    CHKSYN          ; Make sure ',' follows
4983+ 336C 2C                   defb    ','
4984+ 336D CD 76 20             call    GETNUM          ; Get a number
4985+ 3370 CD A3 1C             call    DEINT           ; Get integer -32768 to 32767
4986+ 3373 E3                   ex      (SP),HL         ; Save value,get address
4987+ 3374 73                   ld      (HL),E          ; Save LSB of value
4988+ 3375 23                   inc     HL
4989+ 3376 72                   ld      (HL),D          ; Save MSB of value
4990+ 3377 E1                   pop     HL              ; Restore code string address
4991+ 3378 C9                   ret
4992+ 3379
4993+ 3379              ; stop the execution of code for a certain bit of time. The pause
4994+ 3379              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
4995+ 3379 CD 76 20     PAUSE:  call    GETNUM          ; Get a number
4996+ 337C CD A3 1C             call    DEINT           ; Get integer -32768 to 32767
4997+ 337F 7A                   ld      A,D             ; load D into A
4998+ 3380 B3                   or      E               ; are D & E equal to $00?
4999+ 3381 C8                   ret     Z               ; if yes, then return
5000+ 3382 C5           DIR_PAU:push    BC              ; store BC
5001+ 3383 3A DB 52             ld      A,(TMRCNT)      ; Load current value of system timer
5002+ 3386 47                   ld      B,A             ; move it into B
5003+ 3387 CD 18 1C     RPTPS:  call    TSTBRK          ; Test for break key
5004+ 338A 3A DB 52             ld      A,(TMRCNT)      ; Load current value of system timer
5005+ 338D B8                   cp      B               ; is it the same value?
5006+ 338E 28 F7                jr      Z,RPTPS         ; yes, so read again
5007+ 3390 47                   ld      B,A             ; no, so store the new value
5008+ 3391 1B                   dec     DE              ; decrement interval
5009+ 3392 7A                   ld      A,D             ; load D into A
5010+ 3393 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5011+ 3394 20 F1                jr      NZ,RPTPS        ; no, repeat
5012+ 3396 C1                   pop     BC              ; yes, recover BC and continue
5013+ 3397 C9                   ret
5014+ 3398
5015+ 3398              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5016+ 3398              ; where X is graphic mode:
5017+ 3398              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5018+ 3398              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5019+ 3398              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5020+ 3398              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5021+ 3398              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5022+ 3398 AF           SCREEN: xor     A
5023+ 3399 32 FE 52             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5024+ 339C CD FC 28             call    GETINT          ; Get integer 0-255
5025+ 339F FE 05                cp      $05             ; is it a valid mode (0~4)?
5026+ 33A1 D2 B8 1C             jp      NC,FCERR        ; No - Illegal function call Error
5027+ 33A4 32 FC 52             ld      (TMPBFR1),A     ; store graphic mode
5028+ 33A7 A7                   and     A               ; is it 0 (text mode)?
5029+ 33A8 CA C4 33             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5030+ 33AB CD 03 34     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5031+ 33AE DA B6 33             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5032+ 33B1 3E 02                ld      A,$02           ; no, so set sprite size
5033+ 33B3 32 FE 52             ld      (TMPBFR2),A     ; ...to 16x16
5034+ 33B6 CD 03 34     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5035+ 33B9 DA C4 33             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5036+ 33BC 3A FE 52             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5037+ 33BF F6 01                or      $01             ; ...set sprite magnification to 2x...
5038+ 33C1 32 FE 52             ld      (TMPBFR2),A     ; ...and save flags again
5039+ 33C4 F3           SCVDP:  di                      ; disable INTs
5040+ 33C5 D5                   push    DE              ; store DE
5041+ 33C6 E5                   push    HL              ; store HL
5042+ 33C7 3A FC 52             ld      A,(TMPBFR1)     ; recover graphic mode
5043+ 33CA 5F                   ld      E,A             ; and store it into E
5044+ 33CB 3A FE 52             ld      A,(TMPBFR2)     ; recover sprite flags
5045+ 33CE 57                   ld      D,A             ; and store them into D
5046+ 33CF D5                   push    DE              ; store D & E
5047+ 33D0 CD D3 03             call    initVDP         ; initialize VDP with mode pointed by E
5048+ 33D3 D1                   pop     DE              ; retrieve D & E
5049+ 33D4 7B                   ld      A,E             ; move graphic mode into A
5050+ 33D5 87                   add     A,A
5051+ 33D6 87                   add     A,A
5052+ 33D7 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5053+ 33D8 5F                   ld      E,A             ; and pass it into E
5054+ 33D9 D5                   push    DE              ; store sprite flags in E
5055+ 33DA 16 00                ld      D,$00           ; reset D
5056+ 33DC 21 15 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5057+ 33DF 19                   add     HL,DE           ; load correct reg#1 setting
5058+ 33E0 D1                   pop     DE              ; retrieve sprite flags from E
5059+ 33E1 7E                   ld      A,(HL)          ; load reg#1 setting
5060+ 33E2 E6 FC                and     %11111100       ; reset size & magn. bits
5061+ 33E4 B2                   or      D               ; set size & magn. bits
5062+ 33E5 5F                   ld      E,A             ; value into E
5063+ 33E6 3E 01                ld      A,$01           ; reg #1
5064+ 33E8 CD A7 06             call    WRITE_VREG      ; send setting to reg #1
5065+ 33EB 2A CD 51             ld      HL,(LINEAT)     ; Get current line number
5066+ 33EE 23                   inc     HL              ; -1 means direct statement
5067+ 33EF 7C                   ld      A,H
5068+ 33F0 B5                   or      L
5069+ 33F1 CC 19 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5070+ 33F4 FB                   ei                      ; re-enable interrupts
5071+ 33F5 E1                   pop     HL              ; restore HL
5072+ 33F6 D1                   pop     DE              ; restore DE
5073+ 33F7 3A EC 52             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5074+ 33FA FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5075+ 33FC D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5076+ 33FD 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5077+ 33FF 32 F8 52             ld      (PRNTVIDEO),A   ; ...video buffer...
5078+ 3402 C9                   ret                     ; ...and return to caller
5079+ 3403
5080+ 3403              ; check an additional argument for SCREEN - There are 2 ways of working:
5081+ 3403              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5082+ 3403              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5083+ 3403 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5084+ 3404 CD ED 1B             call    GETCHR          ; Get next character
5085+ 3407 37                   scf                     ; set carry flag
5086+ 3408 C8                   ret     Z               ; return if nothing follows with Carry=1
5087+ 3409 CD AC 19             call    CHKSYN          ; Make sure ',' follows
5088+ 340C 2C                   defb    ','
5089+ 340D CD FC 28             call    GETINT          ; get value
5090+ 3410 1F                   rra                     ; Carry=bit #0
5091+ 3411 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5092+ 3412 C9                   ret                     ; return
5093+ 3413
5094+ 3413
5095+ 3413              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5096+ 3413              ; a=foreground color / b=background color / c=border color
5097+ 3413              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5098+ 3413              ; the number of arguments is based on the current screen mode
5099+ 3413 CD FC 28     COLOR:  call    GETINT          ; get first value
5100+ 3416 CD BC 34             call    CHKCLR1         ; check if it's in range 1~15
5101+ 3419 32 FC 52             ld      (TMPBFR1),A     ; store it
5102+ 341C 3A ED 52             ld      A,(SCR_MODE)    ; check screen mode
5103+ 341F FE 03                cp      $03             ; is it multicolor mode?
5104+ 3421 20 0D                jr      NZ,CNTCKCL      ; no, continue
5105+ 3423 3E 0F                ld      A,$0F           ; white for...
5106+ 3425 32 FA 52             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5107+ 3428 3A FC 52             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5108+ 342B 32 00 53             ld      (TMPBFR3),A     ; move color into temp buffer 3
5109+ 342E 18 31                jr      CLRMC           ; jump to set color
5110+ 3430 CD AC 19     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5111+ 3433 2C                   defb    ','
5112+ 3434 CD FC 28             call    GETINT          ; get second value
5113+ 3437 CD BC 34             call    CHKCLR1         ; check if it's in range 1~15
5114+ 343A 32 FE 52             ld      (TMPBFR2),A     ; store it
5115+ 343D 3A ED 52             ld      A,(SCR_MODE)    ; check screen mode
5116+ 3440 A7                   and     A               ; is it text mode?
5117+ 3441 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5118+ 3443 CD AC 19             call    CHKSYN          ; Make sure ',' follows
5119+ 3446 2C                   defb    ','
5120+ 3447 CD FC 28             call    GETINT          ; get third value
5121+ 344A CD BC 34             call    CHKCLR1         ; check if it's in range 1~15
5122+ 344D 32 00 53             ld      (TMPBFR3),A     ; store it
5123+ 3450 D5                   push    DE              ; store DE
5124+ 3451 3A ED 52             ld      A,(SCR_MODE)    ; check screen mode
5125+ 3454 FE 01                cp      $01             ; is it G1 mode?
5126+ 3456 28 10                jr      Z,CLRG1         ; yes, jump over
5127+ 3458 FE 02                cp      $02             ; is it G2 mode?
5128+ 345A 28 15                jr      Z,CLRG2         ; yes, jump over
5129+ 345C 18 1C                jr      CLREX2          ; last case can only be ExG2
5130+ 345E CD AF 34     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5131+ 3461 32 00 53     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5132+ 3464 D5                   push    DE              ; store DE
5133+ 3465 F3                   di                      ; disable INTs
5134+ 3466 18 2E                jr      SETBRCL         ; set colors and exit
5135+ 3468 CD AF 34     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5136+ 346B 16 01                ld      D,$01           ; repeat 1 time
5137+ 346D 06 20                ld      B,$20           ; 32 bytes of colors
5138+ 346F 18 10                jr      LOADCLR         ; load colors
5139+ 3471 CD AF 34     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5140+ 3474 16 18                ld      D,$18           ; 18 pages of...
5141+ 3476 06 00                ld      B,$00           ; ...256 bytes each
5142+ 3478 18 07                jr      LOADCLR         ; load colors
5143+ 347A CD AF 34     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5144+ 347D 16 08                ld      D,$08           ; 8 pages of...
5145+ 347F 06 00                ld      B,$00           ; ...256 bytes each
5146+ 3481 E5           LOADCLR:push    HL              ; store HL
5147+ 3482 21 00 20             ld      HL,$2000        ; color table start: $2000
5148+ 3485 F3                   di                      ; disable INTs
5149+ 3486 CD 5D 06             call    SETVDPADRS
5150+ 3489 0E 30                ld      C,VDP_DAT       ; VDP data mode
5151+ 348B ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5152+ 348D 00                   nop
5153+ 348E 00                   nop
5154+ 348F 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5155+ 3491 15                   dec     D               ; did we fill up all the pages?
5156+ 3492 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5157+ 3494 FB                   ei
5158+ 3495 E1                   pop     HL              ; retrieve HL
5159+ 3496 3A FC 52     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5160+ 3499 32 FA 52             ld      (FRGNDCLR),A    ; store it
5161+ 349C 3A FE 52             ld      A,(TMPBFR2)     ; retrieve background color
5162+ 349F 32 FB 52             ld      (BKGNDCLR),A    ; store it
5163+ 34A2 3A 00 53             ld      A,(TMPBFR3)     ; recover border color
5164+ 34A5 5F                   ld      E,A             ; move it into E
5165+ 34A6 3E 07                ld      A,$07           ; set VDP register 7
5166+ 34A8 F3                   di
5167+ 34A9 CD A7 06             call    WRITE_VREG      ; send value to VDP: set border color
5168+ 34AC FB                   ei                      ; re-enable INTs
5169+ 34AD D1                   pop     DE              ; retrieve DE
5170+ 34AE C9                   ret                     ; return to caller
5171+ 34AF
5172+ 34AF
5173+ 34AF              ; mix 2 color nibbles in 1 byte
5174+ 34AF 3A FE 52     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5175+ 34B2 47                   ld      B,A             ; move it into B
5176+ 34B3 3A FC 52             ld      A,(TMPBFR1)     ; retrieve foreground color
5177+ 34B6 87                   add     A,A             ; move foreground color into the high nibble of A
5178+ 34B7 87                   add     A,A
5179+ 34B8 87                   add     A,A
5180+ 34B9 87                   add     A,A
5181+ 34BA B0                   or      B               ; put background color into the low nibble of A
5182+ 34BB C9                   ret                     ; return to caller
5183+ 34BC
5184+ 34BC
5185+ 34BC              ; check if the color is not 0 and into the range 1~15
5186+ 34BC A7           CHKCLR1:and     A               ; is it 0?
5187+ 34BD CA CA 16             jp      Z,SNERR         ; yes, raise a SN error
5188+ 34C0 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5189+ 34C2 D2 CA 16             jp      NC,SNERR        ; no, raise a SN error
5190+ 34C5 C9                   ret                     ; param is OK, can return
5191+ 34C6
5192+ 34C6
5193+ 34C6              ; check if in graphics 2 mode
5194+ 34C6 3A ED 52     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5195+ 34C9 FE 02                cp      $02             ; actually, we can paint only in G2
5196+ 34CB C2 CA 3A             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5197+ 34CE C9                   ret                     ; return to caller
5198+ 34CF
5199+ 34CF
5200+ 34CF              ; print a text in screen 2
5201+ 34CF              ; GPRINT text,x,y[,fc[,bc]]
5202+ 34CF              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5203+ 34CF              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5204+ 34CF              ; colors (1~15), resp.
5205+ 34CF              ; (portions of code are from nippur72)
5206+ 34CF              GX      equ     TMPBFR3
5207+ 34CF              GY      equ     TMPBFR4
5208+ 34CF              TMPCLR  equ     TMPBFR2
5209+ 34CF              MIXCOL  equ     TMPBFR1
5210+ 34CF              TMPADR  equ     VIDEOBUFF
5211+ 34CF              CHRPNT  equ     VIDEOBUFF+$02
5212+ 34CF              NUMCHR  equ     VIDEOBUFF+$04
5213+ 34CF              TMPHL   equ     VIDEOBUFF+$06
5214+ 34CF CD C6 34     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5215+ 34D2 2B                   dec     HL              ; dec 'cos GETCHR INCs
5216+ 34D3 CD ED 1B             call    GETCHR          ; check if something follows
5217+ 34D6 CA CA 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
5218+ 34D9 22 04 53             ld      (VIDEOBUFF),HL  ; save current code string pointer
5219+ 34DC CD 88 20             call    EVAL            ; Evaluate expression
5220+ 34DF CD 7A 20             call    TSTSTR          ; Make sure it's a string
5221+ 34E2 22 0A 53             ld      (TMPHL),HL      ; store code string pointer
5222+ 34E5 CD C1 26             call    GSTRCU          ; Current string to pool
5223+ 34E8 CD D2 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5224+ 34EB ED 43 06 53          ld      (CHRPNT),BC     ; store string pointer
5225+ 34EF ED 53 08 53          ld      (NUMCHR),DE     ; store string lenght
5226+ 34F3 2A 0A 53             ld      HL,(TMPHL)      ; store code string pointer
5227+ 34F6 CD AC 19             call    CHKSYN          ; Make sure ',' follows
5228+ 34F9 2C                   defb    ','
5229+ 34FA CD FC 28             call    GETINT          ; get X coord.
5230+ 34FD FE 20                cp      $20             ; is it in rage 0~31?
5231+ 34FF D2 B8 1C             jp      NC,FCERR        ; Illegal function call error
5232+ 3502 32 00 53             ld      (GX),A          ; store into temp. buffer
5233+ 3505 CD AC 19             call    CHKSYN          ; Make sure ',' follows
5234+ 3508 2C                   defb    ','
5235+ 3509 CD FC 28             call    GETINT          ; get Y coord.
5236+ 350C FE 18                cp      $18             ; is it in range 0~23?
5237+ 350E D2 B8 1C             jp      NC,FCERR        ; Illegal function call error
5238+ 3511 32 02 53             ld      (GY),A          ; store into temp. buffer
5239+ 3514 11 FE 52             ld      DE,TMPCLR
5240+ 3517 3A FB 52             ld      A,(BKGNDCLR)    ; load background color
5241+ 351A 12                   ld      (DE),A          ; store into temp buff
5242+ 351B 3A FA 52             ld      A,(FRGNDCLR)    ; load foreground color
5243+ 351E 1B                   dec     DE
5244+ 351F 1B                   dec     DE
5245+ 3520 12                   ld      (DE),A          ; store into temp buff
5246+ 3521 CD AB 35             call    CKCOL           ; check color
5247+ 3524 CA 2C 35             jp      Z,CNTGPT2       ; if anything follows, jump over
5248+ 3527 13                   inc     DE
5249+ 3528 13                   inc     DE
5250+ 3529 CD AB 35             call    CKCOL           ; check background color
5251+ 352C CD AF 34     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5252+ 352F 32 FC 52             ld      (MIXCOL),A      ; store mixed colors
5253+ 3532 E5                   push    HL              ; store code string address
5254+ 3533 ED 4B 06 53          ld      BC,(CHRPNT)     ; retrieve string pointer
5255+ 3537 ED 5B 08 53          ld      DE,(NUMCHR)     ; retrieve string lenght
5256+ 353B 1C                   inc     E               ; Length + 1
5257+ 353C CD 41 35             call    GPNT            ; print on G2
5258+ 353F E1                   pop     HL              ; recover HL
5259+ 3540 C9                   ret                     ; return to caller
5260+ 3541 D5           GPNT:   push    DE              ; store string lenght (E)
5261+ 3542                      ; calculate VRAM address of first char
5262+ 3542 3A 00 53             LD      A,(GX)          ; load X
5263+ 3545 6F                   ld      L,A             ;
5264+ 3546 26 00                ld      H,0             ; HL = X
5265+ 3548 29                   add     HL,HL           ;
5266+ 3549 29                   add     HL,HL           ;
5267+ 354A 29                   add     HL,HL           ; X=X*8
5268+ 354B 3A 02 53             ld      A,(GY)          ; load Y
5269+ 354E 57                   ld      D,A             ; move it into D
5270+ 354F 1E 00                ld      E,0             ; DE =Y*256
5271+ 3551 19                   add     HL,DE           ; address = X*8 + Y*256
5272+ 3552 22 04 53             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5273+ 3555 D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5274+ 3556 1D           RPGPNT: dec     E               ; Count characters
5275+ 3557 C8                   ret     Z               ; End of string - return
5276+ 3558 D5                   push    DE              ; store chars counter
5277+ 3559                      ; calculate dest address in color vram
5278+ 3559 2A 04 53             ld      HL,(TMPADR)     ; recover VRAM address
5279+ 355C 11 00 20             ld      DE,$2000        ; color map address
5280+ 355F 19                   add     HL,DE           ; HL = $2000 + XY address
5281+ 3560 F3                   di                      ; disable INTs
5282+ 3561                      ; send color settings
5283+ 3561 CD 5D 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5284+ 3564 3A FC 52             ld      A,(MIXCOL)      ; load color settings
5285+ 3567 06 08                ld      B,$08           ; repeat for 8 rows
5286+ 3569 0D                   dec     C              ; VDP data mode
5287+ 356A ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5288+ 356C 00                   nop                     ; wait...
5289+ 356D 00                   nop                     ; ...a...
5290+ 356E 00                   nop                     ; ...while
5291+ 356F 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5292+ 3571                      ; calculate source address
5293+ 3571 2A 06 53             ld      HL,(CHRPNT)     ; load char pointer
5294+ 3574 7E                   ld      A,(HL)          ; get char
5295+ 3575 23                   inc     HL              ; increment char pointer
5296+ 3576 22 06 53             ld      (CHRPNT),HL     ; store char pointer
5297+ 3579 6F                   ld      L,A             ;
5298+ 357A 26 00                ld      H,$00           ; char into HL
5299+ 357C 29                   add     HL,HL           ;
5300+ 357D 29                   add     HL,HL           ;
5301+ 357E 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5302+ 357F 11 1A 48             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5303+ 3582 19                   add     HL,DE           ; HL = start of characters in ROM
5304+ 3583 EB                   ex      DE,HL           ; store address into DE
5305+ 3584 2A 04 53     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5306+ 3587 CD 5D 06             call    SETVDPADRS      ; send it to VDP
5307+ 358A EB                   ex      DE,HL           ; restore address into HL
5308+ 358B 06 08                ld      B,$08           ; repeat for 8 rows
5309+ 358D 0D                   dec     C              ; VDP data mode
5310+ 358E ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5311+ 3590 00                   nop                     ; wait...
5312+ 3591 00                   nop                     ; ...a...
5313+ 3592 00                   nop                     ; ...while
5314+ 3593 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5315+ 3595 FB                   ei                      ; re-enable INTs
5316+ 3596 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5317+ 3599 2A 04 53             ld      HL,(TMPADR)     ; load VRAM address
5318+ 359C 19                   add     HL,DE           ; get address of next VRAM cell
5319+ 359D 22 04 53             ld      (TMPADR),HL     ; store new VRAM address
5320+ 35A0 11 00 18             ld      DE,$1800        ; forbidden address
5321+ 35A3 CD B7 3F             call    CMP16           ; check if the printing has gone out of the screen
5322+ 35A6 D1                   pop     DE              ; retrieve number of chars to be printed
5323+ 35A7 D0                   ret     NC              ; if HL>=$1800 then leave
5324+ 35A8 C3 56 35             jp      RPGPNT          ; otherwise, check if more chars to output
5325+ 35AB
5326+ 35AB              ; used by GPRINT to get a color argument (if present)
5327+ 35AB 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5328+ 35AC CD ED 1B             call    GETCHR          ; Get next character
5329+ 35AF C8                   ret     Z               ; return if nothing follows
5330+ 35B0 CD AC 19             call    CHKSYN          ; Make sure ',' follows
5331+ 35B3 2C                   defb    ','
5332+ 35B4 D5                   push    DE              ; store DE
5333+ 35B5 CD FC 28             call    GETINT          ; get value
5334+ 35B8 CD BC 34             call    CHKCLR1         ; check if color is in range 1~15
5335+ 35BB D1                   pop     DE              ; retrieve DE
5336+ 35BC 12                   ld      (DE),A          ; store color into temp buffer
5337+ 35BD C9                   ret                     ; return to caller
5338+ 35BE
5339+ 35BE
5340+ 35BE              ; paint X,Y[,C]: in graphics mode, fills an area starting
5341+ 35BE              ; at point X,Y, using default color or, if used, with
5342+ 35BE              ; color set by C
5343+ 35BE              ; TMPBFR1       X
5344+ 35BE              ; TMPBFR2       Y
5345+ 35BE              ; TMPBFR3       COLOR
5346+ 35BE              PNT     equ     VIDEOBUFF
5347+ 35BE              SPA     equ     VIDEOBUFF+$02
5348+ 35BE              SPB     equ     VIDEOBUFF+$03
5349+ 35BE              ORGSP   equ     VIDEOBUFF+$04
5350+ 35BE CD C6 34     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5351+ 35C1 CD FC 28             call    GETINT          ; get X
5352+ 35C4 32 FC 52             ld      (TMPBFR1),A     ; store X
5353+ 35C7 CD AC 19             call    CHKSYN          ; Make sure ',' follows
5354+ 35CA 2C                   defb    ','
5355+ 35CB CD FC 28             call    GETINT          ; get Y coords,
5356+ 35CE FE C0                cp      $C0             ; check if Y is in range 0~191
5357+ 35D0 D2 B8 1C             jp      NC,FCERR        ; no, raise an FC error
5358+ 35D3 32 FE 52             ld      (TMPBFR2),A     ; store Y
5359+ 35D6 CD B1 3A             call    CLRPRM          ; check if color has been passed
5360+ 35D9 3A 00 53             ld      A,(TMPBFR3)     ; load color
5361+ 35DC A7                   and     A               ; check if 0
5362+ 35DD CA B8 1C             jp      Z,FCERR         ; yes, raise an error
5363+ 35E0 E5                   push    HL              ; store HL
5364+ 35E1 C5                   push    BC              ; store BC
5365+ 35E2 D5                   push    DE              ; store DE
5366+ 35E3                      ; start algorithm
5367+ 35E3 CD F6 36             call    PNTRTN          ; check if pixel is already set
5368+ 35E6 C2 9A 36             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5369+ 35E9 ED 73 08 53          ld      (ORGSP),SP      ; no, store current Stack Pointer
5370+ 35ED 21 01 00             ld      HL,$0001        ; HL=1
5371+ 35F0 22 04 53             ld      (PNT),HL        ; set PNT
5372+ 35F3 3A FC 52             ld      A,(TMPBFR1)     ; load starting X...
5373+ 35F6 47                   ld      B,A             ; ...into B
5374+ 35F7 3A FE 52             ld      A,(TMPBFR2)     ; load starting Y...
5375+ 35FA 4F                   ld      C,A             ; ...into C
5376+ 35FB C5                   push    BC              ; store starting X,Y into stack
5377+ 35FC                      ; main loop
5378+ 35FC 2A 04 53     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5379+ 35FF 7C                   ld      A,H             ; check if PNT=0
5380+ 3600 B5                   or      L
5381+ 3601 CA 96 36             jp      Z,EXITPAI       ; yes, no more points to process - exit
5382+ 3604 2B                   dec     HL              ; no, so decrement PNT...
5383+ 3605 22 04 53             ld      (PNT),HL        ; ...and store it
5384+ 3608 C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5385+ 3609 CD 9E 36     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5386+ 360C 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5387+ 360E 78                   ld      A,B             ; pixel is reset, check if X1=0
5388+ 360F A7                   and     A               ; (reached the limit of the screen)
5389+ 3610 CA 18 36             jp      Z,PAINT1        ; yes, jump over
5390+ 3613 05                   dec     B               ; no, decrement X1...
5391+ 3614 C3 09 36             jp      PAINT0          ; ...and repeat
5392+ 3617 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5393+ 3618 AF           PAINT1: xor     A               ; reset A
5394+ 3619 57                   ld      D,A             ; set SA=0
5395+ 361A 5F                   ld      E,A             ; set SB=0
5396+ 361B CD 9E 36     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5397+ 361E 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5398+ 3620 78                   ld      A,B             ; copy X1
5399+ 3621 32 FC 52             ld      (TMPBFR1),A     ; into buffer
5400+ 3624 79                   ld      A,C             ; copy Y
5401+ 3625 32 FE 52             ld      (TMPBFR2),A     ; into buffer
5402+ 3628 CD 1C 37             call    CNTPLOT         ; plot pixel X1,Y
5403+ 362B 7A                   ld      A,D             ; load SA into A
5404+ 362C A7                   and     A               ; SA=0?
5405+ 362D 20 1C                jr      NZ,PAINT2       ; no, jump over
5406+ 362F 79                   ld      A,C             ; load Y
5407+ 3630 FE 01                cp      $01             ; Y>0?
5408+ 3632 DA 4B 36             jp      C,PAINT2        ; no, jump over
5409+ 3635 3D                   dec     A               ; yes, Y=Y-1
5410+ 3636 CD 9F 36             call    CHECKPY         ; check pixel X1,Y-1
5411+ 3639 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5412+ 363B 0D                   dec     C               ; Y=Y-1
5413+ 363C C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5414+ 363D 0C                   inc     C               ; retrieve original Y
5415+ 363E 2A 04 53             ld      HL,(PNT)        ; load PNT
5416+ 3641 23                   inc     HL              ; increment PNT
5417+ 3642 22 04 53             ld      (PNT),HL        ; store new PNT
5418+ 3645 3E 01                ld      A,$01           ; set SA=1 and...
5419+ 3647 57                   ld      D,A             ; ...store SA into memory
5420+ 3648 C3 5E 36             jp      PAINT3          ; jump over
5421+ 364B 7A           PAINT2: ld      A,D             ; load SA into A
5422+ 364C 1F                   rra                     ; check if SA=1
5423+ 364D 30 0F                jr      NC,PAINT3       ; no, jump over
5424+ 364F 79                   ld      A,C             ; load Y
5425+ 3650 FE 01                cp      $01             ; Y>0?
5426+ 3652 DA 5E 36             jp      C,PAINT3        ; no, jump over
5427+ 3655 3D                   dec     A               ; Y=Y-1
5428+ 3656 CD 9F 36             call    CHECKPY         ; check pixel X1,Y-1
5429+ 3659 CA 5E 36             jp      Z,PAINT3        ; if pixel is off, jump over
5430+ 365C AF                   xor     A               ; pixel is on, so...
5431+ 365D 57                   ld      D,A             ; ...set SA=0
5432+ 365E 7B           PAINT3: ld      A,E             ; check if...
5433+ 365F A7                   and     A               ; SB=0
5434+ 3660 20 1B                jr      NZ,PAINT4       ; no, jump over
5435+ 3662 79                   ld      A,C             ; load Y
5436+ 3663 FE BF                cp      $BF             ; Y<191?
5437+ 3665 30 16                jr      NC,PAINT4       ; no, jump over
5438+ 3667 3C                   inc     A               ; Y=Y+1
5439+ 3668 CD 9F 36             call    CHECKPY         ; check pixel X1,Y+1
5440+ 366B 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5441+ 366D 0C                   inc     C               ; Y=Y+1
5442+ 366E C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5443+ 366F 0D                   dec     C               ; retrieve original Y
5444+ 3670 2A 04 53             ld      HL,(PNT)        ; PNT
5445+ 3673 23                   inc     HL              ; PNT=PNT+1
5446+ 3674 22 04 53             ld      (PNT),HL        ; store PNT
5447+ 3677 3E 01                ld      A,$01           ; SB=1
5448+ 3679 5F                   ld      E,A             ; set SB
5449+ 367A C3 8F 36             jp      PAINT5          ; jump over
5450+ 367D 7B           PAINT4: ld      A,E             ; load SB
5451+ 367E 1F                   rra                     ; check if SB=1
5452+ 367F 30 0E                jr      NC,PAINT5       ; no, jump over
5453+ 3681 79                   ld      A,C             ; load Y
5454+ 3682 FE BF                cp      $BF             ; Y<191?
5455+ 3684 30 09                jr      NC,PAINT5       ; no, jump over
5456+ 3686 3C                   inc     A               ; Y=Y+1
5457+ 3687 CD 9F 36             call    CHECKPY         ; check pixel X1,Y+1
5458+ 368A CA 8F 36             jp      Z,PAINT5        ; if pixel is off, jump over
5459+ 368D AF                   xor     A               ; pixel is on, so...
5460+ 368E 5F                   ld      E,A             ; ...set SB=0
5461+ 368F 04           PAINT5: inc     B               ; X1=X1+1
5462+ 3690 CA FC 35             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5463+ 3693 C3 1B 36             jp      MNPAINT         ; otherwise, repeat for next X
5464+ 3696 ED 7B 08 53  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5465+ 369A D1           EXITPA2:pop     DE              ; retrieve DE
5466+ 369B C1                   pop     BC              ; retrieve BC
5467+ 369C E1                   pop     HL              ; retrieve HL
5468+ 369D C9                   ret                     ; return to caller
5469+ 369E 79           CHECKPA:ld      A,C             ; copy Y into A
5470+ 369F 32 FE 52     CHECKPY:ld      (TMPBFR2),A     ; store Y
5471+ 36A2 78                   ld      A,B             ; copy X1 into A
5472+ 36A3 32 FC 52             ld      (TMPBFR1),A     ; store X1
5473+ 36A6 C5                   push    BC              ; save X1,Y
5474+ 36A7 D5                   push    DE
5475+ 36A8 CD F6 36             call    PNTRTN          ; check if pixel is set/reset
5476+ 36AB D1                   pop     DE
5477+ 36AC C1                   pop     BC              ; retrieve X1,Y
5478+ 36AD C9                   ret                     ; return to caller
5479+ 36AE
5480+ 36AE
5481+ 36AE              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5482+ 36AE CD C6 34     POINT:  call    CHKG2M          ; check if in graphic mode 2
5483+ 36B1 CD AC 19             call    CHKSYN          ; make sure "(" follows
5484+ 36B4 28                   defb    '('
5485+ 36B5 CD FC 28             call    GETINT          ; get X coords.
5486+ 36B8 32 FC 52             ld      (TMPBFR1),A     ; store it into a temp buffer
5487+ 36BB CD AC 19             call    CHKSYN          ; Make sure ',' follows
5488+ 36BE 2C                   defb    ','
5489+ 36BF CD FC 28             call    GETINT          ; get Y coords,
5490+ 36C2 FE C0                cp      $C0             ; check if Y is in range 0~191
5491+ 36C4 D2 B8 1C             jp      NC,FCERR        ; no, raise an FC error
5492+ 36C7 32 FE 52             ld      (TMPBFR2),A     ; store into a temp buffer
5493+ 36CA CD AC 19             call    CHKSYN          ; make sure ")" follows
5494+ 36CD 29                   defb    ')'
5495+ 36CE E5                   push    HL              ; store current string address - the point after the ")" - ...
5496+ 36CF FD E1                pop     IY              ; ...into IY
5497+ 36D1 CD F6 36             call    PNTRTN          ; check if pixel is set or reset
5498+ 36D4 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5499+ 36D6 AF                   xor     A               ; no, it's OFF. make sure to reset A...
5500+ 36D7 47                   ld      B,A             ; ...and B
5501+ 36D8 E1           PNTEND: pop     HL              ; drop original return point
5502+ 36D9 FD E5                push    IY              ; load current string address from IY into stack
5503+ 36DB 11 61 21             ld      DE,RETNUM       ; Address of Return number from function...
5504+ 36DE D5                   push    DE              ; ...saved on stack
5505+ 36DF C3 60 24             jp      ABPASS          ; return AB
5506+ 36E2 CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5507+ 36E4 F3                   di
5508+ 36E5 CD 7D 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5509+ 36E8 FB                   ei
5510+ 36E9 CB 3F                srl     A               ; shift A...
5511+ 36EB CB 3F                srl     A               ; ...4 times...
5512+ 36ED CB 3F                srl     A               ; ...to move foreground color...
5513+ 36EF CB 3F                srl     A               ; ...into lowest nibble
5514+ 36F1 47                   ld      B,A             ; color into B
5515+ 36F2 AF                   xor     A               ; reset MSB
5516+ 36F3 C3 D8 36             jp      PNTEND          ; return AB
5517+ 36F6 CD 69 37     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5518+ 36F9 57                   ld      D,A             ; store pixel index
5519+ 36FA F3                   di                      ; disable INTs
5520+ 36FB CD 7D 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5521+ 36FE FB                   ei                      ; re-enable INTs
5522+ 36FF A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5523+ 3700 C9                   ret                     ; return to caller
5524+ 3701
5525+ 3701
5526+ 3701              ; PLOT X,Y[,color]
5527+ 3701              ; plot a pixel in graphic mode 2
5528+ 3701 CD C6 34     PLOT:   call    CHKG2M          ; check if in G2 mode
5529+ 3704 CD FC 28             call    GETINT          ; get X coords.
5530+ 3707 32 FC 52             ld      (TMPBFR1),A     ; store it into a temp buffer
5531+ 370A CD AC 19             call    CHKSYN          ; Make sure ',' follows
5532+ 370D 2C                   defb    ','
5533+ 370E CD FC 28             call    GETINT          ; get Y coords,
5534+ 3711 FE C0                cp      $C0             ; check if Y is in range 0~191
5535+ 3713 D2 B8 1C             jp      NC,FCERR        ; no, raise an FC error
5536+ 3716 32 FE 52             ld      (TMPBFR2),A     ; store into a temp buffer
5537+ 3719 CD B1 3A             call    CLRPRM          ; check if param "color" has been passed
5538+ 371C E5           CNTPLOT:push    HL              ; store HL
5539+ 371D C5                   push    BC              ; store BC
5540+ 371E D5                   push    DE              ; store DE
5541+ 371F CD 69 37             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5542+ 3722 D2 5D 37             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5543+ 3725 57                   ld      D,A             ; move pixel value into D
5544+ 3726 3A 00 53             ld      A,(TMPBFR3)     ; retrieve color
5545+ 3729 A7                   and     A               ; is it 0? (background, or reset pixel)
5546+ 372A 20 11                jr      NZ,CNTPLT1      ; no, continue
5547+ 372C F3                   di                      ; yes - so, disable INTs
5548+ 372D CD 7D 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5549+ 3730 FB                   ei                      ; re-enable INTs
5550+ 3731 5F                   ld      E,A             ; store value of cell
5551+ 3732 7A                   ld      A,D             ; retrieve pixel
5552+ 3733 2F                   cpl                     ; revert bits
5553+ 3734 A3                   and     E               ; set video pixel to off
5554+ 3735 F3                   di                      ; disable INTs
5555+ 3736 CD 92 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5556+ 3739 FB                   ei                      ; re-enable INTs
5557+ 373A C3 5D 37             jp      NOGD            ; leave
5558+ 373D 87           CNTPLT1:add     A,A             ; now we move low nibble
5559+ 373E 87                   add     A,A             ; in the high nibble
5560+ 373F 87                   add     A,A             ; by adding A to itself
5561+ 3740 87                   add     A,A             ; 4 times (this is a shift left 4)
5562+ 3741 5F                   ld      E,A             ; move it into E
5563+ 3742 F3                   di                      ; disable INTs
5564+ 3743 CD 7D 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5565+ 3746 FB                   ei
5566+ 3747 B2                   or      D               ; merge new pixel preserving original pattern
5567+ 3748 F3                   di
5568+ 3749 CD 92 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5569+ 374C FB                   ei
5570+ 374D CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5571+ 374F F3                   di
5572+ 3750 CD 7D 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5573+ 3753 FB                   ei
5574+ 3754 E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5575+ 3756 B3                   or      E               ; set new foreground color
5576+ 3757 F3                   di
5577+ 3758 CD 92 06             call    WRITE_VIDEO_LOC ; write new color settings
5578+ 375B FB                   ei                      ; re-enable INTs
5579+ 375C 00                   nop                     ; wait for INTs to be enabled again
5580+ 375D D1           NOGD:   pop     DE              ; retrieve DE
5581+ 375E C1                   pop     BC              ; retrieve BC
5582+ 375F E1                   pop     HL              ; retrieve HL
5583+ 3760 C9                   ret                     ; return to caller
5584+ 3761 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5584+ 3765 08 04 02 01
5585+ 3769                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5586+ 3769
5587+ 3769
5588+ 3769              ; compute the VRAM address of the byte containing the pixel
5589+ 3769              ; being pointed by X,Y (TMPBFR1,TMPBFR1)
5590+ 3769              ; byte address is returned into HL
5591+ 3769              ; pixel is returned into A
5592+ 3769              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5593+ 3769                      ; where R(Y/8) is the remainder of (Y/8)
5594+ 3769                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5595+ 3769 3A FE 52             ld      A,(TMPBFR2)     ; retrieve Y
5596+ 376C FE C0                cp      $C0             ; Y>=192?
5597+ 376E D0                   ret     NC              ; yes, so leave
5598+ 376F 1E 08                ld      E,$08           ; load E with divisor
5599+ 3771 57                   ld      D,A             ; and store into D (dividend)
5600+ 3772 CD E6 3F             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5601+ 3775 4F                   ld      C,A             ; store remainder into C
5602+ 3776 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5603+ 3777 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5604+ 3779 3A FC 52             ld      A,(TMPBFR1)     ; retrieve X
5605+ 377C 57                   ld      D,A             ; and move it into D (dividend)
5606+ 377D CD E6 3F             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5607+ 3780 4F                   ld      C,A             ; store remainder into C
5608+ 3781 7A                   ld      A,D             ; move quotient into A
5609+ 3782 87                   add     A,A             ; multiply quotient by 8
5610+ 3783 87                   add     A,A
5611+ 3784 87                   add     A,A
5612+ 3785 5F                   ld      E,A             ; store result into E
5613+ 3786 16 00                ld      D,$00           ; reset D
5614+ 3788 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5615+ 3789 EB                   ex      DE,HL           ; move VRAM address into DE
5616+ 378A 21 61 37             ld      HL,PXLSET       ; starting address of table for pixel to draw
5617+ 378D 06 00                ld      B,$00           ; reset B
5618+ 378F 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5619+ 3790 7E                   ld      A,(HL)          ; load pixel data
5620+ 3791 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5621+ 3792 37                   scf                     ; set Carry for normal exit
5622+ 3793 C9                   ret                     ; return to caller
5623+ 3794
5624+ 3794
5625+ 3794              ; DRAW X1,Y1,X2,Y2[,color]
5626+ 3794              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5627+ 3794              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5628+ 3794              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5629+ 3794              ; the values. If color is not specified, the foreground color set
5630+ 3794              ; with COLOR will be used
5631+ 3794              X1      equ     TMPBFR1
5632+ 3794              Y1      equ     TMPBFR2
5633+ 3794              X2      equ     VIDEOBUFF
5634+ 3794              Y2      equ     VIDEOBUFF+$02
5635+ 3794              ER      equ     VIDEOBUFF+$04
5636+ 3794              E2      equ     VIDEOBUFF+$06
5637+ 3794              SX      equ     VIDEOBUFF+$08
5638+ 3794              SY      equ     VIDEOBUFF+$0A
5639+ 3794              DX      equ     VIDEOBUFF+$0C
5640+ 3794              DY      equ     VIDEOBUFF+$0E
5641+ 3794 CD C6 34     DRAW:   call    CHKG2M          ; check if in G2 mode
5642+ 3797 CD 99 3A             call    CLRVDBF         ; clear VIDEOBUFF
5643+ 379A CD FC 28             call    GETINT          ; get X1 coords.
5644+ 379D 32 FC 52             ld      (X1),A          ; store it into a temp buffer
5645+ 37A0 CD AC 19             call    CHKSYN          ; Make sure ',' follows
5646+ 37A3 2C                   defb    ','
5647+ 37A4 CD FC 28             call    GETINT          ; get Y1 coords.
5648+ 37A7 FE C0                cp      $C0             ; check if Y1 is in range 0~191
5649+ 37A9 D2 B8 1C             jp      NC,FCERR        ; no, raise an FC error
5650+ 37AC 32 FE 52             ld      (Y1),A          ; store into a temp buffer
5651+ 37AF CD AC 19             call    CHKSYN          ; Make sure ',' follows
5652+ 37B2 2C                   defb    ','
5653+ 37B3 CD FC 28             call    GETINT          ; get X2 coords.
5654+ 37B6 32 04 53             ld      (X2),A          ; store it into a temp buffer
5655+ 37B9 CD AC 19             call    CHKSYN          ; Make sure ',' follows
5656+ 37BC 2C                   defb    ','
5657+ 37BD CD FC 28             call    GETINT          ; get Y2 coords
5658+ 37C0 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5659+ 37C2 D2 B8 1C             jp      NC,FCERR        ; no, raise an FC error
5660+ 37C5 32 06 53             ld      (Y2),A          ; store it into a temp buffer
5661+ 37C8 CD B1 3A             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5662+ 37CB E5                   push    HL              ; store register we'll use
5663+ 37CC D5                   push    DE
5664+ 37CD C5                   push    BC
5665+ 37CE ED 5B FC 52          ld      DE,(X1)         ; load X1 and
5666+ 37D2 2A 04 53             ld      HL,(X2)         ; X2
5667+ 37D5 B7                   or      A               ; clear CARRY
5668+ 37D6 ED 52                sbc     HL,DE           ; DX=X2-X1
5669+ 37D8 CD DC 3F             call    absHL           ; DX=ABS(DX)
5670+ 37DB 22 10 53             ld      (DX),HL         ; store DX
5671+ 37DE 01 FF FF             ld      BC,$FFFF        ; SX=-1
5672+ 37E1 2A FC 52             ld      HL,(X1)
5673+ 37E4 ED 5B 04 53          ld      DE,(X2)
5674+ 37E8 CD B7 3F             call    CMP16           ; X1<X2?
5675+ 37EB CA F4 37             jp      Z,X1GR          ; no, X1=X2
5676+ 37EE F2 F4 37             jp      P,X1GR          ; no, X1>X2
5677+ 37F1 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5678+ 37F4 ED 43 0C 53  X1GR:   ld      (SX),BC         ; store SX
5679+ 37F8 ED 5B FE 52          ld      DE,(Y1)
5680+ 37FC 2A 06 53             ld      HL,(Y2)
5681+ 37FF B7                   or      A               ; clear Carry
5682+ 3800 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5683+ 3802 CD DC 3F             call    absHL           ; DY=ABS(DY)
5684+ 3805 22 12 53             ld      (DY),HL         ; store DY
5685+ 3808 01 FF FF             ld      BC,$FFFF        ; SY=-1
5686+ 380B 2A FE 52             ld      HL,(Y1)
5687+ 380E ED 5B 06 53          ld      DE,(Y2)
5688+ 3812 CD B7 3F             call    CMP16           ; is Y1<Y2?
5689+ 3815 CA 1E 38             jp      Z,Y1GR          ; no, Y1=Y2
5690+ 3818 F2 1E 38             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5691+ 381B 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5692+ 381E ED 43 0E 53  Y1GR:   ld      (SY),BC         ; store SY
5693+ 3822 2A 12 53             ld      HL,(DY)         ; ER=DY
5694+ 3825 CD DF 3F             call    negHL           ; ER=-DY
5695+ 3828 22 08 53             ld      (ER),HL         ; store ER
5696+ 382B 2A 10 53             ld      HL,(DX)
5697+ 382E ED 5B 12 53          ld      DE,(DY)
5698+ 3832 CD B7 3F             call    CMP16           ; DX>DY?
5699+ 3835 CA 41 38             jp      Z,ER2           ; no, DX=DY
5700+ 3838 FA 41 38             jp      M,ER2           ; no, DX<DY
5701+ 383B 2A 10 53             ld      HL,(DX)         ; reload DX
5702+ 383E 22 08 53             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5703+ 3841 2A 08 53     ER2:    ld      HL,(ER)         ; load ER
5704+ 3844 CB 2C                sra     H               ; right shift (and preserve sign)...
5705+ 3846 CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5706+ 3848 CB 7C                bit     7,H             ; is the number negative?
5707+ 384A CA 4E 38             jp      Z,STRE2         ; no, jump over
5708+ 384D 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5709+ 384E 22 08 53     STRE2:  ld      (ER),HL         ; store ER
5710+ 3851 CD 1C 37     RPTDRW: call    CNTPLOT         ; plot first pixel
5711+ 3854 2A FC 52             ld      HL,(X1)
5712+ 3857 ED 5B 04 53          ld      DE,(X2)
5713+ 385B CD B7 3F             call    CMP16           ; X1=X2?
5714+ 385E 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5715+ 3860 2A FE 52             ld      HL,(Y1)         ; yes, so check
5716+ 3863 ED 5B 06 53          ld      DE,(Y2)         ; also Y
5717+ 3867 CD B7 3F             call    CMP16           ; Y1=Y2?
5718+ 386A CA C6 38             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5719+ 386D ED 5B 08 53  CNTDRW: ld      DE,(ER)
5720+ 3871 ED 53 0A 53          ld      (E2),DE         ; E2=ER
5721+ 3875 2A 10 53             ld      HL,(DX)
5722+ 3878 CD DF 3F             call    negHL           ; DX=-DX
5723+ 387B EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5724+ 387C CD B7 3F             call    CMP16           ; E2>-DX?
5725+ 387F CA 9D 38             jp      Z,DXGR          ; no, E2=-DX: jump
5726+ 3882 FA 9D 38             jp      M,DXGR          ; no, E2<-DX: jump
5727+ 3885 2A 08 53             ld      HL,(ER)         ; yes
5728+ 3888 ED 5B 12 53          ld      DE,(DY)
5729+ 388C B7                   or      A               ; clear CARRY
5730+ 388D ED 52                sbc     HL,DE           ; ER=ER-DY
5731+ 388F 22 08 53             ld      (ER),HL
5732+ 3892 2A FC 52             ld      HL,(X1)
5733+ 3895 ED 5B 0C 53          ld      DE,(SX)
5734+ 3899 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5735+ 389A 22 FC 52             ld      (X1),HL
5736+ 389D 2A 0A 53     DXGR:   ld      HL,(E2)
5737+ 38A0 ED 5B 12 53          ld      DE,(DY)
5738+ 38A4 CD B7 3F             call    CMP16           ; E2<DY?
5739+ 38A7 CA 51 38             jp      Z,RPTDRW        ; no, E2=DY: jump
5740+ 38AA F2 51 38             jp      P,RPTDRW        ; no, E2>DY: jump
5741+ 38AD 2A 08 53             ld      HL,(ER)         ; yes
5742+ 38B0 ED 5B 10 53          ld      DE,(DX)
5743+ 38B4 19                   add     HL,DE           ; ER=ER+DX
5744+ 38B5 22 08 53             ld      (ER),HL
5745+ 38B8 2A FE 52             ld      HL,(Y1)
5746+ 38BB ED 5B 0E 53          ld      DE,(SY)
5747+ 38BF 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5748+ 38C0 22 FE 52             ld      (Y1),HL
5749+ 38C3 C3 51 38             jp      RPTDRW          ; repeat
5750+ 38C6 C1           ENDDRAW:pop     BC              ; retrieve BC
5751+ 38C7 D1                   pop     DE              ; retrieve DE
5752+ 38C8 E1                   pop     HL              ; retrieve HL
5753+ 38C9 C9                   ret                     ; return to caller
5754+ 38CA
5755+ 38CA
5756+ 38CA              ; CIRCLE X,Y,R[,C]
5757+ 38CA              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5758+ 38CA              ; and radius R, with optional color C. If color is not specified, the
5759+ 38CA              ; foreground color set with COLOR will be used
5760+ 38CA              XC      equ     VIDEOBUFF
5761+ 38CA              YC      equ     VIDEOBUFF+$02
5762+ 38CA              RADIUS  equ     VIDEOBUFF+$04
5763+ 38CA              XI      equ     VIDEOBUFF+$06
5764+ 38CA              YI      equ     VIDEOBUFF+$08
5765+ 38CA              DC      equ     VIDEOBUFF+$0A
5766+ 38CA CD C6 34     CIRCLE: call    CHKG2M          ; check if in G2 mode
5767+ 38CD CD 99 3A             call    CLRVDBF         ; clear VIDEOBUFF
5768+ 38D0 CD FC 28             call    GETINT          ; get X coords.
5769+ 38D3 32 04 53             ld      (XC),A          ; store it into a temp buffer
5770+ 38D6 CD AC 19             call    CHKSYN          ; Make sure ',' follows
5771+ 38D9 2C                   defb    ','
5772+ 38DA CD FC 28             call    GETINT          ; get Y coords,
5773+ 38DD 32 06 53             ld      (YC),A          ; store it into a temp buffer
5774+ 38E0 CD AC 19             call    CHKSYN          ; Make sure ',' follows
5775+ 38E3 2C                   defb    ','
5776+ 38E4 CD FC 28             call    GETINT          ; get radius
5777+ 38E7 32 08 53             ld      (RADIUS),A      ; store it into a temp buffer
5778+ 38EA CD B1 3A             call    CLRPRM          ; check if param "color" has been passed
5779+ 38ED C5                   push    BC              ; store BC
5780+ 38EE D5                   push    DE              ; store DE
5781+ 38EF E5                   push    HL              ; store HL
5782+ 38F0 AF                   xor     A               ; clear A,
5783+ 38F1 47                   ld      B,A             ; B,
5784+ 38F2 4F                   ld      C,A             ; C,
5785+ 38F3 57                   ld      D,A             ; D,
5786+ 38F4 67                   ld      H,A             ; and H
5787+ 38F5 ED 43 0A 53          ld      (XI),BC         ; clear XI
5788+ 38F9 3A 08 53             ld      A,(RADIUS)      ; load RADIUS into A
5789+ 38FC 6F                   ld      L,A             ; HL now contains R
5790+ 38FD 22 0C 53             ld      (YI),HL         ; YI=RADIUS
5791+ 3900 29                   add     HL,HL           ; R*2
5792+ 3901 EB                   ex      DE,HL           ; put HL into DE
5793+ 3902 21 03 00             ld      HL,$0003        ; HL = 3
5794+ 3905 AF                   xor     A               ; clear Carry
5795+ 3906 ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5796+ 3908 22 0E 53             ld      (DC),HL         ; store D
5797+ 390B CD 6A 39             call    DRWCRL          ; draw initial point
5798+ 390E ED 5B 0A 53  RPTCRL: ld      DE,(XI)         ; load XI
5799+ 3912 2A 0C 53             ld      HL,(YI)         ; load YI
5800+ 3915 CD B7 3F             call    CMP16           ; is YI<DI?
5801+ 3918 CA 21 39             jp      Z,RPTCL1        ; no, YI=XI
5802+ 391B F2 21 39             jp      P,RPTCL1        ; no, YI>XI
5803+ 391E C3 66 39             jp      ENDCRL          ; yes, so we've finished
5804+ 3921 21 0A 53     RPTCL1: ld      HL,XI
5805+ 3924 34                   inc     (HL)            ; XI=XI+1
5806+ 3925 2A 0E 53             ld      HL,(DC)         ; load D
5807+ 3928 7C                   ld      A,H
5808+ 3929 B5                   or      L               ; is D=0? Yes, jump over
5809+ 392A CA 4E 39             jp      Z,DLSZ
5810+ 392D CB 7C                bit     7,H             ; is D<0?
5811+ 392F 20 1D                jr      NZ,DLSZ         ; yes, jump over
5812+ 3931 ED 5B 0C 53          ld      DE,(YI)         ; D>0
5813+ 3935 1B                   dec     DE              ; so, YI=YI-1
5814+ 3936 ED 53 0C 53          ld      (YI),DE         ; store YI
5815+ 393A AF                   xor     A               ; clear Carry
5816+ 393B 2A 0A 53             ld      HL,(XI)
5817+ 393E ED 52                sbc     HL,DE           ; HL=XI-YI
5818+ 3940 29                   add     HL,HL
5819+ 3941 29                   add     HL,HL           ; HL=HL*4
5820+ 3942 11 0A 00             ld      DE,10
5821+ 3945 19                   add     HL,DE           ; HL=HL+10
5822+ 3946 ED 5B 0E 53          ld      DE,(DC)         ; load D
5823+ 394A EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5824+ 394B 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5825+ 394C 18 0F                jr      PLTCRL          ; plot next pixel
5826+ 394E 2A 0A 53     DLSZ:   ld      HL,(XI)         ; load XI
5827+ 3951 29                   add     HL,HL
5828+ 3952 29                   add     HL,HL           ; XI=XI*4
5829+ 3953 11 06 00             ld      DE,$0006
5830+ 3956 19                   add     HL,DE
5831+ 3957 ED 5B 0E 53          ld      DE,(DC)
5832+ 395B EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5833+ 395C 19                   add     HL,DE           ; D=D+4*XI+6
5834+ 395D 22 0E 53     PLTCRL: ld      (DC),HL         ; store new D
5835+ 3960 CD 6A 39             call    DRWCRL          ; plot pixel
5836+ 3963 C3 0E 39             jp      RPTCRL          ; repeat
5837+ 3966 E1           ENDCRL: pop     HL
5838+ 3967 D1                   pop     DE
5839+ 3968 C1                   pop     BC
5840+ 3969 C9                   ret                     ; return to caller
5841+ 396A 2A 04 53     DRWCRL: ld      HL,(XC)
5842+ 396D ED 5B 0A 53          ld      DE,(XI)
5843+ 3971 19                   add     HL,DE           ; X=XC+XI
5844+ 3972 22 FC 52             ld      (X1),HL         ; store X
5845+ 3975 CD 89 3A             call    VALIDX          ; check if X is valid (0~255)
5846+ 3978 DA 8C 39             jp      C,CNTCL1        ; if Carry is set, X is not valid
5847+ 397B 2A 06 53             ld      HL,(YC)
5848+ 397E ED 5B 0C 53          ld      DE,(YI)
5849+ 3982 19                   add     HL,DE           ; Y=YC+YI
5850+ 3983 22 FE 52             ld      (Y1),HL         ; store Y
5851+ 3986 CD 8E 3A             call    VALIDY          ; check if Y is valid (0~191)
5852+ 3989 D4 1C 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5853+ 398C AF           CNTCL1: xor     A               ; clear Carry
5854+ 398D 2A 04 53             ld      HL,(XC)
5855+ 3990 ED 5B 0A 53          ld      DE,(XI)
5856+ 3994 ED 52                sbc     HL,DE           ; X=XC-XI
5857+ 3996 22 FC 52             ld      (X1),HL         ; store X
5858+ 3999 CD 89 3A             call    VALIDX          ; check if X is valid (0~255)
5859+ 399C DA B0 39             jp      C,CNTCL2        ; if Carry is set, X is not valid
5860+ 399F 2A 06 53             ld      HL,(YC)
5861+ 39A2 ED 5B 0C 53          ld      DE,(YI)
5862+ 39A6 19                   add     HL,DE           ; Y=YC+YI
5863+ 39A7 22 FE 52             ld      (Y1),HL         ; store Y
5864+ 39AA CD 8E 3A             call    VALIDY          ; check if Y is valid (0~191)
5865+ 39AD D4 1C 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5866+ 39B0 2A 04 53     CNTCL2: ld      HL,(XC)
5867+ 39B3 ED 5B 0A 53          ld      DE,(XI)
5868+ 39B7 19                   add     HL,DE           ; X=XC+XI
5869+ 39B8 22 FC 52             ld      (X1),HL         ; store X
5870+ 39BB CD 89 3A             call    VALIDX          ; check if X is valid (0~255)
5871+ 39BE DA D4 39             jp      C,CNTCL3        ; if Carry is set, X is not valid
5872+ 39C1 AF                   xor     A               ; clear Carry
5873+ 39C2 2A 06 53             ld      HL,(YC)
5874+ 39C5 ED 5B 0C 53          ld      DE,(YI)
5875+ 39C9 ED 52                sbc     HL,DE           ; Y=YC-YI
5876+ 39CB 22 FE 52             ld      (Y1),HL         ; store Y
5877+ 39CE CD 8E 3A             call    VALIDY          ; check if Y is valid (0~191)
5878+ 39D1 D4 1C 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5879+ 39D4 AF           CNTCL3: xor     A               ; clear Carry
5880+ 39D5 2A 04 53             ld      HL,(XC)
5881+ 39D8 ED 5B 0A 53          ld      DE,(XI)
5882+ 39DC ED 52                sbc     HL,DE           ; X=XC-XI
5883+ 39DE 22 FC 52             ld      (X1),HL         ; store X
5884+ 39E1 CD 89 3A             call    VALIDX          ; check if X is valid (0~255)
5885+ 39E4 DA FA 39             jp      C,CNTCL4        ; if Carry is set, X is not valid
5886+ 39E7 AF                   xor     A               ; clear Carry
5887+ 39E8 2A 06 53             ld      HL,(YC)
5888+ 39EB ED 5B 0C 53          ld      DE,(YI)
5889+ 39EF ED 52                sbc     HL,DE           ; Y=YC-YI
5890+ 39F1 22 FE 52             ld      (Y1),HL         ; store Y
5891+ 39F4 CD 8E 3A             call    VALIDY          ; check if Y is valid (0~191)
5892+ 39F7 D4 1C 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5893+ 39FA 2A 04 53     CNTCL4: ld      HL,(XC)
5894+ 39FD ED 5B 0C 53          ld      DE,(YI)
5895+ 3A01 19                   add     HL,DE           ; X=XC+YI
5896+ 3A02 22 FC 52             ld      (X1),HL         ; store X
5897+ 3A05 CD 89 3A             call    VALIDX          ; check if X is valid (0~255)
5898+ 3A08 DA 1C 3A             jp      C,CNTCL5        ; if Carry is set, X is not valid
5899+ 3A0B 2A 06 53             ld      HL,(YC)
5900+ 3A0E ED 5B 0A 53          ld      DE,(XI)
5901+ 3A12 19                   add     HL,DE           ; Y=YC+XI
5902+ 3A13 22 FE 52             ld      (Y1),HL         ; store Y
5903+ 3A16 CD 8E 3A             call    VALIDY          ; check if Y is valid (0~191)
5904+ 3A19 D4 1C 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5905+ 3A1C AF           CNTCL5: xor     A               ; clear Carry
5906+ 3A1D 2A 04 53             ld      HL,(XC)
5907+ 3A20 ED 5B 0C 53          ld      DE,(YI)
5908+ 3A24 ED 52                sbc     HL,DE           ; X=XC-YI
5909+ 3A26 22 FC 52             ld      (X1),HL         ; store X
5910+ 3A29 CD 89 3A             call    VALIDX          ; check if X is valid (0~255)
5911+ 3A2C DA 40 3A             jp      C,CNTCL6        ; if Carry is set, X is not valid
5912+ 3A2F 2A 06 53             ld      HL,(YC)
5913+ 3A32 ED 5B 0A 53          ld      DE,(XI)
5914+ 3A36 19                   add     HL,DE           ; Y=YC+XI
5915+ 3A37 22 FE 52             ld      (Y1),HL         ; store Y
5916+ 3A3A CD 8E 3A             call    VALIDY          ; check if Y is valid (0~191)
5917+ 3A3D D4 1C 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5918+ 3A40 2A 04 53     CNTCL6: ld      HL,(XC)
5919+ 3A43 ED 5B 0C 53          ld      DE,(YI)
5920+ 3A47 19                   add     HL,DE           ; X=XC+YI
5921+ 3A48 22 FC 52             ld      (X1),HL         ; store X
5922+ 3A4B CD 89 3A             call    VALIDX          ; check if X is valid (0~255)
5923+ 3A4E DA 64 3A             jp      C,CNTCL7        ; if Carry is set, X is not valid
5924+ 3A51 AF                   xor     A               ; clear Carry
5925+ 3A52 2A 06 53             ld      HL,(YC)
5926+ 3A55 ED 5B 0A 53          ld      DE,(XI)
5927+ 3A59 ED 52                sbc     HL,DE           ; Y=YC-XI
5928+ 3A5B 22 FE 52             ld      (Y1),HL         ; store Y
5929+ 3A5E CD 8E 3A             call    VALIDY          ; check if Y is valid (0~191)
5930+ 3A61 D4 1C 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5931+ 3A64 AF           CNTCL7: xor     A               ; clear Carry
5932+ 3A65 2A 04 53             ld      HL,(XC)
5933+ 3A68 ED 5B 0C 53          ld      DE,(YI)
5934+ 3A6C ED 52                sbc     HL,DE           ; X=XC-YI
5935+ 3A6E 22 FC 52             ld      (X1),HL         ; store X
5936+ 3A71 CD 89 3A             call    VALIDX          ; check if X is valid (0~255)
5937+ 3A74 D8                   ret     C               ; if Carry is set, X is not valid
5938+ 3A75 AF                   xor     A               ; clear Carry
5939+ 3A76 2A 06 53             ld      HL,(YC)
5940+ 3A79 ED 5B 0A 53          ld      DE,(XI)
5941+ 3A7D ED 52                sbc     HL,DE           ; Y=YC-XI
5942+ 3A7F 22 FE 52             ld      (Y1),HL         ; store Y
5943+ 3A82 CD 8E 3A             call    VALIDY          ; check if Y is valid (0~191)
5944+ 3A85 D4 1C 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5945+ 3A88 C9                   ret                     ; return to caller
5946+ 3A89
5947+ 3A89              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
5948+ 3A89              ; input: HL (value to check), can be negative
5949+ 3A89              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
5950+ 3A89              ; destroys: A
5951+ 3A89 AF           VALIDX: xor     A               ; reset A
5952+ 3A8A B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
5953+ 3A8B C8                   ret     Z               ; yes, we can return (C is clear)
5954+ 3A8C 37                   scf                     ; set Carry flag to raise error
5955+ 3A8D C9                   ret                     ; return to caller
5956+ 3A8E
5957+ 3A8E AF           VALIDY: xor     A               ; reset A
5958+ 3A8F B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
5959+ 3A90 28 02                jr      Z,CNTVALY       ; yes, continue checking
5960+ 3A92 37                   scf                     ; no, raise error by setting Carry flag
5961+ 3A93 C9                   ret                     ; return to caller
5962+ 3A94 7D           CNTVALY:ld      A,L
5963+ 3A95 FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
5964+ 3A97 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
5965+ 3A98 C9                   ret                     ; return to caller
5966+ 3A99
5967+ 3A99
5968+ 3A99              ; clear VIDEOBUFF before using it as temp buffer
5969+ 3A99 AF           CLRVDBF:xor     A               ; clear A
5970+ 3A9A C5                   push    BC              ; store BC
5971+ 3A9B E5                   push    HL              ; store HL
5972+ 3A9C 21 FC 52             ld      HL,TMPBFR1      ; address of 1st cell
5973+ 3A9F 06 06                ld      B,$06           ; 6 cells
5974+ 3AA1 77           RPTCVB1:ld      (HL),A          ; clear cell
5975+ 3AA2 23                   inc     HL              ; next cell
5976+ 3AA3 10 FC                djnz    RPTCVB1         ; repeat
5977+ 3AA5 06 28                ld      B,$28           ; 40 cells
5978+ 3AA7 21 04 53             ld      HL,VIDEOBUFF    ; address of 1st cell
5979+ 3AAA 77           RPTCVB2:ld      (HL),A          ; clear cell
5980+ 3AAB 23                   inc     HL              ; next cell
5981+ 3AAC 10 FC                djnz    RPTCVB2         ; repeat
5982+ 3AAE E1                   pop     HL              ; retrieve HL
5983+ 3AAF C1                   pop     BC              ; retrieve BC
5984+ 3AB0 C9                   ret                     ; return to caller
5985+ 3AB1
5986+ 3AB1
5987+ 3AB1              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
5988+ 3AB1              ; commands. If not present, the default foreground color will be used
5989+ 3AB1 3A FA 52     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
5990+ 3AB4 32 00 53             ld      (TMPBFR3),A     ; store into temp buffer
5991+ 3AB7 2B                   dec     HL              ; dec 'cos GETCHR INCs
5992+ 3AB8 CD ED 1B             call    GETCHR          ; Get next character
5993+ 3ABB C8                   ret     Z               ; return foreground color if nothing follows
5994+ 3ABC CD AC 19             call    CHKSYN          ; Make sure ',' follows
5995+ 3ABF 2C                   defb    ','
5996+ 3AC0 CD FC 28             call    GETINT          ; get value
5997+ 3AC3 CD C0 34             call    CHKCLR0         ; check if color is in range 0~15
5998+ 3AC6 32 00 53             ld      (TMPBFR3),A     ; store color into temp buffer
5999+ 3AC9 C9                   ret                     ; return to caller
6000+ 3ACA
6001+ 3ACA
6002+ 3ACA              ; no graphics mode error: raised when a graphics command is invoked
6003+ 3ACA              ; out of graphic 2 mode.
6004+ 3ACA 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6005+ 3ACC C3 DE 16             jp      ERROR           ; print error
6006+ 3ACF
6007+ 3ACF
6008+ 3ACF              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6009+ 3ACF              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6010+ 3ACF              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6011+ 3ACF              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6012+ 3ACF              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6013+ 3ACF              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6014+ 3ACF              ; they are assumed to be 8,0,1 resp.
6015+ 3ACF              PRTNUM  equ     VIDEOBUFF
6016+ 3ACF              BPS     equ     VIDEOBUFF+$01
6017+ 3ACF              DATABT  equ     BPS+$02
6018+ 3ACF              PARBT   equ     DATABT+$01
6019+ 3ACF              STPBT   equ     PARBT+$01
6020+ 3ACF              SIOBFR  equ     STPBT+$01
6021+ 3ACF CD FC 28     SERIAL: call    GETINT          ; get port #
6022+ 3AD2 A7                   and     A               ; is it zero?
6023+ 3AD3 CA B8 1C             jp      Z,FCERR         ; yes, error
6024+ 3AD6 FE 03                cp      $03             ; is it 1 or 2?
6025+ 3AD8 D2 F8 3C             jp      NC,SCERR        ; no, error
6026+ 3ADB 32 04 53             ld      (PRTNUM),A      ; store port number into a temp buffer
6027+ 3ADE CD AC 19             call    CHKSYN          ; Make sure ',' follows
6028+ 3AE1 2C                   defb    ','
6029+ 3AE2 2B                   dec     HL
6030+ 3AE3 CD ED 1B             call    GETCHR          ; check what's following
6031+ 3AE6 CA CA 16             jp      Z,SNERR         ; error if nothing follows
6032+ 3AE9 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6033+ 3AEB CD BD 1C             call    ATOH            ; get bps (returned into DE)
6034+ 3AEE 18 0F                jr      CHKZSER         ; jump over
6035+ 3AF0 CD 76 20     SERVAR: call    GETNUM          ; get number
6036+ 3AF3 CD 83 2E             call    TSTSGN          ; check value
6037+ 3AF6 FA B8 1C             jp      M,FCERR         ; negative - illegal function call
6038+ 3AF9 3A 53 53             ld      A,(FPEXP)       ; Get integer value to DE
6039+ 3AFC CD 2B 2F             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6040+ 3AFF 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6041+ 3B00 B3                   or      E               ; check if bps=0
6042+ 3B01 20 3A                jr      NZ,CNTSER       ; no, continue checking
6043+ 3B03                      ; if baud rate is 0, then close the serial comm.
6044+ 3B03 3A 04 53     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6045+ 3B06 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6046+ 3B07 C6 22                add     SIO_CA          ; find correct channel
6047+ 3B09 4F                   ld      C,A             ; store serial channel
6048+ 3B0A F3                   di                      ; disable INTs
6049+ 3B0B AF                   xor     A               ; reset A
6050+ 3B0C 16 01                ld      D,$01           ; start from WR1
6051+ 3B0E 06 05                ld      B,$05           ; 5 registers
6052+ 3B10 ED 51        RPTRSSR:out     (C),D           ; select register
6053+ 3B12 ED 79                out     (C),A           ; reset register
6054+ 3B14 14                   inc     D               ; next register
6055+ 3B15 10 F9                djnz    RPTRSSR         ; repeat
6056+ 3B17 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6057+ 3B19 ED 79                out     (C),A           ; send command to serial channel
6058+ 3B1B 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6059+ 3B1D ED 79                out     (C),A           ; send command to serial channel
6060+ 3B1F FB                   ei                      ; re-enable INTs
6061+ 3B20 E5                   push    HL              ; store HL
6062+ 3B21 21 3E 53             ld      HL,SERIALS_EN   ; serials enabled status byte
6063+ 3B24 DB 01                in      A,(PIO_DB)      ; read status LEDs
6064+ 3B26 CB 41                bit     0,C             ; check serial port
6065+ 3B28 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6066+ 3B2A CB B7                res     6,A             ; it's port 1
6067+ 3B2C CB A7                res     4,A             ; remove possible error LED
6068+ 3B2E CB 86                res     0,(HL)          ; disable port 1
6069+ 3B30 C3 39 3B             jp      SERLED          ; jump over
6070+ 3B33 CB BF        SRPT2:  res     7,A             ; it's port 2
6071+ 3B35 CB AF                res     5,A             ; remove possible error LED
6072+ 3B37 CB 8E                res     1,(HL)          ; disable port 2
6073+ 3B39 D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6074+ 3B3B E1                   pop     HL              ; retrieve HL
6075+ 3B3C C9                   ret                     ; return to caller
6076+ 3B3D                      ; check if bps=1, meaning reactivate RX on serial
6077+ 3B3D 7A           CNTSER: ld      A,D
6078+ 3B3E B2                   or      D               ; check if bps<>1 by first checking D=0
6079+ 3B3F 20 36                jr      NZ,CNTSER2      ; if not, jump over
6080+ 3B41 7B                   ld      A,E             ; then by checking that
6081+ 3B42 FE 01                cp      $01             ; E=1
6082+ 3B44 20 31                jr      NZ,CNTSER2      ; if not, jump over
6083+ 3B46 3A 04 53             ld      A,(PRTNUM)      ; load port number
6084+ 3B49 57                   ld      D,A             ; store port on D
6085+ 3B4A 3A 3E 53             ld      A,(SERIALS_EN)  ; load address of serial status cell
6086+ 3B4D A2                   and     D               ; check status
6087+ 3B4E CA F8 3C             jp      Z,SCERR         ; port not open, raise error
6088+ 3B51 F3                   di                      ; disable INTs
6089+ 3B52 7A                   ld      A,D             ; move port # into A
6090+ 3B53 5F                   ld      E,A             ; and also into E
6091+ 3B54 87                   add     A
6092+ 3B55 87                   add     A               ; move A to left times 2
6093+ 3B56 57                   ld      D,A             ; move value into D
6094+ 3B57 3A 3E 53             ld      A,(SERIALS_EN)  ; load serial status byte
6095+ 3B5A B2                   or      D               ; re-enable RX
6096+ 3B5B 32 3E 53             ld      (SERIALS_EN),A  ; store new serial status
6097+ 3B5E 7B                   ld      A,E             ; recover port #
6098+ 3B5F 3D                   dec     A               ; check port
6099+ 3B60 20 0A                jr      NZ,CNTRX2       ; port is #2
6100+ 3B62 CD DA 01             call    SIO_A_EI        ; re-enable RX on port 1
6101+ 3B65 DB 01                in      A,(PIO_DB)      ; load status LEDs
6102+ 3B67 CB A7                res     4,A             ; remove error LED
6103+ 3B69 C3 73 3B             jp      RXEND           ; terminate setting
6104+ 3B6C CD E2 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6105+ 3B6F DB 01                in      A,(PIO_DB)      ; load status LEDs
6106+ 3B71 CB AF                res     5,A             ; remove error LED
6107+ 3B73 D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6108+ 3B75 FB                   ei                      ; re-enable INTs
6109+ 3B76 C9                   ret                     ; return to caller
6110+ 3B77                      ; set serial port comm.
6111+ 3B77 D5           CNTSER2:push    DE              ; store BPS
6112+ 3B78 3A 04 53             ld      A,(PRTNUM)      ; load port number
6113+ 3B7B 57                   ld      D,A             ; move port # into D
6114+ 3B7C 3A 3E 53             ld      A,(SERIALS_EN)  ; check if serial port is already open
6115+ 3B7F A2                   and     D               ; by ANDing A with D
6116+ 3B80 D1                   pop     DE              ; retrieve BPS
6117+ 3B81 CA 89 3B             jp      Z,CNTSER3       ; not open, continue
6118+ 3B84 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6119+ 3B86 C3 DE 16             jp      ERROR           ; and leave
6120+ 3B89 E5           CNTSER3:push    HL              ; store HL
6121+ 3B8A 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6122+ 3B8D CD B7 3F             call    CMP16           ; is bps<=57,600?
6123+ 3B90 E1                   pop     HL              ; but first, recover HL
6124+ 3B91 DA F8 3C             jp      C,SCERR         ; no (bps>57,600) then error
6125+ 3B94 ED 53 05 53          ld      (BPS),DE        ; store bps
6126+ 3B98 2B                   dec     HL              ; dec 'cos GETCHR INCs
6127+ 3B99 CD ED 1B             call    GETCHR          ; Get next character
6128+ 3B9C CA D4 3B             jp      Z,DEFSER        ; defaults if nothing follows
6129+ 3B9F CD AC 19             call    CHKSYN          ; Make sure ',' follows
6130+ 3BA2 2C                   defb    ','
6131+ 3BA3 CD FC 28             call    GETINT          ; get data bits
6132+ 3BA6 FE 05                cp      $05             ; is it <5?
6133+ 3BA8 DA F8 3C             jp      C,SCERR         ; yes, error
6134+ 3BAB FE 09                cp      $09             ; is it >=9?
6135+ 3BAD D2 B8 1C             jp      NC,FCERR        ; yes, error
6136+ 3BB0 32 07 53             ld      (DATABT),A      ; store data bits
6137+ 3BB3 CD AC 19             call    CHKSYN          ; Make sure ',' follows
6138+ 3BB6 2C                   defb    ','
6139+ 3BB7 CD FC 28             call    GETINT          ; get parity bits
6140+ 3BBA BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6141+ 3BBD D2 F8 3C             jp      NC,SCERR        ; no, error
6142+ 3BC0 32 08 53             ld      (PARBT),A       ; store parity
6143+ 3BC3 CD AC 19             call    CHKSYN          ; Make sure ',' follows
6144+ 3BC6 2C                   defb    ','
6145+ 3BC7 CD FC 28             call    GETINT          ; get stop bits
6146+ 3BCA FE 03                cp      $03             ; is it >=3?
6147+ 3BCC D2 F8 3C             jp      NC,SCERR        ; yes, error
6148+ 3BCF 32 09 53             ld      (STPBT),A       ; store stop bits
6149+ 3BD2 18 0D                jr      SETSER          ; jump to set serial
6150+ 3BD4 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6151+ 3BD6 32 07 53             ld      (DATABT),A
6152+ 3BD9 AF                   xor     A               ; no parity bit
6153+ 3BDA 32 08 53             ld      (PARBT),A
6154+ 3BDD 3C                   inc     A               ; 1 bit for stop
6155+ 3BDE 32 09 53             ld      (STPBT),A
6156+ 3BE1                      ; check if bps are legal
6157+ 3BE1 E5           SETSER: push    HL              ; store HL
6158+ 3BE2 D5                   push    DE              ; store DE
6159+ 3BE3 DD E5                push    IX              ; store IX
6160+ 3BE5 DD 21 D3 3C          ld      IX,SUP_BPS      ; allowed BPSs
6161+ 3BE9 06 0B                ld      B,$0B           ; 11 items
6162+ 3BEB 0E 00                ld      C,$00           ; reset pointer
6163+ 3BED 2A 05 53     CKBPS:  ld      HL,(BPS)        ; load BPS
6164+ 3BF0 DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6165+ 3BF3 DD 56 01             ld      D,(IX+1)        ; load MSB of item
6166+ 3BF6 CD B7 3F             call    CMP16           ; is it equal?
6167+ 3BF9 CA 06 3C             jp      Z,SET_PT        ; yes, found a correspondance
6168+ 3BFC DD 23                inc     IX
6169+ 3BFE DD 23                inc     IX              ; no, go to next entry
6170+ 3C00 0C                   inc     C               ; increment pointer
6171+ 3C01 10 EA                djnz    CKBPS           ; repeat for 10 entries
6172+ 3C03 C3 F4 3C             jp      SCERR1          ; if nothing found, raise an error
6173+ 3C06              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6174+ 3C06                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6175+ 3C06                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6176+ 3C06                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6177+ 3C06 F3                   di                      ; disable INTs
6178+ 3C07 06 00                ld      B,$00           ; reset B
6179+ 3C09 21 E9 3C             ld      HL,CTC_CFG      ; address of first CTC divider
6180+ 3C0C 09                   add     HL,BC           ; adjust for correct CTC divider
6181+ 3C0D 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6182+ 3C0F 3A 04 53             ld      A,(PRTNUM)      ; load port number
6183+ 3C12 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6184+ 3C13 DA 17 3C             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6185+ 3C16 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6186+ 3C17 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6187+ 3C19                                              ; start upon loading time constant, time constant follows, sw reset, command word
6188+ 3C19 ED 79                out     (C),A           ; configure CTC channel
6189+ 3C1B 7E                   ld      A,(HL)          ; load CTC divider
6190+ 3C1C ED 79                out     (C),A           ; send divider
6191+ 3C1E                      ; configure SIO
6192+ 3C1E 21 38 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6193+ 3C21 11 0A 53             ld      DE,SIOBFR       ; into a temp buffer
6194+ 3C24 01 0A 00             ld      BC,$000A        ; 10 items to copy
6195+ 3C27 ED B0                ldir                    ; copy SIO settings into TEMP buffer
6196+ 3C29 3A 0F 53             ld      A,(SIOBFR+5)    ; load WR5 setting
6197+ 3C2C 47                   ld      B,A             ; move it into B
6198+ 3C2D 3A 07 53             ld      A,(DATABT)      ; load DATA bits
6199+ 3C30 FE 05                cp      $05             ; is it 5 bits?
6200+ 3C32 20 06                jr      NZ,BITS6        ; no, jump over
6201+ 3C34 CB B0                res     6,B
6202+ 3C36 CB A8                res     5,B             ; set D6 & D5 to 0
6203+ 3C38 18 19                jr      SETPAR          ; jump to set parity
6204+ 3C3A FE 06        BITS6:  cp      $06             ; is it 6 bits?
6205+ 3C3C 20 06                jr      NZ,BITS7        ; no, jump over
6206+ 3C3E CB F0                set     6,B
6207+ 3C40 CB A8                res     5,B             ; set D6 & D5 to 1,0
6208+ 3C42 18 0F                jr      SETPAR          ; jump to set parity
6209+ 3C44 FE 07        BITS7:  cp      $07             ; is it 7 bits?
6210+ 3C46 20 07                jr      NZ,BITS8        ; no, jump over
6211+ 3C48 CB B0                res     6,B
6212+ 3C4A CB E8                set     5,B             ; set D6 & D5 to 0,1
6213+ 3C4C C3 53 3C             jp      SETPAR          ; jump to set parity
6214+ 3C4F CB F0        BITS8:  set     6,B
6215+ 3C51 CB E8                set     5,B             ; set D6 & D5 to 1,1
6216+ 3C53 21 3F 53     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6217+ 3C56 3A 04 53             ld      A,(PRTNUM)      ; check serial port number
6218+ 3C59 3D                   dec     A               ; is it port #1?
6219+ 3C5A CA 5E 3C             jp      Z,SETPAR2       ; yes, jump over
6220+ 3C5D 23                   inc     HL              ; port #2, use SERBBITS instead
6221+ 3C5E 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6222+ 3C5F 32 0F 53             ld      (SIOBFR+5),A    ; save DATA bits
6223+ 3C62 E6 60                and     %01100000       ; filter only D5&D6 bits
6224+ 3C64 87                   add     A,A             ; shift left times 1
6225+ 3C65 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6226+ 3C66 3A 09 53             ld      A,(STPBT)       ; load STOP bits
6227+ 3C69 87                   add     A,A
6228+ 3C6A 87                   add     A,A             ; 2 left shifts
6229+ 3C6B 47                   ld      B,A             ; move forming byte into B
6230+ 3C6C 3A 08 53             ld      A,(PARBT)       ; load PARITY setting
6231+ 3C6F A7                   and     A               ; is it 0?
6232+ 3C70 CA 7B 3C             jp      Z,STRPAR        ; yes, jump over
6233+ 3C73 CB C0                set     0,B             ; set PARITY on
6234+ 3C75 3D                   dec     A               ; is parity ODD?
6235+ 3C76 CA 7B 3C             jp      Z,STRPAR        ; yes, so jump over
6236+ 3C79 CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6237+ 3C7B 3A 0D 53     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6238+ 3C7E E6 F0                and     %11110000       ; reset STOP & PARITY bits
6239+ 3C80 B0                   or      B               ; set new STOP & PARITY bits
6240+ 3C81 32 0D 53             ld      (SIOBFR+3),A    ; store new value
6241+ 3C84                      ;set up TX and RX:
6242+ 3C84                      ; the followings are settings for channel A
6243+ 3C84 21 0A 53             ld      HL,SIOBFR       ; settings for SIO ch. A
6244+ 3C87 06 06                ld      B,$06           ; 6 bytes to send
6245+ 3C89 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6246+ 3C8B 3A 04 53             ld      A,(PRTNUM)      ; load port number
6247+ 3C8E 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6248+ 3C8F DA 93 3C             jp      C,SRLCNT        ; port 1, continue
6249+ 3C92 0C                   inc     C               ; port 2, increment address port into C
6250+ 3C93 ED B3        SRLCNT: otir                    ; send bytes to SIO
6251+ 3C95                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6252+ 3C95 06 04                ld      B,$04           ; other 4 bytes to send
6253+ 3C97 51                   ld      D,C             ; store port address into D
6254+ 3C98 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6255+ 3C9A ED B3                otir                    ; send bytes to SIO
6256+ 3C9C                      ; the following are settings for selected channel
6257+ 3C9C 3E 01                ld      A,$01           ; write into WR0: select WR1
6258+ 3C9E 4A                   ld      C,D             ; retrieve port address
6259+ 3C9F ED 79                out     (C),A
6260+ 3CA1 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6261+ 3CA3                                              ; buffer overrun is special condition
6262+ 3CA3 ED 79                out     (C),A
6263+ 3CA5 21 3E 53             ld      HL,SERIALS_EN
6264+ 3CA8 3A 04 53             ld      A,(PRTNUM)      ; retrieve serial channel
6265+ 3CAB 3D                   dec     A               ; channel A?
6266+ 3CAC 20 10                jr      NZ,ENCHB        ; no, jump over
6267+ 3CAE CD DA 01             call    SIO_A_EI        ; enable RX on SIO channel A
6268+ 3CB1 CB C6                set     0,(HL)          ; set serial port 1 status ON
6269+ 3CB3 CB D6                set     2,(HL)          ; set serial port 1 RX ON
6270+ 3CB5                      ; back to normal running
6271+ 3CB5 FB                   ei                      ; re-enable INTs
6272+ 3CB6 DB 01                in      A,(PIO_DB)      ; load status LEDs
6273+ 3CB8 CB F7                set     6,A             ; set status LED on
6274+ 3CBA CB A7                res     4,A             ; set error LED off
6275+ 3CBC 18 0E                jr      EXNRM           ; leave
6276+ 3CBE CD E2 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6277+ 3CC1 CB CE                set     1,(HL)          ; set serial port 2 status ON
6278+ 3CC3 CB DE                set     3,(HL)          ; set serial port 2 RX ON
6279+ 3CC5                      ; back to normal running
6280+ 3CC5 FB                   ei                      ; re-enable INTs
6281+ 3CC6 DB 01                in      A,(PIO_DB)      ; load status LEDs
6282+ 3CC8 CB FF                set     7,A             ; set status LED on
6283+ 3CCA CB AF                res     5,A             ; set error LED off
6284+ 3CCC D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6285+ 3CCE DD E1                pop     IX              ; retrieve IX
6286+ 3CD0 D1                   pop     DE              ; retrieve DE
6287+ 3CD1 E1                   pop     HL              ; retrieve HL
6288+ 3CD2 C9                   ret                     ; return to caller
6289+ 3CD3
6290+ 3CD3              ; allowed bps (Bauds per second)
6291+ 3CD3 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6291+ 3CD7 80 70 00 4B
6291+ 3CDB 40 38 80 25
6291+ 3CDF C0 12 10 0E
6291+ 3CE3 60 09 B0 04
6291+ 3CE7 58 02
6292+ 3CE9              ; corresponding CTC divider
6293+ 3CE9 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6293+ 3CED 08 0C 18 20
6293+ 3CF1 30 60 C0
6294+ 3CF4
6295+ 3CF4
6296+ 3CF4              ; serial configuration error
6297+ 3CF4 DD E1        SCERR1: pop     IX              ; retrieve IX
6298+ 3CF6 D1                   pop     DE              ; retrieve DE
6299+ 3CF7 E1                   pop     HL              ; retrieve HL
6300+ 3CF8 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6301+ 3CFA C3 DE 16             jp      ERROR           ; print error
6302+ 3CFD
6303+ 3CFD
6304+ 3CFD              ; serial buffer overrun
6305+ 3CFD CD BA 1E     SOERR:  call    PRNTCRLF
6306+ 3D00 1E 30                ld      E,SO            ; Serial Buffer Overrun
6307+ 3D02 C3 DE 16             jp      ERROR
6308+ 3D05
6309+ 3D05
6310+ 3D05              ; check for direct mode
6311+ 3D05 E5           DIRMOD: push    HL              ; Save code string address
6312+ 3D06 2A CD 51             ld      HL,(LINEAT)     ; Get current line number
6313+ 3D09 23                   inc     HL              ; -1 means direct statement
6314+ 3D0A 7C                   ld      A,H
6315+ 3D0B B5                   or      L
6316+ 3D0C E1                   pop     HL              ; Restore code string address
6317+ 3D0D C2 27 3D             jp      NZ,HLPERR       ; raise error if in indirect mode
6318+ 3D10 C9                   ret
6319+ 3D11
6320+ 3D11
6321+ 3D11              ; HELP lists the line program where an error occured
6322+ 3D11 CD 05 3D     HELP:   call    DIRMOD          ; check if in direct mode
6323+ 3D14 E5                   push    HL              ; store HL
6324+ 3D15 2A CF 51             ld      HL,(HLPLN)      ; load HELP line
6325+ 3D18 23                   inc     HL              ; increment HL
6326+ 3D19 7C                   ld      A,H
6327+ 3D1A B5                   or      L               ; check if there is a line into the HELP reg.
6328+ 3D1B E1                   pop     HL
6329+ 3D1C CA 27 3D             jp      Z,HLPERR        ; no line found, raise error
6330+ 3D1F ED 5B CF 51          ld      DE,(HLPLN)      ; recover line
6331+ 3D23 C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6332+ 3D24 C3 3A 1A             jp      LST01H          ; jump to list line
6333+ 3D27 1E 32        HLPERR: ld      E,HP            ; HELP call error
6334+ 3D29 C3 DE 16             jp      ERROR           ; raise error
6335+ 3D2C
6336+ 3D2C
6337+ 3D2C              ; KEY command to list/modify function keys and auto-repeat
6338+ 3D2C 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6339+ 3D2D CD ED 1B             call    GETCHR          ; Get next character
6340+ 3D30 CA B0 3D             jp      Z,LSTKEYS       ; jump if nothing follows
6341+ 3D33                      ; change FN keys
6342+ 3D33 CD FC 28             call    GETINT          ; get a number
6343+ 3D36 A7                   and     A               ; is it 0?
6344+ 3D37 20 10                jr      NZ,KEYCH        ; no, jump over
6345+ 3D39 E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6346+ 3D3A D5                   push    DE              ; store HL & DE
6347+ 3D3B 21 B8 15             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6348+ 3D3E 11 D1 51             ld      DE,KEYDEL       ; pointer to destination
6349+ 3D41 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6350+ 3D44 ED B0                ldir                    ; restore default texts
6351+ 3D46 D1                   pop     DE              ; retrieve DE
6352+ 3D47 E1                   pop     HL              ; retrieve HL
6353+ 3D48 C9                   ret                     ; return to caller
6354+ 3D49 FE 09        KEYCH:  cp      $09             ; is it >= 9?
6355+ 3D4B D2 63 3E             jp      NC,SETREP       ; yes - jump over
6356+ 3D4E 3D                   dec     A               ; FN key in range 0~7
6357+ 3D4F 87                   add     A,A             ; multiply A...
6358+ 3D50 87                   add     A,A             ; ... times 4...
6359+ 3D51 87                   add     A,A             ; ... to get the correct...
6360+ 3D52 87                   add     A,A             ; ... offset fo FN key text
6361+ 3D53 32 FC 52             ld      (TMPBFR1),A     ; store FN key offset...
6362+ 3D56 AF                   xor     A               ; ...in a...
6363+ 3D57 32 FD 52             ld      (TMPBFR1+1),A   ; ...16-bit register
6364+ 3D5A CD AC 19             call    CHKSYN          ; Make sure ',' follows
6365+ 3D5D 2C                   defb    ','
6366+ 3D5E 44 4D                ld      BC,HL           ; copy address into BC
6367+ 3D60 CD 88 20             call    EVAL            ; Evaluate expression (in E there is the length)
6368+ 3D63 E5                   push    HL              ; store string pointer
6369+ 3D64 3A B2 52             ld      A,(TYPE)        ; Get variable type
6370+ 3D67 B7                   or      A               ; Is it a string variable?
6371+ 3D68 CA CA 16             jp      Z,SNERR         ; no - syntax error
6372+ 3D6B CD C1 26             call    GSTRCU          ; Current string to pool
6373+ 3D6E CD D2 2E             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6374+ 3D71 7B                   ld      A,E             ; copy length into A
6375+ 3D72 FE 11                cp      $11             ; is length > 16?
6376+ 3D74 DA 79 3D             jp      C,DECLN1        ; no, jump over
6377+ 3D77 1E 10                ld      E,$10           ; yes, so set length to 16
6378+ 3D79 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6379+ 3D7B 93                   sub     E               ; ...null chars needed to fill up...
6380+ 3D7C 57                   ld      D,A             ; ...the FN key text
6381+ 3D7D C5                   push    BC              ; store address of string
6382+ 3D7E ED 4B FC 52          ld      BC,(TMPBFR1)    ; load FN key offset
6383+ 3D82 21 D3 51             ld      HL,FNKEYS       ; load address of FN keys texts
6384+ 3D85 09                   add     HL,BC           ; get corrected address
6385+ 3D86 C1                   pop     BC              ; retrieve address of string chars
6386+ 3D87 0A           CPKEY:  ld      A,(BC)          ; load char from string
6387+ 3D88 FE 0D                cp      CR              ; return?
6388+ 3D8A CA 97 3D             jp      Z,CPKEY2        ; yes, store char
6389+ 3D8D FE 7B                cp      $7B             ; if char > "z" ?
6390+ 3D8F D2 CA 16             jp      NC,SNERR        ; yes - syntax error
6391+ 3D92 FE 20                cp      $20             ; is char < space?
6392+ 3D94 DA CA 16             jp      C,SNERR         ; yes - syntax error
6393+ 3D97 FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6394+ 3D99 DA 9E 3D             jp      C,CPKEY3        ; no, continue
6395+ 3D9C E6 5F                and     %01011111       ; set letters to uppercase
6396+ 3D9E 77           CPKEY3: ld      (HL),A          ; store char
6397+ 3D9F 23                   inc     HL              ; next string char
6398+ 3DA0 03                   inc     BC              ; next free cell
6399+ 3DA1 1D                   dec     E               ; decrement E
6400+ 3DA2 20 E3                jr      NZ,CPKEY        ; repeat until 0
6401+ 3DA4 AF                   xor     A               ; null char
6402+ 3DA5 14                   inc     D               ; +1 to decrement below
6403+ 3DA6 15           CPKEY1: dec     D               ; how many null chars to insert?
6404+ 3DA7 CA AE 3D             jp      Z,CPKYEND       ; no more nulls, so exit
6405+ 3DAA 77                   ld      (HL),A          ; store it
6406+ 3DAB 23                   inc     HL              ; next cell
6407+ 3DAC 18 F8                jr      CPKEY1          ; repeat
6408+ 3DAE E1           CPKYEND:pop     HL              ; retrieve pointer to string
6409+ 3DAF C9                   ret                     ; return to caller
6410+ 3DB0                                              ; list FN keys
6411+ 3DB0 E5           LSTKEYS:push    HL              ; Save code string address
6412+ 3DB1 2A CD 51             ld      HL,(LINEAT)     ; Get current line number
6413+ 3DB4 23                   inc     HL              ; -1 means direct statement
6414+ 3DB5 7C                   ld      A,H
6415+ 3DB6 B5                   or      L
6416+ 3DB7 E1                   pop     HL              ; Restore code string address
6417+ 3DB8 C2 CA 16             jp      NZ,SNERR        ; raise error if in indirect mode
6418+ 3DBB E5                   push    HL              ; store HL
6419+ 3DBC D5                   push    DE              ; store DE
6420+ 3DBD 21 D3 51             ld      HL,FNKEYS       ; load starting address of FN keys text
6421+ 3DC0 0E 01                ld      C,$01           ; 8 function keys
6422+ 3DC2 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6423+ 3DC4 11 85 3E     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6424+ 3DC7 CD 54 3E             call    PRTCKEY         ; print it
6425+ 3DCA 79                   ld      A,C             ; load FN key
6426+ 3DCB C6 30                add     $30             ; get number in ASCI code
6427+ 3DCD CD B7 19             call    OUTC            ; print it
6428+ 3DD0 11 8A 3E             ld      DE,CHKEY2       ; message ": ""
6429+ 3DD3 CD 54 3E             call    PRTCKEY         ; print it
6430+ 3DD6 3E 01                ld      A,$01           ; " opened
6431+ 3DD8 32 FC 52             ld      (TMPBFR1),A
6432+ 3DDB 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6433+ 3DDC A7                   and     A               ; is it zero?
6434+ 3DDD CA F0 3D             jp      Z,CNTLTK        ; yes, go next char
6435+ 3DE0 CD 3C 3E             call    OPNQT           ; check if quotes are opened
6436+ 3DE3 FE 22                cp      $22             ; check if char is "?
6437+ 3DE5 CA 05 3E             jp      Z,PRTCHR        ; yes, print "chr$("
6438+ 3DE8 FE 0D                cp      CR              ; is it a CR?
6439+ 3DEA CA 05 3E             jp      Z,PRTCHR        ; yes, print "chr$("
6440+ 3DED CD B7 19     PRTK3:  call    OUTC            ; no, just print it
6441+ 3DF0 23           CNTLTK: inc     HL              ; next char
6442+ 3DF1 10 E8                djnz    LDKEY           ; continue until finished
6443+ 3DF3 CD 2A 3E             call    CLSQT           ; check if quotes are still open
6444+ 3DF6 3E 0D                ld      A,CR            ; go next line
6445+ 3DF8 CD B7 19             call    OUTC            ; print it
6446+ 3DFB 0C                   inc     C               ; next FN key
6447+ 3DFC 79                   ld      A,C             ; check if...
6448+ 3DFD FE 09                cp      $09             ; finished keys?
6449+ 3DFF DA C2 3D             jp      C,PRTK4         ; no, repeat 1 more time
6450+ 3E02 D1                   pop     DE              ; retrieve DE
6451+ 3E03 E1                   pop     HL              ; retrieve HL
6452+ 3E04 C9                   ret                     ; return to caller
6453+ 3E05 E5           PRTCHR: push    HL              ; store HL
6454+ 3E06 CD 2A 3E             call    CLSQT           ; check if quotes are closed
6455+ 3E09 3E 2B                ld      A,'+'           ; '+' char
6456+ 3E0B CD B7 19             call    OUTC            ; print it
6457+ 3E0E 11 8D 3E             ld      DE,CHKEY3       ; address of "CHR$("
6458+ 3E11 CD 54 3E             call    PRTCKEY         ; print it
6459+ 3E14 E1                   pop     HL              ; recover HL
6460+ 3E15 23                   inc     HL              ; next char
6461+ 3E16 05                   dec     B               ; increment char counter
6462+ 3E17 11 93 3E             ld      DE,CHKEY4       ; load address of RETURN
6463+ 3E1A 7E                   ld      A,(HL)          ; load char
6464+ 3E1B FE 0D                cp      CR              ; is it a RETURN?
6465+ 3E1D 20 03                jr      NZ,PTCHR1       ; no, jump over
6466+ 3E1F 11 96 3E             ld      DE,CHKEY5       ; yes, load address of "
6467+ 3E22 CD 54 3E     PTCHR1: call    PRTCKEY         ; print it
6468+ 3E25 3E 29                ld      A,')'           ; char )
6469+ 3E27 C3 ED 3D             jp      PRTK3           ; continue
6470+ 3E2A F5           CLSQT:  push    AF              ; store A
6471+ 3E2B 3A FC 52             ld      A,(TMPBFR1)     ; quote status
6472+ 3E2E A7                   and     A               ; are they closed?
6473+ 3E2F 28 09                jr      Z,CLSQT1        ; if yes, return
6474+ 3E31 3E 22                ld      A,$22           ; no, so close them
6475+ 3E33 CD B7 19             call    OUTC            ; print "
6476+ 3E36 AF                   xor     A               ; set quotes
6477+ 3E37 32 FC 52             ld      (TMPBFR1),A     ; as closed
6478+ 3E3A F1           CLSQT1: pop     AF              ; retrieve A
6479+ 3E3B C9                   ret                     ; return to caller
6480+ 3E3C F5           OPNQT:  push    AF              ; store A
6481+ 3E3D 3A FC 52             ld      A,(TMPBFR1)     ; quote status
6482+ 3E40 A7                   and     A               ; are they open?
6483+ 3E41 20 0F                jr      NZ,OPNQT1       ; if yes, return
6484+ 3E43 3E 2B                ld      A,'+'           ; no, so add '+
6485+ 3E45 CD B7 19             call    OUTC            ; print it
6486+ 3E48 3E 22                ld      A,$22           ; and then open quotes
6487+ 3E4A CD B7 19             call    OUTC            ; print them
6488+ 3E4D 3E 01                ld      A,$01           ; set quotes
6489+ 3E4F 32 FC 52             ld      (TMPBFR1),A     ; as opened
6490+ 3E52 F1           OPNQT1: pop     AF              ; retrieve A
6491+ 3E53 C9                   ret                     ; return to caller
6492+ 3E54 F5           PRTCKEY:push    AF              ; store original char
6493+ 3E55 1A           PRTK1:  ld      A,(DE)          ; load char
6494+ 3E56 A7                   and     A               ; is it 0?
6495+ 3E57 CA 61 3E             jp      Z,PRTEND        ; yes, finished printing
6496+ 3E5A CD B7 19             call    OUTC            ; no, print char
6497+ 3E5D 13                   inc     DE              ; next char
6498+ 3E5E C3 55 3E             jp      PRTK1           ; repeat
6499+ 3E61 F1           PRTEND: pop     AF              ; retrieve AF
6500+ 3E62 C9                   ret                     ; return to caller
6501+ 3E63 FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6502+ 3E65 C2 CA 16             jp      NZ,SNERR        ; no, raise an error
6503+ 3E68 CD AC 19             call    CHKSYN          ; Check for comma
6504+ 3E6B 2C                   defb    ','
6505+ 3E6C CD FC 28             call    GETINT          ; get a number
6506+ 3E6F 32 FC 52             ld      (TMPBFR1),A     ; store it
6507+ 3E72 CD AC 19             call    CHKSYN          ; Check for comma
6508+ 3E75 2C                   defb    ','
6509+ 3E76 CD FC 28             call    GETINT          ; get another number
6510+ 3E79 E5                   push    HL              ; store HL
6511+ 3E7A 21 D2 51             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6512+ 3E7D 77                   ld      (HL),A          ; store auto-repeat delay
6513+ 3E7E 2B                   dec     HL              ; previous cell
6514+ 3E7F 3A FC 52             ld      A,(TMPBFR1)     ; retrieve value
6515+ 3E82 77                   ld      (HL),A          ; store delay for auto-repeat
6516+ 3E83 E1                   pop     HL              ; retrieve HL
6517+ 3E84 C9                   ret
6518+ 3E85 4B 45 59 20  CHKEY1: defb    "KEY ",0
6518+ 3E89 00
6519+ 3E8A 3A 22 00     CHKEY2: defb    ":",34,0
6520+ 3E8D 63 68 72 24  CHKEY3: defb    "chr$(",0
6520+ 3E91 28 00
6521+ 3E93 31 33 00     CHKEY4: defb    "13",0
6522+ 3E96 33 34 00     CHKEY5: defb    "34",0
6523+ 3E99
6524+ 3E99
6525+ 3E99              ; LOAD "filename"
6526+ 3E99              ; load a BASIC program from disk
6527+ 3E99 C9           LOAD:   ret                     ; currently a stub for LOAD
6528+ 3E9A
6529+ 3E9A
6530+ 3E9A              ; SAVE "filename"
6531+ 3E9A              ; save a BASIC program on disk
6532+ 3E9A C9           SAVE:   ret                     ; currently a stub for SAVE
6533+ 3E9B
6534+ 3E9B
6535+ 3E9B              ; FILES
6536+ 3E9B              ; list files on disk
6537+ 3E9B C9           FILES:  ret                     ; currently a stub for FILES
6538+ 3E9C
6539+ 3E9C
6540+ 3E9C              ; ERASE "filename"
6541+ 3E9C              ; erase a file from disk
6542+ 3E9C C9           ERASE:  ret                     ; currently a stub for ERASE
6543+ 3E9D
6544+ 3E9D
6545+ 3E9D              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6546+ 3E9D CD 79 20     HEX: 	call	TSTNUM          ; Verify it's a number
6547+ 3EA0 CD A3 1C             call	DEINT           ; Get integer -32768 to 32767
6548+ 3EA3 C5                   push	BC              ; Save contents of BC
6549+ 3EA4 21 55 53             ld      HL,PBUFF        ; load address of PBUFF into HL
6550+ 3EA7 7A                   ld      A,D             ; Get MSB into A
6551+ 3EA8 B7                   or      A               ; OR with LSB to see if param=0
6552+ 3EA9 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6553+ 3EAB CD D3 3E             call    BYT2ASC         ; Convert D to ASCII
6554+ 3EAE 78                   ld      A,B             ; cechk if B
6555+ 3EAF FE 30                cp      '0'             ; is 0
6556+ 3EB1 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6557+ 3EB3 70                   ld      (HL),B          ; Store it to PBUFF
6558+ 3EB4 23                   inc     HL              ; Next location
6559+ 3EB5 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6560+ 3EB6 23                   inc     HL              ; Next location
6561+ 3EB7 7B           HEX2:   ld      A,E             ; Get lower byte
6562+ 3EB8 CD D3 3E             call    BYT2ASC         ; Convert E to ASCII
6563+ 3EBB 7A                   ld      A,D
6564+ 3EBC B7                   or      A
6565+ 3EBD 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6566+ 3EBF 78                   ld      A,B
6567+ 3EC0 FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6568+ 3EC2 28 02                jr      Z,HEX4
6569+ 3EC4 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6570+ 3EC5 23                   inc     HL              ; Next location
6571+ 3EC6 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6572+ 3EC7 23                   inc     HL              ; PBUFF+4 to zero
6573+ 3EC8 AF                   xor     A               ; Terminating character
6574+ 3EC9 77                   ld      (HL),A          ; Store zero to terminate
6575+ 3ECA 23                   inc     HL              ; Make sure PBUFF is terminated
6576+ 3ECB 77                   ld      (HL),A          ; Store the double zero there
6577+ 3ECC C1                   pop     BC              ; Get BC back
6578+ 3ECD 21 55 53             ld      HL,PBUFF        ; Reset to start of PBUFF
6579+ 3ED0 C3 0E 25             jp      STR1            ; Convert the PBUFF to a string and return it
6580+ 3ED3 47           BYT2ASC:ld      B,A             ; Save original value
6581+ 3ED4 E6 0F                and     $0F             ; Strip off upper nybble
6582+ 3ED6 FE 0A                cp      $0A             ; 0-9?
6583+ 3ED8 38 02                jr      C,ADD30         ; If A-F, add 7 more
6584+ 3EDA C6 07                add     A,$07           ; Bring value up to ASCII A-F
6585+ 3EDC C6 30        ADD30:  add     A,$30           ; And make ASCII
6586+ 3EDE 4F                   ld      C,A             ; Save converted char to C
6587+ 3EDF 78                   ld      A,B             ; Retrieve original value
6588+ 3EE0 0F                   rrca                    ; and Rotate it right
6589+ 3EE1 0F                   rrca
6590+ 3EE2 0F                   rrca
6591+ 3EE3 0F                   rrca
6592+ 3EE4 E6 0F                and     $0F             ; Mask off upper nybble
6593+ 3EE6 FE 0A                cp      $0A             ; 0-9? < A hex?
6594+ 3EE8 38 02                jr      C,ADD301        ; Skip Add 7
6595+ 3EEA C6 07                add     A,$07           ; Bring it up to ASCII A-F
6596+ 3EEC C6 30        ADD301: add     A,$30           ; And make it full ASCII
6597+ 3EEE 47                   ld      B,A             ; Store high order byte
6598+ 3EEF C9                   ret
6599+ 3EF0
6600+ 3EF0              ; Convert "&Hnnnn" to FPREG
6601+ 3EF0              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6602+ 3EF0              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6603+ 3EF0 EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6604+ 3EF1 21 00 00             ld      HL,$0000        ; Zero out the value
6605+ 3EF4 CD 09 3F             call    GETHEX          ; Check the number for valid hex
6606+ 3EF7 DA 29 3F             jp      C,HXERR         ; First value wasn't hex, HX error
6607+ 3EFA 18 05                jr      HEXLP1          ; Convert first character
6608+ 3EFC CD 09 3F     HEXLP:  call    GETHEX          ; Get second and addtional characters
6609+ 3EFF 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6610+ 3F01 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6611+ 3F02 29                   add     HL,HL
6612+ 3F03 29                   add     HL,HL
6613+ 3F04 29                   add     HL,HL
6614+ 3F05 B5                   or      L               ; Add in D0-D3 into L
6615+ 3F06 6F                   ld      L,A             ; Save new value
6616+ 3F07 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6617+ 3F09
6618+ 3F09 13           GETHEX: inc     DE              ; Next location
6619+ 3F0A 1A                   ld      A,(DE)          ; Load character at pointer
6620+ 3F0B FE 20                cp      SPC
6621+ 3F0D CA 09 3F             jp      Z,GETHEX        ; Skip spaces
6622+ 3F10 D6 30                sub     $30             ; Get absolute value
6623+ 3F12 D8                   ret     C               ; < "0", error
6624+ 3F13 FE 0A                cp      $0A
6625+ 3F15 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6626+ 3F17 D6 07                sub     $07             ; Reduce to A-F
6627+ 3F19 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6628+ 3F1B D8                   ret     C               ; CY set if was :            ; < = > ? @
6629+ 3F1C FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6630+ 3F1E 3F                   ccf
6631+ 3F1F C9                   ret                     ; CY set if it wasn't valid hex
6632+ 3F20
6633+ 3F20 EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6634+ 3F21 7A                   ld      A,D             ; Load DE into AC
6635+ 3F22 4B                   ld      C,E             ; For prep to
6636+ 3F23 E5                   push    HL
6637+ 3F24 CD 5F 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6638+ 3F27 E1                   pop     HL
6639+ 3F28 C9                   ret
6640+ 3F29
6641+ 3F29 DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
6642+ 3F2B C3 DE 16             jp      ERROR
6643+ 3F2E
6644+ 3F2E              ; BIN$(NN) Convert integer to a 1-16 char binary string
6645+ 3F2E CD 79 20     BIN:    call    TSTNUM          ; Verify it's a number
6646+ 3F31 CD A3 1C             call    DEINT           ; Get integer -32768 to 32767
6647+ 3F34 C5           BIN2:   push    BC              ; Save contents of BC
6648+ 3F35 21 55 53             ld      HL,PBUFF
6649+ 3F38 06 11                ld      B,$11           ; One higher than max char count (16+1)
6650+ 3F3A              ZEROSUP:                        ; Suppress leading zeros
6651+ 3F3A 05                   dec     B               ; Max 16 chars
6652+ 3F3B 78                   ld      A,B
6653+ 3F3C FE 01                cp      $01
6654+ 3F3E 28 08                jr      Z,BITOUT        ; Always output at least one character
6655+ 3F40 CB 13                rl      E
6656+ 3F42 CB 12                rl      D
6657+ 3F44 30 F4                jr      NC,ZEROSUP
6658+ 3F46 18 04                jr      BITOUT2
6659+ 3F48 CB 13        BITOUT: rl      E
6660+ 3F4A CB 12                rl      D               ; Top bit now in carry
6661+ 3F4C 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6662+ 3F4E CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6663+ 3F50 77                   ld      (HL),A
6664+ 3F51 23                   inc     HL
6665+ 3F52 05                   dec     B
6666+ 3F53 20 F3                jr      NZ,BITOUT
6667+ 3F55 AF                   xor     A               ; Terminating character
6668+ 3F56 77                   ld      (HL),A          ; Store zero to terminate
6669+ 3F57 23                   inc     HL              ; Make sure PBUFF is terminated
6670+ 3F58 77                   ld      (HL),A          ; Store the double zero there
6671+ 3F59 C1                   pop     BC
6672+ 3F5A 21 55 53             ld      HL,PBUFF
6673+ 3F5D C3 0E 25             jp      STR1
6674+ 3F60
6675+ 3F60              ; Convert "&Bnnnn" to FPREG
6676+ 3F60              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6677+ 3F60 EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6678+ 3F61 21 00 00             ld      HL,$0000        ; Zero out the value
6679+ 3F64 CD 7D 3F             call    CHKBIN          ; Check the number for valid bin
6680+ 3F67 DA 8B 3F             jp      C,BINERR        ; First value wasn't bin, HX error
6681+ 3F6A D6 30        BINIT:  sub     '0'
6682+ 3F6C 29                   add     HL,HL           ; Rotate HL left
6683+ 3F6D B5                   or      L
6684+ 3F6E 6F                   ld      L,A
6685+ 3F6F CD 7D 3F             call    CHKBIN          ; Get second and addtional characters
6686+ 3F72 30 F6                jr      NC,BINIT        ; Process if a bin character
6687+ 3F74 EB                   ex      DE,HL           ; Value into DE, Code string into HL
6688+ 3F75 7A                   ld      A,D             ; Load DE into AC
6689+ 3F76 4B                   ld      C,E             ; For prep to
6690+ 3F77 E5                   push    HL
6691+ 3F78 CD 5F 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6692+ 3F7B E1                   pop     HL
6693+ 3F7C C9                   ret
6694+ 3F7D
6695+ 3F7D              ; Char is in A, NC if char is 0 or 1
6696+ 3F7D 13           CHKBIN: inc     DE
6697+ 3F7E 1A                   ld      A,(DE)
6698+ 3F7F FE 20                cp      SPC
6699+ 3F81 CA 7D 3F             jp      Z,CHKBIN        ; Skip spaces
6700+ 3F84 FE 30                cp      '0'             ; Set C if < '0'
6701+ 3F86 D8                   ret     C
6702+ 3F87 FE 32                cp      '2'
6703+ 3F89 3F                   ccf                     ; Set C if > '1'
6704+ 3F8A C9                   ret
6705+ 3F8B
6706+ 3F8B 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6707+ 3F8D C3 DE 16             jp      ERROR
6708+ 3F90
6709+ 3F90
6710+ 3F90 C3 08 00     MONOUT: jp      $0008           ; output a char
6711+ 3F93
6712+ 3F93
6713+ 3F93 3A 3E 53     RESET:  ld      A,(SERIALS_EN)
6714+ 3F96 E6 11                and     $11             ; are serial ports open?
6715+ 3F98 C4 03 3B             call    NZ,RSTSERS      ; yes, reset serials
6716+ 3F9B CD 17 29             call    DISNMI          ; disable NMI vector
6717+ 3F9E F3                   di                      ; disable INTs
6718+ 3F9F                  IFDEF LM80C64K
6719+ 3F9F C3 EF 50             jp      ROM2RAM         ; Restart
6720+ 3FA2                  ELSE
6721+ 3FA2 ~                    jp      $0000           ; Restart
6722+ 3FA2                  ENDIF
6723+ 3FA2
6724+ 3FA2
6725+ 3FA2 3E 00        INITST: ld      A,$00           ; Clear break flag
6726+ 3FA4 32 C7 51             ld      (BRKFLG),A
6727+ 3FA7 C3 F6 11             jp      INIT
6728+ 3FAA
6729+ 3FAA
6730+ 3FAA F5           TSTBIT: push    AF              ; Save bit mask
6731+ 3FAB A0                   and     B               ; Get common bits
6732+ 3FAC C1                   pop     BC              ; Restore bit mask
6733+ 3FAD B8                   cp      B               ; Same bit set?
6734+ 3FAE 3E 00                ld      A,$00           ; Return 0 in A
6735+ 3FB0 C9                   ret
6736+ 3FB1
6737+ 3FB1 CD B7 19     OUTNCR: call    OUTC            ; Output character in A
6738+ 3FB4 C3 BA 1E             jp      PRNTCRLF        ; Output CRLF
6739+ 3FB7
# file closed: ../include/basic/basic-1.03.asm
  79  3FB7
  80  3FB7              ; include utils
  81  3FB7                  INCLUDE "../include/utils/utils-r11.asm"
# file opened: ../include/utils/utils-r11.asm
   1+ 3FB7              ; ------------------------------------------------------------------------------
   2+ 3FB7              ; LM80C - UTILITY ROUTINES - R1.1
   3+ 3FB7              ; ------------------------------------------------------------------------------
   4+ 3FB7              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 3FB7              ; designed by Leonardo Miliani. More info at
   6+ 3FB7              ; www DOT leonardomiliani DOT com
   7+ 3FB7              ;
   8+ 3FB7              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 3FB7              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 3FB7              ;
  11+ 3FB7              ; * WKT are routines from WikiTI:
  12+ 3FB7              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 3FB7              ;
  14+ 3FB7              ; * LAC are routines from Learn@Cemetch
  15+ 3FB7              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 3FB7              ;
  17+ 3FB7              ; ------------------------------------------------------------------------------
  18+ 3FB7              ; Code Revision:
  19+ 3FB7              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 3FB7              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 3FB7              ;
  22+ 3FB7              ; ------------------------------------------------------------------------------
  23+ 3FB7
  24+ 3FB7              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  25+ 3FB7              ; values can be both signed or unsigned words
  26+ 3FB7              ; inputs: HL, DE
  27+ 3FB7              ; destroys: A,F,HL
  28+ 3FB7              ;
  29+ 3FB7              ; returns: Z=1 if HL = DE
  30+ 3FB7              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  31+ 3FB7              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  32+ 3FB7              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  33+ 3FB7              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  34+ 3FB7              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  35+ 3FB7              ; Source: ALS
  36+ 3FB7
  37+ 3FB7 B7           CMP16:  or      A           ; clear CARRY
  38+ 3FB8 ED 52                sbc     HL,DE       ; subtract DE from HL
  39+ 3FBA E0                   ret     PO          ; return if no overflow
  40+ 3FBB 7C                   ld      A,H         ; overflow - invert SIGN flag
  41+ 3FBC 1F                   rra                 ; save CARRY flag in bit 7
  42+ 3FBD EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  43+ 3FBF 37                   scf                 ; ensure a Non-Zero result
  44+ 3FC0 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  45+ 3FC1                                          ; ZERO flag = 0 for sure
  46+ 3FC1 C9                   ret                 ; return
  47+ 3FC2
  48+ 3FC2              ; ----------------------------------------------------------------------
  49+ 3FC2
  50+ 3FC2              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  51+ 3FC2              ; signed/unsigned product
  52+ 3FC2              ; inputs: HL (multiplicand); DE (multiplier)
  53+ 3FC2              ; destroys: A,F
  54+ 3FC2              ; returns: HL (product)
  55+ 3FC2              ; Source: ALS
  56+ 3FC2
  57+ 3FC2              ; initialize partial product, bit count
  58+ 3FC2 C5           MUL16:  push    BC
  59+ 3FC3 4D                   ld      C,L         ; BC = multiplier
  60+ 3FC4 44                   ld      B,H
  61+ 3FC5 21 00 00             ld      HL,0        ; product = 0
  62+ 3FC8 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  63+ 3FCA                      ; shift-and-add algorithm
  64+ 3FCA                      ; if MSB of multiplier is 1, add multiplicand to partial product
  65+ 3FCA                      ; shift partial product, multiplier left 1 bit
  66+ 3FCA CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  67+ 3FCC CB 12                rl      D
  68+ 3FCE 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  69+ 3FD0 09                   add     HL,BC       ; add multiplicand to partial product
  70+ 3FD1 29           MLP1:   add     HL,HL       ; shift partial product left
  71+ 3FD2 3D                   dec     A
  72+ 3FD3 20 F5                jr      NZ,MLP      ; continue until count = 0
  73+ 3FD5                      ; add multiplicand one last time if MSB of multiplier is 1
  74+ 3FD5 B2                   or      D           ; sign flag = MSB of multiplier
  75+ 3FD6 F2 DA 3F             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  76+ 3FD9 09                   add     HL,BC       ; add multiplicand to product
  77+ 3FDA C1           EXMUL16:pop     BC
  78+ 3FDB C9                   ret
  79+ 3FDC
  80+ 3FDC              ; ----------------------------------------------------------------------
  81+ 3FDC              ; absolute value of HL (same applies to other 16-bit register pairs)
  82+ 3FDC              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
  83+ 3FDC              ;
  84+ 3FDC              ; inputs: HL
  85+ 3FDC              ; destroys: A
  86+ 3FDC              ; operation: ABS(HL)
  87+ 3FDC              ; returns: HL with no sign or negated
  88+ 3FDC              ; Source: WKT
  89+ 3FDC
  90+ 3FDC CB 7C        absHL:  bit     7,H
  91+ 3FDE C8                   ret     Z
  92+ 3FDF AF           negHL:  xor     A
  93+ 3FE0 95                   sub     L
  94+ 3FE1 6F                   ld      L,A
  95+ 3FE2 9F                   sbc     A,A
  96+ 3FE3 94                   sub     H
  97+ 3FE4 67                   ld      H,A
  98+ 3FE5 C9                   ret
  99+ 3FE6
 100+ 3FE6              ; ------------------------------------------------------------------------------
 101+ 3FE6
 102+ 3FE6              ; 8/8 division
 103+ 3FE6              ; INPUT: D (dividend), E (divisor)
 104+ 3FE6              ; OPERATION: D/E
 105+ 3FE6              ; OUTPUT: D (quotient), A (remainder)
 106+ 3FE6 AF           DIV_8_8:    xor     A
 107+ 3FE7 C5                       push    BC
 108+ 3FE8 06 08                    ld      B,08h
 109+ 3FEA CB 22        DIV_8_8LOOP:sla     D
 110+ 3FEC 17                       rla
 111+ 3FED BB                       cp      E
 112+ 3FEE 38 02                    jr      C,$+4
 113+ 3FF0 93                       sub     E
 114+ 3FF1 14                       inc     D
 115+ 3FF2 10 F6                    djnz    DIV_8_8LOOP
 116+ 3FF4 C1                       pop     BC
 117+ 3FF5 C9                       ret
 118+ 3FF6
 119+ 3FF6              ; ----------------------------------------------------------------------
 120+ 3FF6              ; divide a 16-bit number by an 8-bit number
 121+ 3FF6              ; (16/8 division)
 122+ 3FF6              ;
 123+ 3FF6              ; inputs: HL (Dividend), C (divisor)
 124+ 3FF6              ; destroys: A
 125+ 3FF6              ; OPERATION: HL/C
 126+ 3FF6              ; returns: HL (quotient), A (remainder)
 127+ 3FF6              ; source: WKT
 128+ 3FF6
 129+ 3FF6 AF           DIV_16_8:   xor     A
 130+ 3FF7 06 10                    ld      B,16
 131+ 3FF9 29           DIV_16_8LP: add     HL,HL
 132+ 3FFA 17                       rla
 133+ 3FFB 38 03                    jr      C,$+5
 134+ 3FFD B9                       cp      C
 135+ 3FFE 38 02                    jr      C,$+4
 136+ 4000 91                       sub     C
 137+ 4001 2C                       inc     L
 138+ 4002 10 F5                    djnz    DIV_16_8LP
 139+ 4004 C9                       ret
 140+ 4005
 141+ 4005              ; ----------------------------------------------------------------------
 142+ 4005              ; divide a 16-bit number by a 16-bit number
 143+ 4005              ; (16/16 division)
 144+ 4005              ;
 145+ 4005              ; inputs: AC (Dividend), DE (divisor)
 146+ 4005              ; destroys: HL,A,C
 147+ 4005              ; OPERATION: AC/DE
 148+ 4005              ; returns: AC (quotient), HL (remainder)
 149+ 4005              ; source: WKT
 150+ 4005 21 00 00     DIV_16_16:  ld      HL, 0
 151+ 4008 06 10                    ld      B, 16
 152+ 400A CB 21        DV16_16_LP: sla     C
 153+ 400C CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 154+ 400E 17                       rla
 155+ 400F ED 6A                    adc     HL,HL
 156+ 4011 ED 52                    sbc     HL,DE
 157+ 4013 30 02                    jr      NC, $+4
 158+ 4015 19                       add     HL,DE
 159+ 4016 0D                       dec     C
 160+ 4017 10 F1                    djnz    DV16_16_LP
 161+ 4019 C9                       ret
# file closed: ../include/utils/utils-r11.asm
  82  401A
  83  401A              ; include the latest version of the font sets
  84  401A                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 401A              ; ------------------------------------------------------------------------------
   2+ 401A              ; LM80C - 6x8 CHARSET - R1.6
   3+ 401A              ; ------------------------------------------------------------------------------
   4+ 401A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 401A              ; designed by Leonardo Miliani. More info at
   6+ 401A              ; www DOT leonardomiliani DOT com
   7+ 401A              ; ------------------------------------------------------------------------------
   8+ 401A              ; Code Revision:
   9+ 401A              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 401A              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 401A              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 401A              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 401A              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 401A              ; R1.5 - 20200524 - New style for char #252
  15+ 401A              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 401A              ; ------------------------------------------------------------------------------
  17+ 401A              ;
  18+ 401A              ;-------------------------------------------------------------------------------
  19+ 401A              ;
  20+ 401A              ;               6 x 8    C  H  A  R  S  E  T
  21+ 401A              ;
  22+ 401A              ;-------------------------------------------------------------------------------
  23+ 401A              ;
  24+ 401A              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 401A              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 401A
  27+ 401A              CHRST68 equ $
  28+ 401A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 401E 00 00 00 00
  29+ 4022 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 4026 00 00 00 00
  30+ 402A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 402E 00 00 00 00
  31+ 4032 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 4036 00 00 00 00
  32+ 403A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 403E 00 00 00 00
  33+ 4042 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 4046 00 00 00 00
  34+ 404A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 404E 00 00 00 00
  35+ 4052 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 4056 00 00 00 00
  36+ 405A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 405E 00 00 00 00
  37+ 4062 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 4066 00 00 00 00
  38+ 406A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 406E 00 00 00 00
  39+ 4072 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 4076 00 00 00 00
  40+ 407A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 407E 00 00 00 00
  41+ 4082 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 4086 00 00 00 00
  42+ 408A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 408E 00 00 00 00
  43+ 4092 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 4096 00 00 00 00
  44+ 409A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 409E 00 00 00 00
  45+ 40A2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 40A6 00 00 00 00
  46+ 40AA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 40AE 00 00 00 00
  47+ 40B2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 40B6 00 00 00 00
  48+ 40BA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 40BE 00 00 00 00
  49+ 40C2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 40C6 00 00 00 00
  50+ 40CA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 40CE 00 00 00 00
  51+ 40D2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 40D6 00 00 00 00
  52+ 40DA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 40DE 00 00 00 00
  53+ 40E2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 40E6 00 00 00 00
  54+ 40EA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 40EE 00 00 00 00
  55+ 40F2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 40F6 00 00 00 00
  56+ 40FA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 40FE 00 00 00 00
  57+ 4102 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 4106 00 00 00 00
  58+ 410A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 410E 00 00 00 00
  59+ 4112 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 4116 00 00 00 00
  60+ 411A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 411E 00 00 00 00
  61+ 4122 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 4126 20 00 20 00
  62+ 412A 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 412E 00 00 00 00
  63+ 4132 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 4136 F8 50 50 00
  64+ 413A 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 413E 28 F0 20 00
  65+ 4142 C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 4146 40 98 18 00
  66+ 414A 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 414E A8 90 68 00
  67+ 4152 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 4156 00 00 00 00
  68+ 415A 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 415E 40 20 10 00
  69+ 4162 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 4166 10 20 40 00
  70+ 416A 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 416E A8 20 00 00
  71+ 4172 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 4176 20 20 00 00
  72+ 417A 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 417E 60 20 40 00
  73+ 4182 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 4186 00 00 00 00
  74+ 418A 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 418E 00 60 60 00
  75+ 4192 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 4196 40 80 00 00
  76+ 419A 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 419E C8 88 70 00
  77+ 41A2 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 41A6 20 20 70 00
  78+ 41AA 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 41AE 20 40 F8 00
  79+ 41B2 F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 41B6 08 88 70 00
  80+ 41BA 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 41BE F8 10 10 00
  81+ 41C2 F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 41C6 08 88 70 00
  82+ 41CA 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 41CE 88 88 70 00
  83+ 41D2 F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 41D6 40 40 40 00
  84+ 41DA 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 41DE 88 88 70 00
  85+ 41E2 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 41E6 08 10 60 00
  86+ 41EA 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 41EE 30 30 00 00
  87+ 41F2 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 41F6 30 10 20 00
  88+ 41FA 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 41FE 40 20 10 00
  89+ 4202 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 4206 F8 00 00 00
  90+ 420A 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 420E 10 20 40 00
  91+ 4212 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 4216 20 00 20 00
  92+ 421A 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 421E A8 A8 70 00
  93+ 4222 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 4226 F8 88 88 00
  94+ 422A F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 422E 88 88 F0 00
  95+ 4232 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 4236 80 88 70 00
  96+ 423A E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 423E 88 90 E0 00
  97+ 4242 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 4246 80 80 F8 00
  98+ 424A F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 424E 80 80 80 00
  99+ 4252 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 4256 88 88 78 00
 100+ 425A 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 425E 88 88 88 00
 101+ 4262 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 4266 20 20 70 00
 102+ 426A 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 426E 10 90 60 00
 103+ 4272 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 4276 A0 90 88 00
 104+ 427A 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 427E 80 80 F8 00
 105+ 4282 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 4286 88 88 88 00
 106+ 428A 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 428E 88 88 88 00
 107+ 4292 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 4296 88 88 70 00
 108+ 429A F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 429E 80 80 80 00
 109+ 42A2 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 42A6 A8 90 68 00
 110+ 42AA F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 42AE A0 90 88 00
 111+ 42B2 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 42B6 08 08 F0 00
 112+ 42BA F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 42BE 20 20 20 00
 113+ 42C2 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 42C6 88 88 70 00
 114+ 42CA 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 42CE 88 50 20 00
 115+ 42D2 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 42D6 A8 A8 50 00
 116+ 42DA 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 42DE 50 88 88 00
 117+ 42E2 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 42E6 20 20 20 00
 118+ 42EA F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 42EE 40 80 F8 00
 119+ 42F2 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 42F6 40 40 70 00
 120+ 42FA 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 42FE 10 08 00 00
 121+ 4302 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 4306 10 10 70 00
 122+ 430A 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 430E 00 00 00 00
 123+ 4312 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 4316 00 00 00 FC
 124+ 431A 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 431E 00 00 00 00
 125+ 4322 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 4326 78 88 78 00
 126+ 432A 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 432E C8 88 F0 00
 127+ 4332 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 4336 80 88 70 00
 128+ 433A 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 433E 98 88 78 00
 129+ 4342 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 4346 F8 80 70 00
 130+ 434A 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 434E 40 40 40 00
 131+ 4352 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 4356 78 08 70 00
 132+ 435A 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 435E 88 88 88 00
 133+ 4362 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 4366 20 20 20 00
 134+ 436A 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 436E 08 88 70 00
 135+ 4372 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 4376 C0 A0 90 00
 136+ 437A 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 437E 20 20 70 00
 137+ 4382 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 4386 A8 88 88 00
 138+ 438A 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 438E 88 88 88 00
 139+ 4392 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 4396 88 88 70 00
 140+ 439A 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 439E F0 80 80 00
 141+ 43A2 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 43A6 78 08 08 00
 142+ 43AA 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 43AE 80 80 80 00
 143+ 43B2 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 43B6 70 08 F0 00
 144+ 43BA 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 43BE 40 48 30 00
 145+ 43C2 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 43C6 88 98 68 00
 146+ 43CA 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 43CE 88 50 20 00
 147+ 43D2 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 43D6 A8 A8 50 00
 148+ 43DA 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 43DE 20 50 88 00
 149+ 43E2 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 43E6 68 08 70 00
 150+ 43EA 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 43EE 20 40 F8 00
 151+ 43F2 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 43F6 20 20 10 00
 152+ 43FA 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 43FE 20 20 20 00
 153+ 4402 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 4406 10 10 20 00
 154+ 440A 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 440E 00 00 00 00
 155+ 4412 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 4416 00 00 00 00
 156+ 441A 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 441E B4 84 78 00
 157+ 4422 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 4426 B4 CC 78 00
 158+ 442A 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 442E FC 78 30 00
 159+ 4432 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 4436 F8 70 20 00
 160+ 443A 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 443E A8 20 70 00
 161+ 4442 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 4446 A8 20 70 00
 162+ 444A 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 444E FC 30 30 30
 163+ 4452 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 4456 3C 30 30 30
 164+ 445A 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 445E F0 30 30 30
 165+ 4462 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 4466 F0 00 00 00
 166+ 446A 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 446E 3C 00 00 00
 167+ 4472 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 4476 FC 00 00 00
 168+ 447A 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 447E 3C 30 30 30
 169+ 4482 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 4486 FC 30 30 30
 170+ 448A 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 448E F0 30 30 30
 171+ 4492 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 4496 FC 00 00 00
 172+ 449A 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 449E 30 30 30 30
 173+ 44A2 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 44A6 70 60 E0 C0
 174+ 44AA C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 44AE 38 18 1C 0C
 175+ 44B2 CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 44B6 30 78 CC CC
 176+ 44BA 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 44BE 20 20 20 20
 177+ 44C2 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 44C6 20 20 20 20
 178+ 44CA 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 44CE 20 20 20 20
 179+ 44D2 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 44D6 00 00 00 00
 180+ 44DA 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 44DE 00 00 00 00
 181+ 44E2 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 44E6 00 00 00 00
 182+ 44EA 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 44EE 20 20 20 20
 183+ 44F2 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 44F6 20 20 20 20
 184+ 44FA 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 44FE 20 20 20 20
 185+ 4502 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 4506 00 00 00 00
 186+ 450A 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 450E 20 20 20 20
 187+ 4512 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 4516 20 40 40 80
 188+ 451A 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 451E 10 08 08 04
 189+ 4522 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 4526 30 48 48 84
 190+ 452A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 452E 00 00 FC FC
 191+ 4532 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 4536 FC FC FC FC
 192+ 453A 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 453E FC FC FC FC
 193+ 4542 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 4546 00 00 00 00
 194+ 454A FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 454E 00 00 00 00
 195+ 4552 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 4556 FC FC 00 00
 196+ 455A 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 455E 80 80 80 80
 197+ 4562 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 4566 E0 E0 E0 E0
 198+ 456A F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 456E F8 F8 F8 F8
 199+ 4572 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 4576 04 04 04 04
 200+ 457A 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 457E 1C 1C 1C 1C
 201+ 4582 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 4586 7C 7C 7C 7C
 202+ 458A FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 458E 84 84 84 FC
 203+ 4592 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 4596 E0 E0 E0 E0
 204+ 459A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 459E 1C 1C 1C 1C
 205+ 45A2 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 45A6 00 00 00 00
 206+ 45AA E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 45AE 00 00 00 00
 207+ 45B2 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 45B6 1C 1C 1C 1C
 208+ 45BA 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 45BE E0 E0 E0 E0
 209+ 45C2 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 45C6 78 78 78 78
 210+ 45CA CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 45CE CC CC CC CC
 211+ 45D2 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 45D6 00 00 FC FC
 212+ 45DA 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 45DE FC FC 00 00
 213+ 45E2 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 45E6 30 30 CC CC
 214+ 45EA 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 45EE 54 A8 54 A8
 215+ 45F2 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 45F6 64 30 98 CC
 216+ 45FA CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 45FE CC 64 30 98
 217+ 4602 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 4606 30 98 CC 64
 218+ 460A 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 460E 64 CC 98 30
 219+ 4612 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 4616 20 00 F8 00
 220+ 461A C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 461E C0 00 F8 00
 221+ 4622 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 4626 18 00 F8 00
 222+ 462A 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 462E A0 60 20 00
 223+ 4632 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 4636 00 00 00 00
 224+ 463A 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 463E 70 00 00 00
 225+ 4642 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 4646 00 FC 00 00
 226+ 464A 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 464E 54 A8 00 00
 227+ 4652 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 4656 E0 C0 80 00
 228+ 465A FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 465E 00 00 00 00
 229+ 4662 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 4666 1C 0C 04 00
 230+ 466A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 466E 00 30 78 FC
 231+ 4672 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 4676 20 20 20 00
 232+ 467A 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 467E 40 80 00 00
 233+ 4682 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 4686 18 10 00 00
 234+ 468A 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 468E 24 1C 1C 3C
 235+ 4692 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 4696 20 F8 70 20
 236+ 469A 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 469E 90 E0 E0 F0
 237+ 46A2 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 46A6 60 20 00 00
 238+ 46AA F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 46AE 08 04 00 00
 239+ 46B2 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 46B6 F0 44 38 00
 240+ 46BA 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 46BE 28 28 28 00
 241+ 46C2 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 46C6 1C 20 20 20
 242+ 46CA 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 46CE E0 10 10 10
 243+ 46D2 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 46D6 00 00 00 00
 244+ 46DA 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 46DE 00 00 00 00
 245+ 46E2 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 46E6 3C 30 30 30
 246+ 46EA 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 46EE F0 30 30 30
 247+ 46F2 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 46F6 E0 00 00 00
 248+ 46FA 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 46FE 1C 00 00 00
 249+ 4702 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 4706 48 30 00 00
 250+ 470A 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 470E 78 30 00 00
 251+ 4712 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 4716 FC 78 30 00
 252+ 471A FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 471E E0 C0 80 80
 253+ 4722 FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 4726 1C 0C 04 04
 254+ 472A 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 472E 1C 3C 7C FC
 255+ 4732 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 4736 E0 F0 F8 FC
 256+ 473A 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 473E F0 E0 C0 00
 257+ 4742 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 4746 78 CC 00 00
 258+ 474A 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 474E 70 20 70 20
 259+ 4752 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 4756 90 90 60 00
 260+ 475A F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 475E 84 84 84 FC
 261+ 4762 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 4766 84 84 84 FC
 262+ 476A 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 476E 48 48 48 78
 263+ 4772 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 4776 FC B4 B4 FC
 264+ 477A 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 477E D4 D4 00 00
 265+ 4782 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 4786 78 48 48 48
 266+ 478A 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 478E B4 84 78 00
 267+ 4792 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 4796 A8 80 00 00
 268+ 479A 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 479E A0 88 70 00
 269+ 47A2 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 47A6 84 84 FC 00
 270+ 47AA 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 47AE F0 F0 F0 00
 271+ 47B2 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 47B6 F0 F0 F0 00
 272+ 47BA FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 47BE 94 94 84 FC
 273+ 47C2 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 47C6 68 70 80 00
 274+ 47CA 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 47CE 6C 18 08 00
 275+ 47D2 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 47D6 20 60 E0 40
 276+ 47DA 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 47DE E4 68 20 00
 277+ 47E2 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 47E6 E0 60 20 00
 278+ 47EA 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 47EE F8 FC F0 90
 279+ 47F2 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 47F6 B4 84 78 00
 280+ 47FA 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 47FE 40 48 B0 00
 281+ 4802 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 4806 48 3C 84 78
 282+ 480A 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 480E F8 00 20 00
 283+ 4812 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 4816 FC FC FC FC
 284+ 481A                      ; here ends the ASCII table
 285+ 481A
# file closed: ../include/vdp/6x8fonts-r16.asm
  85  481A                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 481A              ; ------------------------------------------------------------------------------
   2+ 481A              ; LM80C - 8x8 CHARSET - R1.8
   3+ 481A              ; ------------------------------------------------------------------------------
   4+ 481A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 481A              ; designed by Leonardo Miliani. More info at
   6+ 481A              ; www DOT leonardomiliani DOT com
   7+ 481A              ; ------------------------------------------------------------------------------
   8+ 481A              ; Code Revision:
   9+ 481A              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 481A              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 481A              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 481A              ; R1.3 - 20191015 - More graphic chars
  13+ 481A              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 481A              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 481A              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 481A              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 481A              ; R1.8 - 20200524 - New style for char #252
  18+ 481A              ; ------------------------------------------------------------------------------
  19+ 481A              ;
  20+ 481A              ;-------------------------------------------------------------------------------
  21+ 481A              ;
  22+ 481A              ;               8 x 8    C  H  A  R  S  E  T
  23+ 481A              ;
  24+ 481A              ;-------------------------------------------------------------------------------
  25+ 481A              ;
  26+ 481A              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 481A
  28+ 481A              CHRST88 equ $
  29+ 481A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 481E 00 00 00 00
  30+ 4822 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 4826 00 00 00 00
  31+ 482A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 482E 00 00 00 00
  32+ 4832 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 4836 00 00 00 00
  33+ 483A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 483E 00 00 00 00
  34+ 4842 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 4846 00 00 00 00
  35+ 484A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 484E 00 00 00 00
  36+ 4852 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 4856 00 00 00 00
  37+ 485A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 485E 00 00 00 00
  38+ 4862 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 4866 00 00 00 00
  39+ 486A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 486E 00 00 00 00
  40+ 4872 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 4876 00 00 00 00
  41+ 487A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 487E 00 00 00 00
  42+ 4882 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 4886 00 00 00 00
  43+ 488A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 488E 00 00 00 00
  44+ 4892 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 4896 00 00 00 00
  45+ 489A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 489E 00 00 00 00
  46+ 48A2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 48A6 00 00 00 00
  47+ 48AA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 48AE 00 00 00 00
  48+ 48B2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 48B6 00 00 00 00
  49+ 48BA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 48BE 00 00 00 00
  50+ 48C2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 48C6 00 00 00 00
  51+ 48CA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 48CE 00 00 00 00
  52+ 48D2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 48D6 00 00 00 00
  53+ 48DA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 48DE 00 00 00 00
  54+ 48E2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 48E6 00 00 00 00
  55+ 48EA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 48EE 00 00 00 00
  56+ 48F2 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 48F6 00 00 00 00
  57+ 48FA 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 48FE 00 00 00 00
  58+ 4902 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 4906 00 00 00 00
  59+ 490A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 490E 00 00 00 00
  60+ 4912 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 4916 00 00 00 00
  61+ 491A 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 491E 00 00 00 00
  62+ 4922 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 4926 10 00 10 00
  63+ 492A 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 492E 00 00 00 00
  64+ 4932 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 4936 FE 28 28 00
  65+ 493A 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 493E 14 78 10 00
  66+ 4942 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 4946 10 26 46 00
  67+ 494A 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 494E 4A 44 3A 00
  68+ 4952 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 4956 00 00 00 00
  69+ 495A 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 495E 20 10 08 00
  70+ 4962 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 4966 08 10 20 00
  71+ 496A 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 496E 38 54 10 00
  72+ 4972 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 4976 10 10 00 00
  73+ 497A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 497E 00 18 08 10
  74+ 4982 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 4986 00 00 00 00
  75+ 498A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 498E 00 18 18 00
  76+ 4992 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 4996 10 20 40 00
  77+ 499A 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 499E 64 44 38 00
  78+ 49A2 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 49A6 10 10 7C 00
  79+ 49AA 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 49AE 10 20 7C 00
  80+ 49B2 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 49B6 04 44 38 00
  81+ 49BA 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 49BE 7C 08 08 00
  82+ 49C2 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 49C6 04 44 38 00
  83+ 49CA 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 49CE 44 44 38 00
  84+ 49D2 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 49D6 20 20 20 00
  85+ 49DA 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 49DE 44 44 38 00
  86+ 49E2 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 49E6 04 44 38 00
  87+ 49EA 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 49EE 18 18 00 00
  88+ 49F2 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 49F6 18 08 10 00
  89+ 49FA 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 49FE 10 08 04 00
  90+ 4A02 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 4A06 7E 00 00 00
  91+ 4A0A 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 4A0E 08 10 20 00
  92+ 4A12 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 4A16 10 00 10 00
  93+ 4A1A 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 4A1E B8 80 84 78
  94+ 4A22 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4A26 7C 44 44 00
  95+ 4A2A 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4A2E 44 44 78 00
  96+ 4A32 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4A36 40 44 38 00
  97+ 4A3A 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4A3E 44 44 78 00
  98+ 4A42 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4A46 40 40 7C 00
  99+ 4A4A 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4A4E 40 40 40 00
 100+ 4A52 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4A56 5C 44 38 00
 101+ 4A5A 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4A5E 44 44 44 00
 102+ 4A62 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4A66 10 10 38 00
 103+ 4A6A 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4A6E 04 44 38 00
 104+ 4A72 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4A76 48 44 44 00
 105+ 4A7A 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4A7E 40 40 7C 00
 106+ 4A82 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4A86 42 42 42 00
 107+ 4A8A 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4A8E 44 44 44 00
 108+ 4A92 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4A96 44 44 38 00
 109+ 4A9A 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4A9E 78 40 40 00
 110+ 4AA2 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4AA6 54 48 34 00
 111+ 4AAA 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4AAE 78 48 44 00
 112+ 4AB2 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4AB6 04 04 78 00
 113+ 4ABA 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4ABE 10 10 10 00
 114+ 4AC2 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4AC6 44 44 38 00
 115+ 4ACA 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4ACE 44 28 10 00
 116+ 4AD2 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4AD6 5A 5A 24 00
 117+ 4ADA 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4ADE 28 44 44 00
 118+ 4AE2 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4AE6 10 10 10 00
 119+ 4AEA 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4AEE 20 40 7C 00
 120+ 4AF2 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4AF6 20 20 38 00
 121+ 4AFA 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4AFE 08 04 02 00
 122+ 4B02 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4B06 08 08 38 00
 123+ 4B0A 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4B0E 00 00 00 00
 124+ 4B12 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4B16 00 00 7E 00
 125+ 4B1A 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4B1E 00 00 00 00
 126+ 4B22 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4B26 3C 44 3C 00
 127+ 4B2A 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4B2E 44 44 78 00
 128+ 4B32 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4B36 40 44 38 00
 129+ 4B3A 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4B3E 44 44 3C 00
 130+ 4B42 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4B46 7C 40 38 00
 131+ 4B4A 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4B4E 20 20 20 00
 132+ 4B52 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4B56 44 3C 04 38
 133+ 4B5A 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4B5E 44 44 44 00
 134+ 4B62 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4B66 10 10 10 00
 135+ 4B6A 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4B6E 08 08 48 30
 136+ 4B72 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4B76 60 50 48 00
 137+ 4B7A 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4B7E 10 10 38 00
 138+ 4B82 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4B86 4A 42 42 00
 139+ 4B8A 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4B8E 44 44 44 00
 140+ 4B92 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4B96 44 44 38 00
 141+ 4B9A 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4B9E 44 78 40 40
 142+ 4BA2 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4BA6 44 3C 04 04
 143+ 4BAA 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4BAE 40 40 40 00
 144+ 4BB2 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4BB6 38 04 78 00
 145+ 4BBA 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4BBE 20 24 18 00
 146+ 4BC2 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4BC6 44 4C 34 00
 147+ 4BCA 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4BCE 44 28 10 00
 148+ 4BD2 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4BD6 54 54 28 00
 149+ 4BDA 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4BDE 10 28 44 00
 150+ 4BE2 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4BE6 4C 34 04 38
 151+ 4BEA 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4BEE 10 20 7C 00
 152+ 4BF2 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4BF6 20 20 18 00
 153+ 4BFA 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4BFE 10 10 10 00
 154+ 4C02 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4C06 08 08 30 00
 155+ 4C0A 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4C0E 00 00 00 00
 156+ 4C12 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4C16 00 00 00 00
 157+ 4C1A 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4C1E A5 99 42 3C
 158+ 4C22 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4C26 DB E7 7E 3C
 159+ 4C2A 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4C2E 7C 38 10 00
 160+ 4C32 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4C36 7C 38 10 00
 161+ 4C3A 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4C3E 54 10 7C 00
 162+ 4C42 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4C46 D6 10 7C 00
 163+ 4C4A 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4C4E FF 18 18 18
 164+ 4C52 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4C56 1F 18 18 18
 165+ 4C5A 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4C5E F8 18 18 18
 166+ 4C62 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4C66 F8 00 00 00
 167+ 4C6A 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4C6E 1F 00 00 00
 168+ 4C72 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4C76 FF 00 00 00
 169+ 4C7A 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4C7E 1F 18 18 18
 170+ 4C82 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4C86 FF 18 18 18
 171+ 4C8A 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4C8E F8 18 18 18
 172+ 4C92 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4C96 FF 00 00 00
 173+ 4C9A 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4C9E 18 18 18 18
 174+ 4CA2 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4CA6 38 70 E0 C0
 175+ 4CAA C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4CAE 1C 0E 07 03
 176+ 4CB2 C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4CB6 3C 7E E7 C3
 177+ 4CBA 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4CBE 10 10 10 10
 178+ 4CC2 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4CC6 10 10 10 10
 179+ 4CCA 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4CCE 10 10 10 10
 180+ 4CD2 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4CD6 00 00 00 00
 181+ 4CDA 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4CDE 00 00 00 00
 182+ 4CE2 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4CE6 00 00 00 00
 183+ 4CEA 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4CEE 10 10 10 10
 184+ 4CF2 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4CF6 10 10 10 10
 185+ 4CFA 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4CFE 10 10 10 10
 186+ 4D02 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4D06 00 00 00 00
 187+ 4D0A 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4D0E 10 10 10 10
 188+ 4D12 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4D16 10 20 40 80
 189+ 4D1A 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4D1E 08 04 02 01
 190+ 4D22 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4D26 18 24 42 81
 191+ 4D2A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4D2E 00 00 FF FF
 192+ 4D32 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4D36 FF FF FF FF
 193+ 4D3A 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4D3E FF FF FF FF
 194+ 4D42 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4D46 00 00 00 00
 195+ 4D4A FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4D4E 00 00 00 00
 196+ 4D52 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4D56 FF FF 00 00
 197+ 4D5A C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4D5E C0 C0 C0 C0
 198+ 4D62 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4D66 F0 F0 F0 F0
 199+ 4D6A FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4D6E FC FC FC FC
 200+ 4D72 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4D76 03 03 03 03
 201+ 4D7A 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4D7E 0F 0F 0F 0F
 202+ 4D82 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4D86 3F 3F 3F 3F
 203+ 4D8A FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4D8E 81 81 81 FF
 204+ 4D92 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4D96 F0 F0 F0 F0
 205+ 4D9A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4D9E 0F 0F 0F 0F
 206+ 4DA2 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4DA6 00 00 00 00
 207+ 4DAA F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 4DAE 00 00 00 00
 208+ 4DB2 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 4DB6 0F 0F 0F 0F
 209+ 4DBA 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 4DBE F0 F0 F0 F0
 210+ 4DC2 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 4DC6 3C 3C 3C 3C
 211+ 4DCA C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 4DCE C3 C3 C3 C3
 212+ 4DD2 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 4DD6 00 00 FF FF
 213+ 4DDA 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 4DDE FF FF 00 00
 214+ 4DE2 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 4DE6 33 33 CC CC
 215+ 4DEA 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 4DEE 55 AA 55 AA
 216+ 4DF2 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 4DF6 66 33 99 CC
 217+ 4DFA CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 4DFE CC 99 33 66
 218+ 4E02 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 4E06 33 99 CC 66
 219+ 4E0A 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 4E0E 66 CC 99 33
 220+ 4E12 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 4E16 10 00 7C 00
 221+ 4E1A 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 4E1E 60 00 7E 00
 222+ 4E22 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 4E26 06 00 7E 00
 223+ 4E2A 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 4E2E A0 60 20 00
 224+ 4E32 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 4E36 00 00 00 00
 225+ 4E3A 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 4E3E 70 00 00 00
 226+ 4E42 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 4E46 00 7E 00 00
 227+ 4E4A 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 4E4E 54 A8 00 00
 228+ 4E52 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 4E56 E0 C0 80 00
 229+ 4E5A FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 4E5E 00 00 00 00
 230+ 4E62 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 4E66 07 03 01 00
 231+ 4E6A 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 4E6E 10 38 7C FE
 232+ 4E72 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 4E76 10 10 10 00
 233+ 4E7A 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 4E7E 20 40 00 00
 234+ 4E82 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 4E86 0C 08 00 00
 235+ 4E8A 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 4E8E 0E 0E 1E 00
 236+ 4E92 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 4E96 7C 38 10 00
 237+ 4E9A 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 4E9E E0 E0 F0 00
 238+ 4EA2 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 4EA6 60 20 00 00
 239+ 4EAA F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 4EAE 08 04 00 00
 240+ 4EB2 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 4EB6 F0 44 38 00
 241+ 4EBA 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 4EBE 28 28 28 00
 242+ 4EC2 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 4EC6 08 10 10 10
 243+ 4ECA 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 4ECE 20 10 10 10
 244+ 4ED2 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 4ED6 00 00 00 00
 245+ 4EDA 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 4EDE 00 00 00 00
 246+ 4EE2 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 4EE6 0F 1C 18 18
 247+ 4EEA 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 4EEE F0 38 18 18
 248+ 4EF2 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 4EF6 E0 00 00 00
 249+ 4EFA 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 4EFE 07 00 00 00
 250+ 4F02 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 4F06 42 42 3C 00
 251+ 4F0A 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 4F0E 7E 7E 3C 00
 252+ 4F12 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 4F16 7E 3C 18 00
 253+ 4F1A FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 4F1E F0 E0 C0 80
 254+ 4F22 FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 4F26 0F 07 03 01
 255+ 4F2A 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 4F2E 1F 3F 7F FF
 256+ 4F32 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 4F36 F8 FC FE FF
 257+ 4F3A 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 4F3E 78 70 60 00
 258+ 4F42 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 4F46 3C 66 00 00
 259+ 4F4A 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 4F4E 38 10 38 10
 260+ 4F52 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 4F56 44 44 38 00
 261+ 4F5A 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 4F5E 42 42 42 7E
 262+ 4F62 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 4F66 81 81 81 FF
 263+ 4F6A 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 4F6E 54 54 54 7C
 264+ 4F72 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 4F76 BD AD AD FF
 265+ 4F7A 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 4F7E AC AA EA 00
 266+ 4F82 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 4F86 7E 66 66 66
 267+ 4F8A 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 4F8E 9D 81 42 3C
 268+ 4F92 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 4F96 A5 A2 00 00
 269+ 4F9A 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 4F9E 48 42 42 3C
 270+ 4FA2 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 4FA6 99 81 FF 00
 271+ 4FAA 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 4FAE 7C 7C 7C 00
 272+ 4FB2 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 4FB6 F8 F8 F8 00
 273+ 4FBA FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 4FBE A5 A5 81 FF
 274+ 4FC2 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 4FC6 52 24 58 80
 275+ 4FCA 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 4FCE 81 76 0C 04
 276+ 4FD2 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 4FD6 08 18 38 10
 277+ 4FDA 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 4FDE F5 F5 31 12
 278+ 4FE2 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 4FE6 F0 F0 30 10
 279+ 4FEA 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 4FEE 7C 7E 78 48
 280+ 4FF2 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 4FF6 A1 99 42 3C
 281+ 4FFA 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 4FFE 20 22 5C 00
 282+ 5002 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 5006 24 1E 42 3C
 283+ 500A 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 500E 7C 00 10 00
 284+ 5012 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 5016 FF FF FF FF
 285+ 501A
# file closed: ../include/vdp/8x8fonts-r18.asm
  86  501A                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 501A              ; ------------------------------------------------------------------------------
   2+ 501A              ; LM80C - LOGO CHARSET - R1.1
   3+ 501A              ; ------------------------------------------------------------------------------
   4+ 501A              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 501A              ; designed by Leonardo Miliani. More info at
   6+ 501A              ; www DOT leonardomiliani DOT com
   7+ 501A              ; ------------------------------------------------------------------------------
   8+ 501A              ; Code Revision:
   9+ 501A              ; R1.0 - 20200124 - First revision: logo chars
  10+ 501A              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 501A              ; ------------------------------------------------------------------------------
  12+ 501A
  13+ 501A              LOGOFONT:   equ $
  14+ 501A 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 501E 00 00 00 00
  15+ 5022 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 5026 FF FF FF FF
  16+ 502A FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 502E 00 00 00 00
  17+ 5032 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 5036 0F 0F 0F 0F
  18+ 503A 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 503E FF FF FF FF
  19+ 5042 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 5046 F0 F0 F0 F0
  20+ 504A 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 504E 0F 0F 0F 0F
  21+ 5052 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 5056 F0 F0 F0 F0
  22+ 505A F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 505E 00 00 00 00
  23+ 5062 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 5066 00 00 00 00
  24+ 506A 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 506E FF 07 03 00
  25+ 5072 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 5076 FF E0 C0 00
  26+ 507A 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 507E 19 1F 18 18
  27+ 5082 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 5086 98 F8 18 18
  28+ 508A 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 508E 0F 00 00 00
  29+ 5092 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 5096 1F 1C 18 18
  30+ 509A 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 509E F8 38 18 18
  31+ 50A2 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 50A6 F0 00 00 00
  32+ 50AA 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 50AE FF 00 00 00
  33+ 50B2 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 50B6 FF FF FF FF
  34+ 50BA F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 50BE FF FF FF FF
  35+ 50C2 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 50C6 F0 F0 F0 F0
  36+ 50CA FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 50CE 0F 0F 0F 0F
  37+ 50D2 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 50D6 30 00 00 00
  38+ 50DA
# file closed: ../include/vdp/logo-fonts.asm
  87  50DA
  88  50DA              ; include ROM/RAM switcher
  89  50DA                  INCLUDE "../include/switcher/switcher-r11.asm"
# file opened: ../include/switcher/switcher-r11.asm
   1+ 50DA              ; ------------------------------------------------------------------------------
   2+ 50DA              ; LM80C - ROM/RAM SWITCHER - R1.1
   3+ 50DA              ; ------------------------------------------------------------------------------
   4+ 50DA              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 50DA              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 50DA              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 50DA              ; kind of warranty: you can use them at your own risk.
   8+ 50DA              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 50DA              ; maintain the copyright notices, include this advice and the note to the
  10+ 50DA              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 50DA              ; redistribuite them.
  12+ 50DA              ; https://www.leonardomiliani.com
  13+ 50DA              ;
  14+ 50DA              ; Please support me by visiting the following links:
  15+ 50DA              ; Main project page: https://www.leonardomiliani.com
  16+ 50DA              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 50DA              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 50DA              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 50DA              ; ------------------------------------------------------------------------------
  20+ 50DA              ; Code Revision:
  21+ 50DA              ; R1.0   - 20200718 - First version
  22+ 50DA              ; R1.1   - 20200827 - PIO settings now are part of the file
  23+ 50DA              ;-------------------------------------------------------------------------------
  24+ 50DA
  25+ 50DA              TMP_FW_LOC:     equ     $8000           ; address from where to make a temporary copy of the FW
  26+ 50DA              ;-------------------------------------------------------------------------------
  27+ 50DA              ; THIS CODE WILL BE EXECUTED FROM RAM
  28+ 50DA 3E FC        RAMRUN:         ld      A,%11111100     ; set ROM off and RAM on..
  29+ 50DC D3 01                        out     (PIO_DB),A      ; ...by setting bit #0 to 0 (and leave VRAM bank #0)
  30+ 50DE 01 1E 51                     ld      BC,END_OF_FW    ; let's copy back FW into low RAM - bytes to copy
  31+ 50E1 21 00 80                     ld      HL,TMP_FW_LOC   ; source address
  32+ 50E4 11 00 00                     ld      DE,$0000        ; dest. address
  33+ 50E7 ED B0                        ldir                    ; copy!
  34+ 50E9 AF                           xor     A
  35+ 50EA D3 01                        out     (PIO_DB),A      ; all LEDs off - finished copying
  36+ 50EC C3 B0 02                     jp      INIT_HW         ; return control to old init (now into RAM)
  37+ 50EF
  38+ 50EF              ;-------------------------------------------------------------------------------
  39+ 50EF              ; copy the whole contents of ROM into RAM then disable the first memory
  40+ 50EF 3A 7B 51     ROM2RAM:        ld      A,(basicStarted); check if BASIC is already started
  41+ 50F2 FE 59                        cp      'Y'             ; to see if this is a power-up
  42+ 50F4 20 0F                        jr      NZ,CNTCP2RAM    ; no, continue copy to RAM
  43+ 50F6                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  44+ 50F6 3E CF                        ld      A,%11001111     ; set mode 3 ("control mode")
  45+ 50F8 D3 03                        out     (PIO_CB),A      ; for PIO port B
  46+ 50FA AF                           xor     A               ; set LEDs off, RAM on, VRAM on bank #0
  47+ 50FB D3 01                        out     (PIO_DB),A      ; send settings to PIO register
  48+ 50FD D3 03                        out     (PIO_CB),A      ; set pins following register's status
  49+ 50FF 21 AD 52                     ld      HL,TEMPSTACK    ; temporary stack
  50+ 5102 C3 B3 02                     jp      INIT_HW2        ; jump to re-init HW
  51+ 5105
  52+ 5105                              ; WARNING: Do **NOT** change the following "out()" sequence, ABSOLUTELY!
  53+ 5105 3E CF        CNTCP2RAM:      ld      A,%11001111     ; set mode 3 (mode control)
  54+ 5107 D3 03                        out     (PIO_CB),A      ; for PIO port B
  55+ 5109 3E FD                        ld      A,%11111101     ; set pin #0 as HIGH to enable ROM
  56+ 510B D3 01                        out     (PIO_DB),A      ; store the value into the internal register
  57+ 510D AF                           xor     A               ; set pins to OUTPUT
  58+ 510E D3 03                        out     (PIO_CB),A      ; for port B, activating the RAM
  59+ 5110 01 1E 51                     ld      BC,END_OF_FW    ; copy FW from ROM to high RAM
  60+ 5113 21 00 00                     ld      HL,$0000        ; source address
  61+ 5116 11 00 80                     ld      DE,TMP_FW_LOC   ; dest. address
  62+ 5119 ED B0                        ldir                    ; copy!
  63+ 511B C3 DA D0                     jp      RAMRUN+TMP_FW_LOC; jump to execute code into RAM
  64+ 511E
  65+ 511E              ;-------------------------------------------------------------------------------
  66+ 511E              END_OF_FW:      equ     $   ; this is the last cell of the firmware
# file closed: ../include/switcher/switcher-r11.asm
  90  511E
  91  511E              ; include workspace equates
  92  511E                  INCLUDE "../include/workspace/workspace-r1.0.asm"
# file opened: ../include/workspace/workspace-r1.0.asm
   1+ 511E              ; ------------------------------------------------------------------------------
   2+ 511E              ; LM80C 64K - WORKSPACE EQUATES - R1.0
   3+ 511E              ; ------------------------------------------------------------------------------
   4+ 511E              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 511E              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 511E              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 511E              ; kind of warranty: you can use them at your own risk.
   8+ 511E              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 511E              ; maintain the copyright notices, include this advice and the note to the
  10+ 511E              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 511E              ; redistribuite them.
  12+ 511E              ; https://www.leonardomiliani.com
  13+ 511E              ;
  14+ 511E              ; Please support me by visiting the following links:
  15+ 511E              ; Main project page: https://www.leonardomiliani.com
  16+ 511E              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 511E              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 511E              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 511E              ; ------------------------------------------------------------------------------
  20+ 511E
  21+ 511E              ; set starting of RAM based on computer model
  22+ 511E                  IFDEF LM80C64K
  23+ 511E              SERBUF_START    equ     END_OF_FW       ; RAM starts here
  24+ 511E                  ELSE
  25+ 511E ~            SERBUF_START    equ     $8000           ; RAM starts here
  26+ 511E                  ENDIF
  27+ 511E
  28+ 511E              ;-------------------------------------------------------------------------------
  29+ 511E              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  30+ 511E              serRdPtr        equ     serInPtr+2
  31+ 511E              serBufUsed      equ     serRdPtr+2
  32+ 511E              basicStarted    equ     serBufUsed+1
  33+ 511E              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  34+ 511E              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  35+ 511E
  36+ 511E              ; BASIC WORK SPACE LOCATIONS
  37+ 511E              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  38+ 511E              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  39+ 511E              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  40+ 511E              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  41+ 511E              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  42+ 511E              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  43+ 511E              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  44+ 511E              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  45+ 511E              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  46+ 511E              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  47+ 511E              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  48+ 511E              DIV2            equ     DIV1+$04        ; (4) <-   to
  49+ 511E              DIV3            equ     DIV2+$04        ; (3) <-   be
  50+ 511E              DIV4            equ     DIV3+$03        ; (2) <-inserted
  51+ 511E              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  52+ 511E              LSTRND          equ     SEED+$23        ; (4) Last random number
  53+ 511E              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  54+ 511E              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  55+ 511E              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  56+ 511E              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  57+ 511E              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  58+ 511E              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  59+ 511E              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  60+ 511E              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  61+ 511E              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  62+ 511E              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  63+ 511E              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  64+ 511E              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  65+ 511E              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  66+ 511E              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  67+ 511E              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  68+ 511E              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  69+ 511E              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  70+ 511E              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  71+ 511E              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  72+ 511E              STACK           equ     BUFFER+$05      ; (85) Initial stack
  73+ 511E              CURPOS          equ     STACK+$55       ; (1) Character position on line
  74+ 511E              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  75+ 511E              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  76+ 511E              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  77+ 511E              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location usable by BASIC
  78+ 511E              TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
  79+ 511E              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  80+ 511E              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  81+ 511E              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  82+ 511E              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  83+ 511E              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  84+ 511E              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  85+ 511E              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  86+ 511E              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  87+ 511E              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  88+ 511E              BRKLIN          equ     READFG+$01      ; (2) Line of break
  89+ 511E              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  90+ 511E              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  91+ 511E              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  92+ 511E              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  93+ 511E              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  94+ 511E              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  95+ 511E              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  96+ 511E              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  97+ 511E              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  98+ 511E              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  99+ 511E              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
 100+ 511E              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
 101+ 511E              SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
 102+ 511E              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 103+ 511E              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 104+ 511E              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 105+ 511E              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 106+ 511E              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 107+ 511E              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 108+ 511E              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 109+ 511E              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 110+ 511E              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 111+ 511E              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 112+ 511E              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 113+ 511E              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 511E              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 511E              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 116+ 511E              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 117+ 511E              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 118+ 511E              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 119+ 511E              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 120+ 511E              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 121+ 511E                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 122+ 511E              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 123+ 511E              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 124+ 511E              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 125+ 511E              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 126+ 511E              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 127+ 511E              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 128+ 511E              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 129+ 511E              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 130+ 511E              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 131+ 511E              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 132+ 511E              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 133+ 511E              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 134+ 511E                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 135+ 511E              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 136+ 511E              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 137+ 511E              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 138+ 511E              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 139+ 511E              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 140+ 511E                                                      ; from here there are the RAM locations that
 141+ 511E                                                      ; are saved during SAVE
 142+ 511E              PROGND          equ     DOS_EN+$01      ; (2) End of program
 143+ 511E              VAREND          equ     PROGND+$02      ; (2) End of variables
 144+ 511E              ARREND          equ     VAREND+$02      ; (2) End of arrays
 145+ 511E              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 146+ 511E              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 147+ 511E              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 148+ 511E              FPREG           equ     FNARG+$04       ; (3) Floating point register
 149+ 511E              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 150+ 511E              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 151+ 511E              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 152+ 511E              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 153+ 511E              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 154+ 511E              STLOOK          equ     PROGST+$64      ; Start of memory test
 155+ 511E
# file closed: ../include/workspace/workspace-r1.0.asm
  93  511E
  94  511E              ; END OF ASSEMBLY SOURCE
  95  511E              ;-------------------------------------------------------------------------------
  96  511E
# file closed: LM80C_64K-firmware-r1.04.asm

Value    Label
------ - -----------------------------------------------------------
0x5334   CHCSNDDTN
0x5332   CHBSNDDTN
0x51C6   NMIFLG
0x5105   CNTCP2RAM
0x511E   END_OF_FW
0x50DA   RAMRUN
0x8000   TMP_FW_LOC
0x400A   DV16_16_LP
0x4005 X DIV_16_16
0x3FF9   DIV_16_8LP
0x3FEA   DIV_8_8LOOP
0x3FDA   EXMUL16
0x3FD1   MLP1
0x3FCA   MLP
0x3FAA X TSTBIT
0x3F6A   BINIT
0x3F7D   CHKBIN
0x3F4C   BITOUT2
0x3F48   BITOUT
0x3F3A   ZEROSUP
0x3F34 X BIN2
0x3F1C   NOSUB7
0x3F20   HEXIT
0x3EFC   HEXLP
0x3F01   HEXLP1
0x3F29   HXERR
0x3F09   GETHEX
0x3EEC   ADD301
0x3EDC   ADD30
0x3EC6   HEX4
0x3EC4   HEX3
0x3EB5   HEX1
0x3EB7   HEX2
0x3E61   PRTEND
0x3E55   PRTK1
0x3E52   OPNQT1
0x3E3A   CLSQT1
0x3E96   CHKEY5
0x3E22   PTCHR1
0x3E93   CHKEY4
0x3E2A   CLSQT
0x3DED   PRTK3
0x3E05   PRTCHR
0x3E3C   OPNQT
0x3DF0   CNTLTK
0x3DDB   LDKEY
0x3E8A   CHKEY2
0x3E54   PRTCKEY
0x3E85   CHKEY1
0x3DC4 X PRTK2
0x3DC2   PRTK4
0x3DAE   CPKYEND
0x3DA6   CPKEY1
0x3D9E   CPKEY3
0x3D97   CPKEY2
0x3D87   CPKEY
0x3D79   DECLN1
0x3E63   SETREP
0x3D49   KEYCH
0x3DB0   LSTKEYS
0x3D27   HLPERR
0x3D05   DIRMOD
0x3CCC   EXNRM
0x3CBE   ENCHB
0x3C93   SRLCNT
0x3C7B   STRPAR
0x3C5E   SETPAR2
0x3C4F   BITS8
0x3C44   BITS7
0x3C53   SETPAR
0x3C3A   BITS6
0x3C17   SET_CTC
0x3CE9   CTC_CFG
0x3CF4   SCERR1
0x3C06   SET_PT
0x3BED   CKBPS
0x3CD3   SUP_BPS
0x3BE1   SETSER
0x3BD4   DEFSER
0x3B89   CNTSER3
0x3B6C   CNTRX2
0x3B77   CNTSER2
0x3B39   SERLED
0x3B33   SRPT2
0x3B10   RPTRSSR
0x3B03   RSTSERS
0x3B3D   CNTSER
0x3AFF   CHKZSER
0x3AF0   SERVAR
0x3CF8   SCERR
0x530A   SIOBFR
0x5309   STPBT
0x5308   PARBT
0x5307   DATABT
0x5305   BPS
0x5304   PRTNUM
0x3AAA   RPTCVB2
0x3AA1   RPTCVB1
0x3A94   CNTVALY
0x3A64   CNTCL7
0x3A40   CNTCL6
0x3A1C   CNTCL5
0x39FA   CNTCL4
0x39D4   CNTCL3
0x39B0   CNTCL2
0x3A8E   VALIDY
0x398C   CNTCL1
0x3A89   VALIDX
0x395D   PLTCRL
0x394E   DLSZ
0x3966   ENDCRL
0x3921   RPTCL1
0x390E   RPTCRL
0x396A   DRWCRL
0x530E   DC
0x530C   YI
0x530A   XI
0x5308   RADIUS
0x5306   YC
0x5304   XC
0x389D   DXGR
0x38C6   ENDDRAW
0x386D   CNTDRW
0x3851   RPTDRW
0x384E   STRE2
0x3841   ER2
0x3FDF   negHL
0x381E   Y1GR
0x37F4   X1GR
0x3FDC   absHL
0x3A99   CLRVDBF
0x5310   DX
0x530E   SY
0x530C   SX
0x530A   E2
0x5308   ER
0x5306   Y2
0x5304   X2
0x52FE   Y1
0x52FC   X1
0x3FE6   DIV_8_8
0x3761   PXLSET
0x373D   CNTPLT1
0x375D   NOGD
0x3769   XY2HL
0x36D8   PNTEND
0x36E2   CTPOINT
0x368F   PAINT5
0x365E   PAINT3
0x369F   CHECKPY
0x364B   PAINT2
0x371C   CNTPLOT
0x361B   MNPAINT
0x3618   PAINT1
0x3617   PAINT11
0x369E   CHECKPA
0x3609   PAINT0
0x3696   EXITPAI
0x35FC   NXTLOOP
0x369A   EXITPA2
0x36F6   PNTRTN
0x3AB1   CLRPRM
0x5308   ORGSP
0x5307 X SPB
0x5306 X SPA
0x5304   PNT
0x358E   GPCPCH1
0x3584 X GPCPCHR
0x356A   GPNTCO1
0x3561 X GPNTCOL
0x3556   RPGPNT
0x3541   GPNT
0x352C   CNTGPT2
0x35AB   CKCOL
0x530A   TMPHL
0x5308   NUMCHR
0x5306   CHRPNT
0x5304   TMPADR
0x52FC   MIXCOL
0x52FE   TMPCLR
0x5302   GY
0x5300   GX
0x3ACA   GMERR
0x34C6   CHKG2M
0x34C0   CHKCLR0
0x348B   RPTLDCL
0x3481   LOADCLR
0x3496   SETBRCL
0x34AF   MIXCLRS
0x347A   CLREX2
0x3471   CLRG2
0x3468   CLRG1
0x345E   CLRTXT
0x3461   CLRMC
0x34BC   CHKCLR1
0x33B6   CKMAGN
0x3403   CHKSCAR
0x33AB X SETVDP
0x33C4   SCVDP
0x3387   RPTPS
0x3382 X DIR_PAU
0x335C X RECWRD
0x3338 X ARET
0x3313   ATNTAB
0x3309   ATN1
0x32C2   SINTAB
0x32A6   SIN1
0x32BE   QUARTR
0x32BA   HALFPI
0x3253   RND2
0x3237   RND1
0x3264   RNDTAB
0x51B9   LSTRND
0x325C   RESEED
0x5196   SEED
0x31E3   SUMLP
0x31DA   SMSER1
0x31AA   EXPTAB
0x3152   POWER2
0x3135   POWER1
0x3117   NEGAFT
0x30E2   EXPTEN
0x30E0   OUTEXP
0x30EF   NOENED
0x30C4   SUPTLZ
0x30D0   DOEBIT
0x309F   TRYAGN
0x3090   DIGTXT
0x3105   POWERS
0x307F   MAKNUM
0x305A   GTSIXD
0x3063   INRNG
0x3045   SIXDIG
0x30F2   RNGTST
0x30EC   JSTZER
0x3036   SPCFST
0x5355   PBUFF
0x2FE0   MULTEN
0x2FD5   ENDCON
0x2FDF   SCALPL
0x2FC9   SCALMI
0x3009   EDIGIT
0x2FB4   EXPLP
0x2FC6   CONEXP
0x2FC2   DPOINT
0x2FE7   ADDIG
0x2F9E   MANLP
0x2F96   CNVNUM
0x2F85   NOMLAD
0x2F77   MLDBLP
0x2F4F   DCBCDE
0x2F18   CMPFP
0x2EE0   DETHLB
0x2ED9   INCHL
0x2E8C   RETREL
0x2E6C   MLSP10
0x2E5F   OVTST1
0x2E64   OVTST2
0x2E65   OVTST3
0x2E11   RESDIV
0x5188   DIVSUP
0x2DFE   DIVLP
0x5194   DIV4
0x5189   DIV1
0x518D   DIV2
0x5191   DIV3
0x2DCB   DIV10
0x2D63   NOMADD
0x2D52   MUL8LP
0x2D75   BYTSFT
0x2D49   MULT8
0x5362   MULVAL
0x2E41   ADDEXP
0x2D27   FPMULT
0x2D1E   MULLN2
0x2FFE   RSCALE
0x31CB   SUMSER
0x2DD9   DVBCDE
0x2CD9   LOGTAB
0x2CD5   UNITY
0x2CC3   SHRLP
0x2CC0   SHRITE
0x2CB3   SCALLP
0x5354   SGNRES
0x2C84   FPROND
0x2C73   RONDB
0x2C57   NORMAL
0x2C53   SAVEXP
0x2C5F   PNORM
0x2C3A   CONPOS
0x2CC7   SHRT1
0x2C72   RONDUP
0x2C91   PLUCDE
0x2C2C   MINCDE
0x2CB1   SCALE
0x2EE9   SIGNS
0x2C06   NOSWAP
0x2BE9   SUBCDE
0x2BE3   SUBPHL
0x2BEC   FPADD
0x3101   HALF
0x2BDA   ROUND
0x2BD7 X ENDINK2
0x2BBC   CHKINK
0x2BB8   SRTINK
0x2BCE   ENDINK
0x2BA4   INKEY2
0x2B95   CMP_A
0x2B43   NOS3
0x2B2A   NOS2
0x2B17   NOS1
0x2AE7   SNDOVR
0x2B3A   WRTSND
0x2AB2   SND1
0x2A44   RPVOLCG
0x2A50   VOLCH
0x29A9   PKEPRMS
0x2993   SYSRET
0x2985   NOSYSPR
0x2947   NMIINT
0x2953   NMIVR1
0x293D   NMIEINT
0x2939   NMI2
0x2944   NMIDINT
0x2917   DISNMI
0x2928   NM1
0x5186   OTPORT
0x28E0   WAITLP
0x28DF   NOXOR
0x5185   OUTSUB
0x28E9   SETIO
0x51BD   INPSUB
0x51BE   INPORT
0x28A8   VAL2
0x28AB   VAL3
0x289E   VAL1
0x2C52   RESZER
0x2869   RSTSTR
0x28B4   MIDNUM
0x2835   LVINSTR
0x283F   CNTZIN
0x27DF   RP2INST
0x2808   CNT1INS
0x27B8   RPTINST
0x282A   RZINSTR
0x5312   DY
0x27A7   EMPTINS
0x530C   TF
0x530A   TP
0x5308   PT2
0x5304   PT
0x5302   ADRS2
0x5300   LNS2
0x52FE   ADRS1
0x52FC   LNS1
0x272E   ALLFOL
0x2726   MID1
0x3F8B   BINERR
0x2724   RIGHT1
0x28AF   LFRGNM
0x28FF   MAKINT
0x2703 X GTFLNM
0x26F4   GETLEN
0x26DD   POPHL
0x26BE   GETSTR
0x26B5   TSALP
0x26AB   SSTSA
0x26C4   GSTRHL
0x2618   GRBARY
0x264F   SCNEND
0x25F8   GNXARY
0x2629   STRADD
0x25F9   ARRLP
0x25E3   SMPVAR
0x2626   STPOOL
0x25D2   GRBLP
0x25C4   GARBLP
0x25B5   TESTOS
0x2599   GRBDON
0x2588   PRSLP
0x257D   PRNUMS
0x255E   TSTOPL
0x2552   CRTSTE
0x2543   QTSTLP
0x252D   MKTMST
0x26B4   TOSTRA
0x2530   CRTMST
0x2597   TESTR
0x271C   TOPOOL
0x250E   STR1
0x2536   SVSTAD
0x24F7   CHEKFN
0x246F   PASSA
0x2E9A   RETINT
0x25C1   GARBGE
0x245A   FRENUM
0x2439   ENDTMR
0x2405   FNDELP
0x2424   ENDDIM
0x23E3   ZERARY
0x2F6F   MLDEBC
0x23C5   DEFSIZ
0x23BD   CRARLP
0x239D   BSERR
0x2400   FINDEL
0x2384   NXTARY
0x23A2   CREARY
0x2370   FNDARY
0x2348   SCPTLP
0x2326   ZEROLP
0x2337   RETNUL
0x2334   RETADR
0x22F5   FNTHR
0x2300   CFEVAL
0x22E7   FNDVAR
0x2D73   POPHRT
0x534C   FNARG
0x2342   SBSCPT
0x22CD   NSCFOR
0x236A   ARLDSV
0x22BD   NOTSTR
0x22A2   ENDNAM
0x22AE   CHARTY
0x22A1   SVNAM2
0x228A   GTFNAM
0x52B1   LCRFLG
0x2277   DIMRET
0x2E95   FLGREL
0x2E8E   FLGDIF
0x223E   CMPSTR
0x26C5   GSTRDE
0x26C1   GSTRCU
0x2256   CMPRES
0x2214   CMPLG1
0x2212   CMPLOG
0x21FB   PXOR1
0x21EE X PAND1
0x21F3   POR1
0x245F   ACPASS
0x2EC4   FPBCDE
0x21D3   CNTLGC
0x21B9   SGNEXP
0x21B0   GOFUNC
0x21A8   FNVAL
0x2169   FRMEVL
0x2161   RETNUM
0x2EAC   INVSGN
0x214D   EVLPAR
0x2177   FNOFST
0x24A1   DOFN
0x2260   EVNOT
0x2155   MINUS
0x3F60   BINTFP
0x3EF0   HEXTFP
0x212A   NOTAMP
0x2166   CONVAR
0x2EB4   STAKFP
0x20E8   STKTHS
0x2674   CONCAT
0x2200   TSTRED
0x52CA   CUROPR
0x20C0   FOPRND
0x20A4   RLTLP
0x2097   EVAL3
0x52D5   NXTOPR
0x2094   EVAL2
0x20FF   OPRND
0x208B   EVAL1
0x2084   OPNPAR
0x207A   TSTSTR
0x2066   KILFOR
0x2ED2   LOADFP
0x2BDD   ADDPHL
0x2EC1   PHLTFP
0x202E   NEXT1
0x2020   FANDT
0x1FF7   EXTIG
0x1FDC   MORDT
0x2F8A   ASCTFP
0x1FD0   LTSTND
0x2540   DTSTR
0x1FB6   ITMSEP
0x1FB9   STRENT
0x1FC5   INPBIN
0x2007   FDTLP
0x1F9B   ANTVLU
0x1F6F   NEDMOR
0x1F73   GTVLUS
0x1F67   NXTITM
0x1F4A   NOPMPT
0x24E9   IDTEST
0x52D2   READFG
0x1F1F   BADINP
0x1F0D   REDO
0x1EFE   SPCLP
0x1EF7   DOSPC
0x28F9   FNDNUM
0x1ED7   ZONELP
0x1EC4   CNTEND
0x2581   PRS1
0x253C   CRTST
0x3028   NUMASC
0x1EA1   PRNTST
0x1F06   NEXITM
0x1EC9   DOCOM
0x1EE2   DOTAB
0x1E5A   PRNTLP
0x1E53   MRPRNT
0x1E3C   IF0
0x1E45   IF1
0x1E33   IFGO
0x1E17   ONGOLP
0x1E16   ONGO
0x28FC   GETINT
0x2EDB   FPTHL
0x2EDE   DETHL4
0x2518   SAVSTR
0x26DF   BAKTMP
0x52C4   TMPSTR
0x1DF7   MVSTPT
0x1DEF   CRESTR
0x5350   FPREG
0x1DC8   LETSTR
0x1E00   LETNUM
0x207B   CHKTYP
0x2088   EVAL
0x52B2   TYPE
0x2285   GETVAR
0x1D9F   NXTSTT
0x1D9C   NXTSTL
0x1D95   NXTDTA
0x1D90   RETLIN
0x1D52   RUNLIN
0x1D0B   STORED
0x1CC1   GTLNLP
0x1CBE   GETLN
0x2EFE   CMPNUM
0x2F2B   FPINT
0x5353   FPEXP
0x1C9D   DEPINT
0x1C9A X POSINT
0x2AED   NOISUP
0x1C97   FPSINT
0x1C8F   CHKLTR
0x51C4   CHKSUM
0x1C82 X ACCSUM
0x1C63   ERRINT
0x52D7   ERRLIN
0x1C52   NOLIN
0x1C3C   INPBRK
0x51C7   BRKFLG
0x1C26   STALL
0x1C30   BRK
0x5348   NXTDAT
0x1C13   UPDATA
0x1C12   RESTNL
0x1BD5   ONJMP
0x1BD4   IFJMP
0x1C3F   ENDPRG
0x1BAD   RUNCNT
0x1BA9   PUTFID
0x2E83   TSTSGN
0x1BA0   SAVSTP
0x2ECF   BCDEFP
0x2076   GETNUM
0x2079   TSTNUM
0x1B64   FORFND
0x1B48   FORSLP
0x52CC   LOOPST
0x1B2D   CNTWTSP
0x1B21   WTSPC
0x1B19   LVSRLN
0x1B0E   SRCLN1
0x1AEB   OUTWRD
0x1AF9   NXTLN
0x1AD2   LSTLP3
0x1ACF   LSTLP2
0x1AC3   LST07
0x1AC0   LST08
0x1B1B   TSTSPC
0x1C18   TSTBRK
0x367D   PAINT4
0x1A95   LST02
0x1A92   LST05
0x1A55   LST06
0x1A7E   LST03
0x1A59   LSTNOT
0x1A3A   LST01H
0x1A9E   LISTLP
0x1B0D   SRCLN
0x1B07   SRCHLIN
0x1A37   LST01
0x1A66   LSTALL
0x3339   GETINP
0x3F90   MONOUT
0x19EA   SND2VID
0x19D7   INCLEN
0x52B0   CURPOS
0x51C0   LWIDTH
0x19DB   DINPOS
0x25B3   POPAF
0x19AC   CHKSYN
0x199D   OUTIT
0x19A0   OUTNBS
0x3FB1   OUTNCR
0x1989   PUTBUF
0x1EB0   ENDINP
0x1983   GMNCR
0x198E   PUTCTL
0x194E   PROCES
0x19F8   CLOTST
0x1926   KILIN
0x191B   DELCHR
0x1935   MORINP
0x1923   OTKLN
0x190F   ECHDEL
0x51C2   NULFLG
0x18FB   DODEL
0x18E2   NXTCHR
0x18DC   TSTREM
0x18D9   SETLIT
0x18BB   NOCHNG
0x18B2   NOSPC
0x18C3   MATCH
0x18A1   NXTBYT
0x1891   GETNXT
0x188F   SEARCH
0x18C7   RETNAD
0x1876   FNDWRD
0x18F2   ENDBUF
0x18EB   CPYLIT
0x18CB   MOVDIR
0x184C   CRNCLP
0x52B3   DATFLG
0x51C8   RINPUT
0x182F   DOAGN
0x534A   FNRGNM
0x52D0   FORFLG
0x52D9   CONTAD
0x52B6   TMSTPT
0x52B8   TMSTPL
0x5344   VAREND
0x52C8   STRBOT
0x52D3   BRKLIN
0x1800   INTVAR
0x17D3   SRCHLP
0x5253   BASTXT
0x17C4   FNDEND
0x17B8   PTRLP
0x17FC   RUNFST
0x17AB   MOVBUF
0x17B3   SETPTR
0x177D   SFTPRG
0x5342   PROGND
0x178C   INEWLN
0x1D6C   ULERR
0x1775   LINFND
0x17D0   SRCHLN
0x52D1   LSTBIN
0x1BCD   EXCUTE
0x1843   CRUNCH
0x192C   GETLIN
0x1731   GETCMD
0x1723   POPNOK
0x3015   LINEIN
0x51CF   HLPLN
0x171F   PTLN
0x1702   ERRIN
0x19B7   OUTC
0x1EA8   STTLIN
0x51C3   CTLOFG
0x16DC   TMERR
0x16D9   OVERR
0x16D6   UFERR
0x16D3   DDERR
0x16D0   NFERR
0x16CD   DZERR
0x52CE   DATLIN
0x16C4   DATSNR
0x16C2   LDG1ND
0x16B1   LDG1
0x16A4   EXITGM
0x16DE   ERROR
0x169F   OMERR
0x5346   ARREND
0x1687   CHKSTK
0x167C   MOVLP
0x1679   MOVSTR
0x1690   ENFMEM
0x1676   MOVUP
0x166D   INDFND
0x1657   LOKFOR
0x1653   BAKSTK
0x164D   BRKMSG
0x1648   OKMSG
0x1647   ZERBYT
0x1643   INMSG
0x163C   ERRMSG
0x15BA X DEFFNKS
0x15B8   AUTORP
0x192C   TTYLIN
0x1CB8   FCERR
0x21CC   POR
0x21D1   PXOR
0x21C9   PAND
0x2C3D   BNORM
0x3125   POWER
0x2D7A   DINT
0x2D82   MOD
0x2DD7   DIV
0x2D25   MULT
0x2BE7   PSUB
0x3004   PADD
0x1545   PRITAB
0x00E9   ZLEFT
0x00E1   ZINSTR
0x00E0   ZPOINT
0x00CA   ZSGN
0x00C9   ZLTH
0x00C8   ZEQUAL
0x00C7   ZGTR
0x00C6   ZOR
0x00C2 X ZDINT
0x00C1 X ZMOD
0x00C0 X ZDIV
0x00BF X ZTIMES
0x00BE   ZMINUS
0x00BD   ZPLUS
0x00BC   ZSTEP
0x00BB   ZNOT
0x00BA   ZTHEN
0x00B9   ZSPC
0x00B8   ZFN
0x00B7   ZTO
0x00B6   ZTAB
0x00B5   ZNEW
0x00AF   ZPRINT
0x00AE   ZELSE
0x008E   ZREM
0x008C   ZGOSUB
0x0088   ZGOTO
0x0083   ZDATA
0x0081   ZFOR
0x0080   ZEND
0x17F0   NEW
0x3E9A   SAVE
0x3E99   LOAD
0x1CE2   CLEAR
0x1A0B   LIST
0x1C69   CONT
0x1E57   PRINT
0x3F93   RESET
0x2967   SYS
0x334F   WIDTH
0x34CF   GPRINT
0x290D   NMI
0x3D2C   KEY
0x333B   CLS
0x3D11   HELP
0x3ACF   SERIAL
0x35BE   PAINT
0x38CA   CIRCLE
0x3794   DRAW
0x3701   PLOT
0x3413   COLOR
0x3379   PAUSE
0x2A22   VOLUME
0x2A5B   SOUND
0x29CF   LOCATE
0x2B4F   VREG
0x2A01   SREG
0x29C4   VPOKE
0x3362   DOKE
0x29BF   POKE
0x2474   DEF
0x28CB   WAIT
0x3E9C   ERASE
0x3E9B   FILES
0x1E07   ON
0x28C5   POUT
0x1C35   STOP
0x1D98   REM
0x1D71   RETURN
0x1D42   GOSUB
0x1BFD   RESTOR
0x1E25   IF
0x1D2E   RUN
0x1D53   GOTO
0x1DAD   LET
0x1F62   READ
0x2280   DIM
0x1F30   INPUT
0x1D96   DATA
0x202B   NEXT
0x1B34   FOR
0x1C37   PEND
0x14D9   WORDTB
0x134C   WORDS
0x2850   MID
0x2846   RIGHT
0x2720   LEFT
0x3F2E   BIN
0x3E9D   HEX
0x2710   CHR
0x26FF   ASC
0x2880   VAL
0x2508   STR
0x3B73   RXEND
0x26F0   LEN
0x2750   INSTR
0x36AE   POINT
0x2B8A   INKEY
0x2B76   SSTAT
0x2B6B   VSTAT
0x299C   VPEEK
0x3357   DEEK
0x2995   PEEK
0x32EC   ATN
0x32D7   TAN
0x3398   SCREEN
0x3276   SIN
0x3270   COS
0x316A   EXP
0x2CE6   LOG
0x31FB   RND
0x311C   SQR
0x246C   POS
0x28B9   INP
0x243E   FRE
0x5306   PT1
0x5182   USR
0x2EA8   ABS_
0x2F56   INT
0x2428   TMR
0x2E92   SGN
0x1308   FNCTAB
0x1724   PRNTOK
0x3D39   RESFN
0x1299   BRKRET
0x525B   STACK
0x12AE   BFREE
0x301D   PRNTHL
0x12A5   BLNSPC
0x17F1   CLRPTR
0x51CB   STRSPC
0x52B4   LSTRAM
0x1262   NODOS
0x19A6   CPDEHL
0x16CA   SNERR
0x1CBD   ATOH
0x124B   SETTOP
0x1227   MLOOP
0x53C9   STLOOK
0x1239   TSTMEM
0x1BED   GETCHR
0x1833   PROMPT
0x257E   PRS
0x12FD   MEMMSG
0x1211   MSIZE
0x1224   MNOASK
0x2A69   CTSNDC
0x5365   PROGST
0x5256   BUFFER
0x1EBA   PRNTCRLF
0x1816   CLREG
0x1AE1   FNDTOK
0x163C   INITBE
0x1563   INITAB
0x11F6   INIT
0x517C   WRKSPC
0x2460   ABPASS
0x1E9D   PRNTNB
0x1CA3   DEINT
0x11EF   CSTART
0x1296   WARMST
0x11E8   STARTB
0x1032 X ERRORS
0x11D8   HPMSG
0x1030 X HPPTR
0x11C2   SOMSG
0x11A9   SAMSG
0x102C X SAPTR
0x1194   SCMSG
0x102A X SCPTR
0x1028 X GMPRT
0x1178   BNMSG
0x1026 X BNPTR
0x116D   HXMSG
0x1024 X HXPTR
0x115D   MOMSG
0x1022 X MOPTR
0x3ED3   BYT2ASC
0x1147   UFMSG
0x1020 X UFPTR
0x1138   CNMSG
0x101E X CNPTR
0x111D   STMSG
0x101C X STPTR
0x102E X SOPTR
0x110D   LSMSG
0x101A X LSPTR
0x10F9   OSMSG
0x1018 X OSPTR
0x10EA   TMMSG
0x1016 X TMPTR
0x10DB   IDMSG
0x1014 X IDPTR
0x10CA   DZMSG
0x1012 X DZPTR
0x10B5   DDMSG
0x1010 X DDPTR
0x10A7   BSMSG
0x100E X BSPTR
0x1098   ULMSG
0x3E8D   CHKEY3
0x100C X ULPTR
0x108A   OMMSG
0x100A X OMPTR
0x1081   OVMSG
0x1008 X OVPTR
0x106B   FCMSG
0x1006 X FCPTR
0x105F   ODMSG
0x1004 X ODPTR
0x104A   RGMSG
0x1002 X RGPTR
0x1043   SNMSG
0x1000 X SNPTR
0x1032   NFMSG
0x0FFE X NFPTR
0x0FFE   ERRTBL
0x0032   HP
0x0030   SO
0x002E   SA
0x002C   SC
0x002A   GM
0x0028   BN
0x0026 X HX
0x0024   MO
0x0022   UF
0x0020   CN
0x001E   ST
0x1EFC   ASPCS
0x001C   LS
0x001A   OS
0x0018   TM
0x0016   ID
0x0014   DZ
0x0012   DD
0x0010   BS
0x000E   UL
0x000C   OM
0x000A   OV
0x0008   FC
0x0006   OD
0x0004   RG
0x0002   SN
0x0000   NF
0x007F   DEL
0x0020   SPC
0x001B   ESC
0x0015   CTRLU
0x0013   CTRLS
0x0012   CTRLR
0x0011   CTRLQ
0x000F   CTRLO
0x0007   CTRLG
0x0ED6   CNTFNK
0x0EE9   PRNTFNK
0x0EDC   PUTCHRBUF1
0x0EC2   LDFNKEYCHR
0x51D3   FNKEYS
0x51CD   LINEAT
0x12BC   SIGNON
0x0EA9 X LVKBRDCHK
0x0EA2   PNT2VD
0x0E95   PUTCHRBUF
0x0E83   SNDKEYTOBFR
0x0EAA   PRNTFNKEY
0x0E7B   CHKFNK
0x0EF6   FNKEYSORD
0x0E75   CNTKBCK
0x0003   CTRLC
0x51D2   AUTOKE
0x2C40   BNRMLP
0x0E62   SENDKEY
0x0E33   SETNEWAUTO
0x0EA5   LVKBRDCHK2
0x51D1   KEYDEL
0x0E43   CHKAUTO
0x533B   KEYTMR
0x0E55   NEWKEY
0x0F7E   KBMAP_ALT
0x0FBE   KBMAP_CTRL
0x0DFA   CHKALT
0x0E01   LOADMAP
0x0F3E   KBMAP_SFT
0x0DF1   CHKCTRL
0x0EFE   KBMAP
0x0DDD   CHKLN
0x533A   STATUSKEY
0x5339   LASTKEYPRSD
0x0DC5   ENDCTRLCK
0x0DBF   TESTCTRL
0x0DDB   FINDKEY
0x0DB2   TESTALT
0x5337   KBTMP
0x0DC9   NOKEYPRSD
0x0D83   RPTKBDRD
0x0D7F   CHECKKBD
0x0D71   CHECKCTRL
0x533D   CONTROLKEYS
0x0D63   CHECKALT
0x0D23   CNTCHKSND
0x0CE8   CHKSNDCH
0x0CB6   RPTWLCMBP
0x0CCC   NOBPDAT
0x0CB3   SENDSND
0x0CC4   WLCBPDAT
0x0CD9   WRTSNDREG
0x0CD4   SETSNDREG
0x0C9A   SNDREGCFG
0x0C86   CLRPSGREGS
0x0C82   EMPTSNDBFR
0x0B34 X VDPMODESETEX2
0x0B2C X VDPMODESETMC
0x0B24 X VDPMODESET2
0x253D   QTSTR
0x0B1C X VDPMODESET1
0x0B0A   SENDCHRPTRNS
0x481A   CHRST88
0x0B08   NXTCHAR
0x401A   CHRST68
0x0AEA   LDREGVLS
0x0B14   VDPMODESET
0x0AD3   RSTVDPRAMREG
0x5330   CHASNDDTN
0x0AC4   EMPTVRM
0x0A59 X CNTNULL2
0x0A4C   RPTNLLSRC2
0x3FC2   MUL16
0x0A27   ADDNEWLINE
0x09F4   SNDCHRTOBFR
0x09DB   CNTNULL
0x09CB   RPTNLLSRC
0x0A13   PRNTRETURN
0x5302   TMPBFR4
0x5300   TMPBFR3
0x52FE   SRTTXT
0x52FE   TMPBFR2
0x09A1   RPTEMPTYROW
0x0987   WRITEBUF
0x095F   LOADNEXTCOL
0x5304   VIDEOBUFF
0x094E   SCROLLNXTRW
0x532E   VIDTMP2
0x532C   VIDTMP1
0x092C   EXITCURSOR_ON
0x0916   EXITCURSORDOWN
0x08F6   EXITCURSORRGHT
0x08F0   CONTCRSRGT
0x08DD   CHCKYPOS2
0x08C2   EXITCURSORUP
0x0899   CHKYPOS
0x0886   EXITCURSORLEFT
0x0883   CONTCRSLFT
0x0872   CHCKYPOS
0x0888   MVCRS2LFT
0x0843   MVBKSP
0x0856   LVBKSP
0x080F X ENDINSRT
0x080A   NXTINST
0x3FB7   CMP16
0x07F9   CHKHL
0x5300   ENDTXT
0x0A34   ENDOFLN
0x52FC   CUR_POS
0x07D7   PUTCRSCHR
0x0935   SCROLLUP
0x0797   SETCRSRY
0x0798   SETCSRCOORDS
0x07AA   EXITCHAR2VID
0x076E   NXTCPCK
0x0761   RPTCPCK
0x07B7   PLACEHOLDER
0x000A   LF
0x07DB   INSERTKEY
0x001A   INSRT
0x08F9   CURSORDOWN
0x001F   CRSDN
0x08C4   CURSORRIGHT
0x001D   CRSRGT
0x08AB   CURSORUP
0x001E   CRSUP
0x085F   CURSORLEFT
0x001C   CRSLFT
0x081C   BACKSPACE
0x3430   CNTCKCL
0x0008   BKSP
0x09AD   CRGRETURN
0x000C   CS
0x0019   HOME
0x0730   CHRTBL
0x3FF6   DIV_16_8
0x071F   HL2XY
0x0A5A   POS_TB_CRS_32
0x0711   CONT_POS_CURS
0x0A8A   POS_TB_CRS_40
0x52F7   LSTCSRSTA
0x06C9   MOVSHOWCRS
0x06DE   NEWCRSRCOORD
0x06F3   RSTCHRCRS
0x06FC   LOAD_CRSR_POS
0x06B2   READ_VSTAT
0x06A7   WRITE_VREG
0x0692   WRITE_VIDEO_LOC
0x067D   READ_VIDEO_LOC
0x06C3   MOVCRS
0x52F3   SCR_CUR_NX
0x0000   NLLCR
0x52F4   SCR_CUR_NY
0x0673   ATHOME
0x06B9   POS_CURSOR
0x0666   CLEARVIDBUF
0x0653   RPTFLL1
0x0641   SNDCLRSET
0x063D   STARTEMPTY
0x0607   CLRG2PTNTBL
0x05ED   RPTEMPTYBUF
0x05E7   LDCOLSTOEMPTY
0x0626   EMPTYMC
0x05F6   EMPTYG2
0x05CC   LVCKSPLK
0x0D2E   READKBLN
0x05AF   SNDLOGPT
0x2C9D   COMPL
0x501A   LOGOFONT
0x0CB0   NOBEEP
0x0CAA   WLCMBEEP
0x057B   RPT100
0x05BE   CHKSPCK
0x0591   BEEPOFF
0x0585   SETBEEP
0x054F   DEC_D
0x5341   DOS_EN
0x52FC   TMPBFR1
0x053D   RPT104
0x0599   LOADLOGOCHRS
0x0535   RPT103
0x0B3C   LM80CLOGO
0x051F   RPT102
0x0C8D   RSTPSG
0x051C   RPT101
0x05B9   CLRTABLE
0x056E   ERASECLRTBL
0x064B   SETNAMETABLE
0x0AE0   SET_GFX_MODE2
0x52F5   SCR_ORG_CHR
0x05CE   EMPTYVIDBUF
0x0459   LDCLRTBMD1
0x52FA   FRGNDCLR
0x065D   SETVDPADRS
0x04E9   ENDVDPSET
0x52EF   SCR_NAM_TB
0x51C1   COMMAN
0x52EC   SCR_SIZE_H
0x52EB   SCR_SIZE_W
0x52FB   BKGNDCLR
0x52F2   SCR_CURS_Y
0x04E0   LDCLRTBEX2
0x52F1   SCR_CURS_X
0x0AF4   LOADCHARSET
0x03F8 X TXTMD
0x04A7   EXG2MD
0x0484   MCMD
0x0462   G2MD
0x0422   G1MD
0x52ED   SCR_MODE
0x0ACD   CLR_RAM_REG
0x0AD8   SET_GFX_MODE
0x0ABA   EMPTY_VRAM
0x0367   RESTMR
0x036C   CTCCONF
0x033E X SIO_B_SETS
0x0338   SIO_A_SETS
0x11E5   WARM
0x11E2   COLD
0x092E   CURSOR_OFF
0x031E   ECHO_CHAR
0x0311   CHECKWARM
0x02FA   CORW
0x0919   CURSOR_ON
0x03B6   MSGTXT2
0x0306   COLDSTART
0x517B   basicStarted
0x0378   MSGTXT1
0x52F8   PRNTVIDEO
0x3FA2   INITST
0x03D3   initVDP
0x04F4   SHOW_LOGO
0x0C7C   initPSG
0x0342   initCTC
0x02B3   INIT_HW2
0x52AD   TEMPSTACK
0x02B0   INIT_HW
0x0D43   KEYBOARD
0x0CDE   MNGSNDS
0x07B8   FLASHCURSOR
0x029C   CHKCRSR
0x0296   INCTMR3
0x52DB   TMRCNT
0x028D   CH3_TIMER
0x027F   RAWPRINT
0x026B   EXTXA
0x026E   TX_EMP
0x0266   TXA_EXIT
0x0257   CNTTXA
0x0249   RXA_EXIT
0x0238   NOTRDWRAP
0x5178   serRdPtr
0x511E   SERBUF_START
0x020B   NOTWRAP
0x0076   bufWrap
0x5176   serInPtr
0x01FF   NOTFULL
0x517A   serBufUsed
0x01E2   SIO_B_EI
0x01E8   SIO_RXEN
0x01DA   SIO_A_EI
0x01D0   SIO_RXDI
0x01B0 X B_RTS_ON
0x01B6   SIO_RTS_ON
0x01A8   A_RTS_ON
0x5340   SERBBITS
0x019C   SIO_RTS_OFF
0x533F   SERABITS
0x0180   EMPTYCHBBFR
0x01CA   SIO_B_DI
0x0196   B_RTS_OFF
0x3CFD   SOERR
0x015C   CHABFREMPTY
0x014E   EMPTYCHABFR
0x533E   SERIALS_EN
0x01C2   SIO_A_DI
0x1183   GMMSG
0x074E   CHAR2VID
0x52F6   CRSR_STATE
0x5336   KBDNPT
0x0120   CNTRXCHA
0x000D   CR
0x52F9   CHR4VID
0x0130   LVRXCHA
0x01F4   CHARINTOBFR
0x5338   TMPKEYBFR
0x018E   A_RTS_OFF
0x00EC   FMVEREND
0x00D0 X FWVER
0x517F   NMIUSR
0x52E8   CTC3IV
0x52E5   CTC2IV
0x52E2   CTC1IV
0x52DF   CTC0IV
0x027A   CKINCHAR
0x0018 X RST18
0x0223   RXA
0x0010 X RST10
0x0135   SPEC_RXA_CNDT
0x0100   RX_CHA_AVAIL
0x024D   TXA
0x0008 X RST08
0x0167   SPEC_RXB_CNDT
0x0164   RX_CHB_AVAIL
0x50EF   ROM2RAM
0x0000 X RST00
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x0058   SER_BUFSIZE
0x0041   PSG_DAT
0x0040   PSG_REG
0x0032   VDP_SET
0x0030   VDP_DAT
0x0021   SIO_DB
0x0020   SIO_DA
0x0023   SIO_CB
0x0022   SIO_CA
0x0013   CTC_CH3
0x0012   CTC_CH2
0x0011   CTC_CH1
0x0010   CTC_CH0
0x0003   PIO_CB
0x0002 X PIO_CA
0x0001   PIO_DB
0x0000 X PIO_DA
