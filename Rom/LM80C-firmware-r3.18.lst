# file opened: LM80C-firmware-r3.18.asm
   1  0000              ; ------------------------------------------------------------------------------
   2  0000              ; LM80C - FIRMWARE - R3.18
   3  0000              ; ------------------------------------------------------------------------------
   4  0000              ; The following code is intended to be used with LM80C Z80-based computer
   5  0000              ; designed by Leonardo Miliani. More info at
   6  0000              ; www DOT leonardomiliani DOT com
   7  0000              ; ------------------------------------------------------------------------------
   8  0000              ; Coding/Editing/Compiling:
   9  0000              ; Original init code for MC68B05 by Grant Searle
  10  0000              ; Original SIO/CTC/PIO init code by Mario Blunk
  11  0000              ; NASCOM BASIC originally modified by Gran Searle
  12  0000              ; Code modified and adapted for LM80C by Leonardo Miliani
  13  0000              ;
  14  0000              ; Edited with Visual Studio Code
  15  0000              ;
  16  0000              ; Compiled with SjASMPlus assembler 1.18.0
  17  0000              ; https://github.com/z00m128/sjasmplus
  18  0000              ; ------------------------------------------------------------------------------
  19  0000              ; Copyright notes:
  20  0000              ; Parts of the code (c) Grant Searle - free for non commercial use
  21  0000              ; Please include this advice and the note to the attribution of the original
  22  0000              ; version to Grant Searle if you intend to redistribuite it
  23  0000              ; http://searle.hostei.com/grant/index.html
  24  0000              ; eMail: home.micros01@btinternet.com
  25  0000              ;
  26  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  27  0000              ; Parts of the code (c) Mario Blunk
  28  0000              ; http://www.trainÂ­z.de
  29  0000              ;
  30  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  31  0000              ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  32  0000              ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  33  0000              ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  34  0000              ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  35  0000              ; the original ROM code (checksum A934H). PA
  36  0000              ;
  37  0000              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  38  0000              ; The following code is intended to be used with LM80C Z80-based computer
  39  0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
  40  0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
  41  0000              ; kind of warranty: you can use them at your own risk.
  42  0000              ; You are free to use them for any non-commercial use: you are only asked to
  43  0000              ; maintain the copyright notices, include this advice and the note to the
  44  0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  45  0000              ; redistribuite them.
  46  0000              ; https://www.leonardomiliani.com
  47  0000              ;
  48  0000              ; Please support me by visiting the following links:
  49  0000              ; Main project page: https://www.leonardomiliani.com
  50  0000              ; Schematics and code: https://github.com/leomil72/LM80C
  51  0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  52  0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  53  0000              ; ------------------------------------------------------------------------------
  54  0000              ; output binary file
  55  0000                  OUTPUT "LM80C-firmware-r3.18.bin"
  56  0000
  57  0000              ; set computer model
  58  0000                  DEFINE LM80C
  59  0000
  60  0000              ; set firmware version
  61  0000                  DEFINE VERSION "3.18"
  62  0000
  63  0000              ; define shorter VDP_DAT load instruction
  64  0000                  DEFINE LD_VDP_DAT ld      C,VDP_DAT
  65  0000
  66  0000              ; ------------------------------------------------------------------------------
  67  0000              ; include the latest version of the bootloader: this sets up the address aliases
  68  0000              ; configure the hardware, checks if warm or cold startup and loads the BASIC interpreter
  69  0000                  INCLUDE "../include/bootloader/bootloader-1.05.asm"
# file opened: ../include/bootloader/bootloader-1.05.asm
   1+ 0000              ; ------------------------------------------------------------------------------
   2+ 0000              ; LM80C - BOOTLOADER - 1.04
   3+ 0000              ; ------------------------------------------------------------------------------
   4+ 0000              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0000              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0000              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0000              ; kind of warranty: you can use them at your own risk.
   8+ 0000              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0000              ; maintain the copyright notices, include this advice and the note to the
  10+ 0000              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0000              ; redistribuite them.
  12+ 0000              ; https://www.leonardomiliani.com
  13+ 0000              ;
  14+ 0000              ; Please support me by visiting the following links:
  15+ 0000              ; Main project page: https://www.leonardomiliani.com
  16+ 0000              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0000              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0000              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0000              ; ------------------------------------------------------------------------------
  20+ 0000
  21+ 0000              ; ADDRESS DECODING (bits A6/A5/A4)
  22+ 0000              ; 0000xxxx : PIO
  23+ 0000              ; 0001xxxx : CTC
  24+ 0000              ; 0010xxxx : SIO
  25+ 0000              ; 0011xxxx : VDP
  26+ 0000              ; 0100xxxx : PSG
  27+ 0000              ; 0101xxxx : C.F.
  28+ 0000
  29+ 0000
  30+ 0000              ; ------------------------------------------------------------------------------
  31+ 0000              ;               EQUATES
  32+ 0000              ; ------------------------------------------------------------------------------
  33+ 0000              ; label defining for PIO (Parallel Input/Output)
  34+ 0000              PIO_DA          equ %00000000
  35+ 0000              PIO_DB          equ %00000001
  36+ 0000              PIO_CA          equ %00000010
  37+ 0000              PIO_CB          equ %00000011
  38+ 0000
  39+ 0000              ; label defining for CTC (Counter Timer Circuit)
  40+ 0000              CTC_CH0         equ %00010000
  41+ 0000              CTC_CH1         equ %00010001
  42+ 0000              CTC_CH2         equ %00010010
  43+ 0000              CTC_CH3         equ %00010011
  44+ 0000
  45+ 0000              ;label defining for SIO (Serial Input/Output)
  46+ 0000              SIO_CA          equ %00100010
  47+ 0000              SIO_CB          equ %00100011
  48+ 0000              SIO_DA          equ %00100000
  49+ 0000              SIO_DB          equ %00100001
  50+ 0000
  51+ 0000              ;label defining for VDP (Video Display Processor)
  52+ 0000              VDP_DAT         equ %00110000
  53+ 0000                  IFDEF LM8064K
  54+ 0000 ~            VDP_SET         equ %00110001
  55+ 0000                  ELSE
  56+ 0000              VDP_SET         equ %00110010
  57+ 0000                  ENDIF
  58+ 0000
  59+ 0000              ; label defining for PSG (Programmable Sound Generator)
  60+ 0000              PSG_REG         equ %01000000
  61+ 0000              PSG_DAT         equ %01000001
  62+ 0000
  63+ 0000              ; Interrupt-driven serial I/O interface lead by the Z80 SIO to run modified
  64+ 0000              ; NASCOM Basic 4.7 - Full input buffering with incoming data hardware handshaking
  65+ 0000              ; Handshake shows full before the buffer is totally filled to allow run-on from the sender
  66+ 0000              SER_BUFSIZE     equ     $58
  67+ 0000              SER_FULLSIZE    equ     $50
  68+ 0000              SER_EMPTYSIZE   equ     $05
  69+ 0000
  70+ 0000
  71+ 0000              ;------------------------------------------------------------------------------
  72+ 0000              ;                                F I R M W A R E
  73+ 0000              ;------------------------------------------------------------------------------
  74+ 0000              ; BASE MEMORY - RESET LOCATION ($0000) -> the CPU jumps to $0000 after a reset
  75+ 0000                              org     $0000
  76+ 0000 F3           RST00:          di                      ; be sure that INTs are disabled
  77+ 0001                  IFDEF LM80C64K
  78+ 0001 ~                            jp      ROM2RAM         ; jump to ROM/RAM switcher
  79+ 0001                  ELSE
  80+ 0001 C3 B0 02                     jp      INIT_HW         ; jump to system initialization
  81+ 0004                  ENDIF
  82+ 0004
  83+ 0004              ;------------------------------------------------------------------------------
  84+ 0004              ; interrupt vector when SIO ch.B has a char available in its buffer
  85+ 0004                              ;$0004
  86+ 0004 64 01                        defw    RX_CHB_AVAIL
  87+ 0006
  88+ 0006              ;------------------------------------------------------------------------------
  89+ 0006              ; interrupt vector for SIO ch.B special conditions (i.e. buf overrun)
  90+ 0006                              ;$0006
  91+ 0006 67 01                        defw    SPEC_RXB_CNDT
  92+ 0008
  93+ 0008              ;------------------------------------------------------------------------------
  94+ 0008              ; send a character over serial ch. A
  95+ 0008                              ;$0008
  96+ 0008 C3 4D 02     RST08:          jp      TXA
  97+ 000B FF                           BLOCK   1,$FF   ; filler
  98+ 000C
  99+ 000C              ;------------------------------------------------------------------------------
 100+ 000C              ; interrupt vector when SIO ch.A has a char available in its buffer
 101+ 000C                              ;$000C
 102+ 000C 00 01                        defw    RX_CHA_AVAIL
 103+ 000E
 104+ 000E              ;------------------------------------------------------------------------------
 105+ 000E              ; interrupt vector for SIO ch.A special conditions (i.e. buf overrun)
 106+ 000E                              ;$000E
 107+ 000E 35 01                        defw    SPEC_RXA_CNDT
 108+ 0010
 109+ 0010              ;------------------------------------------------------------------------------
 110+ 0010              ; receive a character over serial ch. A
 111+ 0010                              ;$0010
 112+ 0010 C3 23 02     RST10:          jp      RXA
 113+ 0013 FF FF FF...                  BLOCK   5,$FF   ; filler
 114+ 0018              ;------------------------------------------------------------------------------
 115+ 0018              ; check serial status
 116+ 0018
 117+ 0018                              ;$0018
 118+ 0018 C3 7A 02     RST18:          jp      CKINCHAR
 119+ 001B FF FF FF...                  BLOCK   $25,$FF ; filler
 120+ 0040              ;------------------------------------------------------------------------------
 121+ 0040              ; interrupt vectors for CTC
 122+ 0040                              ;$0040               ; for CH0 Timer - used in BASIC by serial 1 for bps
 123+ 0040 C1 81                        defw    CTC0IV
 124+ 0042                              ;$0042               ; for CH1 Timer - used in BASIC by serial 2 for bps
 125+ 0042 C4 81                        defw    CTC1IV
 126+ 0044                              ;$0044               ; for CH2 timer - unused
 127+ 0044 C7 81                        defw    CTC2IV
 128+ 0046                              ;$0046               ; for CH3 Timer - used by FW for 100ths/s counter
 129+ 0046 CA 81                        defw    CTC3IV
 130+ 0048 FF FF FF...                  BLOCK   $1E,$FF ; filler
 131+ 0066              ;------------------------------------------------------------------------------
 132+ 0066              ; interrupt routine for NMI
 133+ 0066                              ;$0066
 134+ 0066 C3 61 80                     jp      NMIUSR              ; jump to execute NMI service routine
 135+ 0069 FF FF FF...                  BLOCK   $27,$FF ; filler
 136+ 0090              ;------------------------------------------------------------------------------
 137+ 0090
 138+ 0090                              ;$0090
 139+ 0090                  IFDEF LM80C
 140+ 0090 4C 4D 38 30                  defb    $4C,$4D,$38,$30,$43,$20,$43,$4F
 140+ 0094 43 20 43 4F
 141+ 0098 4C 4F 52 00                  defb    $4C,$4F,$52,$00,$00,$00,$00,$00
 141+ 009C 00 00 00 00
 142+ 00A0                  ELSE
 143+ 00A0 ~                            defb    $4C,$4D,$38,$30,$43,$20,$36,$34
 144+ 00A0 ~                            defb    $4B,$20,$43,$4F,$4C,$4F,$52,$00
 145+ 00A0                  ENDIF
 146+ 00A0 43 4F 4D 50                  defb    $43,$4F,$4D,$50,$55,$54,$45,$52
 146+ 00A4 55 54 45 52
 147+ 00A8 20 28 32 30                  defb    $20,$28,$32,$30,$32,$30,$29,$00
 147+ 00AC 32 30 29 00
 148+ 00B0 44 65 73 69                  defb    $44,$65,$73,$69,$67,$6E,$65,$64
 148+ 00B4 67 6E 65 64
 149+ 00B8 20 62 79 00                  defb    $20,$62,$79,$00,$00,$00,$00,$00
 149+ 00BC 00 00 00 00
 150+ 00C0 4C 65 6F 6E                  defb    $4C,$65,$6F,$6E,$61,$72,$64,$6F
 150+ 00C4 61 72 64 6F
 151+ 00C8 20 4D 69 6C                  defb    $20,$4D,$69,$6C,$69,$61,$6E,$69
 151+ 00CC 69 61 6E 69
 152+ 00D0 46 57 20 33  FWVER:          defm    "FW ","3.18",$20,"2021-01-05",$20,"17:57:13",$00
 152+ 00D4 2E 31 38 20
 152+ 00D8 32 30 32 31
 152+ 00DC 2D 30 31 2D
 152+ 00E0 30 35 20 31
 152+ 00E4 37 3A 35 37
 152+ 00E8 3A 31 33 00
 153+ 00EC              FMVEREND:       equ     $
 154+ 00EC FF FF FF...                  BLOCK   $100-FMVEREND,$FF   ; filler
 155+ 0100              ;------------------------------------------------------------------------------
 156+ 0100
 157+ 0100              ;-------------------------------------------------------------------------------
 158+ 0100              ;               Z80 SIO CH. A MANAGEMENT
 159+ 0100              ;-------------------------------------------------------------------------------
 160+ 0100
 161+ 0100              ;-------------------------------------------------------------------------------
 162+ 0100              ; interrupt driven routine to get chars from Z80 SIO ch.A
 163+ 0100              ; this is the only channel that can print received chars onto the screen
 164+ 0100                              ;$0100
 165+ 0100 F5           RX_CHA_AVAIL:   push    AF              ; store A
 166+ 0101 E5                           push    HL              ; and HL
 167+ 0102 CD 8E 01                     call    A_RTS_OFF       ; disable RTS line
 168+ 0105 DB 20                        in      A,(SIO_DA)      ; read char from RX buffer into A
 169+ 0107 32 1A 82                     ld      (TMPKEYBFR),A   ; store it into the temp key buffer
 170+ 010A CD F4 01                     call    CHARINTOBFR     ; sub-routine to put the char into the input buffer
 171+ 010D D2 30 01                     jp      NC,LVRXCHA      ; if buffer is full, then leave without doing anything else
 172+ 0110 3A 1A 82                     ld      A,(TMPKEYBFR)   ; retrieve char
 173+ 0113 32 DB 81                     ld      (CHR4VID),A     ; write into buffer for video printing
 174+ 0116 FE 0D                        cp      CR              ; is it RETURN?
 175+ 0118 CA 20 01                     jp      Z,CNTRXCHA      ; yes, continue
 176+ 011B FE 20                        cp      $20             ; is it another control char (code < 32)?
 177+ 011D DA 30 01                     jp      C,LVRXCHA       ; yes, leave w/o printing it on video nor sending back to serial
 178+ 0120 F5           CNTRXCHA:       push    AF              ; store char
 179+ 0121 AF                           xor     A
 180+ 0122 32 18 82                     ld      (KBDNPT),A      ; a char from serial is like a char printed by BASIC
 181+ 0125 3A D8 81                     ld      A,(CRSR_STATE)  ; check cursor state
 182+ 0128 B7                           or      A               ; is it on?
 183+ 0129 C4 6E 07                     call    NZ,CHAR2VID     ; yes, print on screen
 184+ 012C F1                           pop     AF              ; retrieve char
 185+ 012D CD 4D 02                     call    TXA             ; send back to serial
 186+ 0130 E1           LVRXCHA:        pop     HL              ; retrieve HL
 187+ 0131 F1                           pop     AF              ; and A
 188+ 0132 FB                           ei                      ; re-enable interrupts
 189+ 0133 ED 4D                        reti                    ; and exit
 190+ 0135
 191+ 0135              ;-------------------------------------------------------------------------------
 192+ 0135              ; special SIO ch.A condition (i.e., buffer overrun)
 193+ 0135              ; if buffer overruns then show an error, empty the RX buffer and send
 194+ 0135              ; a break char
 195+ 0135 F5           SPEC_RXA_CNDT:  push    AF              ; store AF
 196+ 0136 CD 8E 01                     call    A_RTS_OFF       ; disable RTS
 197+ 0139 CD C2 01                     call    SIO_A_DI        ; disable RX on ch. A
 198+ 013C 3A 20 82                     ld      A,(SERIALS_EN)  ; load serial status
 199+ 013F CB 97                        res     2,A             ; disable RX on port 1
 200+ 0141 32 20 82                     ld      (SERIALS_EN),A  ; store new serial status
 201+ 0144 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 202+ 0146 CB E7                        set     4,A             ; set 5th pin ON
 203+ 0148 D3 01                        out     (PIO_DB),A      ; send new setting
 204+ 014A 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 205+ 014C D3 22                        out     (SIO_CA),A      ; send command to SIO
 206+ 014E AF           EMPTYCHABFR:    xor     A
 207+ 014F D3 22                        out     (SIO_CA),A      ; write to WR0, select RR0
 208+ 0151 DB 22                        in      A,(SIO_CA)      ; read RR0 register
 209+ 0153 E6 01                        and     $01             ; check if input buffer if empty
 210+ 0155 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then leave
 211+ 0158 DB 20                        in      A,(SIO_DA)      ; read chars
 212+ 015A 18 F2                        jr      EMPTYCHABFR     ; repeat
 213+ 015C F1           CHABFREMPTY:    pop     AF              ; retrieve AF
 214+ 015D 21 24 3D                     ld      HL,SOERR        ; return point set to Serial Buffer Overrun routine
 215+ 0160 E3                           ex      (SP),HL         ; store onto stack
 216+ 0161 FB                           ei                      ; re-enable interrupts
 217+ 0162 ED 4D                        reti                    ; return from interrupt and execute code at SOERR
 218+ 0164
 219+ 0164              ;-------------------------------------------------------------------------------
 220+ 0164              ;               Z80 SIO CH. A MANAGEMENT
 221+ 0164              ;-------------------------------------------------------------------------------
 222+ 0164
 223+ 0164              ;-------------------------------------------------------------------------------
 224+ 0164              ; interrupt driven routine to get chars from Z80 SIO ch.B
 225+ 0164 FB           RX_CHB_AVAIL:   ei
 226+ 0165 ED 4D                        reti
 227+ 0167
 228+ 0167              ;-------------------------------------------------------------------------------
 229+ 0167              ; special SIO ch.A condition (i.e., buffer overrun)
 230+ 0167              ; if buffer overruns then show an error, empty the RX buffer and send
 231+ 0167              ; a break char
 232+ 0167 F5           SPEC_RXB_CNDT:  push    AF              ; store A
 233+ 0168 CD 96 01                     call    B_RTS_OFF       ; disable RTS
 234+ 016B CD CA 01                     call    SIO_B_DI        ; disable RX on ch.B
 235+ 016E 3A 20 82                     ld      A,(SERIALS_EN)  ; load serial status
 236+ 0171 CB 9F                        res     3,A             ; disable RX on port 2
 237+ 0173 32 20 82                     ld      (SERIALS_EN),A  ; store new serial status
 238+ 0176 DB 01                        in      A,(PIO_DB)      ; read status LEDs
 239+ 0178 CB EF                        set     5,A             ; set 5th pin ON
 240+ 017A D3 01                        out     (PIO_DB),A      ; send new setting
 241+ 017C 3E 30                        ld      A,%00110000     ; write into WR0: error reset, select WR0
 242+ 017E D3 23                        out     (SIO_CB),A      ; send command to SIO
 243+ 0180 AF           EMPTYCHBBFR:    xor     A
 244+ 0181 D3 23                        out     (SIO_CB),A      ; write to WR0, select RR0
 245+ 0183 DB 23                        in      A,(SIO_CB)      ; read RR0 register
 246+ 0185 E6 01                        and     $01             ; check if input buffer if empty
 247+ 0187 CA 5C 01                     jp      Z,CHABFREMPTY   ; if yes (bit 0 = 0) then jump to run "exit" code
 248+ 018A DB 21                        in      A,(SIO_DB)      ; read chars
 249+ 018C 18 F2                        jr      EMPTYCHBBFR     ; repeat
 250+ 018E
 251+ 018E
 252+ 018E              ;-------------------------------------------------------------------------------
 253+ 018E              ;               Z80 SIO MANAGEMENT
 254+ 018E              ;-------------------------------------------------------------------------------
 255+ 018E              ; disable RTS:
 256+ 018E              ; by resetting RTS bit (set to 0), the RTS line is disabled (HIGH)
 257+ 018E C5           A_RTS_OFF:      push    BC              ; store BC
 258+ 018F 0E 22                        ld      C,SIO_CA        ; select channel A
 259+ 0191 3A 21 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 260+ 0194 18 06                        jr      SIO_RTS_OFF
 261+ 0196 C5           B_RTS_OFF:      push    BC              ; store BC
 262+ 0197 0E 23                        ld      C,SIO_CB        ; select channel B
 263+ 0199 3A 22 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 264+ 019C 47           SIO_RTS_OFF:    ld      B,A             ; store data bits
 265+ 019D 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 266+ 019F ED 79                        out     (C),A
 267+ 01A1 78                           ld      A,B             ; retrieve data bits
 268+ 01A2 F6 28                        or      %00101000       ; TX enable; RTS disable
 269+ 01A4 ED 79                        out     (C),A           ; send setting
 270+ 01A6 C1                           pop     BC              ; retrieve BC
 271+ 01A7 C9                           ret                     ; exit
 272+ 01A8
 273+ 01A8              ;-------------------------------------------------------------------------------
 274+ 01A8              ; enable RTS
 275+ 01A8              ; by setting RTS bit (set to 1), the RTS line is enabled (LOW)
 276+ 01A8 C5           A_RTS_ON:       push    BC              ; store BC
 277+ 01A9 0E 22                        ld      C,SIO_CA        ; select channel A
 278+ 01AB 3A 21 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 279+ 01AE 18 06                        jr      SIO_RTS_ON
 280+ 01B0 C5           B_RTS_ON:       push    BC              ; store BC
 281+ 01B1 0E 23                        ld      C,SIO_CB        ; select channel B
 282+ 01B3 3A 22 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 283+ 01B6 47           SIO_RTS_ON:     ld      B,A             ; store data bits
 284+ 01B7 3E 05                        ld      A,%00000101     ; write into WR0: select WR5
 285+ 01B9 ED 79                        out     (C),A
 286+ 01BB 78                           ld      A,B             ; retrieve data bits
 287+ 01BC F6 2A                        or      %00101010       ; TX enable; RTS enable
 288+ 01BE ED 79                        out     (C),A           ; send setting
 289+ 01C0 C1                           pop     BC              ; retrieve BC
 290+ 01C1 C9                           ret                     ; return
 291+ 01C2
 292+ 01C2              ;-------------------------------------------------------------------------------
 293+ 01C2              ; disable SIO RX channel
 294+ 01C2 C5           SIO_A_DI:       push    BC              ; store BC
 295+ 01C3 0E 22                        ld      C,SIO_CA        ; SIO channel A
 296+ 01C5 3A 21 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 297+ 01C8 18 06                        jr      SIO_RXDI        ; jump to disable RX
 298+ 01CA C5           SIO_B_DI:       push    BC              ; store BC
 299+ 01CB 0E 23                        ld      C,SIO_CB        ; SIO channel B
 300+ 01CD 3A 22 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 301+ 01D0 47           SIO_RXDI:       ld      B,A             ; store data bits
 302+ 01D1 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 303+ 01D3 ED 79                        out     (C),A
 304+ 01D5 78                           ld      A,B             ; retrieve data bits; RX disabled; auto enable is OFF
 305+ 01D6 ED 79                        out     (C),A
 306+ 01D8 C1                           pop     BC              ; retrieve BC
 307+ 01D9 C9                           ret                     ; return
 308+ 01DA
 309+ 01DA              ;-------------------------------------------------------------------------------
 310+ 01DA              ; enable SIO RX channel
 311+ 01DA C5           SIO_A_EI:       push    BC              ; store BC
 312+ 01DB 0E 22                        ld      C,SIO_CA
 313+ 01DD 3A 21 82                     ld      A,(SERABITS)    ; load data serial bits for ch.A
 314+ 01E0 18 06                        jr      SIO_RXEN
 315+ 01E2 C5           SIO_B_EI:       push    BC              ; store BC
 316+ 01E3 0E 23                        ld      C,SIO_CB
 317+ 01E5 3A 22 82                     ld      A,(SERBBITS)    ; load data serial bits for ch.B
 318+ 01E8 47           SIO_RXEN:       ld      B,A             ; store data bits
 319+ 01E9 3E 03                        ld      A,%00000011     ; write into WR0: select WR3
 320+ 01EB ED 79                        out     (C),A           ; select register
 321+ 01ED 78                           ld      A,B             ; retrieve data bits
 322+ 01EE CB C7                        set     0,A             ; set RX enabled; auto enable is OFF
 323+ 01F0 ED 79                        out     (C),A           ; send settings to SIO
 324+ 01F2 C1                           pop     BC              ; retrieve BC
 325+ 01F3 C9                           ret
 326+ 01F4
 327+ 01F4              ;------------------------------------------------------------------------------
 328+ 01F4              ; put a char into the input buffer, char is into A
 329+ 01F4              ; this sub is called both from the ISR "RX_CHA_AVAIL" and when
 330+ 01F4              ; the RETURN key is pressed on the keyboard
 331+ 01F4 F5           CHARINTOBFR:    push    AF              ; store it
 332+ 01F5 3A 5C 80                     ld      A,(serBufUsed)  ; load buffer size
 333+ 01F8 FE 58                        cp      SER_BUFSIZE     ; if buffer is not full
 334+ 01FA DA FF 01                     jp      C,NOTFULL       ; then store the char
 335+ 01FD F1                           pop     AF              ; else drop it
 336+ 01FE C9                           ret                     ; and exit
 337+ 01FF 2A 58 80     NOTFULL:        ld      HL,(serInPtr)   ; buffer is not full, can store the char
 338+ 0202 23                           inc     HL              ; load pointer to find first free cell
 339+ 0203 7D                           ld      A,L             ; only check low byte because buffer<256
 340+ 0204 FE 58                        cp      bufWrap         ; check if the pointer is at the last cell
 341+ 0206 20 03                        jr      NZ,NOTWRAP      ; if not then continue
 342+ 0208 21 00 80                     ld      HL,SERBUF_START ; else load the address of the first cell
 343+ 020B 22 58 80     NOTWRAP:        ld      (serInPtr),HL   ; store the new pointer
 344+ 020E F1                           pop     AF              ; then recover the char
 345+ 020F 77                           ld      (HL),A          ; and store it in the appropriate cell
 346+ 0210 3A 5C 80                     ld      A,(serBufUsed)  ; load the size of the input buffer
 347+ 0213 3C                           inc     A               ; increment it
 348+ 0214 32 5C 80                     ld      (serBufUsed),A  ; and store the new size
 349+ 0217 FE 50                        cp      SER_FULLSIZE    ; check if input buffer is full
 350+ 0219 D8                           ret     C               ; exit if buffer is not full
 351+ 021A 3A 20 82                     ld      A,(SERIALS_EN)  ; check if serial 1 is open
 352+ 021D 1F                           rra                     ; bit 0 into Carry: if Carry is 1 then serial 0 is open and...
 353+ 021E DC 8E 01                     call    C,A_RTS_OFF     ; ...stop receiving further chars
 354+ 0221 AF                           xor     A               ; clear Carry to set a buffer full condition
 355+ 0222 C9                           ret
 356+ 0223
 357+ 0223
 358+ 0223              ;-------------------------------------------------------------------------------
 359+ 0223              ; retrieve a char from the input buffer
 360+ 0223 3A 5C 80     RXA:            ld      A,(serBufUsed)  ; load the buffer size
 361+ 0226 A7                           and     A               ; check if it's 0 (empty)
 362+ 0227 CA 23 02                     jp      Z,RXA           ; if it's empty, wait for a char
 363+ 022A F3                           di                      ; disable interrupts
 364+ 022B E5                           push    HL              ; store HL
 365+ 022C 2A 5A 80                     ld      HL,(serRdPtr)   ; load pointer to first available char
 366+ 022F 23                           inc     HL              ; increment it (go to the next char)
 367+ 0230 7D                           ld      A,L             ; check if the end of the buffer has been reached
 368+ 0231 FE 58                        cp      bufWrap         ; (only check low byte because buffer<256)
 369+ 0233 20 03                        jr      NZ,NOTRDWRAP    ; if not, jump straight
 370+ 0235 21 00 80                     ld      HL,SERBUF_START ; else reload the starting address of the buffer
 371+ 0238 22 5A 80     NOTRDWRAP:      ld      (serRdPtr),HL   ; store new pointer to the next char to read
 372+ 023B 3A 5C 80                     ld      A,(serBufUsed)  ; load buffer size
 373+ 023E 3D                           dec     A               ; decrement it
 374+ 023F 32 5C 80                     ld      (serBufUsed),A  ; and store the new size
 375+ 0242 FE 05                        cp      SER_EMPTYSIZE   ; check if input buffer can be considered empty
 376+ 0244 30 03                        jr      NC,RXA_EXIT     ; if not empty yet, then exit
 377+ 0246 CD A8 01                     call    A_RTS_ON        ; else re-enable receiving chars
 378+ 0249 7E           RXA_EXIT:       ld      A,(HL)          ; recover the char and return it into A
 379+ 024A E1                           pop     HL              ; retrieve HL
 380+ 024B FB                           ei                      ; re-enable interrupts
 381+ 024C C9                           ret                     ; return
 382+ 024D
 383+ 024D              ;------------------------------------------------------------------------------
 384+ 024D              ; sends a char over the serial (trick for INTs from WikiTI)
 385+ 024D              ; char is into A
 386+ 024D F5           TXA:            push    AF              ; store AF
 387+ 024E C5                           push    BC              ; store BC
 388+ 024F 47                           ld      B,A             ; store char
 389+ 0250 ED 57                        ld      A,I             ; when loading I into A, P/V is set to the value of IFF (P/V is set if INTs enabled)
 390+ 0252 EA 57 02                     jp      PE,CNTTXA       ; if set, jump over
 391+ 0255 ED 57                        ld      A,I             ; if not set, test again to fix "false negative" from interrupt occurring at first test
 392+ 0257 F5           CNTTXA:         push    AF              ; store current P/V flag
 393+ 0258 F3                           di                      ; disable INTs
 394+ 0259 3A 20 82                     ld      A,(SERIALS_EN)  ; load serial status
 395+ 025C FE 05                        cp      %00000101       ; check if serial 1 is open and RX/TX is enabled
 396+ 025E 20 06                        jr      NZ,TXA_EXIT     ; no, jump over
 397+ 0260 78                           ld      A,B             ; retrieve char
 398+ 0261 D3 20                        out     (SIO_DA),A      ; send char to the SIO
 399+ 0263 CD 6E 02                     call    TX_EMP          ; wait for outgoing char to be sent
 400+ 0266 F1           TXA_EXIT:       pop     AF              ; retrieve P/V flag
 401+ 0267 E2 6B 02                     jp      PO,EXTXA        ; if P is reset, INTs were disabled so we can leave right now
 402+ 026A FB                           ei                      ; INTs were enabled, so re-enable interrupts
 403+ 026B C1           EXTXA:          pop     BC              ; retrieve BC
 404+ 026C F1                           pop     AF              ; retrieve AF
 405+ 026D C9                           ret                     ; return
 406+ 026E
 407+ 026E              ;------------------------------------------------------------------------------
 408+ 026E              ; wait until outgoing serial has been sent
 409+ 026E 97           TX_EMP:         sub     A               ; set A to 0
 410+ 026F 3C                           inc     A               ; set A to 1
 411+ 0270 D3 22                        out     (SIO_CA),A      ; write to WR0, select RR1
 412+ 0272 DB 22                        in      A,(SIO_CA)      ; read RR1 register
 413+ 0274 CB 47                        bit     0,A             ; check if all chars have been sent
 414+ 0276 CA 6E 02                     jp      Z,TX_EMP        ; if not (bit 0 = 0) then retrieve
 415+ 0279 C9                           ret                     ; else exit
 416+ 027A
 417+ 027A
 418+ 027A              ;------------------------------------------------------------------------------
 419+ 027A              ; check if there is some chars into the buffer
 420+ 027A 3A 5C 80     CKINCHAR:       ld      A,(serBufUsed)  ; load char in buffer
 421+ 027D A7                           and     A               ; compare to 0
 422+ 027E C9                           ret                     ; return
 423+ 027F
 424+ 027F              ;------------------------------------------------------------------------------
 425+ 027F              ; print a text from memory, and terminate when $00 is found
 426+ 027F 7E           RAWPRINT:       ld      A,(HL)          ; load character from memory cell pointed by HL
 427+ 0280 B7                           or      A               ; is it $00 (end string)?
 428+ 0281 C8                           ret     Z               ; Yes, then return
 429+ 0282 32 DB 81                     ld      (CHR4VID),A     ; store char
 430+ 0285 F3                           di
 431+ 0286 CD 6E 07                     call    CHAR2VID        ; and send it to screen
 432+ 0289 FB                           ei
 433+ 028A 23                           inc     HL              ; and select the next one
 434+ 028B 18 F2                        jr      RAWPRINT        ; repeat
 435+ 028D
 436+ 028D              ;-------------------------------------------------
 437+ 028D              ; Interrupt service routine (ISR) for CH3 timer
 438+ 028D              ; this is used to increment the 100ths of a second counter and for cursor flashing
 439+ 028D F5           CH3_TIMER:      push    AF              ; save regs. A,
 440+ 028E C5                           push    BC              ; BC,
 441+ 028F D5                           push    DE              ; DE,
 442+ 0290 E5                           push    HL              ; HL
 443+ 0291 21 BD 81                     ld      HL,TMRCNT       ; load starting address of the timer
 444+ 0294 06 04                        ld      B,$04           ; 4 bytes to check
 445+ 0296 34           INCTMR3:        inc     (HL)            ; increment timer
 446+ 0297 20 03                        jr      NZ,CHKCRSR      ; if not zero then exit (finished increment)
 447+ 0299 23                           inc     HL              ; if yes, there was an overflow, so increment next byte
 448+ 029A 10 FA                        djnz    INCTMR3         ; repeat for 4 bytes
 449+ 029C CD D8 07     CHKCRSR:        call    FLASHCURSOR     ; call the flashing cursor routine
 450+ 029F CD 03 0D                     call    MNGSNDS         ; call the tone managemenet
 451+ 02A2 3A BD 81                     ld      A,(TMRCNT)      ; check for keyboard management
 452+ 02A5 1F                           rra                     ; bit 0 = 1 ?
 453+ 02A6 D4 68 0D                     call    NC,KEYBOARD     ; no, so read the keyboard inputs
 454+ 02A9 E1                           pop     HL              ; retrieve HL,
 455+ 02AA D1                           pop     DE              ; DE,
 456+ 02AB C1                           pop     BC              ; BC,
 457+ 02AC F1                           pop     AF              ; and A
 458+ 02AD FB                           ei                      ; re-enable interrupts
 459+ 02AE ED 4D                        reti                    ; exit from ISR
 460+ 02B0
 461+ 02B0              ;------------------------------------------------------------------------------
 462+ 02B0              ;               HARDWARE INITIALISATION
 463+ 02B0              ;------------------------------------------------------------------------------
 464+ 02B0              ; first run - setup HW & SW
 465+ 02B0              ; (on LN80C 64K runs from RAM)
 466+ 02B0 21 8F 81     INIT_HW:        ld      HL,TEMPSTACK    ; load temp stack pointer
 467+ 02B3 F9           INIT_HW2:       ld      SP,HL           ; set stack to temp stack pointer
 468+ 02B4 21 00 80                     ld      HL,SERBUF_START ; set beginning of input buffer
 469+ 02B7 22 58 80                     ld      (serInPtr),HL   ; for incoming chars to store into buffer
 470+ 02BA 22 5A 80                     ld      (serRdPtr),HL   ; and for chars to be read from buffer
 471+ 02BD AF                           xor     A               ; reset A
 472+ 02BE 32 5C 80                     ld      (serBufUsed),A  ; actual buffer size is 0
 473+ 02C1 32 20 82                     ld      (SERIALS_EN),A  ; set serial ports status to OFF
 474+ 02C4                  IFDEF LM80C
 475+ 02C4 CD 3B 03                     call    HELLOWRLD       ; little serial blink with LEDs
 476+ 02C7                  ENDIF
 477+ 02C7 CD 60 03                     call    initCTC         ; configure CTC, then...
 478+ 02CA CD A1 0C                     call    initPSG         ; ...configure PSG
 479+ 02CD CD 12 05                     call    SHOW_LOGO       ; show computer logo
 480+ 02D0 1E 01                        ld      E,$01           ; E chooses the video mode (graphics 1)
 481+ 02D2 CD EF 03                     call    initVDP         ; set video display
 482+ 02D5 AF                           xor     A
 483+ 02D6 ED 47                        ld      I,A             ; set high byte of interrupt vectors to point to page 0
 484+ 02D8 ED 5E                        im      2               ; interrupt mode 2
 485+ 02DA FB                           ei                      ; enable interrupts
 486+ 02DB                              ; print system messages
 487+ 02DB AF                           xor     A               ; A=0 so...
 488+ 02DC 32 18 82                     ld      (KBDNPT),A      ; ...inputs don't come from keyboard
 489+ 02DF 3C                           inc     A               ; A=1...
 490+ 02E0 32 DA 81                     ld      (PRNTVIDEO),A   ; ...to activate the print-on-video
 491+ 02E3 21 96 03                     ld      HL,MSGTXT1      ; sign-on message
 492+ 02E6 CD 7F 02                     call    RAWPRINT        ; print message
 493+ 02E9 3A 5D 80                     ld      A,(basicStarted); check if BASIC is already started
 494+ 02EC FE 59                        cp      'Y'             ; to see if this is a power-up
 495+ 02EE 20 19                        jr      NZ,COLDSTART    ; if not, then do a COLD start
 496+ 02F0 21 D2 03                     ld      HL,MSGTXT2      ; message to choose kind of start
 497+ 02F3 CD 7F 02                     call    RAWPRINT        ; print message
 498+ 02F6 CD 39 09                     call    CURSOR_ON       ; enable cursor
 499+ 02F9 AF                           xor     A
 500+ 02FA 32 DA 81                     ld      (PRNTVIDEO),A   ; disable print-on-video
 501+ 02FD CD 23 02     CORW:           call    RXA             ; look for a pressed key
 502+ 0300 E6 DF                        and     %11011111       ; only UPPERCASE char
 503+ 0302 FE 43                        cp      'C'             ; cold start?
 504+ 0304 20 0E                        jr      NZ,CHECKWARM    ; no, let's check for warm start
 505+ 0306 CD 21 03                     call    ECHO_CHAR       ; echoes the char
 506+ 0309 3E 59        COLDSTART:      ld      A,'Y'           ; yes, set the "BASIC started" flag
 507+ 030B 32 5D 80                     ld      (basicStarted),A
 508+ 030E CD 4E 09                     call    CURSOR_OFF      ; disable cursor
 509+ 0311 C3 07 12                     jp      COLD            ; start BASIC COLD
 510+ 0314 FE 57        CHECKWARM:      cp      'W'
 511+ 0316 20 E5                        jr      NZ,CORW         ; char not recognized, wait again
 512+ 0318 CD 21 03                     call    ECHO_CHAR       ; echoes the char
 513+ 031B CD 4E 09                     call    CURSOR_OFF      ; disable cursor
 514+ 031E C3 0A 12                     jp      WARM            ; start BASIC WARM
 515+ 0321
 516+ 0321              ;-------------------------------------------------------------------------------
 517+ 0321              ; send back char received through ch. A
 518+ 0321 32 DB 81     ECHO_CHAR:      ld      (CHR4VID),A     ; set char for video printing
 519+ 0324 AF                           xor     A
 520+ 0325 32 18 82                     ld      (KBDNPT),A      ; input is not from keyboard
 521+ 0328 F3                           di                      ; disable INTs
 522+ 0329 CD 6E 07                     call    CHAR2VID        ; echoes back the pressed key,
 523+ 032C 3E 0D                        ld      A,CR            ; then set a CR
 524+ 032E 32 DB 81                     ld      (CHR4VID),A     ; set char for video printing
 525+ 0331 CD 6E 07                     call    CHAR2VID        ; and send it to screen
 526+ 0334 FB                           ei                      ; re-enable INTs
 527+ 0335 3E 01                        ld      A,$01
 528+ 0337 32 DA 81                     ld      (PRNTVIDEO),A   ; re-enable video printing
 529+ 033A C9                           ret                     ; return to caller
 530+ 033B
 531+ 033B                  IFDEF LM80C
 532+ 033B              ;-------------------------------------------------------------------------------
 533+ 033B              ; little serial blink with LEDs
 534+ 033B 0E 09        HELLOWRLD:      ld      C,$09           ; 8 LEDs to be turned off + 1 more step to turn off the last LED
 535+ 033D 3E CF                        ld      A,%11001111     ; set mode 3 (mode control)
 536+ 033F D3 03                        out     (PIO_CB),A      ; for PIO port B
 537+ 0341 AF                           xor     A               ; set pins to OUTPUT
 538+ 0342 D3 03                        out     (PIO_CB),A      ; for port B
 539+ 0344 3C                           inc     A               ; LSB on
 540+ 0345 D3 01        LEDLIGHT:       out     (PIO_DB),A      ; turn LEDs on/off for a "Supercar" sequence
 541+ 0347 1E 20                        ld      E,$20           ; little delay
 542+ 0349 06 00        DEC_E:          ld      B,$00           ; count to 256
 543+ 034B 10 FE        COUNTER:        djnz    COUNTER         ; decrement inner counter
 544+ 034D 1D                           dec     E               ; decrement outer counter
 545+ 034E 20 F9                        jr      NZ,DEC_E        ; finish delay
 546+ 0350 CB 27                        sla     A               ; shift reg.A to left 1 bit
 547+ 0352 0D                           dec     C               ; next LED
 548+ 0353 20 F0                        jr      NZ,LEDLIGHT     ; all LEDs done? no, repeat
 549+ 0355 C9                           ret                     ; return to caller
 550+ 0356                  ENDIF
 551+ 0356              ;-------------------------------------------------------------------------------
 552+ 0356              ; Z80 SIO default settings for serial channels
 553+ 0356 30           SIO_A_SETS:     defb    %00110000       ; write into WR0: error reset, select WR0
 554+ 0357 18                           defb    %00011000       ; write into WR0: channel reset
 555+ 0358 04                           defb    %00000100       ; write into WR0: select WR4
 556+ 0359 44                           defb    %01000100       ; write into WR4: presc. 16x, 1 stop bit, no parity
 557+ 035A 05                           defb    %00000101       ; write into WR0: select WR5
 558+ 035B E8                           defb    %11101000       ; write into WR5: DTR on, TX 8 bits, BREAK off, TX on, RTS off
 559+ 035C 01           SIO_B_SETS:     defb    %00000001       ; write into WR0: select WR1
 560+ 035D 04                           defb    %00000100       ; write into WR1: status affects interrupt vectors
 561+ 035E 02                           defb    %00000010       ; write into WR0: select WR2
 562+ 035F 00                           defb    %00000000       ; write into WR2: set interrupt vector, but bits D3/D2/D1 of this vector
 563+ 0360                                                      ; will be affected by the channel & condition that raised the interrupt
 564+ 0360                                                      ; (see datasheet): in our example, 0x0C for Ch.A receiving A char, 0x0E
 565+ 0360                                                      ; for special conditions
 566+ 0360              ;------------------------------------------------------------------------------
 567+ 0360              ;               Z80 CTC SETTING UP
 568+ 0360              ;------------------------------------------------------------------------------
 569+ 0360              initCTC:
 570+ 0360 21 8A 03                     ld      HL,CTCCONF      ; CTC configuration
 571+ 0363 11 C1 81                     ld      DE,CTC0IV       ; CTC interrupt vector table
 572+ 0366 01 0C 00                     ld      BC,$000C        ; 12 bytes
 573+ 0369 ED B0                        ldir                    ; copy data
 574+ 036B              ;CH0, CH1, & CH2 disabled
 575+ 036B 3E 03                        ld      A,%00000011     ; interrupt off, timer mode, prescaler=16, don't care ext. TRG edge,
 576+ 036D                                                      ; start timer on loading constant, no time constant follows, software reset, command word
 577+ 036D D3 10                        out     (CTC_CH0),A     ; set CH0
 578+ 036F D3 11                        out     (CTC_CH1),A     ; set CH1
 579+ 0371 D3 12                        out     (CTC_CH2),A     ; set CH2
 580+ 0373              ;init CH3
 581+ 0373              ;CH3 divides CPU CLK by 144*256 providing an interrupt signal at 100 Hz (1/100 sec).
 582+ 0373              ;f = CPU_CLK/(144*256) => 3,686,400 / ( 36,864 ) => 100Hz
 583+ 0373 3E A7                        ld      A,%10100111     ; interrupt on; timer mode; prescaler=256; don't care ext; automatic trigger;
 584+ 0375                                                      ; time constant follows; cont. operation; command word
 585+ 0375 D3 13                        out     (CTC_CH3),A     ; send to CH3
 586+ 0377 3E 90                        ld      A,$90           ; time constant - 90$ (144d)
 587+ 0379 D3 13                        out     (CTC_CH3),A     ; send to CH3
 588+ 037B 3E 40                        ld      A,%01000000     ; D7..D3 provide the first part of the int vector (in our case, $0100), followed by
 589+ 037D                                                      ; D2..D1, provided by the CTC (they point to the channel), D0=interrupt word
 590+ 037D                                                      ; so int vector is 01000xx00
 591+ 037D D3 10                        out     (CTC_CH0),A     ; send to CTC
 592+ 037F                              ; reset cells of 100ths of a second counter
 593+ 037F AF                           xor     A               ; reset A
 594+ 0380 21 BD 81                     ld      HL,TMRCNT       ; load TMR pointer
 595+ 0383 06 04                        ld      B,$04           ; 4 memory cells
 596+ 0385 77           RESTMR:         ld      (HL),A          ; reset n-cell of TMR
 597+ 0386 23                           inc     HL              ; next cell
 598+ 0387 10 FC                        djnz    RESTMR          ; repeat for 4 cells
 599+ 0389 C9                           ret
 600+ 038A
 601+ 038A
 602+ 038A              ;------------------------------------------------------------------------------
 603+ 038A              ; jump table for CHx interrupts
 604+ 038A FB ED 4D     CTCCONF:        defb    $FB,$ED,$4D     ; CTC0 interrupt vector (ei; reti)
 605+ 038D FB ED 4D                     defb    $FB,$ED,$4D     ; CTC1 interrupt vector (ei; reti)
 606+ 0390 FB ED 4D                     defb    $FB,$ED,$4D     ; CTC2 interrupt vector (ei; reti)
 607+ 0393 C3 8D 02                     jp      CH3_TIMER       ; CTC3 interrupt vector (jump to execute sys-tick timer)
 608+ 0396
 609+ 0396
 610+ 0396              ;------------------------------------------------------------------------------
 611+ 0396              ; welcome messages
 612+ 0396              MSGTXT1:
 613+ 0396                  IFDEF LM80C64K
 614+ 0396 ~                            defm    "    LM80C 64K Color Computer",CR
 615+ 0396                  ELSE
 616+ 0396 20 20 20 20                  defm    "      LM80C Color Computer",CR
 616+ 039A 20 20 4C 4D
 616+ 039E 38 30 43 20
 616+ 03A2 43 6F 6C 6F
 616+ 03A6 72 20 43 6F
 616+ 03AA 6D 70 75 74
 616+ 03AE 65 72 0D
 617+ 03B1                  ENDIF
 618+ 03B1 20 62 79 20                  defm    " by Leonardo Miliani * FW R","3.18",CR,0
 618+ 03B5 4C 65 6F 6E
 618+ 03B9 61 72 64 6F
 618+ 03BD 20 4D 69 6C
 618+ 03C1 69 61 6E 69
 618+ 03C5 20 2A 20 46
 618+ 03C9 57 20 52 33
 618+ 03CD 2E 31 38 0D
 618+ 03D1 00
 619+ 03D2 0D           MSGTXT2:        defb    CR
 620+ 03D3 20 20 20 3C                  defm    "   <C>old or <W>arm start? ",0
 620+ 03D7 43 3E 6F 6C
 620+ 03DB 64 20 6F 72
 620+ 03DF 20 3C 57 3E
 620+ 03E3 61 72 6D 20
 620+ 03E7 73 74 61 72
 620+ 03EB 74 3F 20 00
 621+ 03EF
# file closed: ../include/bootloader/bootloader-1.05.asm
  70  03EF
  71  03EF              ; incude the latest version of the VDP module
  72  03EF                  INCLUDE "../include/vdp/vdp-1.3.asm"
# file opened: ../include/vdp/vdp-1.3.asm
   1+ 03EF              ; ------------------------------------------------------------------------------
   2+ 03EF              ; LM80C - VDP ROUTINES - 1.3
   3+ 03EF              ; ------------------------------------------------------------------------------
   4+ 03EF              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 03EF              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 03EF              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 03EF              ; kind of warranty: you can use them at your own risk.
   8+ 03EF              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 03EF              ; maintain the copyright notices, include this advice and the note to the
  10+ 03EF              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 03EF              ; redistribuite them.
  12+ 03EF              ; https://www.leonardomiliani.com
  13+ 03EF              ;
  14+ 03EF              ; Please support me by visiting the following links:
  15+ 03EF              ; Main project page: https://www.leonardomiliani.com
  16+ 03EF              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 03EF              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 03EF              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 03EF              ; ------------------------------------------------------------------------------
  20+ 03EF              ;
  21+ 03EF              ;------------------------------------------------------------------------------
  22+ 03EF              ; VDP INITIALISATION
  23+ 03EF              ; initialize VDP for a specific graphics mode
  24+ 03EF              ; INPUT: E -> contains the graphics mode:
  25+ 03EF              ; 0=text; 1=graphics 1; 2=graphics 2; 3=multicolor; 4=extended graphics 2
  26+ 03EF D5           initVDP:        push    DE              ; store E
  27+ 03F0 CD DD 0A                     call    EMPTY_VRAM      ; reset VRAM
  28+ 03F3 CD FC 0A                     call    SET_GFX_MODE    ; load register settings
  29+ 03F6 CD F1 0A                     call    CLR_RAM_REG     ; reset RAM registers
  30+ 03F9 D1                           pop     DE              ; restore reg. E
  31+ 03FA AF                           xor     A               ; reset A
  32+ 03FB 47                           ld      B,A             ; reset B (will be used later)
  33+ 03FC 7B                           ld      A,E             ; move E into A
  34+ 03FD 32 CF 81                     ld      (SCR_MODE),A    ; store screen mode
  35+ 0400 FE 01                        cp      $01             ; is it graphics 1 (A=1)?
  36+ 0402 CA 3E 04                     jp      Z,G1MD          ; yes, jump over
  37+ 0405 FE 02                        cp      $02             ; is it graphics 2 (A=2)?
  38+ 0407 CA 7F 04                     jp      Z,G2MD          ; yes, jump over
  39+ 040A FE 03                        cp      $03             ; is it multicolor (A=3)?
  40+ 040C CA A1 04                     jp      Z,MCMD          ; yes, jump over
  41+ 040F FE 04                        cp      $04             ; is it extended graphics 2 (A=4)?
  42+ 0411 CA C4 04                     jp      Z,EXG2MD        ; yes, jump over
  43+ 0414                              ; otherwise, it must be $00 so we assume that it's text mode
  44+ 0414
  45+ 0414              ; LOAD VDP SETTINGS FOR SELECTED VIDEO MODE:
  46+ 0414
  47+ 0414                              ; TEXT MODE (G0)
  48+ 0414                              ; load charset
  49+ 0414 60           TXTMD:          ld      H,B
  50+ 0415 68                           ld      L,B             ; HL=first pattern cell $0000
  51+ 0416 CD 18 0B                     call    LOADCHARSET     ; load patterns into VRAM
  52+ 0419                              ; set cursor & video overlay
  53+ 0419 AF                           xor     A               ; reset A
  54+ 041A 32 D3 81                     ld      (SCR_CURS_X),A  ; set cursor position at X=0
  55+ 041D 32 D4 81                     ld      (SCR_CURS_Y),A  ; and Y=0
  56+ 0420 3E 05                        ld      A,$05           ; light blue
  57+ 0422 32 DD 81                     ld      (BKGNDCLR),A    ; set background/border color
  58+ 0425 3E 28                        ld      A,$28
  59+ 0427 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 40 cols
  60+ 042A 3E 18                        ld      A,$18
  61+ 042C 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  62+ 042F 3E 1E                        ld      A,$1E
  63+ 0431 32 A3 80                     ld      (COMMAN),A      ; width for commas (4 columns)
  64+ 0434 11 00 08                     ld      DE,$0800
  65+ 0437 ED 53 D1 81                  ld      (SCR_NAM_TB),DE ; set name table address
  66+ 043B C3 07 05                     jp      ENDVDPSET       ; execute the rest of the video setting
  67+ 043E
  68+ 043E                              ; GRAPHICS 1 MODE (G1)
  69+ 043E                              ; load pattern table
  70+ 043E 68           G1MD:           ld      L,B
  71+ 043F 60                           ld      H,B             ; HL=first pattern cell $0000
  72+ 0440 CD 18 0B                     call    LOADCHARSET     ; load patterns into VRAM
  73+ 0443                              ; set cursor & video overlay
  74+ 0443 AF                           xor     A               ; position cursor
  75+ 0444 32 D3 81                     ld      (SCR_CURS_X),A  ; at X=0
  76+ 0447 32 D4 81                     ld      (SCR_CURS_Y),A  ; and Y=0
  77+ 044A 3E 20                        ld      A,$20
  78+ 044C 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
  79+ 044F 3E 18                        ld      A,$18
  80+ 0451 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
  81+ 0454 3E 14                        ld      A,$14
  82+ 0456 32 A3 80                     ld      (COMMAN),A      ; width for commas (3 columns)
  83+ 0459 11 00 18                     ld      DE,$1800
  84+ 045C ED 53 D1 81                  ld      (SCR_NAM_TB),DE ; set name table address
  85+ 0460                              ; load color table
  86+ 0460 21 00 20                     ld      HL,$2000        ; color table start: $2000
  87+ 0463 CD 7D 06                     call    SETVDPADRS
  88+ 0466 3E 01                        ld      A,$01           ; foreground color...
  89+ 0468 32 DC 81                     ld      (FRGNDCLR),A    ; ...set to black
  90+ 046B 3E 0F                        ld      A,$0F           ; background color...
  91+ 046D 32 DD 81                     ld      (BKGNDCLR),A    ; ...set to white
  92+ 0470 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
  93+ 0472 06 20                        ld      B,$20           ; 32 bytes of colors
  94+ 0474 0E 30                        ld      C,VDP_DAT              ; VDP data mode
  95+ 0476 ED 79        LDCLRTBMD1:     out     (C),A           ; after the first byte, the VDP autoincrements VRAM pointer
  96+ 0478 00                           nop
  97+ 0479 00                           nop
  98+ 047A 10 FA                        djnz    LDCLRTBMD1      ; repeat for 32 bytes
  99+ 047C C3 07 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 100+ 047F
 101+ 047F                              ; GRAPHICS 2 MODE (G2)
 102+ 047F AF           G2MD:           xor     A               ; position cursor
 103+ 0480 32 D3 81                     ld      (SCR_CURS_X),A  ; at X=0
 104+ 0483 32 D4 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 105+ 0486 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 256 pixels (0=256)
 106+ 0489 3C                           inc     A               ; black on...
 107+ 048A 32 DC 81                     ld      (FRGNDCLR),A    ; ...foreground
 108+ 048D 3E 0F                        ld      A,$0F           ; white on...
 109+ 048F 32 DD 81                     ld      (BKGNDCLR),A    ; ...background
 110+ 0492 3E C0                        ld      A,$C0
 111+ 0494 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 192 pixels
 112+ 0497 11 00 18                     ld      DE,$1800
 113+ 049A ED 53 D1 81                  ld      (SCR_NAM_TB),DE ; set name table address
 114+ 049E C3 07 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 115+ 04A1
 116+ 04A1                              ; MULTICOLOR MODE (G3)
 117+ 04A1 AF           MCMD:           xor     A               ; position cursor
 118+ 04A2 32 D3 81                     ld      (SCR_CURS_X),A  ; at X=0
 119+ 04A5 32 D4 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 120+ 04A8 3E 0F                        ld      A,$0F           ; white color for...
 121+ 04AA 32 DD 81                     ld      (BKGNDCLR),A    ; ...background and...
 122+ 04AD 32 DC 81                     ld      (FRGNDCLR),A    ; ...foreground (even this is not used in MC)
 123+ 04B0 3E 40                        ld      A,$40
 124+ 04B2 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 64 blocks
 125+ 04B5 3E 30                        ld      A,$30
 126+ 04B7 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 48 blocks
 127+ 04BA 11 00 08                     ld      DE,$0800
 128+ 04BD ED 53 D1 81                  ld      (SCR_NAM_TB),DE ; set name table address
 129+ 04C1 C3 07 05                     jp      ENDVDPSET       ; execute the rest of the video setting
 130+ 04C4
 131+ 04C4                              ; EXTENDED GRAPHICS 2 (G4)
 132+ 04C4              EXG2MD:         ; load pattern table
 133+ 04C4 60                           ld      H,B
 134+ 04C5 68                           ld      L,B             ; HL=first pattern cell $0000
 135+ 04C6 CD 18 0B                     call    LOADCHARSET     ; load patterns into VRAM
 136+ 04C9                              ; set cursor & video overlay
 137+ 04C9 AF                           xor     A               ; position cursor
 138+ 04CA 32 D3 81                     ld      (SCR_CURS_X),A  ; at X=0
 139+ 04CD 32 D4 81                     ld      (SCR_CURS_Y),A  ; and Y=0
 140+ 04D0 3E 20                        ld      A,$20
 141+ 04D2 32 CD 81                     ld      (SCR_SIZE_W),A  ; screen width = 32 cols
 142+ 04D5 3E 18                        ld      A,$18
 143+ 04D7 32 CE 81                     ld      (SCR_SIZE_H),A  ; screen height = 24 rows
 144+ 04DA 3E 14                        ld      A,$14
 145+ 04DC 32 A3 80                     ld      (COMMAN),A      ; width for commas (3 columns)
 146+ 04DF 11 00 38                     ld      DE,$3800
 147+ 04E2 ED 53 D1 81                  ld      (SCR_NAM_TB),DE ; set name table address
 148+ 04E6                               ; load color table
 149+ 04E6 21 00 20                     ld      HL,$2000        ; color table start: $2000
 150+ 04E9 CD 7D 06                     call    SETVDPADRS
 151+ 04EC 3E 01                        ld      A,$01           ; foreground color is...
 152+ 04EE 32 DC 81                     ld      (FRGNDCLR),A    ; ...set to black
 153+ 04F1 3E 0F                        ld      A,$0F           ; whitefor...
 154+ 04F3 32 DD 81                     ld      (BKGNDCLR),A    ; ...background
 155+ 04F6 3E 1F                        ld      A,$1F           ; reg.A loaded with colors for chars: bloack pixels on white background
 156+ 04F8 16 08                        ld      D,$08           ; 8 pages of
 157+ 04FA 06 00                        ld      B,$00           ; 256 bytes of colors (total of 2,048 cells)
 158+ 04FC 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 159+ 04FE ED 79        LDCLRTBEX2:     out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
 160+ 0500 00                           nop
 161+ 0501 00                           nop
 162+ 0502 10 FA                        djnz    LDCLRTBEX2      ; repeat for 256 bytes
 163+ 0504 15                           dec     D               ; did we fill up all the cells?
 164+ 0505 20 F7                        jr      NZ,LDCLRTBEX2   ; no, repeat
 165+ 0507                              ; LAST VDP SETTINGS
 166+ 0507 CD 4E 09     ENDVDPSET:      call    CURSOR_OFF      ; disable cursor
 167+ 050A CD EB 05                     call    EMPTYVIDBUF     ; empty video buffer
 168+ 050D AF                           xor     A
 169+ 050E 32 D7 81                     ld      (SCR_ORG_CHR),A ; store byte used tochar used to empty the video buffer
 170+ 0511 C9                           ret                     ; return to caller
 171+ 0512
 172+ 0512
 173+ 0512              ; show initial logo
 174+ 0512 CD DD 0A     SHOW_LOGO:      call    EMPTY_VRAM      ; reset VRAM
 175+ 0515                              ; set VDP for G2 mode
 176+ 0515 06 07                        ld      B,$07           ; set only the first 7 registers
 177+ 0517 11 10 00                     ld      DE,$0010        ; load settings for G2 mode
 178+ 051A CD 04 0B                     call    SET_GFX_MODE2   ; load register settings
 179+ 051D 16 01                        ld      D,$01           ; backdrop color set to black
 180+ 051F ED 51                        out     (C),D           ; send data to VDP
 181+ 0521 ED 79                        out     (C),A           ; indicate the register to send data to
 182+ 0523                              ; set name table
 183+ 0523 21 00 18                     ld      HL,$1800        ; name table address
 184+ 0526 CD 6A 06                     call    SETNAMETABLE    ; set name table (load names into table)
 185+ 0529 CD 89 05                     call    ERASECLRTBL     ; erase color table (set foreground & background to black)
 186+ 052C                              ; set colors for logo
 187+ 052C 21 00 28                     ld      HL,$2800        ; 2nd page of color table
 188+ 052F CD 7D 06                     call    SETVDPADRS
 189+ 0532 06 05                        ld      B,$05           ; 5 bands
 190+ 0534 21 D6 05                     ld      HL,CLRTABLE
 191+ 0537 0E 30                        ld      C,VDP_DAT              ; set VDP_DAT
 192+ 0539 1E 08                        ld      E,$08           ; 8 pixels each pattern
 193+ 053B 16 40        RPT101:         ld      D,$40           ; 64 chars each band
 194+ 053D 7E                           ld      A,(HL)          ; load data
 195+ 053E ED 79        RPT102:         out     (C),A           ; send it to VRAM
 196+ 0540 00                           nop                     ; little delay
 197+ 0541 1D                           dec     E               ; decrement counter
 198+ 0542 20 FA                        jr      NZ,RPT102       ; repeat until zero
 199+ 0544 1E 08                        ld      E,$08           ; 8 pixels each pattern
 200+ 0546 15                           dec     D               ; decrement char band counter
 201+ 0547 20 F5                        jr      NZ,RPT102       ; repeat until zero
 202+ 0549 23                           inc     HL              ; next pattern
 203+ 054A 10 EF                        djnz    RPT101          ; repeat until covered every band
 204+ 054C                              ; set pattern table
 205+ 054C 21 00 08                     ld      HL,$0800        ; address of first cell of 2nd area of pattern table
 206+ 054F 11 61 0B                     ld      DE,LM80CLOGO    ; pointer to logo pattern
 207+ 0552 06 00                        ld      B,$00           ; 256 bytes, 8 rows
 208+ 0554 CD B5 05     RPT103:         call    LOADLOGOCHRS
 209+ 0557 13                           inc     DE              ; next logo pattern
 210+ 0558 10 FA                        djnz    RPT103
 211+ 055A 06 20                        ld      B,$20           ; repeat for another 2 rows
 212+ 055C CD B5 05     RPT104:         call    LOADLOGOCHRS
 213+ 055F 13                           inc     DE              ; next logo pattern
 214+ 0560 10 FA                        djnz    RPT104
 215+ 0562                              ; show logo/message, play a beep, check for SHIFT pressure (to disable DOS), and wait a while
 216+ 0562 06 02                        ld      B,$02           ; two times
 217+ 0564 AF                           xor     A               ; reset A
 218+ 0565 57                           ld      D,A             ; 256 times
 219+ 0566 5F                           ld      E,A             ; x 256 times
 220+ 0567 32 DE 81                     ld      (TMPBFR1),A     ; sound flag set to 0
 221+ 056A                  IFDEF LM80C64K
 222+ 056A ~                            inc     A               ; by default, I/O DOS buffer is enabled on LM80C 64K, disabled on LM80C
 223+ 056A                  ENDIF
 224+ 056A 32 23 82                     ld      (DOS_EN),A      ; DOS enabled
 225+ 056D 00           DEC_D:          nop                     ; does nothing...
 226+ 056E 00                           nop
 227+ 056F 00                           nop
 228+ 0570 00                           nop
 229+ 0571 00                           nop
 230+ 0572 00                           nop                     ; ...until here
 231+ 0573 1D                           dec     E               ; decrement E
 232+ 0574 20 F7                        jr      NZ,DEC_D        ; repeat until $00
 233+ 0576 7A                           ld      A,D
 234+ 0577 FE 40                        cp      $40             ; ...equal to 64
 235+ 0579 CC A1 05                     call    Z,SETBEEP       ; if yes, start sound
 236+ 057C 15                           dec     D
 237+ 057D 20 EE                        jr      NZ,DEC_D        ; repeat
 238+ 057F 3A DE 81                     ld      A,(TMPBFR1)     ; sound state
 239+ 0582 FE 02                        cp      $02             ; check if sound is to be set off
 240+ 0584 C4 AD 05                     call    NZ,BEEPOFF      ; yes
 241+ 0587                  IFDEF LM80C64K
 242+ 0587 ~                            call    CHKSPCK         ; check if special key (CTRL) has been pressed on keyboard
 243+ 0587 ~                                                    ; on LM80C 64K, you can disabled the I/O DOS buffer, on LM80C you can't
 244+ 0587                  ENDIF
 245+ 0587 10 E4                        djnz    DEC_D           ; repeat
 246+ 0589              ERASECLRTBL:    ; erase color table
 247+ 0589 3E 11                        ld      A,$11           ; foreground and background set to black
 248+ 058B 16 0A                        ld      D,$0A           ; 10 pages
 249+ 058D 06 00                        ld      B,$00           ; 256 color cells per page
 250+ 058F 21 00 28                     ld      HL,$2800        ; first cell of 2nd color table
 251+ 0592 CD 7D 06                     call    SETVDPADRS      ; send address
 252+ 0595 0E 30                        ld      C,VDP_DAT              ; VDP address for passing data
 253+ 0597 ED 79        RPT100:         out     (C),A           ; send data
 254+ 0599 00                           nop
 255+ 059A 00                           nop                     ; little delay
 256+ 059B 10 FA                        djnz    RPT100          ; repeat for entire page
 257+ 059D 15                           dec     D
 258+ 059E 20 F7                        jr      NZ,RPT100       ; repeat for all the pages ($0A00 cells)
 259+ 05A0 C9                           ret                     ; return to caller
 260+ 05A1
 261+ 05A1              ; play a beep
 262+ 05A1 3A DE 81     SETBEEP:        ld      A,(TMPBFR1)     ; check the already-beeped flag
 263+ 05A4 B7                           or      A               ; is it 0?
 264+ 05A5 C0                           ret     NZ              ; no, exit
 265+ 05A6 3C                           inc     A               ; flag to 1
 266+ 05A7 32 DE 81                     ld      (TMPBFR1),A     ; set sound
 267+ 05AA C3 CF 0C                     jp      WLCMBEEP        ; play a beep & return
 268+ 05AD
 269+ 05AD              ; beep off
 270+ 05AD 3E 02        BEEPOFF:        ld      A,$02           ; flag for sound off
 271+ 05AF 32 DE 81                     ld      (TMPBFR1),A     ; set flag
 272+ 05B2 C3 D5 0C                     jp      NOBEEP          ; stop beep and return
 273+ 05B5
 274+ 05B5
 275+ 05B5              ; used to load the chars that will compose the logo of the splash screen
 276+ 05B5 1A           LOADLOGOCHRS:   ld      A,(DE)          ; load a pattern char of the logo
 277+ 05B6 87                           add     A,A
 278+ 05B7 87                           add     A,A
 279+ 05B8 87                           add     A,A             ; multiply times 8 to get the offset
 280+ 05B9 C5                           push    BC
 281+ 05BA D5                           push    DE              ; store BC and DE
 282+ 05BB E5                           push    HL              ; store VRAM address to write to
 283+ 05BC 21 41 50                     ld      HL,LOGOFONT     ; start of logo font data
 284+ 05BF 5F                           ld      E,A
 285+ 05C0 16 00                        ld      D,$00           ; put offset (A) into DE
 286+ 05C2 19                           add     HL,DE           ; get address of pattern data
 287+ 05C3 EB                           ex      DE,HL           ; move address into DE
 288+ 05C4 E1                           pop     HL              ; retrieve VRAM address
 289+ 05C5 06 08                        ld      B,$08           ; 8 bytes per pattern
 290+ 05C7 CD 7D 06                     call    SETVDPADRS      ; set VDP address
 291+ 05CA 0E 30                        ld      C,VDP_DAT              ; VDP_DAT
 292+ 05CC 1A           SNDLOGPT:       ld      A,(DE)          ; load data from RAM
 293+ 05CD ED 79                        out     (C),A           ; and send to VRAM
 294+ 05CF 13                           inc     DE              ; next byte into RAM
 295+ 05D0 23                           inc     HL              ; next byte into VRAM (used in future iterations)
 296+ 05D1 10 F9                        djnz    SNDLOGPT        ; repeat 8 times
 297+ 05D3 D1                           pop     DE
 298+ 05D4 C1                           pop     BC              ; retrieve BC & DE
 299+ 05D5 C9                           ret                     ; return to caller
 300+ 05D6              CLRTABLE:       equ $
 301+ 05D6 18 1B 13 14                  defb    $18,$1B,$13,$14,$1D ; colors of background bands of the logo
 301+ 05DA 1D
 302+ 05DB
 303+ 05DB
 304+ 05DB              ; while showing the logo, check if special key (CTRL) is being pressed
 305+ 05DB              ; if yes, then disable DOS functions recovering RAM
 306+ 05DB F5           CHKSPCK:        push    AF
 307+ 05DC 3E FE                        ld      A,%11111110     ; select CTRL row
 308+ 05DE CD 53 0D                     call    READKBLN        ; read row
 309+ 05E1 CB 57                        bit     2,A             ; test if CTRL key is pressed
 310+ 05E3 20 04                        jr      NZ,LVCKSPLK     ; no, leave
 311+ 05E5 AF                           xor     A               ; yes, so...
 312+ 05E6 32 23 82                     ld      (DOS_EN),A      ; ...disable DOS
 313+ 05E9 F1           LVCKSPLK:       pop     AF
 314+ 05EA C9                           ret
 315+ 05EB
 316+ 05EB
 317+ 05EB              ; empty video buffer
 318+ 05EB 3A CF 81     EMPTYVIDBUF:    ld      A,(SCR_MODE)    ; check screen mode
 319+ 05EE FE 02                        cp      $02             ; is it G2 mode?
 320+ 05F0 CA 14 06                     jp      Z,EMPTYG2       ; yes, jump over
 321+ 05F3 FE 03                        cp      $03             ; is it MC mode?
 322+ 05F5 CA 45 06                     jp      Z,EMPTYMC       ; yes, jump over
 323+ 05F8 3A CE 81                     ld      A,(SCR_SIZE_H)  ; load height of screen
 324+ 05FB 47                           ld      B,A             ; move rows into B
 325+ 05FC AF                           xor     A               ; filling char is $00
 326+ 05FD 2A D1 81                     ld      HL,(SCR_NAM_TB) ; load the name table address
 327+ 0600 CD 7D 06                     call    SETVDPADRS      ; send address to VDP
 328+ 0603 0E 30                        ld      C,VDP_DAT              ; VDP address for passing data
 329+ 0605 5F           LDCOLSTOEMPTY:  ld      E,A             ; store filling char into E
 330+ 0606 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load # of cols to empty into A
 331+ 0609 57                           ld      D,A             ; move A into D
 332+ 060A 7B                           ld      A,E             ; recover filling char
 333+ 060B ED 79        RPTEMPTYBUF:    out     (C),A           ; write empty byte into VRAM
 334+ 060D 00                           nop
 335+ 060E 15                           dec     D               ; decr. D
 336+ 060F 20 FA                        jr      NZ,RPTEMPTYBUF  ; repeat for the # of cols
 337+ 0611 10 F2                        djnz    LDCOLSTOEMPTY   ; repeat for the # of rows
 338+ 0613 C9                           ret                     ; return to caller
 339+ 0614 2A D1 81     EMPTYG2:        ld      HL,(SCR_NAM_TB) ; yes, additional setup for G2 - load G2 name table address (usually $1800)
 340+ 0617 CD 6A 06                     call    SETNAMETABLE    ; set name table
 341+ 061A 21 00 00                     ld      HL,$0000        ; set pattern table
 342+ 061D CD 7D 06                     call    SETVDPADRS      ; send address to VDP
 343+ 0620 AF                           xor     A               ; empty pattern
 344+ 0621 16 18                        ld      D,$18           ; 6144 ($1800) cell to clean, 24 pages ($18)
 345+ 0623 47                           ld      B,A             ; 256 bytes for page
 346+ 0624 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 347+ 0626 ED 79        CLRG2PTNTBL:    out     (C),A           ; clear pattern
 348+ 0628 00                           nop                     ; little delay
 349+ 0629 00                           nop
 350+ 062A 10 FA                        djnz    CLRG2PTNTBL     ; repeat for 1 page
 351+ 062C 15                           dec     D               ; next page
 352+ 062D 20 F7                        jr      NZ,CLRG2PTNTBL  ; repeat
 353+ 062F 21 00 20                     ld      HL,$2000        ; load the color table address
 354+ 0632 CD 7D 06                     call    SETVDPADRS      ; send address to VDP
 355+ 0635 3A DC 81                     ld      A,(FRGNDCLR)    ; load foreground
 356+ 0638 87                           add     A,A
 357+ 0639 87                           add     A,A
 358+ 063A 87                           add     A,A
 359+ 063B 87                           add     A,A             ; move to high nibble
 360+ 063C 57                           ld      D,A             ; store into D
 361+ 063D 3A DD 81                     ld      A,(BKGNDCLR)    ; load background color
 362+ 0640 B2                           or      D               ; combine with background color
 363+ 0641 16 18                        ld      D,$18           ; 6144 ($1800) cells to fill, so 24 pages ($18)
 364+ 0643 18 17                        jr      STARTEMPTY
 365+ 0645 21 00 08     EMPTYMC:        ld      HL,$0800        ; MC name table
 366+ 0648 CD 6A 06                     call    SETNAMETABLE    ; set name table
 367+ 064B 21 00 00                     ld      HL,$0000        ; color table address
 368+ 064E CD 7D 06                     call    SETVDPADRS      ; send address to VDP
 369+ 0651 3A DD 81                     ld      A,(BKGNDCLR)    ; load background
 370+ 0654 57                           ld      D,A             ; store into D
 371+ 0655 87                           add     A,A
 372+ 0656 87                           add     A,A
 373+ 0657 87                           add     A,A
 374+ 0658 87                           add     A,A             ; move to high nibble
 375+ 0659 B2                           or      D               ; set background color for high and low nibble
 376+ 065A 16 08                        ld      D,$08           ; 2048 ($0800) cells to fill, so 8 pages ($08)
 377+ 065C 0E 30        STARTEMPTY:     ld      C,VDP_DAT       ; VDP address for passing data
 378+ 065E 06 00                        ld      B,$00           ; 256 bytes each page ($00=256)
 379+ 0660 ED 79        SNDCLRSET:      out     (C),A           ; send color setting
 380+ 0662 00                           nop                     ; wait a while
 381+ 0663 00                           nop
 382+ 0664 10 FA                        djnz    SNDCLRSET       ; repeat for 1 page
 383+ 0666 15                           dec     D               ; have we filled all the pages?
 384+ 0667 20 F7                        jr      NZ,SNDCLRSET    ; no, repeat
 385+ 0669 C9                           ret                     ; return to caller
 386+ 066A
 387+ 066A              ; set name table for G2 mode (patterns from $00 to $FF for each of the 3 areas of the screen)
 388+ 066A CD 7D 06     SETNAMETABLE:   call    SETVDPADRS      ; send address to VDP
 389+ 066D 0E 30                        ld      C,VDP_DAT              ; VDP address for passing data
 390+ 066F 16 03                        ld      D,$03           ; 3 pages to fill into VRAM (768 cells)
 391+ 0671 AF                           xor     A               ; starting char name #0 (chars go from 0 to 255)
 392+ 0672 47                           ld      B,A             ; reset B
 393+ 0673 ED 79        RPTFLL1:        out     (C),A           ; send name to VRAM
 394+ 0675 00                           nop
 395+ 0676 3C                           inc     A               ; increment # of name
 396+ 0677 10 FA                        djnz    RPTFLL1         ; repeat for 256 cells (1 page)
 397+ 0679 15                           dec     D               ; did we fill all the pages?
 398+ 067A 20 F7                        jr      NZ,RPTFLL1      ; no, continue
 399+ 067C C9                           ret                     ; return to caller
 400+ 067D
 401+ 067D              ; set an address into VRAM: address is in HL - HL is changed after it
 402+ 067D 0E 32        SETVDPADRS:     ld      C,VDP_SET       ; VDP address mode
 403+ 067F CB F4                        set     6,H             ; set bit #6 of address, to write to VRAM
 404+ 0681 ED 69                        out     (C),L           ; send low and...
 405+ 0683 ED 61                        out     (C),H           ; ...high byte of the first cell
 406+ 0685 C9                           ret                     ; return to caller
 407+ 0686
 408+ 0686              ; clear the video buffer and position the cursor at 0,0
 409+ 0686 CD EB 05     CLEARVIDBUF:    call    EMPTYVIDBUF     ; clear video buffer
 410+ 0689 AF                           xor     A               ; reset A
 411+ 068A 32 D3 81                     ld      (SCR_CURS_X),A  ; cursor X to 0
 412+ 068D 32 D4 81                     ld      (SCR_CURS_Y),A  ; cursor Y to 0
 413+ 0690 C3 D9 06                     jp      POS_CURSOR      ; position cursor & return to caller
 414+ 0693
 415+ 0693              ; HOME: position the cursor at coords. 0,0
 416+ 0693 AF           ATHOME:         xor     A               ; position cursor at 0,0 by storing...
 417+ 0694 32 D6 81                     ld      (SCR_CUR_NY),A  ; ...new Y...
 418+ 0697 32 D5 81                     ld      (SCR_CUR_NX),A  ; ...and new X
 419+ 069A C3 E3 06                     jp      MOVCRS          ; move cursor to new location & return to caller
 420+ 069D
 421+ 069D              ; load the char or byte at the VRAM position set by HL
 422+ 069D              ; value is returned into A
 423+ 069D C5           READ_VIDEO_LOC: push    BC              ; store BC
 424+ 069E 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 425+ 06A0 44                           ld      B,H
 426+ 06A1 CB B8                        res     7,B
 427+ 06A3 CB B0                        res     6,B
 428+ 06A5 ED 69                        out     (C),L           ; low byte then...
 429+ 06A7 ED 41                        out     (C),B           ; high byte
 430+ 06A9 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 431+ 06AB 00                           nop                     ; wait...
 432+ 06AC 00                           nop                     ; ...a while
 433+ 06AD 00                           nop
 434+ 06AE                  IFDEF LM80C64K
 435+ 06AE ~                            nop
 436+ 06AE                  ENDIF
 437+ 06AE ED 78                        in      A,(C)           ; read byte at current VRAM location
 438+ 06B0 C1                           pop     BC              ; restore BC
 439+ 06B1 C9                           ret                     ; return to caller
 440+ 06B2
 441+ 06B2              ; write a byte at the VRAM position pointed by HL
 442+ 06B2              ; value is in A
 443+ 06B2 C5           WRITE_VIDEO_LOC:push    BC              ; store BC
 444+ 06B3 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 445+ 06B5 44                           ld      B,H             ; copy H into B
 446+ 06B6 CB B8                        res     7,B
 447+ 06B8 CB F0                        set     6,B             ; write to VRAM
 448+ 06BA ED 69                        out     (C),L           ; low byte then...
 449+ 06BC ED 41                        out     (C),B           ; high byte of VRAM address
 450+ 06BE 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 451+ 06C0 00                           nop                     ; wait...
 452+ 06C1 00                           nop                     ; ...a while
 453+ 06C2 00                           nop
 454+ 06C3                  IFDEF LM80C64K
 455+ 06C3 ~                            nop
 456+ 06C3                  ENDIF
 457+ 06C3 ED 79                        out     (C),A           ; write byte into VRAM
 458+ 06C5 C1                           pop     BC              ; restore BC
 459+ 06C6 C9                           ret                     ; return to caller
 460+ 06C7
 461+ 06C7              ; write a value into a specific VDP register
 462+ 06C7              ; value is in E, register is in A
 463+ 06C7 C5           WRITE_VREG:     push    BC              ; store BC
 464+ 06C8 C6 80                        add     A,$80           ; set VDP to write to registers
 465+ 06CA 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 466+ 06CC ED 59                        out     (C),E           ; send data to VDP
 467+ 06CE ED 79                        out     (C),A           ; select the destination register
 468+ 06D0 C1                           pop     BC              ; restore BC
 469+ 06D1 C9                           ret                     ; return to caller
 470+ 06D2
 471+ 06D2              ; read VDP status register and return value into A
 472+ 06D2 C5           READ_VSTAT:     push    BC              ; store BC
 473+ 06D3 0E 32                        ld      C,VDP_SET       ; VDP register access
 474+ 06D5 ED 78                        in      A,(C)           ; read status register
 475+ 06D7 C1                           pop     BC              ; restore BC
 476+ 06D8 C9                           ret                     ; return to caller
 477+ 06D9
 478+ 06D9              ; position the cursor at the current coordinates, preserving underlying char
 479+ 06D9 CD 1C 07     POS_CURSOR:     call    LOAD_CRSR_POS   ; load the VRAM address of cursor into HL
 480+ 06DC CD 9D 06                     call    READ_VIDEO_LOC  ; load the current char at the cursor position (return in A)
 481+ 06DF 32 D7 81                     ld      (SCR_ORG_CHR),A ; store the current char
 482+ 06E2 C9                           ret
 483+ 06E3
 484+ 06E3              ; move cursor to new X,Y coordinates
 485+ 06E3 CD 13 07     MOVCRS:         call    RSTCHRCRS       ; restore the char in the current cursor position
 486+ 06E6 CD FE 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 487+ 06E9 CD D9 06     MOVSHOWCRS:     call    POS_CURSOR      ; position cursor into new location
 488+ 06EC 3A D8 81                     ld      A,(CRSR_STATE)  ; load status of cursor
 489+ 06EF A7                           and     A               ; is cursor off?
 490+ 06F0 C8                           ret     Z               ; yes, return
 491+ 06F1 3A BD 81                     ld      A,(TMRCNT)      ; load timer
 492+ 06F4 E6 20                        and     $20             ; check status of cursor flashing
 493+ 06F6 32 D9 81                     ld      (LSTCSRSTA),A   ; store the last cursor state
 494+ 06F9 3E FF                        ld      A,$FF           ; BTW, set cursor visible after moved it
 495+ 06FB C3 B2 06                     jp      WRITE_VIDEO_LOC ; write into video cell
 496+ 06FE
 497+ 06FE
 498+ 06FE              ; set new cursor's coordinates
 499+ 06FE 3A D5 81     NEWCRSRCOORD:   ld      A,(SCR_CUR_NX)  ; load new X
 500+ 0701 32 D3 81                     ld      (SCR_CURS_X),A  ; write new X
 501+ 0704 3A D6 81                     ld      A,(SCR_CUR_NY)  ; load new Y
 502+ 0707 32 D4 81                     ld      (SCR_CURS_Y),A  ; write new Y
 503+ 070A 3E FF                        ld      A,$FF           ; delete new values
 504+ 070C 32 D5 81                     ld      (SCR_CUR_NX),A  ; of X
 505+ 070F 32 D6 81                     ld      (SCR_CUR_NY),A  ; and Y
 506+ 0712 C9                           ret
 507+ 0713
 508+ 0713              ; recover char under the cursor and prints it onto the screen
 509+ 0713 CD 1C 07     RSTCHRCRS:      call    LOAD_CRSR_POS   ; recover old cursor position
 510+ 0716 3A D7 81                     ld      A,(SCR_ORG_CHR) ; recover old char
 511+ 0719 C3 B2 06                     jp      WRITE_VIDEO_LOC ; write char into VRAM & return
 512+ 071C
 513+ 071C              ; retrieve cursor position from either current coordinates or next place
 514+ 071C              ; return address position into HL
 515+ 071C 3A D4 81     LOAD_CRSR_POS:  ld      A,(SCR_CURS_Y)  ; load cursor Y
 516+ 071F 6F                           ld      L,A             ; move it into reg.L
 517+ 0720 AF                           xor     A               ; reset A
 518+ 0721 67                           ld      H,A             ; reset H
 519+ 0722 47                           ld      B,A             ; reset B
 520+ 0723 29                           add     HL,HL           ; create offset (each address is 2-bytes long so we need to double HL)
 521+ 0724 11 AD 0A                     ld      DE,POS_TB_CRS_40; load position table address of cursor for 40 cols
 522+ 0727 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load screen width
 523+ 072A FE 28                        cp      $28             ; is it 40 cols?
 524+ 072C 28 03                        jr      Z,CONT_POS_CURS ; yes, jump over
 525+ 072E 11 7D 0A                     ld      DE,POS_TB_CRS_32; no, load position table address of cursor for 32 cols
 526+ 0731 19           CONT_POS_CURS:  add     HL,DE           ; the correct starting address of the required row is now into HL
 527+ 0732 5E                           ld      E,(HL)          ; load starting address of the required row into DE
 528+ 0733 23                           inc     HL
 529+ 0734 56                           ld      D,(HL)
 530+ 0735 2A D1 81                     ld      HL,(SCR_NAM_TB) ; load starting address of name table
 531+ 0738 19                           add     HL,DE           ; starting address of the current row into name table
 532+ 0739 3A D3 81                     ld      A,(SCR_CURS_X)  ; load cursor X
 533+ 073C 4F                           ld      C,A             ; transfer A into C
 534+ 073D 09                           add     HL,BC           ; add X offset: now HL contains the address of the current cursor position
 535+ 073E C9                           ret
 536+ 073F
 537+ 073F              ; find X,Y coordinates of a screen address pointed in VRAM by HL
 538+ 073F              ; return them into L,A for X,Y
 539+ 073F D5           HL2XY:          push    DE              ; store DE
 540+ 0740 ED 5B D1 81                  ld      DE,(SCR_NAM_TB) ; load starting address of name table into DE
 541+ 0744 AF                           xor     A               ; clear Carry
 542+ 0745 ED 52                        sbc     HL,DE           ; find position relative to screen (from 0,0)
 543+ 0747 D1                           pop     DE
 544+ 0748 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load screen width
 545+ 074B 4F                           ld      C,A             ; move it into C
 546+ 074C CD 1D 40                     call    DIV_16_8        ; divide position by C: return Y into L and X into A
 547+ 074F C9                           ret                     ; return to caller
 548+ 0750
 549+ 0750              ;-------------------------------------------------------------------------------
 550+ 0750              ; char table for jumps
 551+ 0750 19           CHRTBL:         defb    HOME
 552+ 0751 93 06                        defw    ATHOME          ; move the cursor to 0,0
 553+ 0753
 554+ 0753 0C                           defb    CS
 555+ 0754 86 06                        defw    CLEARVIDBUF     ; clear video buffer and position cursor at 0,0
 556+ 0756
 557+ 0756 0D                           defb    CR
 558+ 0757 D0 09                        defw    CRGRETURN       ; go to the beginning of the next line
 559+ 0759
 560+ 0759 08                           defb    BKSP
 561+ 075A 3C 08                        defw    BACKSPACE       ; move cursor left 1 position
 562+ 075C
 563+ 075C 1C                           defb    CRSLFT
 564+ 075D 7F 08                        defw    CURSORLEFT      ; move cursor left
 565+ 075F
 566+ 075F 1E                           defb    CRSUP
 567+ 0760 CB 08                        defw    CURSORUP        ; move cursor up
 568+ 0762
 569+ 0762 1D                           defb    CRSRGT
 570+ 0763 E4 08                        defw    CURSORRIGHT     ; move cursor right
 571+ 0765
 572+ 0765 1F                           defb    CRSDN
 573+ 0766 19 09                        defw    CURSORDOWN      ; move cursor up
 574+ 0768
 575+ 0768 1A                           defb    INSRT
 576+ 0769 FB 07                        defw    INSERTKEY       ; insert a space
 577+ 076B
 578+ 076B 0A                           defb    LF
 579+ 076C D7 07                        defw    PLACEHOLDER     ; CURRENTLY WE DON'T PRINT LINE FEED
 580+ 076E
 581+ 076E              ; send current char to video buffer
 582+ 076E F5           CHAR2VID:       push    AF              ; store AF
 583+ 076F C5                           push    BC              ; store BC
 584+ 0770 D5                           push    DE              ; store DE
 585+ 0771 E5                           push    HL              ; store HL
 586+ 0772 3A D8 81                     ld      A,(CRSR_STATE)  ; store cursor state...
 587+ 0775 F5                           push    AF              ; into stack
 588+ 0776 CD 4E 09                     call    CURSOR_OFF      ; cursor off
 589+ 0779 3A DB 81                     ld      A,(CHR4VID)     ; recover char
 590+ 077C 06 0A                        ld      B,$0A           ; 10 chars to check
 591+ 077E 21 50 07                     ld      HL,CHRTBL       ; address of key table
 592+ 0781 BE           RPTCPCK:        cp      (HL)            ; compare with char
 593+ 0782 23                           inc     HL              ; beginning of sub-routine address
 594+ 0783 20 09                        jr      NZ,NXTCPCK      ; different, go to next char
 595+ 0785 5E                           ld      E,(HL)          ; load addres into DE
 596+ 0786 23                           inc     HL
 597+ 0787 56                           ld      D,(HL)
 598+ 0788 EB                           ex      DE,HL           ; move user routine's address into HL
 599+ 0789 11 CA 07                     ld      DE,EXITCHAR2VID ; set point of return after the user routine
 600+ 078C D5                           push    DE              ; store into stack
 601+ 078D E9                           jp      (HL)            ; call user routine - then, the CPU will return (jump) to EXITCHAR2VID
 602+ 078E 23           NXTCPCK:        inc     HL              ; jump over 2 cells...
 603+ 078F 23                           inc     HL              ; ...to the next char code
 604+ 0790 10 EF                        djnz    RPTCPCK         ; repeat
 605+ 0792                              ; it'a not a special char, just print it
 606+ 0792 CD 1C 07                     call    LOAD_CRSR_POS   ; recover position of cursor
 607+ 0795 3A DB 81                     ld      A,(CHR4VID)     ; recover char to print
 608+ 0798 CD B2 06                     call    WRITE_VIDEO_LOC ; write A into VRAM at (HL)
 609+ 079B 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 610+ 079E 5F                           ld      E,A             ; store cursor Y into E
 611+ 079F 3A D3 81                     ld      A,(SCR_CURS_X)  ; load cursor X
 612+ 07A2 3C                           inc     A               ; move 1 step to right
 613+ 07A3 21 CD 81                     ld      HL,SCR_SIZE_W   ; cell that keeps the width of screen
 614+ 07A6 BE                           cp      (HL)            ; have we reached the most right position?
 615+ 07A7 20 0F                        jr      NZ,SETCSRCOORDS ; no, go over
 616+ 07A9 1C                           inc     E               ; yes, increment cursor Y (go to next line)
 617+ 07AA 7B                           ld      A,E             ; move cursor Y into A
 618+ 07AB 21 CE 81                     ld      HL,SCR_SIZE_H   ; cell that keeps the height of screen
 619+ 07AE BE                           cp      (HL)            ; have we reached the bottom of the screen?
 620+ 07AF 20 06                        jr      NZ,SETCRSRY     ; no, jump over
 621+ 07B1 D5                           push    DE
 622+ 07B2 CD 55 09                     call    SCROLLUP        ; scroll screen up
 623+ 07B5 D1                           pop     DE
 624+ 07B6 1D                           dec     E               ; decrement 1 row, to set cursor Y on the last line
 625+ 07B7 AF           SETCRSRY:       xor     A               ; then set cursor X to 0 (go to beginning of line)
 626+ 07B8 32 D3 81     SETCSRCOORDS:   ld      (SCR_CURS_X),A  ; store current cursor X
 627+ 07BB 7B                           ld      A,E             ; recover Y
 628+ 07BC 32 D4 81                     ld      (SCR_CURS_Y),A  ; store current cursor Y
 629+ 07BF CD D9 06                     call    POS_CURSOR      ; position cursor into new location
 630+ 07C2 3A BD 81                     ld      A,(TMRCNT)      ; load status of cursor flashing
 631+ 07C5 E6 20                        and     $20             ; check cursor state
 632+ 07C7 32 D9 81                     ld      (LSTCSRSTA),A   ; store the last cursor state
 633+ 07CA AF           EXITCHAR2VID:   xor     A               ; reset char
 634+ 07CB 32 DB 81                     ld      (CHR4VID),A     ; to be sent to screen
 635+ 07CE F1                           pop     AF              ; recover cursor state
 636+ 07CF A7                           and     A               ; was it off (A=0)?
 637+ 07D0 C4 39 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 638+ 07D3 E1                           pop     HL              ; restore HL
 639+ 07D4 D1                           pop     DE              ; restore DE
 640+ 07D5 C1                           pop     BC              ; restore BC
 641+ 07D6 F1                           pop     AF              ; restore AF
 642+ 07D7 C9           PLACEHOLDER:    ret                     ; return to caller
 643+ 07D8
 644+ 07D8              ; flash the cursor at the current position
 645+ 07D8              ; (this sub-routine is called by CH3 timer ISR)
 646+ 07D8 3A D8 81     FLASHCURSOR:    ld      A,(CRSR_STATE)  ; now, check the cursor
 647+ 07DB A7                           and     A               ; cursor off (A=0)?
 648+ 07DC C8                           ret     Z               ; yes, return
 649+ 07DD 3A BD 81                     ld      A,(TMRCNT)      ; no, load the first byte of the 100ths of A second's counter
 650+ 07E0 E6 20                        and     $20             ; check if it's time to flash the cursor (check bit #6)
 651+ 07E2 21 D9 81                     ld      HL,LSTCSRSTA    ; load address of cell that stores the last cursor state
 652+ 07E5 BE                           cp      (HL)            ; compare current state with last state
 653+ 07E6 C8                           ret     Z               ; same state, no change required - exit
 654+ 07E7 77                           ld      (HL),A          ; save new state
 655+ 07E8 F5                           push    AF              ; store A (keep state for later use)
 656+ 07E9 CD 1C 07                     call    LOAD_CRSR_POS   ; load current cursor position into HL
 657+ 07EC F1                           pop     AF              ; recover current state
 658+ 07ED 06 FF                        ld      B,$FF           ; cursor char
 659+ 07EF FE 20                        cp      $20             ; is the cursor on video (A == $20)?
 660+ 07F1 28 04                        jr      Z,PUTCRSCHR     ; yes, jump over
 661+ 07F3 3A D7 81                     ld      A,(SCR_ORG_CHR) ; no, load the original char
 662+ 07F6 47                           ld      B,A             ; move char into B
 663+ 07F7 78           PUTCRSCHR:      ld      A,B             ; recover char from B
 664+ 07F8 C3 B2 06                     jp      WRITE_VIDEO_LOC ; print cursor/char at the current position & return
 665+ 07FB
 666+ 07FB
 667+ 07FB              ; insert an empty space at the current position of the cursor, moving the following text
 668+ 07FB              ; 1 cell straight
 669+ 07FB CD 13 07     INSERTKEY:      call    RSTCHRCRS       ; restore char under the cursor
 670+ 07FE CD 1C 07                     call    LOAD_CRSR_POS   ; retrieve address of cursor cell
 671+ 0801 22 DE 81                     ld      (CUR_POS),HL    ; store it
 672+ 0804 CD 57 0A                     call    ENDOFLN         ; find address of first free cell after the end of the text from the current cursor position - address into HL -
 673+ 0807                                                      ; DE is the address of the bottom right cell of the screen
 674+ 0807 22 E2 81                     ld      (ENDTXT),HL     ; store it
 675+ 080A ED 4B DE 81                  ld      BC,(CUR_POS)    ; load starting address
 676+ 080E AF                           xor     A
 677+ 080F ED 42                        sbc     HL,BC           ; how many positions to move?
 678+ 0811 CA E9 06                     jp      Z,MOVSHOWCRS    ; none - leave and re-place cursor
 679+ 0814 44 4D                        ld      BC,HL           ; number of chars to scroll into BC
 680+ 0816 2A E2 81                     ld      HL,(ENDTXT)     ; load address of the end of text
 681+ 0819 2B           CHKHL:          dec     HL              ; decrement to find the address of the char to move
 682+ 081A E5                           push    HL
 683+ 081B CD DE 3F                     call    CMP16           ; is it the last cell (bottom right) of screen?
 684+ 081E E1                           pop     HL
 685+ 081F D2 2A 08                     jp      NC,NXTINST      ; yes, so jump over - nothing to do
 686+ 0822 CD 9D 06                     call    READ_VIDEO_LOC  ; no, so read current char
 687+ 0825 23                           inc     HL              ; next cell
 688+ 0826 CD B2 06                     call    WRITE_VIDEO_LOC ; write into new position
 689+ 0829 2B                           dec     HL              ; decrement to old position
 690+ 082A 0B           NXTINST:        dec     BC              ; decrement number of chars to move
 691+ 082B 79                           ld      A,C
 692+ 082C B0                           or      B               ; finished?
 693+ 082D 20 EA                        jr      NZ,CHKHL        ; no, repeat
 694+ 082F AF           ENDINSRT:       xor     A
 695+ 0830 2A DE 81                     ld      HL,(CUR_POS)
 696+ 0833 32 D7 81                     ld      (SCR_ORG_CHR),A ; reset original char under the cursor
 697+ 0836 CD B2 06                     call    WRITE_VIDEO_LOC ; empty current video location
 698+ 0839 C3 E9 06                     jp      MOVSHOWCRS      ; re-place cursor
 699+ 083C
 700+ 083C              ; delete the char at the left of the cursor
 701+ 083C CD 13 07     BACKSPACE:      call    RSTCHRCRS       ; restore char
 702+ 083F 2A D1 81                     ld      HL,(SCR_NAM_TB) ; address of origin of screen (location 0,0)
 703+ 0842 44 4D                        ld      BC,HL           ; store into BC
 704+ 0844 CD 1C 07                     call    LOAD_CRSR_POS   ; load address of current cursor pos.
 705+ 0847 54 5D                        ld      DE,HL           ; copy into DE
 706+ 0849 AF                           xor     A               ; reset Carry
 707+ 084A ED 42                        sbc     HL,BC           ; check how many chars between
 708+ 084C CA 76 08                     jp      Z,LVBKSP        ; none, so we are at the top left corner
 709+ 084F ED 53 DE 81                  ld      (CUR_POS),DE    ; store current cursor position
 710+ 0853 CD 57 0A                     call    ENDOFLN         ; check end of text
 711+ 0856 ED 5B DE 81                  ld      DE,(CUR_POS)    ; retrieve cursor position
 712+ 085A AF                           xor     A               ; reset Carry
 713+ 085B ED 52                        sbc     HL,DE           ; check if none follows
 714+ 085D CA 76 08                     jp      Z,LVBKSP        ; no chars follow, so simply move the cursor
 715+ 0860 44 4D                        ld      BC,HL           ; save numbers of chars to move
 716+ 0862 EB                           ex      DE,HL           ; copy starting position into HL
 717+ 0863 CD 9D 06     MVBKSP:         call    READ_VIDEO_LOC  ; read char
 718+ 0866 2B                           dec     HL              ; 1 position to left
 719+ 0867 CD B2 06                     call    WRITE_VIDEO_LOC ; write char
 720+ 086A 23                           inc     HL              ; goto next char to copy (2 steps to right)
 721+ 086B 23                           inc     HL
 722+ 086C 0B                           dec     BC              ; decrement # of chars
 723+ 086D 79                           ld      A,C
 724+ 086E B0                           or      B               ; 0 chars?
 725+ 086F 20 F2                        jr      NZ,MVBKSP       ; not finished, continue
 726+ 0871 2B                           dec     HL
 727+ 0872 AF                           xor     A
 728+ 0873 CD B2 06                     call    WRITE_VIDEO_LOC ; reset last char
 729+ 0876 CD A8 08     LVBKSP:         call    MVCRS2LFT       ; move cursor to new position
 730+ 0879 CD FE 06                     call    NEWCRSRCOORD    ; set new cursor's coordinates
 731+ 087C C3 E9 06                     jp      MOVSHOWCRS      ; move cursor to the new location and set it ON
 732+ 087F
 733+ 087F
 734+ 087F              ; move cursor to left
 735+ 087F F5           CURSORLEFT:     push    AF              ; store A
 736+ 0880 3A D3 81                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 737+ 0883 A7                           and     A               ; is it at the most left of the screen (X=0)?
 738+ 0884 28 0C                        jr      Z,CHCKYPOS      ; yes, check Y position
 739+ 0886 3D                           dec     A               ; no, decrement X
 740+ 0887 32 D5 81                     ld      (SCR_CUR_NX),A  ; store new X
 741+ 088A 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 742+ 088D 32 D6 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 743+ 0890 18 11                        jr      CONTCRSLFT      ; go on moving cursor
 744+ 0892 3A D4 81     CHCKYPOS:       ld      A,(SCR_CURS_Y)  ; load cursor Y
 745+ 0895 A7                           and     A               ; is it at the most top of the screen (Y=0)?
 746+ 0896 28 0E                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 747+ 0898 3D                           dec     A               ; no, decrement Y
 748+ 0899 32 D6 81                     ld      (SCR_CUR_NY),A  ; store new Y
 749+ 089C 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load current screen width
 750+ 089F 3D                           dec     A               ; cursor to the most right position (width-0)
 751+ 08A0 32 D5 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 752+ 08A3 CD E3 06     CONTCRSLFT:     call    MOVCRS          ; move cursor into new position
 753+ 08A6 F1           EXITCURSORLEFT: pop     AF              ; restore A
 754+ 08A7 C9                           ret                     ; return to caller
 755+ 08A8
 756+ 08A8              ; move cursor 1 position to the left
 757+ 08A8 3A D3 81     MVCRS2LFT:      ld      A,(SCR_CURS_X)  ; load cursor X into A
 758+ 08AB A7                           and     A               ; is it at the most left of the screen (X=0)?
 759+ 08AC 28 0B                        jr      Z,CHKYPOS       ; yes, check Y position
 760+ 08AE 3D                           dec     A               ; no, decrement X
 761+ 08AF 32 D5 81                     ld      (SCR_CUR_NX),A  ; store new X
 762+ 08B2 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 763+ 08B5 32 D6 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 764+ 08B8 C9                           ret                     ; go on moving cursor
 765+ 08B9 3A D4 81     CHKYPOS:        ld      A,(SCR_CURS_Y)  ; load cursor Y
 766+ 08BC A7                           and     A               ; is it at the most top of the screen (Y=0)?
 767+ 08BD 28 E7                        jr      Z,EXITCURSORLEFT; yes, exit doing nothing
 768+ 08BF 3D                           dec     A               ; no, decrement Y
 769+ 08C0 32 D6 81                     ld      (SCR_CUR_NY),A  ; store new Y
 770+ 08C3 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load current screen width
 771+ 08C6 3D                           dec     A               ; cursor to the most right position (width-1)
 772+ 08C7 32 D5 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 773+ 08CA C9                           ret                     ; return to caller
 774+ 08CB
 775+ 08CB              ; move cursor up
 776+ 08CB F5           CURSORUP:       push    AF              ; store A
 777+ 08CC 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 778+ 08CF A7                           and     A               ; is it at the most top of the screen (Y=0)?
 779+ 08D0 28 10                        jr      Z,EXITCURSORUP  ; yes, exit doing nothing
 780+ 08D2 3D                           dec     A               ; no, decrement Y
 781+ 08D3 32 D6 81                     ld      (SCR_CUR_NY),A  ; store new Y
 782+ 08D6 3A D3 81                     ld      A,(SCR_CURS_X)  ; load current cursor X
 783+ 08D9 32 D5 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 784+ 08DC CD 13 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 785+ 08DF CD E3 06                     call    MOVCRS          ; move cursor into new position
 786+ 08E2 F1           EXITCURSORUP:   pop     AF              ; restore A
 787+ 08E3 C9                           ret                     ; return to caller
 788+ 08E4
 789+ 08E4
 790+ 08E4              ; move cursor to right
 791+ 08E4 F5           CURSORRIGHT:    push    AF              ; store A
 792+ 08E5 C5                           push    BC              ; store B
 793+ 08E6 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load current screen width (in text modes it's 32 or 40)
 794+ 08E9 3D                           dec     A               ; decrement it (most right can only be 31 or 39)
 795+ 08EA 47                           ld      B,A             ; move A into B
 796+ 08EB 3A D3 81                     ld      A,(SCR_CURS_X)  ; load cursor X into A
 797+ 08EE B8                           cp      B               ; is cursor at the most right position on the screen?
 798+ 08EF 30 0C                        jr      NC,CHCKYPOS2    ; yes, so jump to check Y position
 799+ 08F1 3C                           inc     A               ; no, so increment X
 800+ 08F2 32 D5 81                     ld      (SCR_CUR_NX),A  ; store new X
 801+ 08F5 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load current cursor Y
 802+ 08F8 32 D6 81                     ld      (SCR_CUR_NY),A  ; no move over Y axis
 803+ 08FB 18 13                        jr      CONTCRSRGT      ; go on moving cursor
 804+ 08FD 3A CE 81     CHCKYPOS2:      ld      A,(SCR_SIZE_H)  ; load screen height
 805+ 0900 3D                           dec     A               ; decrement it (last row can only be 23)
 806+ 0901 47                           ld      B,A             ; move bottom into B
 807+ 0902 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 808+ 0905 B8                           cp      B               ; is the cursor at the bottom of the screen?
 809+ 0906 30 0E                        jr      NC,EXITCURSORRGHT; yes, exit doing nothing
 810+ 0908 3C                           inc     A               ; no, increment Y
 811+ 0909 32 D6 81                     ld      (SCR_CUR_NY),A  ; store new Y
 812+ 090C AF                           xor     A               ; move cursor to top left
 813+ 090D 32 D5 81                     ld      (SCR_CUR_NX),A  ; store new X
 814+ 0910 CD 13 07     CONTCRSRGT:     call    RSTCHRCRS       ; restore char under the cursor and print it
 815+ 0913 CD E3 06                     call    MOVCRS          ; move cursor into new position
 816+ 0916 C1           EXITCURSORRGHT: pop     BC              ; retrieve BC
 817+ 0917 F1                           pop     AF              ; restore A
 818+ 0918 C9                           ret                     ; return to caller
 819+ 0919
 820+ 0919
 821+ 0919              ; move cursor down
 822+ 0919 F5           CURSORDOWN:     push    AF              ; store A
 823+ 091A C5                           push    BC              ; store B
 824+ 091B 3A CE 81                     ld      A,(SCR_SIZE_H)  ; load current screen height (in text modes it's 24)
 825+ 091E 3D                           dec     A               ; decrement it (positions can only vary between 0 and 23)
 826+ 091F 47                           ld      B,A             ; move X into B
 827+ 0920 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 828+ 0923 B8                           cp      B               ; is current cursor position < 23?
 829+ 0924 30 10                        jr      NC,EXITCURSORDOWN; no, exit doing nothing
 830+ 0926 3C                           inc     A               ; yes, increment Y
 831+ 0927 32 D6 81                     ld      (SCR_CUR_NY),A  ; store new Y
 832+ 092A 3A D3 81                     ld      A,(SCR_CURS_X)  ; load current cursor X
 833+ 092D 32 D5 81                     ld      (SCR_CUR_NX),A  ; set new cursor X
 834+ 0930 CD 13 07                     call    RSTCHRCRS       ; restore char under the cursor and print it
 835+ 0933 CD E3 06                     call    MOVCRS          ; move cursor into new position
 836+ 0936 C1           EXITCURSORDOWN: pop     BC              ; retrieve BC
 837+ 0937 F1                           pop     AF              ; retrieve A
 838+ 0938 C9                           ret                     ; return to caller
 839+ 0939
 840+ 0939
 841+ 0939              ; set cursor on (visible on screen)
 842+ 0939 F5           CURSOR_ON:      push    AF              ; store AF
 843+ 093A 3A D8 81                     ld      A,(CRSR_STATE)  ; load cursor state
 844+ 093D B7                           or      A               ; is it on?
 845+ 093E 20 0C                        jr      NZ,EXITCURSOR_ON; yes, so nothing to do
 846+ 0940 3A CE 81                     ld      A,(SCR_SIZE_H)  ; check the video mode
 847+ 0943 FE 30                        cp      $30             ; graphics 2 or 3 (if value>=48)?
 848+ 0945 30 05                        jr      NC,EXITCURSOR_ON; yes, so exit (no cursor in graphics 2 or 3)
 849+ 0947 3E 01                        ld      A,$01           ; cursor state ON
 850+ 0949 32 D8 81                     ld      (CRSR_STATE),A  ; set state
 851+ 094C F1           EXITCURSOR_ON:  pop     AF              ; restore AF
 852+ 094D C9                           ret                     ; return to caller
 853+ 094E
 854+ 094E              ; set cursor off (invisible on screen)
 855+ 094E F5           CURSOR_OFF:     push    AF              ; store AF
 856+ 094F AF                           xor     A               ; cursor state OFF
 857+ 0950 32 D8 81                     ld      (CRSR_STATE),A  ; set state
 858+ 0953 F1                           pop     AF              ; restore AF
 859+ 0954 C9                           ret
 860+ 0955
 861+ 0955              ; scroll the screen 1 row up
 862+ 0955 AF           SCROLLUP:       xor     A
 863+ 0956 32 DA 81                     ld      (PRNTVIDEO),A
 864+ 0959 2A D1 81                     ld      HL,(SCR_NAM_TB) ; start address of the name table
 865+ 095C 22 0E 82                     ld      (VIDTMP1),HL    ; store address of the destination row (1st row of the screen)
 866+ 095F 3A CD 81                     ld      A,(SCR_SIZE_W)  ; load the screen width
 867+ 0962 5F                           ld      E,A             ; move width into E
 868+ 0963 16 00                        ld      D,$00           ; reset D
 869+ 0965 19                           add     HL,DE           ; HL now contains the address of the source row (2nd row of the screen)
 870+ 0966 22 10 82                     ld      (VIDTMP2),HL    ; store address of source row
 871+ 0969 3A CE 81                     ld      A,(SCR_SIZE_H)  ; load the screen height
 872+ 096C 3D                           dec     A               ; decrement the # of rows: now, A contains the # of rows to be moved
 873+ 096D 47                           ld      B,A             ; move # of rows into B
 874+ 096E 3A CD 81     SCROLLNXTRW:    ld      A,(SCR_SIZE_W)  ; (re)load the screen width
 875+ 0971 5F                           ld      E,A             ; move width into E
 876+ 0972 2A 10 82                     ld      HL,(VIDTMP2)    ; load source address
 877+ 0975 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 878+ 0977 ED 69                        out     (C),L           ; low byte of source
 879+ 0979 ED 61                        out     (C),H           ; high byte of source
 880+ 097B 21 E6 81                     ld      HL,VIDEOBUFF    ; load address of the first cell of the video buffer
 881+ 097E 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 882+ 0980 ED 78        LOADNEXTCOL:    in      A,(C)           ; load char
 883+ 0982 77                           ld      (HL),A          ; store char
 884+ 0983 23                           inc     HL              ; next cell of the buffer
 885+ 0984 1D                           dec     E               ; count the chars to be read
 886+ 0985 20 F9                        jr      NZ,LOADNEXTCOL  ; repeat until we read the entire row
 887+ 0987 3A CD 81                     ld      A,(SCR_SIZE_W)  ; reload the screen width
 888+ 098A 5F                           ld      E,A             ; move # of rows into E
 889+ 098B 16 00                        ld      D,$00           ; reset D
 890+ 098D 2A 0E 82                     ld      HL,(VIDTMP1)    ; load address of destination row
 891+ 0990 E5                           push    HL              ; store HL
 892+ 0991 2A 10 82                     ld      HL,(VIDTMP2)    ; current source will be..
 893+ 0994 22 0E 82                     ld      (VIDTMP1),HL    ; ..new destination
 894+ 0997 19                           add     HL,DE           ; address of new
 895+ 0998 22 10 82                     ld      (VIDTMP2),HL    ; source row
 896+ 099B E1                           pop     HL              ; restore address of current destination row
 897+ 099C CB F4                        set     6,H             ; writing mode
 898+ 099E 0E 32                        ld      C,VDP_SET       ; VDP setting mode
 899+ 09A0 ED 69                        out     (C),L           ; low byte
 900+ 09A2 ED 61                        out     (C),H           ; high byte of address
 901+ 09A4 21 E6 81                     ld      HL,VIDEOBUFF    ; video buffer address
 902+ 09A7 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 903+ 09A9 7E           WRITEBUF:       ld      A,(HL)          ; load char
 904+ 09AA ED 79                        out     (C),A           ; send char
 905+ 09AC 23                           inc     HL              ; increment buffer index
 906+ 09AD 1D                           dec     E               ; next row
 907+ 09AE 20 F9                        jr      NZ,WRITEBUF     ; repeat until 0
 908+ 09B0 10 BC                        djnz    SCROLLNXTRW     ; repeat for the entire screen
 909+ 09B2 3A CD 81                     ld      A,(SCR_SIZE_W)  ; reload screen width
 910+ 09B5 47                           ld      B,A             ; cells to empty into B
 911+ 09B6 AF                           xor     A               ; null char
 912+ 09B7 0E 32                        ld      C,VDP_SET       ; VDP set mode
 913+ 09B9 2A 0E 82                     ld      HL,(VIDTMP1)    ; load address of the last row
 914+ 09BC CB F4                        set     6,H             ; writing mode
 915+ 09BE ED 69                        out     (C),L           ; low byte then..
 916+ 09C0 ED 61                        out     (C),H           ; high byte of address
 917+ 09C2 0E 30                        ld      C,VDP_DAT              ; VDP data mode
 918+ 09C4 ED 79        RPTEMPTYROW:    out     (C),A           ; empty cell
 919+ 09C6 00                           nop                     ; delay
 920+ 09C7 00                           nop
 921+ 09C8 10 FA                        djnz    RPTEMPTYROW     ; repeat until the last row has been cleaned
 922+ 09CA 3E 01                        ld      A,$01
 923+ 09CC 32 DA 81                     ld      (PRNTVIDEO),A   ; set print-on-video on
 924+ 09CF C9                           ret                     ; return to caller
 925+ 09D0
 926+ 09D0              ; carriage return: first, it looks for char $00 at the beginning of the line (look for the first null char),
 927+ 09D0              ; then it starts sendind every char it finds on the screen to the terminal buffer of the BASIC interpreter
 928+ 09D0              ; until another null char is found. Finally, move to the next line and position the cursor at the beginning
 929+ 09D0              ; of the row (equivalent to CR+LF), then gets back control to the screen editor to let it interpret the line
 930+ 09D0              CUR_POS         equ     TMPBFR1         ; cursor position
 931+ 09D0              SRTTXT          equ     TMPBFR2         ; start of text line
 932+ 09D0              ENDTXT          equ     TMPBFR3         ; end of text line
 933+ 09D0              CRGRETURN:      ; preliminary: disable cursor if on, and retrieve char under it
 934+ 09D0 3A D8 81                     ld      A,(CRSR_STATE)  ; recover cursor state
 935+ 09D3 32 E4 81                     ld      (TMPBFR4),A     ; store status
 936+ 09D6 A7                           and     A               ; is cursor on?
 937+ 09D7 C4 4E 09                     call    NZ,CURSOR_OFF   ; yes, so set cursor off
 938+ 09DA CD 13 07                     call    RSTCHRCRS       ; restore char under it
 939+ 09DD                              ; first, check if cursor if off, so that we just interpret return as a new line command
 940+ 09DD 3A 18 82                     ld      A,(KBDNPT)      ; check if input from keyboad
 941+ 09E0 A7                           and     A               ; if 0, input is not from keyboard...
 942+ 09E1 CA 36 0A                     jp      Z,PRNTRETURN    ; ...so just print a carriage return; otherwise, interpret the return
 943+ 09E4                              ; first part: look for the beginning of the text line on screen
 944+ 09E4 CD 1C 07                     call    LOAD_CRSR_POS   ; load cursor position into HL
 945+ 09E7 22 DE 81                     ld      (CUR_POS),HL    ; store it
 946+ 09EA ED 5B D1 81                  ld      DE,(SCR_NAM_TB) ; load VRAM address of top-left cell of screen ("home")
 947+ 09EE E5           RPTNLLSRC:      push    HL
 948+ 09EF CD DE 3F                     call    CMP16           ; check if at "home"
 949+ 09F2 E1                           pop     HL
 950+ 09F3 CA FE 09                     jp      Z,CNTNULL       ; yes, exit because there is nothing before
 951+ 09F6 2B                           dec     HL              ; go 1 step back
 952+ 09F7 CD 9D 06                     call    READ_VIDEO_LOC  ; read char of current position
 953+ 09FA A7                           and     A               ; is it $00 (null char)?
 954+ 09FB 20 F1                        jr      NZ,RPTNLLSRC    ; no, continue searching
 955+ 09FD 23                           inc     HL              ; move 1 step forward to go back to the last cell with something in
 956+ 09FE                              ; second part: look for the ending of the text on screen
 957+ 09FE 22 E0 81     CNTNULL:        ld      (SRTTXT),HL     ; store beginning of text
 958+ 0A01 CD 57 0A                     call    ENDOFLN         ; find end of text line looking at the end of chars after the cursor position
 959+ 0A04 22 E2 81                     ld      (ENDTXT),HL     ; store ending of text line
 960+ 0A07 ED 5B E0 81                  ld      DE,(SRTTXT)     ; load beginning of text line
 961+ 0A0B A7                           and     A               ; clear Carry
 962+ 0A0C ED 52                        sbc     HL,DE           ; how many chars?
 963+ 0A0E 28 26                        jr      Z,PRNTRETURN    ; no chars found (HL-DE=0), so just print return & leave
 964+ 0A10                              ;---    central part: send the text on the screen to the interpreter
 965+ 0A10 2A E0 81                     ld      HL,(SRTTXT)     ; load beginning of text line
 966+ 0A13 ED 5B E2 81                  ld      DE,(ENDTXT)     ; load ending of text line
 967+ 0A17 CD 9D 06     SNDCHRTOBFR:    call    READ_VIDEO_LOC  ; read char
 968+ 0A1A E5                           push    HL
 969+ 0A1B CD F4 01                     call    CHARINTOBFR     ; send char to buffer
 970+ 0A1E E1                           pop     HL
 971+ 0A1F 23                           inc     HL              ; go to next char
 972+ 0A20 E5                           push    HL              ; store HL
 973+ 0A21 CD DE 3F                     call    CMP16           ; check if DE=HL (finish chars)
 974+ 0A24 E1                           pop     HL
 975+ 0A25 20 F0                        jr      NZ,SNDCHRTOBFR  ; no, repeat
 976+ 0A27 3E 0D                        ld      A,CR            ; yes, so now send carriage return
 977+ 0A29 CD F4 01                     call    CHARINTOBFR     ; send to buffer
 978+ 0A2C 2A E2 81                     ld      HL,(ENDTXT)     ; recover address of last char of input text
 979+ 0A2F CD 3F 07                     call    HL2XY           ; retrieve X,Y from address
 980+ 0A32 7D                           ld      A,L             ; move Y into A (we don't need X anymore)
 981+ 0A33 32 D4 81                     ld      (SCR_CURS_Y),A  ; store new Y
 982+ 0A36                              ;---    final part: go at the beginning of a new line on the screen
 983+ 0A36 AF           PRNTRETURN:     xor     A               ; move to col 0
 984+ 0A37 32 D3 81                     ld      (SCR_CURS_X),A  ; store new X
 985+ 0A3A 3A D4 81                     ld      A,(SCR_CURS_Y)  ; load cursor Y into A
 986+ 0A3D 3C                           inc     A               ; new row
 987+ 0A3E 21 CE 81                     ld      HL,SCR_SIZE_H   ; load address of cell that keeps screen height
 988+ 0A41 BE                           cp      (HL)            ; is the cursor over the bottom of the screen?
 989+ 0A42 38 06                        jr      C,ADDNEWLINE    ; no, jump over
 990+ 0A44 3D                           dec     A               ; yes, so come back 1 row, then...
 991+ 0A45 F5                           push    AF              ; (store A)
 992+ 0A46 CD 55 09                     call    SCROLLUP        ; ...scroll the screen before to...
 993+ 0A49 F1                           pop     AF              ; (retrieve A)
 994+ 0A4A 32 D4 81     ADDNEWLINE:     ld      (SCR_CURS_Y),A  ; ...store new Y
 995+ 0A4D 3A E4 81                     ld      A,(TMPBFR4)     ; retrieve cursor state
 996+ 0A50 A7                           and     A               ; was it off (A=0)?
 997+ 0A51 C4 39 09                     call    NZ,CURSOR_ON    ; no, set cursor on
 998+ 0A54 C3 D9 06                     jp      POS_CURSOR      ; position cursor to new location & return to caller
 999+ 0A57
1000+ 0A57              ; find end of text line
1001+ 0A57              ; destroys A, DE, and HL - store address of last char of text line into HL,
1002+ 0A57              ; while DE contains the address of the bottom right cell of the screen
1003+ 0A57 3A CE 81     ENDOFLN:        ld      A,(SCR_SIZE_H)
1004+ 0A5A 5F                           ld      E,A             ; load screen height into DE
1005+ 0A5B 3A CD 81                     ld      A,(SCR_SIZE_W)
1006+ 0A5E 6F                           ld      L,A             ; load screen width into HL
1007+ 0A5F AF                           xor     A
1008+ 0A60 67                           ld      H,A
1009+ 0A61 57                           ld      D,A
1010+ 0A62 CD E9 3F                     call    MUL16           ; multiply HL times DE to get the screen size
1011+ 0A65 ED 5B D1 81                  ld      DE,(SCR_NAM_TB) ; load screen name table start address into DE
1012+ 0A69 19                           add     HL,DE           ; get the address...
1013+ 0A6A 2B                           dec     HL              ; ...of the "last" video cell
1014+ 0A6B EB                           ex      DE,HL           ; store address into DE
1015+ 0A6C 2A DE 81                     ld      HL,(CUR_POS)    ; retrieve original cursor position
1016+ 0A6F E5           RPTNLLSRC2:     push    HL
1017+ 0A70 CD DE 3F                     call    CMP16           ; check if at last position on screen (bottom right corner)
1018+ 0A73 E1                           pop     HL
1019+ 0A74 C8                           ret     Z               ; if yes, exit because these is nothing after
1020+ 0A75 23                           inc     HL              ; 1 more step forward
1021+ 0A76 CD 9D 06                     call    READ_VIDEO_LOC  ; read char of current position
1022+ 0A79 A7                           and     A               ; is it $00 (null char)?
1023+ 0A7A 20 F3                        jr      NZ,RPTNLLSRC2   ; no, continue searching
1024+ 0A7C C9           CNTNULL2:       ret                     ; yes: found end of text, return to caller
1025+ 0A7D
1026+ 0A7D
1027+ 0A7D              ; ------------------------------------------------------------------------------
1028+ 0A7D                              ; this table contains the values of the offsets to be added to
1029+ 0A7D                              ; the starting address of the name table to find the correct
1030+ 0A7D                              ; value of the first cell of the corresponding row
1031+ 0A7D                              ; (by doing so, it's faster than doing a multipication)
1032+ 0A7D                              ; table for graphics 1 text mode: 32 cols
1033+ 0A7D 00 00 20 00  POS_TB_CRS_32:  defw    $0000,$0020,$0040,$0060,$0080,$00A0,$00C0,$00E0
1033+ 0A81 40 00 60 00
1033+ 0A85 80 00 A0 00
1033+ 0A89 C0 00 E0 00
1034+ 0A8D 00 01 20 01                  defw    $0100,$0120,$0140,$0160,$0180,$01A0,$01C0,$01E0
1034+ 0A91 40 01 60 01
1034+ 0A95 80 01 A0 01
1034+ 0A99 C0 01 E0 01
1035+ 0A9D 00 02 20 02                  defw    $0200,$0220,$0240,$0260,$0280,$02A0,$02C0,$02E0
1035+ 0AA1 40 02 60 02
1035+ 0AA5 80 02 A0 02
1035+ 0AA9 C0 02 E0 02
1036+ 0AAD                              ; table for pure text mode: 40 cols
1037+ 0AAD 00 00 28 00  POS_TB_CRS_40:  defw    $0000,$0028,$0050,$0078,$00A0,$00C8,$00F0,$0118
1037+ 0AB1 50 00 78 00
1037+ 0AB5 A0 00 C8 00
1037+ 0AB9 F0 00 18 01
1038+ 0ABD 40 01 68 01                  defw    $0140,$0168,$0190,$01B8,$01E0,$0208,$0230,$0258
1038+ 0AC1 90 01 B8 01
1038+ 0AC5 E0 01 08 02
1038+ 0AC9 30 02 58 02
1039+ 0ACD 80 02 A8 02                  defw    $0280,$02A8,$02D0,$02F8,$0320,$0348,$0370,$0398
1039+ 0AD1 D0 02 F8 02
1039+ 0AD5 20 03 48 03
1039+ 0AD9 70 03 98 03
1040+ 0ADD
1041+ 0ADD              ; ------------------------------------------------------------------------------
1042+ 0ADD              ; reset VRAM
1043+ 0ADD AF           EMPTY_VRAM:     xor     A               ; reg.A cleared: we fill up VRAM with $00
1044+ 0ADE 67                           ld      H,A
1045+ 0ADF 6F                           ld      L,A             ; reset HL
1046+ 0AE0 CD 7D 06                     call    SETVDPADRS      ; set address of first VRAM cell to $0000
1047+ 0AE3 06 40                        ld      B,$40           ; $40 pages of RAM...
1048+ 0AE5 57                           ld      D,A             ; ...each one with $100 cells (tot. $4000 bytes)
1049+ 0AE6 0E 30                        ld      C,VDP_DAT              ; VDP data mode
1050+ 0AE8 ED 79        EMPTVRM:        out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
1051+ 0AEA 14                           inc     D               ; next cell
1052+ 0AEB 00                           nop
1053+ 0AEC 20 FA                        jr      NZ,EMPTVRM      ; repeat until page is fully cleared
1054+ 0AEE 10 F8                        djnz    EMPTVRM         ; repeat for $40 pages
1055+ 0AF0 C9                           ret                     ; return to caller
1056+ 0AF1
1057+ 0AF1              ; clear video registers in SRAM
1058+ 0AF1 21 CD 81     CLR_RAM_REG:    ld      HL,SCR_SIZE_W   ; address of first register
1059+ 0AF4 AF                           xor     A               ; $00 to clean the registers
1060+ 0AF5 06 45                        ld      B,CHASNDDTN-SCR_SIZE_W; how many bytes (registers) to clean (dinamically calculated)
1061+ 0AF7 77           RSTVDPRAMREG:   ld      (HL),A          ; reset register
1062+ 0AF8 23                           inc     HL              ; next register
1063+ 0AF9 10 FC                        djnz    RSTVDPRAMREG    ; repeat
1064+ 0AFB C9                           ret                     ; return to caller
1065+ 0AFC
1066+ 0AFC              ; ------------------------------------------------------------------------------
1067+ 0AFC              ; set a specific graphics mode, passed into reg. E
1068+ 0AFC 06 08        SET_GFX_MODE:   ld      B,$08           ; 8 registers means 8 bytes..
1069+ 0AFE CB 23                        sla     E               ; multiply E by 8..
1070+ 0B00 CB 23                        sla     E               ; so that reg. E can point..
1071+ 0B02 CB 23                        sla     E               ; to the correct settings
1072+ 0B04 16 00        SET_GFX_MODE2:  ld      D,$00           ; reset D
1073+ 0B06 21 39 0B                     ld      HL,VDPMODESET   ; pointer to register settings | <= here points the SHOW_LOGO sub-routine
1074+ 0B09 19                           add     HL,DE           ; add offset to get the correct set of values for the required mode
1075+ 0B0A 3E 80                        ld      A,$80           ; start with REG0 ($80+register number)
1076+ 0B0C 0E 32                        ld      C,VDP_SET       ; VDP set
1077+ 0B0E 56           LDREGVLS:       ld      D,(HL)          ; load register's value
1078+ 0B0F ED 51                        out     (C),D           ; send data to VDP
1079+ 0B11 ED 79                        out     (C),A           ; indicate the register to send data to
1080+ 0B13 3C                           inc     A               ; next register
1081+ 0B14 23                           inc     HL              ; next value
1082+ 0B15 10 F7                        djnz    LDREGVLS        ; repeat for 8 registers
1083+ 0B17 C9                           ret
1084+ 0B18
1085+ 0B18              ; ------------------------------------------------------------------------------
1086+ 0B18              LOADCHARSET:    ; reg. A contains the video mode
1087+ 0B18                              ; reg. HL contains address of pattern table into VRAM
1088+ 0B18 06 00                        ld      B,$00           ; 0=256 chars to load (complete charset)
1089+ 0B1A CB F4                        set     $06,H           ; add $4000 to address to indicate that we want to write into VRAM
1090+ 0B1C 0E 32                        ld      C,VDP_SET       ; load VDP address into C
1091+ 0B1E ED 69                        out     (C),L           ; send low byte of address
1092+ 0B20 ED 61                        out     (C),H           ; send high byte
1093+ 0B22 0E 30                        ld      C,VDP_DAT              ; VDP data mode
1094+ 0B24 21 41 40                     ld      HL,CHRST68      ; starting address of 6x8 charset into ROM
1095+ 0B27 A7                           and     A               ; is it text mode (A=0)?
1096+ 0B28 28 03                        jr      Z,NXTCHAR       ; yes, so jump to load chars into VRAM
1097+ 0B2A 21 41 48                     ld      HL,CHRST88      ; no, so we change and load the 8x8 charset
1098+ 0B2D 16 08        NXTCHAR:        ld      D,$08           ; 8 bytes per pattern char
1099+ 0B2F 7E           SENDCHRPTRNS:   ld      A,(HL)          ; load byte to send to VDP
1100+ 0B30 ED 79                        out     (C),A           ; write byte into VRAM
1101+ 0B32 23                           inc     HL              ; inc byte pointer
1102+ 0B33 15                           dec     D               ; 8 bytes sents (0 char)?
1103+ 0B34 20 F9                        jr      NZ,SENDCHRPTRNS ; no, continue
1104+ 0B36 10 F5                        djnz    NXTCHAR         ; yes, decrement chars counter and continue for all the chars
1105+ 0B38 C9                           ret                     ; return to caller
1106+ 0B39
1107+ 0B39              ;------------------------------------------------------------------------------
1108+ 0B39              ; NAME TABLE:       buffer video - contains the chars to be shown on video
1109+ 0B39              ; PATTERN TABLE:    charset - contains the chars/tiles to be loaded into the name table
1110+ 0B39              ; COLOR TABLE:      color settings for chars/tiles
1111+ 0B39
1112+ 0B39                              ; VDP register settings for a text display
1113+ 0B39 00           VDPMODESET:     defb    %00000000       ; reg.0: external video off
1114+ 0B3A D0                           defb    %11010000       ; reg.1: 16K VRAM, video on, int. off, text mode (40x24)
1115+ 0B3B 02                           defb    $02             ; reg.2: name table set to $0800 ($02x$400)
1116+ 0B3C 00                           defb    $00             ; reg.3: not used in text mode
1117+ 0B3D 00                           defb    $00             ; reg.4: pattern table set to $0000
1118+ 0B3E 00                           defb    $00             ; reg.5: not used in text mode
1119+ 0B3F 00                           defb    $00             ; reg.6: not used in text mode
1120+ 0B40 F5                           defb    $f5             ; reg.7: white text on light blue background
1121+ 0B41
1122+ 0B41              VDPMODESET1:    ; VDP register settings for a graphics 1 mode
1123+ 0B41 00                           defb    %00000000       ; reg.0: ext. video off
1124+ 0B42 C0                           defb    %11000000       ; reg.1: 16K Vram; video on, int off, graphics mode 1, sprite size 8x8, sprite magn. 0
1125+ 0B43 06                           defb    $06             ; reg.2: name table address: $1800
1126+ 0B44 80                           defb    $80             ; reg.3: color table address: $2000
1127+ 0B45 00                           defb    $00             ; reg.4: pattern table address: $0000
1128+ 0B46 36                           defb    $36             ; reg.5: sprite attr. table address: $1B00
1129+ 0B47 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1130+ 0B48 05                           defb    $05             ; reg.7: backdrop color (light blue)
1131+ 0B49
1132+ 0B49              VDPMODESET2:    ; VDP register settings for a graphics 2 mode
1133+ 0B49 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1134+ 0B4A C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1135+ 0B4B 06                           defb    $06             ; reg.2: name table addr.: $1800
1136+ 0B4C FF                           defb    $FF             ; reg.3: color table addr.: $2000
1137+ 0B4D 03                           defb    $03             ; reg.4: pattern table addr.: $0000
1138+ 0B4E 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1139+ 0B4F 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1140+ 0B50 05                           defb    $05             ; reg.7: backdrop color: light blue
1141+ 0B51
1142+ 0B51              VDPMODESETMC:   ; VDP register settings for a multicolor mode
1143+ 0B51 00                           defb    %00000000       ; reg.0: ext. video dis.
1144+ 0B52 CB                           defb    %11001011       ; reg.1: 16K VRAM, video on, INT off, multicolor mode, sprite size 8x8, sprite magn. 0
1145+ 0B53 02                           defb    $02             ; reg.2: name table addr.: $0800
1146+ 0B54 00                           defb    $00             ; reg.3: don't care
1147+ 0B55 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1148+ 0B56 36                           defb    $36             ; reg.5: sprite attr. table addr.: $1B00
1149+ 0B57 07                           defb    $07             ; reg.6: sprite pattern table addr.: $3800
1150+ 0B58 0F                           defb    $0F             ; reg.7: backdrop color (white)
1151+ 0B59
1152+ 0B59              VDPMODESETEX2:  ; VDP register settings for an extended graphics 2 mode
1153+ 0B59 02                           defb    %00000010       ; reg.0: graphics 2 mode, ext. video dis.
1154+ 0B5A C0                           defb    %11000000       ; reg.1: 16K VRAM, video on, INT off, sprite size 8x8, sprite magn. 0
1155+ 0B5B 0E                           defb    $0E             ; reg.2: name table addr.: $3800
1156+ 0B5C 9F                           defb    $9F             ; reg.3: color table addr.: $2000
1157+ 0B5D 00                           defb    $00             ; reg.4: pattern table addr.: $0000
1158+ 0B5E 76                           defb    $76             ; reg.5: sprite attr. table addr.: $3B00
1159+ 0B5F 03                           defb    $03             ; reg.6: sprite pattern table addr.: $1800
1160+ 0B60 05                           defb    $05             ; reg.7: backdrop color: light blue
1161+ 0B61
1162+ 0B61              LM80CLOGO:      ; patterns to compose the splash screen logo
1163+ 0B61                              ; 1st band
1164+ 0B61 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1164+ 0B65 00 00 00 00
1164+ 0B69 00 00 00 00
1164+ 0B6D 00 00 00 00
1164+ 0B71 00 00 00 00
1164+ 0B75 00 00 00 00
1164+ 0B79 00 00 00 00
1164+ 0B7D 00 00 00 00
1165+ 0B81 00 00 0F 0A                  defb    0,0,15,10,11,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1165+ 0B85 0B 10 00 00
1165+ 0B89 00 00 00 00
1165+ 0B8D 00 00 00 00
1165+ 0B91 00 00 00 00
1165+ 0B95 00 00 00 00
1165+ 0B99 00 00 00 00
1165+ 0B9D 00 00 00 00
1166+ 0BA1                              ; 2nd band
1167+ 0BA1 00 00 0D 17                  defb    0,0,13,23,0,12,0,0,0,1,0,0,0,20,0,0,6,5,6,21,22,7,6,21,22,7,6,1,1,7,0,0
1167+ 0BA5 00 0C 00 00
1167+ 0BA9 00 01 00 00
1167+ 0BAD 00 14 00 00
1167+ 0BB1 06 05 06 15
1167+ 0BB5 16 07 06 15
1167+ 0BB9 16 07 06 01
1167+ 0BBD 01 07 00 00
1168+ 0BC1 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,20,6,1,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1168+ 0BC5 00 0C 00 00
1168+ 0BC9 00 01 00 00
1168+ 0BCD 00 01 14 06
1168+ 0BD1 01 05 03 05
1168+ 0BD5 03 05 03 05
1168+ 0BD9 03 05 03 05
1168+ 0BDD 03 05 00 00
1169+ 0BE1                              ; 3rd band
1170+ 0BE1 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,1,1,1,5,9,20,19,8,3,5,19,5,3,5,0,0,0,0
1170+ 0BE5 00 0C 00 00
1170+ 0BE9 00 01 00 00
1170+ 0BED 00 01 01 01
1170+ 0BF1 01 05 09 14
1170+ 0BF5 13 08 03 05
1170+ 0BF9 13 05 03 05
1170+ 0BFD 00 00 00 00
1171+ 0C01 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,8,3,5,6,21,22,7,3,1,22,5,3,5,0,0,0,0
1171+ 0C05 00 0C 00 00
1171+ 0C09 00 01 00 00
1171+ 0C0D 00 01 00 08
1171+ 0C11 03 05 06 15
1171+ 0C15 16 07 03 01
1171+ 0C19 16 05 03 05
1171+ 0C1D 00 00 00 00
1172+ 0C21                              ; 4th band
1173+ 0C21 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,0,0,0,1,0,0,3,5,3,5,3,5,3,5,3,5,3,5,3,5,0,0
1173+ 0C25 00 0C 00 00
1173+ 0C29 00 01 00 00
1173+ 0C2D 00 01 00 00
1173+ 0C31 03 05 03 05
1173+ 0C35 03 05 03 05
1173+ 0C39 03 05 03 05
1173+ 0C3D 03 05 00 00
1174+ 0C41 00 00 0D 00                  defb    0,0,13,0,0,12,0,0,0,1,4,4,0,1,0,0,3,5,9,20,19,8,9,20,19,8,9,1,1,8,0,0
1174+ 0C45 00 0C 00 00
1174+ 0C49 00 01 04 04
1174+ 0C4D 00 01 00 00
1174+ 0C51 03 05 09 14
1174+ 0C55 13 08 09 14
1174+ 0C59 13 08 09 01
1174+ 0C5D 01 08 00 00
1175+ 0C61                              ; 5th band
1176+ 0C61 00 00 0E 12                  defb    0,0,14,18,18,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1176+ 0C65 12 11 00 00
1176+ 0C69 00 00 00 00
1176+ 0C6D 00 00 00 00
1176+ 0C71 00 00 00 00
1176+ 0C75 00 00 00 00
1176+ 0C79 00 00 00 00
1176+ 0C7D 00 00 00 00
1177+ 0C81 00 00 00 00                  defb    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1177+ 0C85 00 00 00 00
1177+ 0C89 00 00 00 00
1177+ 0C8D 00 00 00 00
1177+ 0C91 00 00 00 00
1177+ 0C95 00 00 00 00
1177+ 0C99 00 00 00 00
1177+ 0C9D 00 00 00 00
# file closed: ../include/vdp/vdp-1.3.asm
  73  0CA1
  74  0CA1              ; incude the latest version of the PSG module
  75  0CA1                  INCLUDE "../include/psg/psg-1.1.asm"
# file opened: ../include/psg/psg-1.1.asm
   1+ 0CA1              ; ------------------------------------------------------------------------------
   2+ 0CA1              ; LM80C - PSG ROUTINES - 1.1
   3+ 0CA1              ; ------------------------------------------------------------------------------
   4+ 0CA1              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 0CA1              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 0CA1              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 0CA1              ; kind of warranty: you can use them at your own risk.
   8+ 0CA1              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 0CA1              ; maintain the copyright notices, include this advice and the note to the
  10+ 0CA1              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 0CA1              ; redistribuite them.
  12+ 0CA1              ; https://www.leonardomiliani.com
  13+ 0CA1              ;
  14+ 0CA1              ; Please support me by visiting the following links:
  15+ 0CA1              ; Main project page: https://www.leonardomiliani.com
  16+ 0CA1              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 0CA1              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 0CA1              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 0CA1              ; ------------------------------------------------------------------------------
  20+ 0CA1              ;
  21+ 0CA1              ; ------------------------------------------------------------------------------
  22+ 0CA1
  23+ 0CA1              ;------------------------------------------------------------------------------
  24+ 0CA1
  25+ 0CA1              ; configure the PSG
  26+ 0CA1 21 12 82     initPSG:        ld      HL,CHASNDDTN    ; starting address of sound & keyboard RAM registers
  27+ 0CA4 06 0E                        ld      B,SERIALS_EN-CHASNDDTN; # of PSG sound & keyboard registers
  28+ 0CA6 AF                           xor     A               ; reset A
  29+ 0CA7 77           EMPTSNDBFR:     ld      (HL),A          ; reset RAM register
  30+ 0CA8 23                           inc     HL              ; next register
  31+ 0CA9 10 FC                        djnz    EMPTSNDBFR      ; repeat
  32+ 0CAB 06 10        CLRPSGREGS:     ld      B,$10           ; 16 registers to set
  33+ 0CAD 21 BF 0C                     ld      HL,SNDREGCFG    ; starting address of register settings
  34+ 0CB0 16 00                        ld      D,$00           ; first register
  35+ 0CB2 7A           RSTPSG:         ld      A,D             ; register value
  36+ 0CB3 CD F9 0C                     call    SETSNDREG       ; select register
  37+ 0CB6 7E                           ld      A,(HL)          ; load value
  38+ 0CB7 CD FE 0C                     call    WRTSNDREG       ; write to register
  39+ 0CBA 14                           inc     D               ; next register
  40+ 0CBB 23                           inc     HL              ; next value
  41+ 0CBC 10 F4                        djnz    RSTPSG          ; repeat for each register
  42+ 0CBE C9                           ret                     ; return to caller
  43+ 0CBF
  44+ 0CBF 00 00 00 00  SNDREGCFG:      defb $00,$00,$00,$00,$00,$00,$00,%10111111
  44+ 0CC3 00 00 00 BF
  45+ 0CC7 00 00 00 00                  defb $00,$00,$00,$00,$00,$00,$ff,$ff
  45+ 0CCB 00 00 FF FF
  46+ 0CCF                              ; reg. 7: set I/O ch.A to OUTPUT, I/O ch.B to INPUT; set noise to OFF; set audio to OFF
  47+ 0CCF
  48+ 0CCF
  49+ 0CCF              ; routine to play a welcome beep on channel C (tone 4010) and to shut it off
  50+ 0CCF 21 E9 0C     WLCMBEEP:       ld      HL,WLCBPDAT     ; data address
  51+ 0CD2 C3 D8 0C                     jp      SENDSND
  52+ 0CD5 21 F1 0C     NOBEEP:         ld      HL,NOBPDAT      ; data address
  53+ 0CD8 C5           SENDSND:        push    BC
  54+ 0CD9 06 04                        ld      B,$04           ; 4 pairs
  55+ 0CDB 7E           RPTWLCMBP:      ld      A,(HL)          ; read register #
  56+ 0CDC CD F9 0C                     call    SETSNDREG
  57+ 0CDF 23                           inc     HL              ; next cell
  58+ 0CE0 7E                           ld      A,(HL)          ; read value
  59+ 0CE1 CD FE 0C                     call    WRTSNDREG
  60+ 0CE4 23                           inc     HL
  61+ 0CE5 10 F4                        djnz    RPTWLCMBP       ; repeat
  62+ 0CE7 C1                           pop     BC
  63+ 0CE8 C9                           ret                     ; return to caller
  64+ 0CE9
  65+ 0CE9 07 BB 04 56  WLCBPDAT:       defb    $07,%10111011,$04,$56,$05,$00,$0A,$0F
  65+ 0CED 05 00 0A 0F
  66+ 0CF1 04 00 05 00  NOBPDAT:        defb    $04,$00,$05,$00,$0A,$00,$07,%10111111
  66+ 0CF5 0A 00 07 BF
  67+ 0CF9
  68+ 0CF9
  69+ 0CF9              ; select register on PSG
  70+ 0CF9 0E 40        SETSNDREG:      ld      C,PSG_REG       ; PSG register port
  71+ 0CFB ED 79                        out     (C),A           ; set register
  72+ 0CFD C9                           ret                     ; return to caller
  73+ 0CFE
  74+ 0CFE              ; send data to PSG
  75+ 0CFE 0E 41        WRTSNDREG:      ld      C,PSG_DAT       ; PSG data port
  76+ 0D00 ED 79                        out     (C),A           ; send data
  77+ 0D02 C9                           ret                     ; return to caller
  78+ 0D03
  79+ 0D03              ; manage the sounds' duration: each time this subroutine is called, it
  80+ 0D03              ; decrements the single sound durations (measured in ms) and eventually
  81+ 0D03              ; shut off the audio channel whose counter has reached 0.
  82+ 0D03              ; (this sub-routine is called by CH3 timer ISR)
  83+ 0D03 DD E5        MNGSNDS:        push    IX              ; store IX
  84+ 0D05 DD 21 12 82                  ld      IX,CHASNDDTN    ; starting address of tones duration
  85+ 0D09 06 03                        ld      B,$03           ; 3 channels to check
  86+ 0D0B 26 01                        ld      H,$01           ; mixer channels: A=>bit 1, B=>bit 2, C=>bit 3
  87+ 0D0D DD 5E 00     CHKSNDCH:       ld      E,(IX+0)        ; load LSB into E
  88+ 0D10 DD 56 01                     ld      D,(IX+1)        ; load MSB into D
  89+ 0D13 7B                           ld      A,E             ; load E into A
  90+ 0D14 B2                           or      D               ; check that DE=0
  91+ 0D15 28 31                        jr      Z,CNTCHKSND     ; yes, jump over
  92+ 0D17 1B                           dec     DE              ; no, so decrement DE
  93+ 0D18 7B                           ld      A,E             ; reload E into A...
  94+ 0D19 DD 73 00                     ld      (IX+0),E        ; store new...
  95+ 0D1C DD 72 01                     ld      (IX+1),D        ; ...duration and...
  96+ 0D1F B2                           or      D               ; ...do another check to see if DE=0
  97+ 0D20 20 26                        jr      NZ,CNTCHKSND    ; no, so jump over
  98+ 0D22                                                      ; if yes, let's shut down the corresponding channel
  99+ 0D22                                                      ; to shut down a tone we disable it into the mixer
 100+ 0D22                                                      ; then set 0 into its tone registers
 101+ 0D22 16 07                        ld      D,$07           ; mixer register
 102+ 0D24 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 103+ 0D26 ED 51                        out     (C),D           ; set mixer register
 104+ 0D28 ED 78                        in      A,(C)           ; load current value
 105+ 0D2A B4                           or      H               ; set off the channel into the mixer (remember that 1=OFF)
 106+ 0D2B ED 51                        out     (C),D           ; select mixer register
 107+ 0D2D 0E 41                        ld      C,PSG_DAT       ; PSG data port
 108+ 0D2F ED 79                        out     (C),A           ; send new value for the mixer
 109+ 0D31 3E 03                        ld      A,$03           ; three channels
 110+ 0D33 90                           sub     B               ; find current channel (0->A, 1->B, 2->C)
 111+ 0D34 87                           add     A,A             ; and find first register (A=>0, B=>2, C=>4)
 112+ 0D35 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 113+ 0D37 ED 79                        out     (C),A           ; select first tone register of channel
 114+ 0D39 2E 00                        ld      L,$00           ; value 0 into L
 115+ 0D3B 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 116+ 0D3D ED 69                        out     (C),L           ; write 0 into register
 117+ 0D3F 0E 40                        ld      C,PSG_REG       ; PSG register selector port
 118+ 0D41 3C                           inc     A               ; next tone register
 119+ 0D42 ED 79                        out     (C),A           ; select second tone register of channel
 120+ 0D44 0E 41                        ld      C,PSG_DAT       ; PSG data selector port
 121+ 0D46 ED 69                        out     (C),L           ; write 0 into register
 122+ 0D48 DD 23        CNTCHKSND:      inc     IX              ; set for...
 123+ 0D4A DD 23                        inc     IX              ; ...next channel...
 124+ 0D4C CB 24                        sla     H               ; shift left H 1 bit
 125+ 0D4E 10 BD                        djnz    CHKSNDCH        ; repeat for 3 channels
 126+ 0D50 DD E1                        pop     IX              ; restore IX
 127+ 0D52 C9                           ret                     ; return to caller
 128+ 0D53
 129+ 0D53              ; read a specific row of the keyboard matrix, set by A
 130+ 0D53              ; return read into A
 131+ 0D53 C5           READKBLN:       push    BC              ; store BC
 132+ 0D54 06 0F                        ld      B,$0F           ; reg #15
 133+ 0D56 0E 40                        ld      C,PSG_REG       ; PSG register port
 134+ 0D58 ED 41                        out     (C),B           ; select reg #15
 135+ 0D5A 0E 41                        ld      C,PSG_DAT       ; PSG data port
 136+ 0D5C ED 79                        out     (C),A           ; activate the row
 137+ 0D5E 06 0E                        ld      B,$0E           ; register #14 (port B)
 138+ 0D60 0E 40                        ld      C,PSG_REG       ; PSG register port
 139+ 0D62 ED 41                        out     (C),B           ; select reg. 14 (port B)
 140+ 0D64 ED 78                        in      A,(C)           ; read register #14
 141+ 0D66 C1                           pop     BC              ; retrieve BC
 142+ 0D67 C9                           ret
 143+ 0D68
 144+ 0D68              ; read the keyboard matrix to look for a key pressure
 145+ 0D68 0E 40        KEYBOARD:       ld      C,PSG_REG       ; PSG register port
 146+ 0D6A 06 07                        ld      B,$07           ; set register #7...
 147+ 0D6C ED 41                        out     (C),B           ; ...to work with
 148+ 0D6E ED 78                        in      A,(C)           ; read register #7
 149+ 0D70 CB FF                        set     7,A             ; port A set to output
 150+ 0D72 CB B7                        res     6,A             ; port B set to input
 151+ 0D74 ED 41                        out     (C),B           ; set register #7
 152+ 0D76 0E 41                        ld      C,PSG_DAT       ; PSG data port
 153+ 0D78 ED 79                        out     (C),A           ; set I/O ports w/o altering the rest of the mixer
 154+ 0D7A                              ; check special keys (SHIFT/ALT/CTRL)
 155+ 0D7A 3E FD                        ld      A,%11111101     ; select SHIFT row
 156+ 0D7C CD 53 0D                     call    READKBLN        ; read row
 157+ 0D7F CB 5F                        bit     3,A             ; test if SHIFT key is pressed (4th bit is reset)
 158+ 0D81 20 05                        jr      NZ,CHECKALT     ; no, so go on
 159+ 0D83 21 1F 82                     ld      HL,CONTROLKEYS  ; control key flags
 160+ 0D86 36 01                        ld      (HL),%00000001  ; set SHIFT flag, reset CTRL & ALT flags (currently multiply control keys are NOT supported)
 161+ 0D88 3E FE        CHECKALT:       ld      A,%11111110     ; select ALT row
 162+ 0D8A CD 53 0D                     call    READKBLN        ; read ALT row
 163+ 0D8D CB 6F                        bit     5,A             ; test if ALT key is pressed (5th bit is reset)
 164+ 0D8F 20 05                        jr      NZ,CHECKCTRL    ; no, so go on
 165+ 0D91 21 1F 82                     ld      HL,CONTROLKEYS  ; control key flags
 166+ 0D94 36 04                        ld      (HL),%00000100  ; set ALT flag, reset SHIFT & CTRL flag (currently multiply control keys are NOT supported)
 167+ 0D96 3E FE        CHECKCTRL:      ld      A,%11111110     ; select CTRL row
 168+ 0D98 CD 53 0D                     call    READKBLN        ; read CTRL row
 169+ 0D9B CB 57                        bit     2,A             ; test if CTRL key is pressed (3rd bit is reset)
 170+ 0D9D 20 05                        jr      NZ,CHECKKBD     ; no, so make a normal reading
 171+ 0D9F 21 1F 82                     ld      HL,CONTROLKEYS  ; control key flags
 172+ 0DA2 36 02                        ld      (HL),%00000010  ; set CTRL flag, reset SHIFT & ALT flags (currently multiply control keys are NOT supported)
 173+ 0DA4 06 08        CHECKKBD:       ld      B,$08           ; 8 lines
 174+ 0DA6 3E 7F                        ld      A,%01111111     ; start from the last line of the matrix
 175+ 0DA8 16 0F        RPTKBDRD:       ld      D,$0F           ; register #15 (port B)
 176+ 0DAA 0E 40                        ld      C,PSG_REG       ; PSG register port
 177+ 0DAC ED 51                        out     (C),D           ; select reg. #15
 178+ 0DAE 0E 41                        ld      C,PSG_DAT       ; PSG data port
 179+ 0DB0 ED 79                        out     (C),A           ; activate 1 line (active line is grounded, i.e. with a LOW signal)
 180+ 0DB2 5F                           ld      E,A             ; save current line into E
 181+ 0DB3 16 0E                        ld      D,$0E           ; register #14 (port A)
 182+ 0DB5 0E 40                        ld      C,PSG_REG       ; PSG register port
 183+ 0DB7 ED 51                        out     (C),D           ; select reg. 14 (port A)
 184+ 0DB9 00                           nop
 185+ 0DBA ED 78                        in      A,(C)           ; read register #14
 186+ 0DBC FE FF                        cp      $FF             ; is there any line set to 0?
 187+ 0DBE 28 2E                        jr      Z,NOKEYPRSD     ; no, go to the next row
 188+ 0DC0                              ; check control keys
 189+ 0DC0 32 19 82                     ld      (KBTMP),A       ; yes, check if a control key was pressed. First, store current row
 190+ 0DC3 78                           ld      A,B             ; copy current row (B) into A
 191+ 0DC4 FE 02                        cp      $02             ; is it the row of the SHIFT?
 192+ 0DC6 20 0F                        jr      NZ,TESTALT      ; no, continue checking the other control keys
 193+ 0DC8 3A 19 82                     ld      A,(KBTMP)       ; yes, retrieve current row data
 194+ 0DCB CB 5F                        bit     3,A             ; check SHIFT bit line
 195+ 0DCD 20 31                        jr      NZ,FINDKEY      ; no SHIFT, continue checking
 196+ 0DCF CB DF                        set     3,A             ; yes, it's the SHIFT. So remove SHIFT bit
 197+ 0DD1 FE FF                        cp      $FF             ; after deleting the SHIFT bit, is there any other bit selected?
 198+ 0DD3 20 2B                        jr      NZ,FINDKEY      ; yes, go to check which one
 199+ 0DD5 18 17                        jr      NOKEYPRSD       ; no, go to next row
 200+ 0DD7 FE 01        TESTALT:        cp      $01             ; is it the line of ALT & CTRL?
 201+ 0DD9 3A 19 82                     ld      A,(KBTMP)       ; retrieve current row data
 202+ 0DDC 20 22                        jr      NZ,FINDKEY      ; no, continue
 203+ 0DDE CB 6F                        bit     5,A             ; yes, check ALT bit line
 204+ 0DE0 20 02                        jr      NZ,TESTCTRL     ; no ALT, continue checking
 205+ 0DE2 CB EF                        set     5,A             ; yes, it's the ALT. So remove ALT bit
 206+ 0DE4 CB 57        TESTCTRL:       bit     2,A             ; check CTRL bit line
 207+ 0DE6 20 02                        jr      NZ,ENDCTRLCK    ; no CTRL, continue checking
 208+ 0DE8 CB D7                        set     2,A             ; delete CTRL bit flag
 209+ 0DEA FE FF        ENDCTRLCK:      cp      $FF             ; after deleting the ALT & CTRL bits, is there any other bit selected?
 210+ 0DEC 20 12                        jr      NZ,FINDKEY      ; yes, go to check which one
 211+ 0DEE 7B           NOKEYPRSD:      ld      A,E             ; no key pressed, load current output port
 212+ 0DEF 0F                           rrca                    ; rotate right by 1
 213+ 0DF0 10 B6                        djnz    RPTKBDRD        ; repeat for 8 lines
 214+ 0DF2 AF                           xor     A               ; if exit from here, no key has been pressed...
 215+ 0DF3 32 1B 82                     ld      (LASTKEYPRSD),A ; ...so reset the last key cell...
 216+ 0DF6 32 1F 82                     ld      (CONTROLKEYS),A ; ...reset contro key flags...
 217+ 0DF9 32 18 82                     ld      (KBDNPT),A      ; ...no input from keyboard...
 218+ 0DFC 32 1C 82                     ld      (STATUSKEY),A   ; ...no auto-repeat...
 219+ 0DFF C9                           ret                     ; ...and leave
 220+ 0E00 1E FF        FINDKEY:        ld      E,$FF           ; counter
 221+ 0E02 1C           CHKLN:          inc     E               ; E goes from 0 to 7
 222+ 0E03 CB 3F                        srl     A               ; is the first bit reset? (we're looking for a "0", meaning grounded line)
 223+ 0E05 38 FB                        jr      C,CHKLN         ; no, check next bit
 224+ 0E07 3A 1F 82                     ld      A,(CONTROLKEYS) ; load control key flags
 225+ 0E0A 21 23 0F                     ld      HL,KBMAP        ; normal keymap
 226+ 0E0D FE 01                        cp      $01             ; SHIFT flag?
 227+ 0E0F 20 05                        jr      NZ,CHKCTRL      ; no, jump over
 228+ 0E11 21 63 0F                     ld      HL,KBMAP_SFT    ; SHIFT keymap
 229+ 0E14 18 10                        jr      LOADMAP         ; and load it
 230+ 0E16 FE 02        CHKCTRL:        cp      $02             ; CTRL flag?
 231+ 0E18 20 05                        jr      NZ,CHKALT       ; no, jump over
 232+ 0E1A 21 E3 0F                     ld      HL,KBMAP_CTRL   ; CTRL map
 233+ 0E1D 18 07                        jr      LOADMAP         ; and load it
 234+ 0E1F FE 04        CHKALT:         cp      $04             ; ALT flag?
 235+ 0E21 20 03                        jr      NZ,LOADMAP      ; no, check over
 236+ 0E23 21 A3 0F                     ld      HL,KBMAP_ALT    ; ALT map
 237+ 0E26 05           LOADMAP:        dec     B               ; decrement row # (rows go from 0 to 7)
 238+ 0E27 48                           ld      C,B             ; move B into C and...
 239+ 0E28 CB 21                        sla     C               ; ...multiply it...
 240+ 0E2A CB 21                        sla     C               ; ...by 8 to find...
 241+ 0E2C CB 21                        sla     C               ; ...the current row into the matrix
 242+ 0E2E 06 00                        ld      B,$00           ; reset B
 243+ 0E30 09                           add     HL,BC           ; find the address of the current row
 244+ 0E31 50                           ld      D,B             ; reset D
 245+ 0E32 19                           add     HL,DE           ; find the current column - now (HL) stores the pressed key
 246+ 0E33 3A 1B 82                     ld      A,(LASTKEYPRSD) ; load the last key pressed
 247+ 0E36 BE                           cp      (HL)            ; is it the same key?
 248+ 0E37 20 41                        jr      NZ,NEWKEY       ; no, it's a new key
 249+ 0E39 44 4D                        ld      BC,HL           ; store address of current keycode
 250+ 0E3B 2A BD 81                     ld      HL,(TMRCNT)     ; load current system timer
 251+ 0E3E ED 5B 1D 82                  ld      DE,(KEYTMR)     ; load auto-repeat timer
 252+ 0E42 3A 1C 82                     ld      A,(STATUSKEY)   ; yes, load current status of auto-repeat
 253+ 0E45 FE 01                        cp      $01             ; is it initial pressure?
 254+ 0E47 20 1F                        jr      NZ,CHKAUTO      ; no, jump over
 255+ 0E49 AF                           xor     A               ; clear Carry
 256+ 0E4A ED 52                        sbc     HL,DE           ; startint time - actual time
 257+ 0E4C 16 00                        ld      D,$00           ; 64 ths/s > 640 ms
 258+ 0E4E 3A B3 80                     ld      A,(KEYDEL)
 259+ 0E51 5F                           ld      E,A
 260+ 0E52 CD DE 3F                     call    CMP16           ; time elapsed is >= $40?
 261+ 0E55 DA CA 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 262+ 0E58 3E 02        SETNEWAUTO:     ld      A,$02           ; yes set status to...
 263+ 0E5A 32 1C 82                     ld      (STATUSKEY),A   ; ...auto-repeat
 264+ 0E5D 2A BD 81                     ld      HL,(TMRCNT)     ; load system timer
 265+ 0E60 22 1D 82                     ld      (KEYTMR),HL     ; store starting time
 266+ 0E63 60 69                        ld      HL,BC           ; retrieve address of current keycode
 267+ 0E65 C3 87 0E                     jp      SENDKEY         ; send key
 268+ 0E68 AF           CHKAUTO:        xor     A               ; clear Carry
 269+ 0E69 ED 52                        sbc     HL,DE           ; computer interval between initial pressure of key and current time
 270+ 0E6B 16 00                        ld      D,$00
 271+ 0E6D 3A B4 80                     ld      A,(AUTOKE)
 272+ 0E70 5F                           ld      E,A             ; auto-repeat delay into DE
 273+ 0E71 CD DE 3F                     call    CMP16           ; check if interval is greater than delay
 274+ 0E74 DA CA 0E                     jp      C,LVKBRDCHK2    ; no, so leave
 275+ 0E77 C3 58 0E                     jp      SETNEWAUTO      ; set new loop and send key
 276+ 0E7A AF           NEWKEY:         xor     A               ; set initial state...
 277+ 0E7B 3C                           inc     A               ; ...for auto-repeat...
 278+ 0E7C 32 1C 82                     ld      (STATUSKEY),A   ; ...1=pressure init
 279+ 0E7F ED 4B BD 81                  ld      BC,(TMRCNT)     ; load current system timer
 280+ 0E83 ED 43 1D 82                  ld      (KEYTMR),BC     ; set starting time
 281+ 0E87 7E           SENDKEY:        ld      A,(HL)          ; then, load key...
 282+ 0E88 32 1B 82                     ld      (LASTKEYPRSD),A ; ...store it...
 283+ 0E8B 32 1A 82                     ld      (TMPKEYBFR),A   ; ...insert it into the INKEY buffer...
 284+ 0E8E 32 DB 81                     ld      (CHR4VID),A     ; ...and store char for video
 285+ 0E91 FE 03                        cp      CTRLC           ; is it RUN/STOP?
 286+ 0E93 20 05                        jr      NZ,CNTKBCK      ; no, jump over
 287+ 0E95 CD F4 01                     call    CHARINTOBFR     ; yes, send directly to buffer and...
 288+ 0E98 18 30                        jr      LVKBRDCHK2      ; ...leave
 289+ 0E9A 01 00 08     CNTKBCK:        ld      BC,$0800        ; 8 FN keys (B), FN key number (C)
 290+ 0E9D 21 1B 0F                     ld      HL,FNKEYSORD    ; FN keys codes
 291+ 0EA0 BE           CHKFNK:         cp      (HL)            ; is it an FN key?
 292+ 0EA1 CA CF 0E                     jp      Z,PRNTFNKEY     ; yes, jump over
 293+ 0EA4 0C                           inc     C               ; next FN key
 294+ 0EA5 23                           inc     HL              ; next FN key code
 295+ 0EA6 10 F8                        djnz    CHKFNK          ; continue for 8 FN keys
 296+ 0EA8 3E 01        SNDKEYTOBFR:    ld      A,$01           ; normal key - set input flag
 297+ 0EAA 32 18 82                     ld      (KBDNPT),A      ; to keyboard
 298+ 0EAD 3A DA 81                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 299+ 0EB0 B7                           or      A               ; is the print-on-video disabled?
 300+ 0EB1 CA BA 0E                     jp      Z,PUTCHRBUF     ; yes, so send char to input buffer
 301+ 0EB4 3A D8 81                     ld      A,(CRSR_STATE)  ; check cursor state
 302+ 0EB7 B7                           or      A               ; is it 0 (cursor OFF)?
 303+ 0EB8 20 0D                        jr      NZ,PNT2VD       ; no, print on screen
 304+ 0EBA AF           PUTCHRBUF:      xor     A
 305+ 0EBB 32 18 82                     ld      (KBDNPT),A      ; if send to input buffer, set RETURN as from BASIC
 306+ 0EBE 3A 1A 82                     ld      A,(TMPKEYBFR)   ; retrieve char
 307+ 0EC1 CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 308+ 0EC4 C3 CA 0E                     jp      LVKBRDCHK2      ; ...and leave
 309+ 0EC7 CD 6E 07     PNT2VD:         call    CHAR2VID        ; send char to video
 310+ 0ECA AF           LVKBRDCHK2:     xor     A
 311+ 0ECB 32 1F 82                     ld      (CONTROLKEYS),A ; reset control key flags
 312+ 0ECE C9           LVKBRDCHK:      ret                     ; return to caller: the current key code is into TMPKEYBFR
 313+ 0ECF                              ; manage FN keys
 314+ 0ECF 57           PRNTFNKEY:      ld      D,A             ; copy A into D
 315+ 0ED0 2A AF 80                     ld      HL,(LINEAT)     ; Get current line number
 316+ 0ED3 23                           inc     HL              ; -1 means direct statement
 317+ 0ED4 7C                           ld      A,H
 318+ 0ED5 B5                           or      L
 319+ 0ED6 7A                           ld      A,D             ; retrieve char
 320+ 0ED7 20 CF                        jr      NZ,SNDKEYTOBFR  ; indirect mode - just send FN key code to buffer
 321+ 0ED9 79                           ld      A,C             ; direct mode, so print text - first, get FN key number
 322+ 0EDA 87                           add     A,A
 323+ 0EDB 87                           add     A,A
 324+ 0EDC 87                           add     A,A
 325+ 0EDD 87                           add     A,A             ; FN key number * 16
 326+ 0EDE 4F                           ld      C,A             ; move it into C
 327+ 0EDF 06 00                        ld      B,$00           ; reset B, to get offset
 328+ 0EE1 21 B5 80                     ld      HL,FNKEYS       ; load address of FN keys texts
 329+ 0EE4 09                           add     HL,BC           ; get correct text address
 330+ 0EE5 06 10                        ld      B,$10           ; 16 chars
 331+ 0EE7 7E           LDFNKEYCHR:     ld      A,(HL)          ; load char
 332+ 0EE8 A7                           and     A               ; null char?
 333+ 0EE9 CA CA 0E                     jp      Z,LVKBRDCHK2    ; yes, so leave
 334+ 0EEC 57                           ld      D,A             ; pass char into D
 335+ 0EED 3A DA 81                     ld      A,(PRNTVIDEO)   ; load status of print-on-video
 336+ 0EF0 B7                           or      A               ; is the print-on-video disabled?
 337+ 0EF1 CA 01 0F                     jp      Z,PUTCHRBUF1    ; yes, so send char to input buffer
 338+ 0EF4 3A D8 81                     ld      A,(CRSR_STATE)  ; check cursor state
 339+ 0EF7 B7                           or      A               ; is it 0 (cursor OFF)?
 340+ 0EF8 C4 0E 0F                     call    NZ,PRNTFNK      ; no, print on screen
 341+ 0EFB 23           CNTFNK:         inc     HL              ; next char
 342+ 0EFC 10 E9                        djnz    LDFNKEYCHR      ; repeat for max. 16 chars
 343+ 0EFE C3 CA 0E                     jp      LVKBRDCHK2      ; leave
 344+ 0F01 AF           PUTCHRBUF1:     xor     A               ; if send to input buffer,...
 345+ 0F02 32 18 82                     ld      (KBDNPT),A      ; ...set input as from BASIC
 346+ 0F05 7A                           ld      A,D             ; retrieve char
 347+ 0F06 E5                           push    HL              ; store HL
 348+ 0F07 CD F4 01                     call    CHARINTOBFR     ; cursor off, so send char to buffer...
 349+ 0F0A E1                           pop     HL              ; retrieve HL
 350+ 0F0B C3 FB 0E                     jp      CNTFNK          ; repeat
 351+ 0F0E 7A           PRNTFNK:        ld      A,D             ; recover char
 352+ 0F0F 32 DB 81                     ld      (CHR4VID),A     ; store char for printing
 353+ 0F12 3E 01                        ld      A,$01           ; normal key - set input flag
 354+ 0F14 32 18 82                     ld      (KBDNPT),A      ; to keyboard
 355+ 0F17 CD 6E 07                     call    CHAR2VID        ; print on screen
 356+ 0F1A C9                           ret                     ; return to caller
 357+ 0F1B
 358+ 0F1B
 359+ 0F1B              ;-----------------------------------------------------------------------
 360+ 0F1B 01 02 04 05  FNKEYSORD:      defb 1,2,4,5,6,22,23,24                 ; order of FN Keys
 360+ 0F1F 06 16 17 18
 361+ 0F23              ;-----------------------------------------------------------------------
 362+ 0F23              ; key codes
 363+ 0F23 31 19 0E 03  KBMAP:          defb '1',25,14,3,' ',16,'q','2'         ; 25=HOME  14=CTRL  3=RUN/STOP 16=C=
 363+ 0F27 20 10 71 32
 364+ 0F2B 33 77 61 14                  defb '3','w','a',20,'z','s','e','4'     ; 20=SHIFT
 364+ 0F2F 7A 73 65 34
 365+ 0F33 35 72 64 78                  defb '5','r','d','x','c','f','t','6'
 365+ 0F37 63 66 74 36
 366+ 0F3B 37 79 67 76                  defb '7','y','g','v','b','h','u','8'
 366+ 0F3F 62 68 75 38
 367+ 0F43 39 69 6A 6E                  defb '9','i','j','n','m','k','o','0'
 367+ 0F47 6D 6B 6F 30
 368+ 0F4B 1F 70 6C 2C                  defb 31,'p','l',',','.',':','-',30      ; 31=CURSOR DOWN  30=CURSOR UP
 368+ 0F4F 2E 3A 2D 1E
 369+ 0F53 1C 2A 3B 2F                  defb 28,'*',';','/',27,'=','+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 369+ 0F57 1B 3D 2B 1D
 370+ 0F5B 08 0D FC 40                  defb 8,13,252,'@',1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 370+ 0F5F 01 02 04 18
 371+ 0F63
 372+ 0F63              ; shifted codes - not all the keys have the shifted version
 373+ 0F63 21 0C 0E 03  KBMAP_SFT:      defb '!',12,14,3,' ',16,'Q',34          ; 12=CLEAR  14=CTRL  3=RUN/STOP 16=C=   34="
 373+ 0F67 20 10 51 22
 374+ 0F6B 23 57 41 14                  defb '#','W','A',20,'Z','S','E','$'     ; 20=SHIFT
 374+ 0F6F 5A 53 45 24
 375+ 0F73 25 52 44 58                  defb '%','R','D','X','C','F','T','&'
 375+ 0F77 43 46 54 26
 376+ 0F7B 27 59 47 56                  defb 39,'Y','G','V','B','H','U','('     ; 39='
 376+ 0F7F 42 48 55 28
 377+ 0F83 29 49 4A 4E                  defb ')','I','J','N','M','K','O',94     ; 94=^
 377+ 0F87 4D 4B 4F 5E
 378+ 0F8B 1F 50 4C 3C                  defb 31,'P','L','<','>','[','_',30      ; 31=CURSOR DOWN  30=CURSOR UP
 378+ 0F8F 3E 5B 5F 1E
 379+ 0F93 1C 2A 5D 3F                  defb 28,'*',']','?',27,198,'+',29       ; 28=CURSOR LEFT  27=ESCAPE  29=CURSOR RIGHT
 379+ 0F97 1B C6 2B 1D
 380+ 0F9B 1A 0D D3 40                  defb 26,13,211,'@',5,6,22,23            ; 26=INSERT, 211=â¬  5=F4  6=F5  22=F6  23=F7
 380+ 0F9F 05 06 16 17
 381+ 0FA3
 382+ 0FA3              ; ALT (C=) codes - not all the keys have the alt-ed version
 383+ 0FA3 31 0C 0E 03  KBMAP_ALT:      defb '1',12,14,3,' ',16,222,196         ; 12=CLEAR  14=CTRL  3=RUN/STOP  16=C=  34="
 383+ 0FA7 20 10 DE C4
 384+ 0FAB 33 DD 85 14                  defb '3',221,133,20,131,130,165,'4'     ; 20=SHIFT
 384+ 0FAF 83 82 A5 34
 385+ 0FB3 35 A2 A6 84                  defb '5',162,166,132,157,163,168,'6'
 385+ 0FB7 9D A3 A8 36
 386+ 0FBB 37 AB A9 A1                  defb '7',171,169,161,158,172,213,'8'    ;
 386+ 0FBF 9E AC D5 38
 387+ 0FC3 39 D6 D8 9F                  defb '9',214,216,159,160,215,135,195    ;
 387+ 0FC7 A0 D7 87 C3
 388+ 0FCB 1F 88 8A C1                  defb 31,136,138,193,192,123,144,30      ; 31=CURSOR DOWN  123={  30=CURSOR UP
 388+ 0FCF C0 7B 90 1E
 389+ 0FD3 1C 8F 7D FE                  defb 28,143,125,254,27,209,148,29       ; 28=CURSOR LEFT  125=}  27=ESCAPE  29=CURSOR RIGHT
 389+ 0FD7 1B D1 94 1D
 390+ 0FDB 08 0D E0 89                  defb 8,13,224,137,5,6,22,23             ; 8=DEL(backspace)  13=RETURN  252=Â£  5=F4  6=F5  22=F6  23=F7
 390+ 0FDF 05 06 16 17
 391+ 0FE3
 392+ 0FE3              ; CTRL codes - not all the keys have the control-ed version
 393+ 0FE3 31 19 0E 03  KBMAP_CTRL:     defb '1',25,14,3,' ',16,154,'2'         ; 25=HOME  14=CTRL  3=RUN/STOP  16=C=
 393+ 0FE7 20 10 9A 32
 394+ 0FEB 33 9C 95 14                  defb '3',156,149,20,152,150,153,'4'     ; 20=SHIFT
 394+ 0FEF 98 96 99 34
 395+ 0FF3 35 9B B0 97                  defb '5',155,176,151,177,175,165,'6'
 395+ 0FF7 B1 AF A5 36
 396+ 0FFB 37 A6 A8 B2                  defb '7',166,168,178,179,169,167,'8'
 396+ 0FFF B3 A9 A7 38
 397+ 1003 39 B8 AA AC                  defb '9',184,170,172,171,181,164,'0'
 397+ 1007 AB B5 A4 30
 398+ 100B 1F A3 AD 2C                  defb 31,163,173,',','.',':',186,30      ; 31=CURSOR DOWN  30=CURSOR UP
 398+ 100F 2E 3A BA 1E
 399+ 1013 1C E1 3B 2F                  defb 28,225,';','/',27,212,185,29       ; 28=CURSOR LEFT  27=ESCAPE  212=Ï  29=CURSOR RIGHT
 399+ 1017 1B D4 B9 1D
 400+ 101B 08 0D BD A2                  defb 8,13,189,162,1,2,4,24              ; 8=DEL(backspace)  13=RETURN  252=Â£  1=F1  2=F2  4=F3  24=HELP
 400+ 101F 01 02 04 18
# file closed: ../include/psg/psg-1.1.asm
  76  1023
  77  1023              ; include the latest version of the LM80C BASIC interpreter
  78  1023                  INCLUDE "../include/basic/basic-1.03.asm"
# file opened: ../include/basic/basic-1.03.asm
   1+ 1023              ; ------------------------------------------------------------------------------
   2+ 1023              ; LM80C BASIC (32K/64K) - R3.17
   3+ 1023              ; ------------------------------------------------------------------------------
   4+ 1023              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 1023              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 1023              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 1023              ; kind of warranty: you can use them at your own risk.
   8+ 1023              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 1023              ; maintain the copyright notices, include this advice and the note to the
  10+ 1023              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 1023              ; redistribuite them.
  12+ 1023              ; https://www.leonardomiliani.com
  13+ 1023              ;
  14+ 1023              ; Please support me by visiting the following links:
  15+ 1023              ; Main project page: https://www.leonardomiliani.com
  16+ 1023              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 1023              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 1023              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 1023              ; ------------------------------------------------------------------------------
  20+ 1023              ; LM80C BASIC 64K - originally based on the following NASCOM BASIC versions:
  21+ 1023              ; 4.7  - original version by NASCOM/MICROSOFT
  22+ 1023              ; 4.7b - modified version by Grant Searle (additional commands & functions)
  23+ 1023
  24+ 1023
  25+ 1023              ;------------------------------------------------------------------------------
  26+ 1023              ;  L M 8 0 C   B A S I C
  27+ 1023              ;------------------------------------------------------------------------------
  28+ 1023
  29+ 1023              ; GENERAL EQUATES
  30+ 1023
  31+ 1023              NLLCR           equ     $00             ; null char (used as space/empty char in video prints)
  32+ 1023              CTRLC           equ     $03             ; Control "C"
  33+ 1023              CTRLG           equ     $07             ; Control "G"
  34+ 1023              BKSP            equ     $08             ; Back space
  35+ 1023              LF              equ     $0A             ; Line feed
  36+ 1023              CS              equ     $0C             ; Clear screen
  37+ 1023              CR              equ     $0D             ; Carriage return
  38+ 1023              CTRLO           equ     $0F             ; Control "O"
  39+ 1023              CTRLQ           equ     $11             ; Control "Q"
  40+ 1023              CTRLR           equ     $12             ; Control "R"
  41+ 1023              CTRLS           equ     $13             ; Control "S"
  42+ 1023              CTRLU           equ     $15             ; Control "U"
  43+ 1023              HOME            equ     $19             ; Home (cursor at 0,0)
  44+ 1023              ESC             equ     $1B             ; Escape
  45+ 1023              SPC             equ     $20             ; Space
  46+ 1023              DEL             equ     $7F             ; Delete
  47+ 1023              INSRT           equ     $1A             ; Insert Key
  48+ 1023              ; cursor ASCII codes
  49+ 1023              CRSLFT          equ     $1C             ; cursor left
  50+ 1023              CRSRGT          equ     $1D             ; cursor right
  51+ 1023              CRSUP           equ     $1E             ; cursor up
  52+ 1023              CRSDN           equ     $1F             ; cursor down
  53+ 1023
  54+ 1023
  55+ 1023              ;-------------------------------------------------------------------------
  56+ 1023              ; BASIC ERROR MESSAGES
  57+ 1023              ; the interpreter looks for a single-byte code in the following list,
  58+ 1023              ; then loads the corresponding memory pointer in "ERRTBL" table to
  59+ 1023              ; find where to retrieve the message text in "ERRORS"
  60+ 1023
  61+ 1023              ; BASIC ERROR CODE VALUES
  62+ 1023              ; These values act as an offset to point to the error message into the error table
  63+ 1023              ; must be incremented by 2 because they point to a word address jump
  64+ 1023              NF              equ     $00     ; NEXT without FOR
  65+ 1023              SN              equ     $02     ; Syntax error
  66+ 1023              RG              equ     $04     ; RETURN without GOSUB
  67+ 1023              OD              equ     $06     ; Out of DATA
  68+ 1023              FC              equ     $08     ; Function call error
  69+ 1023              OV              equ     $0A     ; Overflow
  70+ 1023              OM              equ     $0C     ; Out of memory
  71+ 1023              UL              equ     $0E     ; Undefined line number
  72+ 1023              BS              equ     $10     ; Bad subscript
  73+ 1023              DD              equ     $12     ; Re-Dimensioned array
  74+ 1023              DZ              equ     $14     ; Division by zero (/0)
  75+ 1023              ID              equ     $16     ; Illegal direct
  76+ 1023              TM              equ     $18     ; Type mis-match
  77+ 1023              OS              equ     $1A     ; Out of string space
  78+ 1023              LS              equ     $1C     ; String too long
  79+ 1023              ST              equ     $1E     ; String formula too complex
  80+ 1023              CN              equ     $20     ; Can't continue
  81+ 1023              UF              equ     $22     ; Undefined FN function
  82+ 1023              MO              equ     $24     ; Missing operand
  83+ 1023              HX              equ     $26     ; HEX error
  84+ 1023              BN              equ     $28     ; BIN error
  85+ 1023              GM              equ     $2A     ; No Graphics Mode
  86+ 1023              SC              equ     $2C     ; Serial configuration
  87+ 1023              SA              equ     $2E     ; Serial port already open
  88+ 1023              SO              equ     $30     ; Serial buffer overrun
  89+ 1023              HP              equ     $32     ; HELP call
  90+ 1023
  91+ 1023              ; BASIC ERROR POINTER TABLE
  92+ 1023              ERRTBL: equ $
  93+ 1023 57 10        NFPTR:  defw    NFMSG
  94+ 1025 68 10        SNPTR:  defw    SNMSG
  95+ 1027 6F 10        RGPTR:  defw    RGMSG
  96+ 1029 84 10        ODPTR:  defw    ODMSG
  97+ 102B 90 10        FCPTR:  defw    FCMSG
  98+ 102D A6 10        OVPTR:  defw    OVMSG
  99+ 102F AF 10        OMPTR:  defw    OMMSG
 100+ 1031 BD 10        ULPTR:  defw    ULMSG
 101+ 1033 CC 10        BSPTR:  defw    BSMSG
 102+ 1035 DA 10        DDPTR:  defw    DDMSG
 103+ 1037 EF 10        DZPTR:  defw    DZMSG
 104+ 1039 00 11        IDPTR:  defw    IDMSG
 105+ 103B 0F 11        TMPTR:  defw    TMMSG
 106+ 103D 1E 11        OSPTR:  defw    OSMSG
 107+ 103F 32 11        LSPTR:  defw    LSMSG
 108+ 1041 42 11        STPTR:  defw    STMSG
 109+ 1043 5D 11        CNPTR:  defw    CNMSG
 110+ 1045 6C 11        UFPTR:  defw    UFMSG
 111+ 1047 82 11        MOPTR:  defw    MOMSG
 112+ 1049 92 11        HXPTR:  defw    HXMSG
 113+ 104B 9D 11        BNPTR:  defw    BNMSG
 114+ 104D A8 11        GMPRT:  defw    GMMSG
 115+ 104F B9 11        SCPTR:  defw    SCMSG
 116+ 1051 CE 11        SAPTR:  defw    SAMSG
 117+ 1053 E7 11        SOPTR:  defw    SOMSG
 118+ 1055 FD 11        HPPTR:  defw    HPMSG
 119+ 1057
 120+ 1057              ; BASIC ERROR MESSAGE LIST
 121+ 1057              ERRORS  equ $
 122+ 1057 4E 45 58 54  NFMSG:  defb    "NEXT Without FOR",0
 122+ 105B 20 57 69 74
 122+ 105F 68 6F 75 74
 122+ 1063 20 46 4F 52
 122+ 1067 00
 123+ 1068 53 79 6E 74  SNMSG:  defb    "Syntax",0
 123+ 106C 61 78 00
 124+ 106F 52 45 54 55  RGMSG:  defb    "RETURN without GOSUB",0
 124+ 1073 52 4E 20 77
 124+ 1077 69 74 68 6F
 124+ 107B 75 74 20 47
 124+ 107F 4F 53 55 42
 124+ 1083 00
 125+ 1084 4F 75 74 20  ODMSG:  defb    "Out of DATA",0
 125+ 1088 6F 66 20 44
 125+ 108C 41 54 41 00
 126+ 1090 49 6C 6C 65  FCMSG:  defb    "Illegal Function Call",0
 126+ 1094 67 61 6C 20
 126+ 1098 46 75 6E 63
 126+ 109C 74 69 6F 6E
 126+ 10A0 20 43 61 6C
 126+ 10A4 6C 00
 127+ 10A6 4F 76 65 72  OVMSG:  defb    "Overflow",0
 127+ 10AA 66 6C 6F 77
 127+ 10AE 00
 128+ 10AF 4F 75 74 20  OMMSG:  defb    "Out of Memory",0
 128+ 10B3 6F 66 20 4D
 128+ 10B7 65 6D 6F 72
 128+ 10BB 79 00
 129+ 10BD 55 6E 64 65  ULMSG:  defb    "Undefined Line",0
 129+ 10C1 66 69 6E 65
 129+ 10C5 64 20 4C 69
 129+ 10C9 6E 65 00
 130+ 10CC 42 61 64 20  BSMSG:  defb    "Bad Subscript",0
 130+ 10D0 53 75 62 73
 130+ 10D4 63 72 69 70
 130+ 10D8 74 00
 131+ 10DA 52 65 2D 44  DDMSG:  defb    "Re-Dimensioned Array",0
 131+ 10DE 69 6D 65 6E
 131+ 10E2 73 69 6F 6E
 131+ 10E6 65 64 20 41
 131+ 10EA 72 72 61 79
 131+ 10EE 00
 132+ 10EF 44 69 76 69  DZMSG:  defb    "Division by Zero",0
 132+ 10F3 73 69 6F 6E
 132+ 10F7 20 62 79 20
 132+ 10FB 5A 65 72 6F
 132+ 10FF 00
 133+ 1100 49 6C 6C 65  IDMSG:  defb    "Illegal Direct",0
 133+ 1104 67 61 6C 20
 133+ 1108 44 69 72 65
 133+ 110C 63 74 00
 134+ 110F 54 79 70 65  TMMSG:  defb    "Type Mis-match",0
 134+ 1113 20 4D 69 73
 134+ 1117 2D 6D 61 74
 134+ 111B 63 68 00
 135+ 111E 4F 75 74 20  OSMSG:  defb    "Out of String Space",0
 135+ 1122 6F 66 20 53
 135+ 1126 74 72 69 6E
 135+ 112A 67 20 53 70
 135+ 112E 61 63 65 00
 136+ 1132 53 74 72 69  LSMSG:  defb    "String Too Long",0
 136+ 1136 6E 67 20 54
 136+ 113A 6F 6F 20 4C
 136+ 113E 6F 6E 67 00
 137+ 1142 53 74 72 69  STMSG:  defb    "String Formula Too Complex",0
 137+ 1146 6E 67 20 46
 137+ 114A 6F 72 6D 75
 137+ 114E 6C 61 20 54
 137+ 1152 6F 6F 20 43
 137+ 1156 6F 6D 70 6C
 137+ 115A 65 78 00
 138+ 115D 43 61 6E 27  CNMSG:  defb    "Can't Continue",0
 138+ 1161 74 20 43 6F
 138+ 1165 6E 74 69 6E
 138+ 1169 75 65 00
 139+ 116C 55 6E 64 65  UFMSG:  defb    "Undefined FN Function",0
 139+ 1170 66 69 6E 65
 139+ 1174 64 20 46 4E
 139+ 1178 20 46 75 6E
 139+ 117C 63 74 69 6F
 139+ 1180 6E 00
 140+ 1182 4D 69 73 73  MOMSG:  defb    "Missing Operand",0
 140+ 1186 69 6E 67 20
 140+ 118A 4F 70 65 72
 140+ 118E 61 6E 64 00
 141+ 1192 48 45 58 20  HXMSG:  defb    "HEX Format",0
 141+ 1196 46 6F 72 6D
 141+ 119A 61 74 00
 142+ 119D 42 49 4E 20  BNMSG:  defb    "BIN Format",0
 142+ 11A1 46 6F 72 6D
 142+ 11A5 61 74 00
 143+ 11A8 4E 6F 20 47  GMMSG:  defb    "No Graphics Mode",0
 143+ 11AC 72 61 70 68
 143+ 11B0 69 63 73 20
 143+ 11B4 4D 6F 64 65
 143+ 11B8 00
 144+ 11B9 53 65 72 69  SCMSG:  defb    "Serial Configuration",0
 144+ 11BD 61 6C 20 43
 144+ 11C1 6F 6E 66 69
 144+ 11C5 67 75 72 61
 144+ 11C9 74 69 6F 6E
 144+ 11CD 00
 145+ 11CE 53 65 72 69  SAMSG:  defb    "Serial Port Already Open",0
 145+ 11D2 61 6C 20 50
 145+ 11D6 6F 72 74 20
 145+ 11DA 41 6C 72 65
 145+ 11DE 61 64 79 20
 145+ 11E2 4F 70 65 6E
 145+ 11E6 00
 146+ 11E7 53 65 72 69  SOMSG:  defb    "Serial Buffer Overrun",0
 146+ 11EB 61 6C 20 42
 146+ 11EF 75 66 66 65
 146+ 11F3 72 20 4F 76
 146+ 11F7 65 72 72 75
 146+ 11FB 6E 00
 147+ 11FD 48 45 4C 50  HPMSG:  defb    "HELP Call",0
 147+ 1201 20 43 61 6C
 147+ 1205 6C 00
 148+ 1207
 149+ 1207
 150+ 1207              ;-----------------------------------------------------------------------------
 151+ 1207              ; STARTING POINTS FOR BASIC BOOT
 152+ 1207              ; COLD: reset every memory pointer, acting as a power-up boot
 153+ 1207              ; WARM: preserve program in memory, keeping every current pointer
 154+ 1207
 155+ 1207 C3 0D 12     COLD:   jp      STARTB          ; Jump for cold start
 156+ 120A C3 BB 12     WARM:   jp      WARMST          ; Jump for warm start
 157+ 120D
 158+ 120D C3 14 12     STARTB: jp      CSTART          ; Jump to initialise
 159+ 1210 C8 1C                defw    DEINT           ; Get integer -32768 to 32767
 160+ 1212 85 24                defw    ABPASS          ; Return integer in AB
 161+ 1214 21 5E 80     CSTART: ld      HL,WRKSPC       ; Start of workspace RAM
 162+ 1217 F9                   ld      SP,HL           ; Set up a temporary stack
 163+ 1218 C3 C9 3F             jp      INITST          ; Go to initialise
 164+ 121B
 165+ 121B 21 88 15     INIT:   ld      HL,INITAB       ; Initialise workspace
 166+ 121E 01 DC 00             ld      BC,INITBE-INITAB+3; Bytes to copy
 167+ 1221 11 5E 80             ld      DE,WRKSPC       ; Into workspace RAM
 168+ 1224 ED B0                ldir                    ; Copy data
 169+ 1226 EB                   ex      DE,HL           ; Copy DE into HL
 170+ 1227 F9                   ld      SP,HL           ; Temporary stack
 171+ 1228 CD 3B 18             call    CLREG           ; Clear registers and stack
 172+ 122B CD DF 1E             call    PRNTCRLF        ; Output CRLF
 173+ 122E 32 91 81             ld      (BUFFER+88+1),A ; Mark end of buffer
 174+ 1231 32 47 82             ld      (PROGST),A      ; Initialise program area
 175+ 1234 18 13                jr      MNOASK          ; usually, don't ask for memory top (only when there are errors)
 176+ 1236 21 22 13     MSIZE:  ld      HL,MEMMSG       ; Point to message
 177+ 1239 CD A3 25             call    PRS             ; Output "Memory size"
 178+ 123C CD 58 18             call    PROMPT          ; Get input with '?'
 179+ 123F CD 39 09             call    CURSOR_ON       ; enable cursor
 180+ 1242 CD 12 1C             call    GETCHR          ; Get next character
 181+ 1245 B7                   or      A               ; Set flags
 182+ 1246 C2 5E 12             jp      NZ,TSTMEM       ; If number - Test if RAM there
 183+ 1249 21 AB 82     MNOASK: ld      HL,STLOOK       ; Point to start of RAM
 184+ 124C 23           MLOOP:  inc     HL              ; Next byte
 185+ 124D 7C                   ld      A,H             ; Above address FFFF ?
 186+ 124E B5                   or      L
 187+ 124F CA 70 12             jp      Z,SETTOP        ; Yes - 64K RAM
 188+ 1252 7E                   ld      A,(HL)          ; Get contents
 189+ 1253 47                   ld      B,A             ; Save it
 190+ 1254 2F                   cpl                     ; Flip all bits
 191+ 1255 77                   ld      (HL),A          ; Put it back
 192+ 1256 BE                   cp      (HL)            ; RAM there if same
 193+ 1257 70                   ld      (HL),B          ; Restore old contents
 194+ 1258 CA 4C 12             jp      Z,MLOOP         ; If RAM - test next byte
 195+ 125B C3 70 12             jp      SETTOP          ; Top of RAM found
 196+ 125E
 197+ 125E CD E2 1C     TSTMEM: call    ATOH            ; Get high memory into DE
 198+ 1261 B7                   or      A               ; Set flags on last byte
 199+ 1262 C2 EF 16             jp      NZ,SNERR        ; ?SN Error if bad character
 200+ 1265 EB                   ex      DE,HL           ; Address into HL
 201+ 1266 2B                   dec     HL              ; Back one byte
 202+ 1267 3E D9                ld      A,%11011001     ; Test byte
 203+ 1269 46                   ld      B,(HL)          ; Get old contents
 204+ 126A 77                   ld      (HL),A          ; Load test byte
 205+ 126B BE                   cp      (HL)            ; RAM there if same
 206+ 126C 70                   ld      (HL),B          ; Restore old contents
 207+ 126D C2 36 12             jp      NZ,MSIZE        ; Ask again if no RAM
 208+ 1270
 209+ 1270 CD 4E 09     SETTOP: call    CURSOR_OFF      ; disable cursor
 210+ 1273 2B                   dec     HL              ; Back one byte
 211+ 1274 11 AA 82             ld      DE,STLOOK-1     ; See if enough RAM
 212+ 1277 CD CB 19             call    CPDEHL          ; Compare DE with HL
 213+ 127A DA 36 12             jp      C,MSIZE         ; Ask again if not enough RAM
 214+ 127D 3A 23 82             ld      A,(DOS_EN)      ; read if the user enabled/disabled DOS while booting
 215+ 1280 1F                   rra                     ; is DOS disabled?
 216+ 1281 30 04                jr      NC,NODOS        ; yes, so jump over
 217+ 1283 11 00 FE             ld      DE,0-512        ; no, so reserve 512 bytes on top of RAM...
 218+ 1286 19                   add     HL,DE           ; ...for I/O buffer
 219+ 1287 11 9C FF     NODOS:  ld      DE,0-100        ; 100 Bytes string space
 220+ 128A 22 96 81             ld      (LSTRAM),HL     ; Save last available RAM
 221+ 128D 19                   add     HL,DE           ; Allocate string space
 222+ 128E 22 AD 80             ld      (STRSPC),HL     ; Save string space
 223+ 1291 CD 16 18             call    CLRPTR          ; Clear program area
 224+ 1294 2A AD 80             ld      HL,(STRSPC)     ; Get end of memory
 225+ 1297 11 EF FF             ld      DE,0-17         ; Offset for free bytes
 226+ 129A 19                   add     HL,DE           ; Adjust HL
 227+ 129B 11 47 82             ld      DE,PROGST       ; Start of program text
 228+ 129E 7D                   ld      A,L             ; Get LSB
 229+ 129F 93                   sub     E               ; Adjust it
 230+ 12A0 6F                   ld      L,A             ; Re-save
 231+ 12A1 7C                   ld      A,H             ; Get MSB
 232+ 12A2 9A                   sbc     A,D             ; Adjust it
 233+ 12A3 67                   ld      H,A             ; Re-save
 234+ 12A4 E5                   push    HL              ; Save bytes free
 235+ 12A5 21 E1 12             ld      HL,SIGNON       ; Sign-on message
 236+ 12A8 CD A3 25             call    PRS             ; Output string
 237+ 12AB 21 CA 12             ld      HL,BLNSPC       ; Empty space
 238+ 12AE CD A3 25             call    PRS             ; Output string
 239+ 12B1 E1                   pop     HL              ; Get bytes free back
 240+ 12B2 CD 42 30             call    PRNTHL          ; Output amount of free memory
 241+ 12B5 21 D3 12             ld      HL,BFREE        ; " Bytes free" message
 242+ 12B8 CD A3 25             call    PRS             ; Output string
 243+ 12BB
 244+ 12BB 31 3D 81     WARMST: ld      SP,STACK        ; Temporary stack
 245+ 12BE CD 3B 18     BRKRET: call    CLREG           ; Clear registers and stack
 246+ 12C1 CD 60 3D             call    RESFN           ; reset FN keys and auto-repeat
 247+ 12C4 CD 39 09             call    CURSOR_ON       ; enable cursor
 248+ 12C7 C3 49 17             jp      PRNTOK          ; Go to get command line
 249+ 12CA
 250+ 12CA 20 20 20 20  BLNSPC: defb    "        ",0    ; 8 empty cells to align the "XXXX Bytes free" message
 250+ 12CE 20 20 20 20
 250+ 12D2 00
 251+ 12D3 20 42 79 74  BFREE:  defb    " Bytes free",CR,CR,0
 251+ 12D7 65 73 20 66
 251+ 12DB 72 65 65 0D
 251+ 12DF 0D 00
 252+ 12E1
 253+ 12E1 4C 4D 38 30  SIGNON: defb    "LM80C BASIC 3.17 ",251,"2021 L.Miliani"
 253+ 12E5 43 20 42 41
 253+ 12E9 53 49 43 20
 253+ 12ED 33 2E 31 37
 253+ 12F1 20 FB 32 30
 253+ 12F5 32 31 20 4C
 253+ 12F9 2E 4D 69 6C
 253+ 12FD 69 61 6E 69
 254+ 1301 20 5A 38 30          defb    " Z80 BASIC 4.7  ",251,"1978 Microsoft",CR,0
 254+ 1305 20 42 41 53
 254+ 1309 49 43 20 34
 254+ 130D 2E 37 20 20
 254+ 1311 FB 31 39 37
 254+ 1315 38 20 4D 69
 254+ 1319 63 72 6F 73
 254+ 131D 6F 66 74 0D
 254+ 1321 00
 255+ 1322
 256+ 1322 4D 65 6D 6F  MEMMSG: defb    "Memory top",0
 256+ 1326 72 79 20 74
 256+ 132A 6F 70 00
 257+ 132D
 258+ 132D              ; The following list reports all the functions supported by the interpreter.
 259+ 132D              ; To add a custom function, the user must first insert the reserved word here,
 260+ 132D              ; then into the list of the reserved words below, and finally must increment the
 261+ 132D              ; ZSGN token value and all the following ones after ZSGN by 1 for every added
 262+ 132D              ; function.
 263+ 132D
 264+ 132D              ; FUNCTION ADDRESS TABLE (this is a sort of offset table)
 265+ 132D              ; this list must be coherent with the tokens' functions list. This means that every
 266+ 132D              ; entry here must have the corresponding entry in the tokens list.
 267+ 132D B7 2E        FNCTAB: defw    SGN
 268+ 132F 4D 24                defw    TMR         ; added by Leonardo Miliani
 269+ 1331 7B 2F                defw    INT
 270+ 1333 CD 2E                defw    ABS_        ; _ necessary for assembler warning
 271+ 1335 64 80                defw    USR
 272+ 1337 63 24                defw    FRE
 273+ 1339 DE 28                defw    INP
 274+ 133B 91 24                defw    POS
 275+ 133D 41 31                defw    SQR
 276+ 133F 20 32                defw    RND
 277+ 1341 0B 2D                defw    LOG
 278+ 1343 8F 31                defw    EXP
 279+ 1345 95 32                defw    COS
 280+ 1347 9B 32                defw    SIN
 281+ 1349 FC 32                defw    TAN
 282+ 134B 11 33                defw    ATN
 283+ 134D BA 29                defw    PEEK
 284+ 134F 7C 33                defw    DEEK
 285+ 1351 C1 29                defw    VPEEK       ; added by Leonardo Miliani
 286+ 1353 90 2B                defw    VSTAT       ; added by Leonardo Miliani
 287+ 1355 9B 2B                defw    SSTAT       ; added by Leonardo Miliani
 288+ 1357 AF 2B                defw    INKEY       ; added by Leonardo Miliani
 289+ 1359 D5 36                defw    POINT       ; added by Leonardo Miliani
 290+ 135B 75 27                defw    INSTR       ; added by Leonardo Miliani
 291+ 135D 15 27                defw    LEN
 292+ 135F 2D 25                defw    STR
 293+ 1361 A5 28                defw    VAL
 294+ 1363 24 27                defw    ASC
 295+ 1365 35 27                defw    CHR
 296+ 1367 C4 3E                defw    HEX         ; added by Grant Searle
 297+ 1369 55 3F                defw    BIN         ; added by Grant Searle
 298+ 136B 45 27                defw    LEFT
 299+ 136D 6B 28                defw    RIGHT
 300+ 136F 75 28                defw    MID
 301+ 1371
 302+ 1371              ; RESERVED WORD LIST
 303+ 1371              ; Here are all the reserved words used by the interpreter
 304+ 1371              ; To add custom functions/commands, the user must insert the keyword
 305+ 1371              ; in this list, following the schematic
 306+ 1371 C5 4E 44     WORDS:  defb    'E'+$80,"ND"            ; from here the list contains the COMMANDS
 307+ 1374 C6 4F 52             defb    'F'+$80,"OR"
 308+ 1377 CE 45 58 54          defb    'N'+$80,"EXT"
 309+ 137B C4 41 54 41          defb    'D'+$80,"ATA"
 310+ 137F C9 4E 50 55          defb    'I'+$80,"NPUT"
 310+ 1383 54
 311+ 1384 C4 49 4D             defb    'D'+$80,"IM"
 312+ 1387 D2 45 41 44          defb    'R'+$80,"EAD"
 313+ 138B CC 45 54             defb    'L'+$80,"ET"
 314+ 138E C7 4F 54 4F          defb    'G'+$80,"OTO"
 315+ 1392 D2 55 4E             defb    'R'+$80,"UN"
 316+ 1395 C9 46                defb    'I'+$80,"F"
 317+ 1397 D2 45 53 54          defb    'R'+$80,"ESTORE"
 317+ 139B 4F 52 45
 318+ 139E C7 4F 53 55          defb    'G'+$80,"OSUB"
 318+ 13A2 42
 319+ 13A3 D2 45 54 55          defb    'R'+$80,"ETURN"
 319+ 13A7 52 4E
 320+ 13A9 D2 45 4D             defb    'R'+$80,"EM"            ; original REM
 321+ 13AC D3 54 4F 50          defb    'S'+$80,"TOP"
 322+ 13B0 CF 55 54             defb    'O'+$80,"UT"
 323+ 13B3 CF 4E                defb    'O'+$80,"N"
 324+ 13B5 C6 49 4C 45          defb    'F'+$80,"ILES"
 324+ 13B9 53
 325+ 13BA C5 52 41 53          defb    'E'+$80,"RASE"          ; added by Leonardo Miliani
 325+ 13BE 45
 326+ 13BF D7 41 49 54          defb    'W'+$80,"AIT"
 327+ 13C3 C4 45 46             defb    'D'+$80,"EF"
 328+ 13C6 D0 4F 4B 45          defb    'P'+$80,"OKE"
 329+ 13CA C4 4F 4B 45          defb    'D'+$80,"OKE"
 330+ 13CE D6 50 4F 4B          defb    'V'+$80,"POKE"          ; added by Leonardo Miliani
 330+ 13D2 45
 331+ 13D3 D3 52 45 47          defb    'S'+$80,"REG"           ; added by Leonardo Miliani
 332+ 13D7 D6 52 45 47          defb    'V'+$80,"REG"           ; added by Leonardo Miliani
 333+ 13DB D3 43 52 45          defb    'S'+$80,"CREEN"         ; changed by Leonardo Miliani
 333+ 13DF 45 4E
 334+ 13E1 CC 4F 43 41          defb    'L'+$80,"OCATE"         ; added by Leonardo Miliani
 334+ 13E5 54 45
 335+ 13E7 D3 4F 55 4E          defb    'S'+$80,"OUND"          ; added by Leonardo Miliani
 335+ 13EB 44
 336+ 13EC D6 4F 4C 55          defb    'V'+$80,"OLUME"         ; added by Leonardo Miliani
 336+ 13F0 4D 45
 337+ 13F2 D0 41 55 53          defb    'P'+$80,"AUSE"          ; added by Leonardo Miliani
 337+ 13F6 45
 338+ 13F7 C3 4F 4C 4F          defb    'C'+$80,"OLOR"          ; added by Leonardo Miliani
 338+ 13FB 52
 339+ 13FC D0 4C 4F 54          defb    'P'+$80,"LOT"           ; added by Leonardo Miliani
 340+ 1400 C4 52 41 57          defb    'D'+$80,"RAW"           ; added by Leonardo Miliani
 341+ 1404 C3 49 52 43          defb    'C'+$80,"IRCLE"         ; added by Leonardo Miliani
 341+ 1408 4C 45
 342+ 140A D0 41 49 4E          defb    'P'+$80,"AINT"          ; added by Leonardo Miliani
 342+ 140E 54
 343+ 140F D3 45 52 49          defb    'S'+$80,"ERIAL"         ; added by Leonardo Miliani
 343+ 1413 41 4C
 344+ 1415 C8 45 4C 50          defb    'H'+$80,"ELP"           ; changed by Leonardo Miliani - was LINES
 345+ 1419 C3 4C 53             defb    'C'+$80,"LS"            ; restored command
 346+ 141C CB 45 59             defb    'K'+$80,"EY"            ; added by Leonardo Miliani
 347+ 141F CE 4D 49             defb    'N'+$80,"MI"            ; added by Leonardo Miliani
 348+ 1422 C7 50 52 49          defb    'G'+$80,"PRINT"         ; added by Leonardo Miliani
 348+ 1426 4E 54
 349+ 1428 D7 49 44 54          defb    'W'+$80,"IDTH"
 349+ 142C 48
 350+ 142D D3 59 53             defb    'S'+$80,"YS"            ; added by Leonardo Miliani
 351+ 1430 D2 45 53 45          defb    'R'+$80,"ESET"          ; changed by Leonardo Miliani
 351+ 1434 54
 352+ 1435 C5 4C 53 45          defb    'E'+$80,"LSE"           ; added by Leonardo Miliani
 353+ 1439 D0 52 49 4E          defb    'P'+$80,"RINT"
 353+ 143D 54
 354+ 143E C3 4F 4E 54          defb    'C'+$80,"ONT"
 355+ 1442 CC 49 53 54          defb    'L'+$80,"IST"
 356+ 1446 C3 4C 45 41          defb    'C'+$80,"LEAR"
 356+ 144A 52
 357+ 144B CC 4F 41 44          defb    'L'+$80,"OAD"
 358+ 144F D3 41 56 45          defb    'S'+$80,"AVE"
 359+ 1453 CE 45 57             defb    'N'+$80,"EW"
 360+ 1456 D4 41 42 28          defb    'T'+$80,"AB("
 361+ 145A D4 4F                defb    'T'+$80,"O"
 362+ 145C C6 4E                defb    'F'+$80,"N"
 363+ 145E D3 50 43 28          defb    'S'+$80,"PC("
 364+ 1462 D4 48 45 4E          defb    'T'+$80,"HEN"
 365+ 1466 CE 4F 54             defb    'N'+$80,"OT"
 366+ 1469 D3 54 45 50          defb    'S'+$80,"TEP"
 367+ 146D                      ; from here: operators
 368+ 146D AB                   defb    '+'+$80
 369+ 146E AD                   defb    '-'+$80
 370+ 146F AA                   defb    '*'+$80
 371+ 1470 AF                   defb    '/'+$80
 372+ 1471 A5                   defb    '%'+$80
 373+ 1472 A3                   defb    '#'+$80
 374+ 1473 DE                   defb    '^'+$80
 375+ 1474 C1 4E 44             defb    'A'+$80,"ND"
 376+ 1477 D8 4F 52             defb    'X'+$80,"OR"
 377+ 147A CF 52                defb    'O'+$80,"R"
 378+ 147C BE                   defb    '>'+$80
 379+ 147D BD                   defb    '='+$80
 380+ 147E BC                   defb    '<'+$80
 381+ 147F
 382+ 147F                      ; from here there are the tokens' FUNCTIONS list
 383+ 147F                      ; this list must be coherent with the functions list above
 384+ 147F D3 47 4E             defb    'S'+$80,"GN"
 385+ 1482 D4 4D 52             defb    'T'+$80,"MR"            ; added by Leonardo Miliani
 386+ 1485 C9 4E 54             defb    'I'+$80,"NT"
 387+ 1488 C1 42 53             defb    'A'+$80,"BS"
 388+ 148B D5 53 52             defb    'U'+$80,"SR"
 389+ 148E C6 52 45             defb    'F'+$80,"RE"
 390+ 1491 C9 4E 50             defb    'I'+$80,"NP"
 391+ 1494 D0 4F 53             defb    'P'+$80,"OS"
 392+ 1497 D3 51 52             defb    'S'+$80,"QR"
 393+ 149A D2 4E 44             defb    'R'+$80,"ND"
 394+ 149D CC 4F 47             defb    'L'+$80,"OG"
 395+ 14A0 C5 58 50             defb    'E'+$80,"XP"
 396+ 14A3 C3 4F 53             defb    'C'+$80,"OS"
 397+ 14A6 D3 49 4E             defb    'S'+$80,"IN"
 398+ 14A9 D4 41 4E             defb    'T'+$80,"AN"
 399+ 14AC C1 54 4E             defb    'A'+$80,"TN"
 400+ 14AF D0 45 45 4B          defb    'P'+$80,"EEK"
 401+ 14B3 C4 45 45 4B          defb    'D'+$80,"EEK"
 402+ 14B7 D6 50 45 45          defb    'V'+$80,"PEEK"          ; added by Leonardo Miliani
 402+ 14BB 4B
 403+ 14BC D6 53 54 41          defb    'V'+$80,"STAT"          ; added by Leonardo Miliani
 403+ 14C0 54
 404+ 14C1 D3 53 54 41          defb    'S'+$80,"STAT"          ; added by Leonardo Miliani
 404+ 14C5 54
 405+ 14C6 C9 4E 4B 45          defb    'I'+$80,"NKEY"          ; added by Leonardo Miliani
 405+ 14CA 59
 406+ 14CB D0 4F 49 4E          defb    'P'+$80,"OINT"          ; added by Leonardo Miliani
 406+ 14CF 54
 407+ 14D0 C9 4E 53 54          defb    'I'+$80,"NSTR"          ; added by Leonardo Miliani
 407+ 14D4 52
 408+ 14D5 CC 45 4E             defb    'L'+$80,"EN"
 409+ 14D8 D3 54 52 24          defb    'S'+$80,"TR$"
 410+ 14DC D6 41 4C             defb    'V'+$80,"AL"
 411+ 14DF C1 53 43             defb    'A'+$80,"SC"
 412+ 14E2 C3 48 52 24          defb    'C'+$80,"HR$"
 413+ 14E6 C8 45 58 24          defb    'H'+$80,"EX$"           ; added by Grant Searle
 414+ 14EA C2 49 4E 24          defb    'B'+$80,"IN$"           ; added by Grant Searle
 415+ 14EE CC 45 46 54          defb    'L'+$80,"EFT$"
 415+ 14F2 24
 416+ 14F3 D2 49 47 48          defb    'R'+$80,"IGHT$"
 416+ 14F7 54 24
 417+ 14F9 CD 49 44 24          defb    'M'+$80,"ID$"
 418+ 14FD 80                   defb    $80                     ; End-of-list marker
 419+ 14FE
 420+ 14FE              ; KEYWORD ADDRESS TABLE
 421+ 14FE              ; this list must be coherent with the commands'
 422+ 14FE              ; tokens list above
 423+ 14FE 5C 1C        WORDTB: defw    PEND
 424+ 1500 59 1B                defw    FOR
 425+ 1502 50 20                defw    NEXT
 426+ 1504 BB 1D                defw    DATA
 427+ 1506 55 1F                defw    INPUT
 428+ 1508 A5 22                defw    DIM
 429+ 150A 87 1F                defw    READ
 430+ 150C D2 1D                defw    LET
 431+ 150E 78 1D                defw    GOTO
 432+ 1510 53 1D                defw    RUN
 433+ 1512 4A 1E                defw    IF
 434+ 1514 22 1C                defw    RESTOR
 435+ 1516 67 1D                defw    GOSUB
 436+ 1518 96 1D                defw    RETURN
 437+ 151A BD 1D                defw    REM         ; original REM
 438+ 151C 5A 1C                defw    STOP
 439+ 151E EA 28                defw    POUT
 440+ 1520 2C 1E                defw    ON
 441+ 1522 C2 3E                defw    FILES       ; changed by Leonardo Miliani - was NULL
 442+ 1524 C3 3E                defw    ERASE       ; added by Leonardo Miliani
 443+ 1526 F0 28                defw    WAIT
 444+ 1528 99 24                defw    DEF
 445+ 152A E4 29                defw    POKE
 446+ 152C 87 33                defw    DOKE
 447+ 152E E9 29                defw    VPOKE       ; added by Leonardo Miliani
 448+ 1530 26 2A                defw    SREG        ; added by Leonardo Miliani
 449+ 1532 74 2B                defw    VREG        ; added by Leonardo Miliani
 450+ 1534 BD 33                defw    SCREEN      ; new behaviour: now it sets up a graphics mode (Leonardo Miliani)
 451+ 1536 F4 29                defw    LOCATE      ; added by Leonardo Miliani
 452+ 1538 80 2A                defw    SOUND       ; added by Leonardo Miliani
 453+ 153A 47 2A                defw    VOLUME      ; added by Leonardo Miliani
 454+ 153C 9E 33                defw    PAUSE       ; added by Leonardo Miliani
 455+ 153E 38 34                defw    COLOR       ; added by Leonardo Miliani
 456+ 1540 28 37                defw    PLOT        ; added by Leonardo Miliani
 457+ 1542 BB 37                defw    DRAW        ; added by Leonardo Miliani
 458+ 1544 F1 38                defw    CIRCLE      ; added by Leonardo Miliani
 459+ 1546 E5 35                defw    PAINT       ; added by Leonardo Miliani
 460+ 1548 F6 3A                defw    SERIAL      ; added by Leonardo Miliani
 461+ 154A 38 3D                defw    HELP        ; changed by Leonardo Miliani - was LINES
 462+ 154C 60 33                defw    CLS
 463+ 154E 53 3D                defw    KEY         ; added by Leonardo Miliani
 464+ 1550 32 29                defw    NMI         ; added by Leonardo Miliani
 465+ 1552 F4 34                defw    GPRINT      ; added by Leonardo Miliani
 466+ 1554 74 33                defw    WIDTH
 467+ 1556 8C 29                defw    SYS         ; added by Leonardo Miliani
 468+ 1558 BA 3F                defw    RESET       ; new behaviour: now it resets the system
 469+ 155A BF 1D                defw    REM+2       ; ELSE: added by Leonardo Miliani
 470+ 155C 7C 1E                defw    PRINT
 471+ 155E 8E 1C                defw    CONT
 472+ 1560 30 1A                defw    LIST
 473+ 1562 07 1D                defw    CLEAR
 474+ 1564 C0 3E                defw    LOAD        ; re-implemented by Leonardo Miliani (was CLOAD)
 475+ 1566 C1 3E                defw    SAVE        ; re-implemented by Leonardo Miliani (was CSAVE)
 476+ 1568 15 18                defw    NEW
 477+ 156A
 478+ 156A              ; RESERVED WORD TOKEN VALUES
 479+ 156A              ; if you add a function or command you must increment by 1
 480+ 156A              ; the values below. Pay attention that you must increment only the
 481+ 156A              ; values AFTER the position where you entered the function/command word
 482+ 156A              ; in the "Reserver word list" above. I.E.: VPOKE has been added between
 483+ 156A              ; DOKE and SCREEN, and since REM is the reserved work listed below
 484+ 156A              ; that is before the point where VPOKE has been entered, every entry
 485+ 156A              ; after REM has been incremented.
 486+ 156A              ; Another example: when TMR has been added, since it's a function, every
 487+ 156A              ; entry after & included ZSGN must be checked (read below)
 488+ 156A
 489+ 156A              ZEND    equ     $80             ; END        <-- from here, there are the commands
 490+ 156A              ZFOR    equ     $81             ; FOR
 491+ 156A              ZDATA   equ     $83             ; DATA
 492+ 156A              ZGOTO   equ     $88             ; GOTO
 493+ 156A              ZGOSUB  equ     $8C             ; GOSUB
 494+ 156A              ZREM    equ     $8E             ; REM
 495+ 156A              ZELSE   equ     $AE             ; ELSE
 496+ 156A              ZPRINT  equ     $AF             ; PRINT
 497+ 156A              ZNEW    equ     $B5             ; NEW
 498+ 156A
 499+ 156A              ZTAB    equ     $B6             ; TAB
 500+ 156A              ZTO     equ     $B7             ; TO
 501+ 156A              ZFN     equ     $B8             ; FN
 502+ 156A              ZSPC    equ     $B9             ; SPC
 503+ 156A              ZTHEN   equ     $BA             ; THEN
 504+ 156A              ZNOT    equ     $BB             ; NOT
 505+ 156A              ZSTEP   equ     $BC             ; STEP
 506+ 156A
 507+ 156A              ZPLUS   equ     $BD             ; +         <-- from here, there are the math operators
 508+ 156A              ZMINUS  equ     $BE             ; -
 509+ 156A              ZTIMES  equ     $BF             ; *
 510+ 156A              ZDIV    equ     $C0             ; /
 511+ 156A              ZMOD    equ     $C1             ; %
 512+ 156A              ZDINT   equ     $C2             ; #
 513+ 156A              ZOR     equ     $C6             ; OR
 514+ 156A              ZGTR    equ     $C7             ; >
 515+ 156A              ZEQUAL  equ     $C8             ; M
 516+ 156A              ZLTH    equ     $C9             ; <
 517+ 156A
 518+ 156A              ZSGN    equ     $CA             ; SGN       <-- from here, there are the functions
 519+ 156A              ZPOINT  equ     $E0             ; ZPOINT    <-- if the user enters a custom function, between
 520+ 156A                                              ;               SGN and POINT, he/she must increment this pointer by 1
 521+ 156A              ZINSTR  equ     $E1             ; ZINSTR    <-- same here
 522+ 156A              ZLEFT   equ     $E9             ; LEFT$     <-- if the user enters a custom function anywhere,
 523+ 156A                                              ;               he/she must increment this pointer by 1
 524+ 156A
 525+ 156A              ; ARITHMETIC PRECEDENCE TABLE
 526+ 156A              ; in the formulas below, <last> is a number stored into the stack that must be retrieved
 527+ 156A              ; with POP BC, POP DE; FPREG is a f.p. number store into the RAM register FPREG
 528+ 156A 79           PRITAB: defb    $79             ; Precedence value
 529+ 156B 29 30                defw    PADD            ; FPREG = <last> + FPREG
 530+ 156D
 531+ 156D 79                   defb    $79             ; Precedence value
 532+ 156E 0C 2C                defw    PSUB            ; FPREG = <last> - FPREG
 533+ 1570
 534+ 1570 7C                   defb    $7C             ; Precedence value
 535+ 1571 4A 2D                defw    MULT            ; PPREG = <last> * FPREG
 536+ 1573
 537+ 1573 7C                   defb    $7C             ; Precedence value
 538+ 1574 FC 2D                defw    DIV             ; FPREG = <last> / FPREG
 539+ 1576
 540+ 1576 7C                   defb    $7C             ; Precedence value
 541+ 1577 A7 2D                defw    MOD             ; FPREG = INT(<last>)-(INT(FPREG)*INT(<last>/FPREG))
 542+ 1579
 543+ 1579 7C                   defb    $7C             ; precedence value
 544+ 157A 9F 2D                defw    DINT            ; FPREG = INT(<last> / FPREG )
 545+ 157C
 546+ 157C 7F                   defb    $7F             ; Precedence value
 547+ 157D 4A 31                defw    POWER           ; FPREG = <last> ^ FPREG
 548+ 157F
 549+ 157F 50                   defb    $50             ; Precedence value
 550+ 1580 EE 21                defw    PAND            ; FPREG = <last> AND FPREG
 551+ 1582
 552+ 1582 4A                   defb    $4A             ; Precedence value
 553+ 1583 F6 21                defw    PXOR            ; FPREG = <last> XOR FPREG
 554+ 1585
 555+ 1585 46                   defb    $46             ; Precedence value
 556+ 1586 F1 21                defw    POR             ; FPREG = <last> OR FPREG
 557+ 1588
 558+ 1588
 559+ 1588              ; INITIALISATION TABLE -------------------------------------------------------
 560+ 1588              ; these values are copied into RAM at startup
 561+ 1588 C3 BB 12     INITAB: jp      WARMST          ; Warm start jump
 562+ 158B ED 45 00             defb    $ED,$45,$00     ; RETN + NOP for default NMI service routine
 563+ 158E C3 DD 1C             jp      FCERR           ; "USR (X)" jump (Set to Error)
 564+ 1591 D3 00                out     (0),A           ; "out p,n" skeleton
 565+ 1593 C9                   ret
 566+ 1594 D6 00                sub     $00             ; Division support routine
 567+ 1596 6F                   ld      L,A
 568+ 1597 7C                   ld      A,H
 569+ 1598 DE 00                sbc     A,$00
 570+ 159A 67                   ld      H,A
 571+ 159B 78                   ld      A,B
 572+ 159C DE 00                sbc     A,$00
 573+ 159E 47                   ld      B,A
 574+ 159F 3E 00                ld      A,$00
 575+ 15A1 C9                   ret
 576+ 15A2 00 00 00             defb    $00,$00,$00     ; Random number seed table used by RND
 577+ 15A5 35 4A CA 99          defb    $35,$4A,$CA,$99 ;-2.65145E+07
 578+ 15A9 39 1C 76 98          defb    $39,$1C,$76,$98 ; 1.61291E+07
 579+ 15AD 22 95 B3 98          defb    $22,$95,$B3,$98 ;-1.17691E+07
 580+ 15B1 0A DD 47 98          defb    $0A,$DD,$47,$98 ; 1.30983E+07
 581+ 15B5 53 D1 99 99          defb    $53,$D1,$99,$99 ;-2-01612E+07
 582+ 15B9 0A 1A 9F 98          defb    $0A,$1A,$9F,$98 ;-1.04269E+07
 583+ 15BD 65 BC CD 98          defb    $65,$BC,$CD,$98 ;-1.34831E+07
 584+ 15C1 D6 77 3E 98          defb    $D6,$77,$3E,$98 ; 1.24825E+07
 585+ 15C5 52 C7 4F 80          defb    $52,$C7,$4F,$80 ; Last random number
 586+ 15C9 DB 00                in      A,($00)         ; INP (x) skeleton
 587+ 15CB C9                   ret
 588+ 15CC FF                   defb    $FF             ; Terminal width (255 = no auto CRLF)
 589+ 15CD 14                   defb    $14             ; Width for commas (at reset, 3 columns, for G1 mode)
 590+ 15CE 00                   defb    $00             ; No nulls after input bytes
 591+ 15CF 00                   defb    $00             ; Output enabled (^O off)
 592+ 15D0 00 00                defw    $00             ; Array load/save check sum
 593+ 15D2 00                   defb    $00             ; Break not by NMI
 594+ 15D3 00                   defb    $00             ; Break flag
 595+ 15D4 C3 51 19             jp      TTYLIN          ; Input reflection (set to TTY)
 596+ 15D7 AB 82                defw    STLOOK          ; Temp string space
 597+ 15D9 FE FF                defw    -2              ; Current line number (cold)
 598+ 15DB FF FF                defw    -1              ; Current line with errors (no errors)
 599+ 15DD 40           AUTORP: defb    $40             ; delay for key auto-repeat start
 600+ 15DE 08                   defb    $08             ; auto-repeat delay
 601+ 15DF 4C 49 53 54  DEFFNKS:defm    "LIST",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 1
 601+ 15E3 0D 00 00 00
 601+ 15E7 00 00 00 00
 601+ 15EB 00 00 00 00
 602+ 15EF 52 55 4E 0D          defm    "RUN",13,0,0,0,0,0,0,0,0,0,0,0,0    ; KEY 2
 602+ 15F3 00 00 00 00
 602+ 15F7 00 00 00 00
 602+ 15FB 00 00 00 00
 603+ 15FF 53 43 52 45          defm    "SCREEN1",13,0,0,0,0,0,0,0,0        ; KEY 3
 603+ 1603 45 4E 31 0D
 603+ 1607 00 00 00 00
 603+ 160B 00 00 00 00
 604+ 160F 43 4F 4C 4F          defm    "COLOR1,15,5",13,0,0,0,0            ; KEY 4
 604+ 1613 52 31 2C 31
 604+ 1617 35 2C 35 0D
 604+ 161B 00 00 00 00
 605+ 161F 53 45 52 49          defm    "SERIAL1,38400",13,0,0              ; KEY 5
 605+ 1623 41 4C 31 2C
 605+ 1627 33 38 34 30
 605+ 162B 30 0D 00 00
 606+ 162F 53 43 52 45          defm    "SCREEN2",13,0,0,0,0,0,0,0,0        ; KEY 6
 606+ 1633 45 4E 32 0D
 606+ 1637 00 00 00 00
 606+ 163B 00 00 00 00
 607+ 163F 43 4F 4E 54          defm    "CONT",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 7
 607+ 1643 0D 00 00 00
 607+ 1647 00 00 00 00
 607+ 164B 00 00 00 00
 608+ 164F 48 45 4C 50          defm    "HELP",13,0,0,0,0,0,0,0,0,0,0,0     ; KEY 8 (HELP KEY)
 608+ 1653 0D 00 00 00
 608+ 1657 00 00 00 00
 608+ 165B 00 00 00 00
 609+ 165F 48 82                defw    PROGST+1        ; Start of program text
 610+ 1661              INITBE:
 611+ 1661
 612+ 1661              ; END OF INITIALISATION TABLE ---------------------------------------------------
 613+ 1661
 614+ 1661 20 45 72 72  ERRMSG: defb    " Error",0
 614+ 1665 6F 72 00
 615+ 1668 20 69 6E 20  INMSG:  defb    " in ",0
 615+ 166C 00
 616+ 166D              ZERBYT  equ     $-1             ; A zero byte
 617+ 166D 4F 6B 0D 00  OKMSG:  defb    "Ok",CR,0,0
 617+ 1671 00
 618+ 1672 42 72 65 61  BRKMSG: defb    "Break",0
 618+ 1676 6B 00
 619+ 1678
 620+ 1678 21 04 00     BAKSTK: ld      HL,$04          ; Look for "FOR" block with
 621+ 167B 39                   add     HL,SP           ; same index as specified
 622+ 167C 7E           LOKFOR: ld      A,(HL)          ; Get block ID
 623+ 167D 23                   inc     HL              ; Point to index address
 624+ 167E FE 81                cp      ZFOR            ; Is it a "FOR" token
 625+ 1680 C0                   ret     NZ              ; No - exit
 626+ 1681 4E                   ld      C,(HL)          ; BC = Address of "FOR" index
 627+ 1682 23                   inc     HL
 628+ 1683 46                   ld      B,(HL)
 629+ 1684 23                   inc     HL              ; Point to sign of STEP
 630+ 1685 E5                   push    HL              ; Save pointer to sign
 631+ 1686 69                   ld      L,C             ; HL = address of "FOR" index
 632+ 1687 60                   ld      H,B
 633+ 1688 7A                   ld      A,D             ; See if an index was specified
 634+ 1689 B3                   or      E               ; DE = 0 if no index specified
 635+ 168A EB                   ex      DE,HL           ; Specified index into HL
 636+ 168B CA 92 16             jp      Z,INDFND        ; Skip if no index given
 637+ 168E EB                   ex      DE,HL           ; Index back into DE
 638+ 168F CD CB 19             call    CPDEHL          ; Compare index with one given
 639+ 1692 01 0D 00     INDFND: ld      BC,16-3         ; Offset to next block
 640+ 1695 E1                   pop     HL              ; Restore pointer to sign
 641+ 1696 C8                   ret     Z               ; Return if block found
 642+ 1697 09                   add     HL,BC           ; Point to next block
 643+ 1698 C3 7C 16             jp      LOKFOR          ; Keep on looking
 644+ 169B
 645+ 169B CD B5 16     MOVUP:  call    ENFMEM          ; See if enough memory
 646+ 169E C5           MOVSTR: push    BC              ; Save end of source
 647+ 169F E3                   ex      (SP),HL         ; Swap source and dest" end
 648+ 16A0 C1                   pop     BC              ; Get end of destination
 649+ 16A1 CD CB 19     MOVLP:  call    CPDEHL          ; See if list moved
 650+ 16A4 7E                   ld      A,(HL)          ; Get byte
 651+ 16A5 02                   ld      (BC),A          ; Move it
 652+ 16A6 C8                   ret     Z               ; Exit if all done
 653+ 16A7 0B                   dec     BC              ; Next byte to move to
 654+ 16A8 2B                   dec     HL              ; Next byte to move
 655+ 16A9 C3 A1 16             jp      MOVLP           ; Loop until all bytes moved
 656+ 16AC
 657+ 16AC E5           CHKSTK: push    HL              ; Save code string address
 658+ 16AD 2A 28 82             ld      HL,(ARREND)     ; Lowest free memory
 659+ 16B0 06 00                ld      B,$00           ; BC = Number of levels to test
 660+ 16B2 09                   add     HL,BC           ; 2 Bytes for each level
 661+ 16B3 09                   add     HL,BC
 662+ 16B4 3E                   defb    $3E             ; Skip "push HL"
 663+ 16B5 E5           ENFMEM: push    HL              ; Save code string address
 664+ 16B6 3E D0                ld      A,$D0           ; LOW -48 ; 48 Bytes minimum RAM
 665+ 16B8 95                   sub     L
 666+ 16B9 6F                   ld      L,A
 667+ 16BA 3E FF                ld      A,$FF           ; HIGH (-48) ; 48 Bytes minimum RAM
 668+ 16BC 9C                   sbc     A,H
 669+ 16BD DA C4 16             jp      C,OMERR         ; Not enough - ?OM Error
 670+ 16C0 67                   ld      H,A
 671+ 16C1 39                   add     HL,SP           ; Test if stack is overflowed
 672+ 16C2 E1                   pop     HL              ; Restore code string address
 673+ 16C3 D8                   ret     C               ; Return if enough memory
 674+ 16C4 1E 0C        OMERR:  ld      E,OM            ; ?OM Error
 675+ 16C6 C3 03 17             jp      ERROR
 676+ 16C9
 677+ 16C9
 678+ 16C9              ; if in graphics mode, return to text (called by "NOLIN" and "ERROR")
 679+ 16C9 F5           EXITGM: push    AF              ; store AF
 680+ 16CA 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
 681+ 16CD FE 02                cp      $02             ; G2?
 682+ 16CF CA D6 16             jp      Z,LDG1          ; yes, back to G1
 683+ 16D2 FE 03                cp      $03             ; G3?
 684+ 16D4 20 11                jr      NZ,LDG1ND       ; no, so return
 685+ 16D6 E5           LDG1:   push    HL              ; store HL
 686+ 16D7 D5                   push    DE              ; store DE
 687+ 16D8 11 01 00             ld      DE,$0001        ; sprites set to defaults, G1 mode
 688+ 16DB F3                   di                      ; disable INTs
 689+ 16DC CD EF 03             call    initVDP         ; initialize VDP with mode pointed by E
 690+ 16DF FB                   ei                      ; re-enable INTs
 691+ 16E0 3E 01                ld      A,$01           ; activate the...
 692+ 16E2 32 DA 81             ld      (PRNTVIDEO),A   ; ...video buffer...
 693+ 16E5 D1                   pop     DE              ; retrieve DE
 694+ 16E6 E1                   pop     HL              ; retrieve HL
 695+ 16E7 F1           LDG1ND: pop     AF              ; retrieve AF
 696+ 16E8 C9                   ret                     ; return to caller
 697+ 16E9
 698+ 16E9
 699+ 16E9 2A B0 81     DATSNR: ld      HL,(DATLIN)     ; Get line of current DATA item
 700+ 16EC 22 AF 80             ld      (LINEAT),HL     ; Save as current line
 701+ 16EF 1E 02        SNERR:  ld      E,SN            ; ?SN Error
 702+ 16F1 01                   defb    $01             ; Skip "ld E,DZ"
 703+ 16F2 1E 14        DZERR:  ld      E,DZ            ; ?/0 Error
 704+ 16F4 01                   defb    $01             ; Skip "ld E,NF"
 705+ 16F5 1E 00        NFERR:  ld      E,NF            ; ?NF Error
 706+ 16F7 01                   defb    $01             ; Skip "ld E,DD"
 707+ 16F8 1E 12        DDERR:  ld      E,DD            ; ?DD Error
 708+ 16FA 01                   defb    $01             ; Skip "ld E,UF"
 709+ 16FB 1E 22        UFERR:  ld      E,UF            ; ?UF Error
 710+ 16FD 01                   defb    $01             ; Skip "ld E,OV
 711+ 16FE 1E 0A        OVERR:  ld      E,OV            ; ?OV Error
 712+ 1700 01                   defb    $01             ; Skip "ld E,TM"
 713+ 1701 1E 18        TMERR:  ld      E,TM            ; ?TM Error
 714+ 1703
 715+ 1703 CD 3B 18     ERROR:  call    CLREG           ; Clear registers and stack
 716+ 1706 CD C9 16             call    EXITGM          ; exit from graphic modes
 717+ 1709 32 A5 80             ld      (CTLOFG),A      ; Enable output (A is 0)
 718+ 170C CD 39 09             call    CURSOR_ON       ; enable cursor
 719+ 170F CD CD 1E             call    STTLIN          ; Start new line
 720+ 1712 21 23 10             ld      HL,ERRTBL       ; Point to error codes
 721+ 1715 57                   ld      D,A             ; D = 0 (A is 0)
 722+ 1716 3E 3F                ld      A,'?'
 723+ 1718 CD DC 19             call    OUTC            ; Output '?'
 724+ 171B 19                   add     HL,DE           ; Offset to correct error code
 725+ 171C 5E                   ld      E,(HL)          ; load pointer to error message
 726+ 171D 23                   inc     HL              ; by loading LSB,
 727+ 171E 56                   ld      D,(HL)          ; then MSB
 728+ 171F 62 6B                ld      HL,DE           ; load pointer to HL
 729+ 1721 CD A3 25             call    PRS             ; Output error message
 730+ 1724 21 61 16             ld      HL,ERRMSG       ; "Error" message
 731+ 1727 CD A3 25     ERRIN:  call    PRS             ; Output message
 732+ 172A 2A AF 80             ld      HL,(LINEAT)     ; Get line of error
 733+ 172D 11 FE FF             ld      DE,-2           ; Cold start error if -2
 734+ 1730 CD CB 19             call    CPDEHL          ; See if cold start error
 735+ 1733 CA 14 12             jp      Z,CSTART        ; Cold start error - Restart
 736+ 1736 7C                   ld      A,H             ; Was it a direct error?
 737+ 1737 A5                   and     L               ; Line = -1 if direct error
 738+ 1738 3C                   inc     A
 739+ 1739 CA 44 17             jp      Z,PTLN          ; Yes, jump over
 740+ 173C E5                   push    HL              ; indirect mode - store HL
 741+ 173D 2A AF 80             ld      HL,(LINEAT)     ; copy current line number
 742+ 1740 22 B1 80             ld      (HLPLN),HL      ; save in HELP line register
 743+ 1743 E1                   pop     HL              ; retrieve HL
 744+ 1744 C4 3A 30     PTLN:   call    NZ,LINEIN       ; No - output line of error
 745+ 1747
 746+ 1747 3E                   defb    $3E             ; Skip "pop BC"
 747+ 1748 C1           POPNOK: pop     BC              ; Drop address in input buffer
 748+ 1749
 749+ 1749              ; run into direct mode: print OK and get command
 750+ 1749 AF           PRNTOK: xor     A               ; Output "Ok" and get command
 751+ 174A 32 A5 80             ld      (CTLOFG),A      ; Enable output
 752+ 174D CD CD 1E             call    STTLIN          ; Start new line
 753+ 1750 21 6D 16             ld      HL,OKMSG        ; "Ok" message
 754+ 1753 CD A3 25             call    PRS             ; Output "Ok"
 755+ 1756 CD 39 09     GETCMD: call    CURSOR_ON       ; enable cursor
 756+ 1759 21 FF FF             ld      HL,-1           ; Flag direct mode
 757+ 175C 22 AF 80             ld      (LINEAT),HL     ; Save as current line
 758+ 175F CD 51 19             call    GETLIN          ; Get an input line
 759+ 1762 DA 56 17             jp      C,GETCMD        ; Get line again if break
 760+ 1765 CD 12 1C             call    GETCHR          ; Get first character
 761+ 1768 17                   rla                     ; 8th bit is copied into carry and original carry is copied into bit 0)
 762+ 1769 DA EF 16             jp      C,SNERR         ; if char >=128 (8th bit set) then raise an error
 763+ 176C 1F                   rra                     ; recover original char and Carry
 764+ 176D 3C                   inc     A               ; Test if end of line
 765+ 176E 3D                   dec     A               ; Without affecting Carry
 766+ 176F CA 56 17             jp      Z,GETCMD        ; Nothing entered - Get another
 767+ 1772 F5                   push    AF              ; Save Carry status
 768+ 1773 CD 4E 09             call    CURSOR_OFF      ; cursor disabled
 769+ 1776 CD E2 1C             call    ATOH            ; Get line number into DE
 770+ 1779 D5                   push    DE              ; Save line number
 771+ 177A CD 68 18             call    CRUNCH          ; Tokenise rest of line
 772+ 177D 47                   ld      B,A             ; Length of tokenised line
 773+ 177E D1                   pop     DE              ; Restore line number
 774+ 177F F1                   pop     AF              ; Restore Carry
 775+ 1780 D2 F2 1B             jp      NC,EXCUTE       ; No line number - Direct mode
 776+ 1783 D5                   push    DE              ; Save line number
 777+ 1784 C5                   push    BC              ; Save length of tokenised line
 778+ 1785 AF                   xor     A
 779+ 1786 32 B3 81             ld      (LSTBIN),A      ; Clear last byte input
 780+ 1789 CD 12 1C             call    GETCHR          ; Get next character
 781+ 178C B7                   or      A               ; Set flags
 782+ 178D F5                   push    AF              ; And save them
 783+ 178E CD F5 17             call    SRCHLN          ; Search for line number in DE
 784+ 1791 DA 9A 17             jp      C,LINFND        ; Jump if line found
 785+ 1794 F1                   pop     AF              ; Get status
 786+ 1795 F5                   push    AF              ; And re-save
 787+ 1796 CA 91 1D             jp      Z,ULERR         ; Nothing after number - Error
 788+ 1799 B7                   or      A               ; Clear Carry
 789+ 179A C5           LINFND: push    BC              ; Save address of line in prog
 790+ 179B D2 B1 17             jp      NC,INEWLN       ; Line not found - Insert new
 791+ 179E EB                   ex      DE,HL           ; Next line address in DE
 792+ 179F 2A 24 82             ld      HL,(PROGND)     ; End of program
 793+ 17A2 1A           SFTPRG: ld      A,(DE)          ; Shift rest of program down
 794+ 17A3 02                   ld      (BC),A
 795+ 17A4 03                   inc     BC              ; Next destination
 796+ 17A5 13                   inc     DE              ; Next source
 797+ 17A6 CD CB 19             call    CPDEHL          ; All done?
 798+ 17A9 C2 A2 17             jp      NZ,SFTPRG       ; More to do
 799+ 17AC 60                   ld      H,B             ; HL - New end of program
 800+ 17AD 69                   ld      L,C
 801+ 17AE 22 24 82             ld      (PROGND),HL     ; Update end of program
 802+ 17B1
 803+ 17B1 D1           INEWLN: pop     DE              ; Get address of line,
 804+ 17B2 F1                   pop     AF              ; Get status
 805+ 17B3 CA D8 17             jp      Z,SETPTR        ; No text - Set up pointers
 806+ 17B6 2A 24 82             ld      HL,(PROGND)     ; Get end of program
 807+ 17B9 E3                   ex      (SP),HL         ; Get length of input line
 808+ 17BA C1                   pop     BC              ; End of program to BC
 809+ 17BB 09                   add     HL,BC           ; Find new end
 810+ 17BC E5                   push    HL              ; Save new end
 811+ 17BD CD 9B 16             call    MOVUP           ; Make space for line
 812+ 17C0 E1                   pop     HL              ; Restore new end
 813+ 17C1 22 24 82             ld      (PROGND),HL     ; Update end of program pointer
 814+ 17C4 EB                   ex      DE,HL           ; Get line to move up in HL
 815+ 17C5 74                   ld      (HL),H          ; Save MSB
 816+ 17C6 D1                   pop     DE              ; Get new line number
 817+ 17C7 23                   inc     HL              ; Skip pointer
 818+ 17C8 23                   inc     HL
 819+ 17C9 73                   ld      (HL),E          ; Save LSB of line number
 820+ 17CA 23                   inc     HL
 821+ 17CB 72                   ld      (HL),D          ; Save MSB of line number
 822+ 17CC 23                   inc     HL              ; To first byte in line
 823+ 17CD 11 38 81             ld      DE,BUFFER       ; Copy buffer to program
 824+ 17D0 1A           MOVBUF: ld      A,(DE)          ; Get source
 825+ 17D1 77                   ld      (HL),A          ; Save destinations
 826+ 17D2 23                   inc     HL              ; Next source
 827+ 17D3 13                   inc     DE              ; Next destination
 828+ 17D4 B7                   or      A               ; Done?
 829+ 17D5 C2 D0 17             jp      NZ,MOVBUF       ; No - Repeat
 830+ 17D8 CD 21 18     SETPTR: call    RUNFST          ; Set line pointers
 831+ 17DB 23                   inc     HL              ; To LSB of pointer
 832+ 17DC EB                   ex      DE,HL           ; Address to DE
 833+ 17DD 62           PTRLP:  ld      H,D             ; Address to HL
 834+ 17DE 6B                   ld      L,E
 835+ 17DF 7E                   ld      A,(HL)          ; Get LSB of pointer
 836+ 17E0 23                   inc     HL              ; To MSB of pointer
 837+ 17E1 B6                   or      (HL)            ; Compare with MSB pointer
 838+ 17E2 CA 56 17             jp      Z,GETCMD        ; Get command line if end
 839+ 17E5 23                   inc     HL              ; To LSB of line number
 840+ 17E6 23                   inc     HL              ; Skip line number
 841+ 17E7 23                   inc     HL              ; Point to first byte in line
 842+ 17E8 AF                   xor     A               ; Looking for 00 byte
 843+ 17E9 BE           FNDEND: cp      (HL)            ; Found end of line?
 844+ 17EA 23                   inc     HL              ; Move to next byte
 845+ 17EB C2 E9 17             jp      NZ,FNDEND       ; No - Keep looking
 846+ 17EE EB                   ex      DE,HL           ; Next line address to HL
 847+ 17EF 73                   ld      (HL),E          ; Save LSB of pointer
 848+ 17F0 23                   inc     HL
 849+ 17F1 72                   ld      (HL),D          ; Save MSB of pointer
 850+ 17F2 C3 DD 17             jp      PTRLP           ; Do next line
 851+ 17F5
 852+ 17F5 2A 35 81     SRCHLN: ld      HL,(BASTXT)     ; Start of program text
 853+ 17F8 44           SRCHLP: ld      B,H             ; BC = Address to look at
 854+ 17F9 4D                   ld      C,L
 855+ 17FA 7E                   ld      A,(HL)          ; Get address of next line
 856+ 17FB 23                   inc     HL
 857+ 17FC B6                   or      (HL)            ; End of program found?
 858+ 17FD 2B                   dec     HL
 859+ 17FE C8                   ret     Z               ; Yes - Line not found
 860+ 17FF 23                   inc     HL
 861+ 1800 23                   inc     HL
 862+ 1801 7E                   ld      A,(HL)          ; Get LSB of line number
 863+ 1802 23                   inc     HL
 864+ 1803 66                   ld      H,(HL)          ; Get MSB of line number
 865+ 1804 6F                   ld      L,A
 866+ 1805 CD CB 19             call    CPDEHL          ; Compare with line in DE
 867+ 1808 60                   ld      H,B             ; HL = Start of this line
 868+ 1809 69                   ld      L,C
 869+ 180A 7E                   ld      A,(HL)          ; Get LSB of next line address
 870+ 180B 23                   inc     HL
 871+ 180C 66                   ld      H,(HL)          ; Get MSB of next line address
 872+ 180D 6F                   ld      L,A             ; Next line to HL
 873+ 180E 3F                   ccf
 874+ 180F C8                   ret     Z               ; Lines found - Exit
 875+ 1810 3F                   ccf
 876+ 1811 D0                   ret     NC              ; Line not found,at line after
 877+ 1812 C3 F8 17             jp      SRCHLP          ; Keep looking
 878+ 1815
 879+ 1815 C0           NEW:    ret     NZ              ; Return if any more on line
 880+ 1816 2A 35 81     CLRPTR: ld      HL,(BASTXT)     ; Point to start of program
 881+ 1819 AF                   xor     A               ; Set program area to empty
 882+ 181A 77                   ld      (HL),A          ; Save LSB = 00
 883+ 181B 23                   inc     HL
 884+ 181C 77                   ld      (HL),A          ; Save MSB = 00
 885+ 181D 23                   inc     HL
 886+ 181E 22 24 82             ld      (PROGND),HL     ; Set program end
 887+ 1821
 888+ 1821 2A 35 81     RUNFST: ld      HL,(BASTXT)     ; Clear all variables
 889+ 1824 2B                   dec     HL
 890+ 1825
 891+ 1825 22 B5 81     INTVAR: ld      (BRKLIN),HL     ; Initialise RUN variables
 892+ 1828 2A 96 81             ld      HL,(LSTRAM)     ; Get end of RAM
 893+ 182B 22 AA 81             ld      (STRBOT),HL     ; Clear string space
 894+ 182E AF                   xor     A
 895+ 182F CD 22 1C             call    RESTOR          ; Reset DATA pointers
 896+ 1832 2A 24 82             ld      HL,(PROGND)     ; Get end of program
 897+ 1835 22 26 82             ld      (VAREND),HL     ; Clear variables
 898+ 1838 22 28 82             ld      (ARREND),HL     ; Clear arrays
 899+ 183B
 900+ 183B C1           CLREG:  pop     BC              ; Save return address
 901+ 183C 2A AD 80             ld      HL,(STRSPC)     ; Get end of working RAM
 902+ 183F F9                   ld      SP,HL           ; Set stack
 903+ 1840 21 9A 81             ld      HL,TMSTPL       ; Temporary string pool
 904+ 1843 22 98 81             ld      (TMSTPT),HL     ; Reset temporary string ptr
 905+ 1846 AF                   xor     A               ; A = 00
 906+ 1847 6F                   ld      L,A             ; HL = 0000
 907+ 1848 67                   ld      H,A
 908+ 1849 22 BB 81             ld      (CONTAD),HL     ; No CONTinue
 909+ 184C 32 B2 81             ld      (FORFLG),A      ; Clear FOR flag
 910+ 184F 22 2C 82             ld      (FNRGNM),HL     ; Clear FN argument
 911+ 1852 E5                   push    HL              ; HL = 0000
 912+ 1853 C5                   push    BC              ; Put back return
 913+ 1854 2A B5 81     DOAGN:  ld      HL,(BRKLIN)     ; Get address of code to RUN
 914+ 1857 C9                   ret                     ; Return to execution driver
 915+ 1858
 916+ 1858 3E 3F        PROMPT: ld      A,'?'           ; '?'
 917+ 185A CD DC 19             call    OUTC            ; Output character
 918+ 185D 3E 00                ld      A,NLLCR         ; null char
 919+ 185F CD DC 19             call    OUTC            ; Output character
 920+ 1862 CD 39 09             call    CURSOR_ON       ; enable cursor
 921+ 1865 C3 AA 80             jp      RINPUT          ; Get input line
 922+ 1868
 923+ 1868 AF           CRUNCH: xor     A               ; Tokenise line @ HL to BUFFER
 924+ 1869 32 95 81             ld      (DATFLG),A      ; Reset literal flag
 925+ 186C 0E 05                ld      C,2+3           ; 2 byte number and 3 nulls
 926+ 186E 11 38 81             ld      DE,BUFFER       ; Start of input buffer
 927+ 1871 7E           CRNCLP: ld      A,(HL)          ; Get byte
 928+ 1872 FE 20                cp      SPC             ; Is it a space?
 929+ 1874 CA F0 18             jp      Z,MOVDIR        ; Yes - Copy direct
 930+ 1877 47                   ld      B,A             ; Save character
 931+ 1878 FE 22                cp      $22             ; '"'             ; Is it a quote?
 932+ 187A CA 10 19             jp      Z,CPYLIT        ; Yes - Copy literal string
 933+ 187D B7                   or      A               ; Is it end of buffer?
 934+ 187E CA 17 19             jp      Z,ENDBUF        ; Yes - End buffer
 935+ 1881 3A 95 81             ld      A,(DATFLG)      ; Get data type
 936+ 1884 B7                   or      A               ; Literal?
 937+ 1885 7E                   ld      A,(HL)          ; Get byte to copy
 938+ 1886 C2 F0 18             jp      NZ,MOVDIR       ; Literal - Copy direct
 939+ 1889 FE 3F                cp      '?'             ; Is it '?' short for PRINT
 940+ 188B 3E AF                ld      A,ZPRINT        ; "PRINT" token
 941+ 188D CA F0 18             jp      Z,MOVDIR        ; Yes - replace it
 942+ 1890 7E                   ld      A,(HL)          ; Get byte again
 943+ 1891 FE 30                cp      '0'             ; Is it less than '0'
 944+ 1893 DA 9B 18             jp      C,FNDWRD        ; Yes - Look for reserved words
 945+ 1896 FE 3C                cp      $3C  ;60; ";"+1       ; Is it "0123456789:;" ?
 946+ 1898 DA F0 18             jp      C,MOVDIR        ; Yes - copy it direct
 947+ 189B D5           FNDWRD: push    DE              ; Look for reserved words
 948+ 189C 11 70 13             ld      DE,WORDS-1      ; Point to table
 949+ 189F C5                   push    BC              ; Save count
 950+ 18A0 01 EC 18             ld      BC,RETNAD       ; Where to return to
 951+ 18A3 C5                   push    BC              ; Save return address
 952+ 18A4 06 7F                ld      B,ZEND-1        ; First token value -1
 953+ 18A6 7E                   ld      A,(HL)          ; Get byte
 954+ 18A7 FE 61                cp      'a'             ; Less than 'a' ?
 955+ 18A9 DA B4 18             jp      C,SEARCH        ; Yes - search for words
 956+ 18AC FE 7B                cp      'z'+1           ; Greater than 'z' ?
 957+ 18AE D2 B4 18             jp      NC,SEARCH       ; Yes - search for words
 958+ 18B1 E6 5F                and     %01011111       ; Force upper case
 959+ 18B3 77                   ld      (HL),A          ; Replace byte
 960+ 18B4 4E           SEARCH: ld      C,(HL)          ; Search for a word
 961+ 18B5 EB                   ex      DE,HL
 962+ 18B6 23           GETNXT: inc     HL              ; Get next reserved word
 963+ 18B7 B6                   or      (HL)            ; Start of word?
 964+ 18B8 F2 B6 18             jp      P,GETNXT        ; No - move on
 965+ 18BB 04                   inc     B               ; Increment token value
 966+ 18BC 7E                   ld      A,(HL)          ; Get byte from table
 967+ 18BD E6 7F                and     %01111111       ; Strip bit 7
 968+ 18BF C8                   ret     Z               ; Return if end of list
 969+ 18C0 B9                   cp      C               ; Same character as in buffer?
 970+ 18C1 C2 B6 18             jp      NZ,GETNXT       ; No - get next word
 971+ 18C4 EB                   ex      DE,HL
 972+ 18C5 E5                   push    HL              ; Save start of word
 973+ 18C6
 974+ 18C6 13           NXTBYT: inc     DE              ; Look through rest of word
 975+ 18C7 1A                   ld      A,(DE)          ; Get byte from table
 976+ 18C8 B7                   or      A               ; End of word ?
 977+ 18C9 FA E8 18             jp      M,MATCH         ; Yes - Match found
 978+ 18CC 4F                   ld      C,A             ; Save it
 979+ 18CD 78                   ld      A,B             ; Get token value
 980+ 18CE FE 88                cp      ZGOTO           ; Is it "GOTO" token ?
 981+ 18D0 C2 D7 18             jp      NZ,NOSPC        ; No - Don't allow spaces
 982+ 18D3 CD 12 1C             call    GETCHR          ; Get next character
 983+ 18D6 2B                   dec     HL              ; Cancel increment from GETCHR
 984+ 18D7 23           NOSPC:  inc     HL              ; Next byte
 985+ 18D8 7E                   ld      A,(HL)          ; Get byte
 986+ 18D9 FE 61                cp      'a'             ; Less than 'a' ?
 987+ 18DB DA E0 18             jp      C,NOCHNG        ; Yes - don't change
 988+ 18DE E6 5F                and     %01011111       ; Make upper case
 989+ 18E0 B9           NOCHNG: cp      C               ; Same as in buffer ?
 990+ 18E1 CA C6 18             jp      Z,NXTBYT        ; Yes - keep testing
 991+ 18E4 E1                   pop     HL              ; Get back start of word
 992+ 18E5 C3 B4 18             jp      SEARCH          ; Look at next word
 993+ 18E8
 994+ 18E8 48           MATCH:  ld      C,B             ; Word found - Save token value
 995+ 18E9 F1                   pop     AF              ; Throw away return
 996+ 18EA EB                   ex      DE,HL
 997+ 18EB C9                   ret                     ; Return to "RETNAD"
 998+ 18EC EB           RETNAD: ex      DE,HL           ; Get address in string
 999+ 18ED 79                   ld      A,C             ; Get token value
1000+ 18EE C1                   pop     BC              ; Restore buffer length
1001+ 18EF D1                   pop     DE              ; Get destination address
1002+ 18F0 23           MOVDIR: inc     HL              ; Next source in buffer
1003+ 18F1 12                   ld      (DE),A          ; Put byte in buffer
1004+ 18F2 13                   inc     DE              ; Move up buffer
1005+ 18F3 0C                   inc     C               ; Increment length of buffer
1006+ 18F4 D6 3A                sub     ':'             ; End of statement?
1007+ 18F6 CA FE 18             jp      Z,SETLIT        ; Jump if multi-statement line
1008+ 18F9 FE 49                cp      ZDATA-$3A       ; Is it DATA statement ?
1009+ 18FB C2 01 19             jp      NZ,TSTREM       ; No - see if REM
1010+ 18FE 32 95 81     SETLIT: ld      (DATFLG),A      ; Set literal flag
1011+ 1901 D6 54        TSTREM: sub     ZREM-$3A        ; Is it REM?
1012+ 1903 C2 71 18             jp      NZ,CRNCLP       ; No - Leave flag
1013+ 1906 47                   ld      B,A             ; Copy rest of buffer
1014+ 1907 7E           NXTCHR: ld      A,(HL)          ; Get byte
1015+ 1908 B7                   or      A               ; End of line ?
1016+ 1909 CA 17 19             jp      Z,ENDBUF        ; Yes - Terminate buffer
1017+ 190C B8                   cp      B               ; End of statement ?
1018+ 190D CA F0 18             jp      Z,MOVDIR        ; Yes - Get next one
1019+ 1910 23           CPYLIT: inc     HL              ; Move up source string
1020+ 1911 12                   ld      (DE),A          ; Save in destination
1021+ 1912 0C                   inc     C               ; Increment length
1022+ 1913 13                   inc     DE              ; Move up destination
1023+ 1914 C3 07 19             jp      NXTCHR          ; Repeat
1024+ 1917
1025+ 1917 21 37 81     ENDBUF: ld      HL,BUFFER-1     ; Point to start of buffer
1026+ 191A 12                   ld      (DE),A          ; Mark end of buffer (A = 00)
1027+ 191B 13                   inc     DE
1028+ 191C 12                   ld      (DE),A          ; A = 00
1029+ 191D 13                   inc     DE
1030+ 191E 12                   ld      (DE),A          ; A = 00
1031+ 191F C9                   ret
1032+ 1920
1033+ 1920 3A A4 80     DODEL:  ld      A,(NULFLG)      ; Get null flag status
1034+ 1923 B7                   or      A               ; Is it zero?
1035+ 1924 3E 00                ld      A,$00           ; Zero A - Leave flags
1036+ 1926 32 A4 80             ld      (NULFLG),A      ; Zero null flag
1037+ 1929 C2 34 19             jp      NZ,ECHDEL       ; Set - Echo it
1038+ 192C 05                   dec     B               ; Decrement length
1039+ 192D CA 51 19             jp      Z,GETLIN        ; Get line again if empty
1040+ 1930 CD DC 19             call    OUTC            ; Output null character
1041+ 1933 3E                   defb    $3E             ; Skip "dec B"
1042+ 1934 05           ECHDEL: dec     B               ; Count bytes in buffer
1043+ 1935 2B                   dec     HL              ; Back space buffer
1044+ 1936 CA 48 19             jp      Z,OTKLN         ; No buffer - Try again
1045+ 1939 7E                   ld      A,(HL)          ; Get deleted byte
1046+ 193A CD DC 19             call    OUTC            ; Echo it
1047+ 193D C3 5A 19             jp      MORINP          ; Get more input
1048+ 1940
1049+ 1940 05           DELCHR: dec     B               ; Count bytes in buffer
1050+ 1941 2B                   dec     HL              ; Back space buffer
1051+ 1942 CD DC 19             call    OUTC            ; Output character in A
1052+ 1945 C2 5A 19             jp      NZ,MORINP       ; Not end - Get more
1053+ 1948 CD DC 19     OTKLN:  call    OUTC            ; Output character in A
1054+ 194B CD DF 1E     KILIN:  call    PRNTCRLF        ; Output CRLF
1055+ 194E C3 51 19             jp      TTYLIN          ; Get line again
1056+ 1951
1057+ 1951              GETLIN:
1058+ 1951 21 38 81     TTYLIN: ld      HL,BUFFER       ; Get a line by character
1059+ 1954 06 01                ld      B,$01           ; Set buffer as empty
1060+ 1956 AF                   xor     A
1061+ 1957 32 A4 80             ld      (NULFLG),A      ; Clear null flag
1062+ 195A CD 1D 1A     MORINP: call    CLOTST          ; Get character and test ^O
1063+ 195D 4F                   ld      C,A             ; Save character in C
1064+ 195E FE 7F                cp      DEL             ; Delete character?
1065+ 1960 CA 20 19             jp      Z,DODEL         ; Yes - Process it
1066+ 1963 3A A4 80             ld      A,(NULFLG)      ; Get null flag
1067+ 1966 B7                   or      A               ; Test null flag status
1068+ 1967 CA 73 19             jp      Z,PROCES        ; Reset - Process character
1069+ 196A 3E 00                ld      A,$00           ; Set a null
1070+ 196C CD DC 19             call    OUTC            ; Output null
1071+ 196F AF                   xor     A               ; Clear A
1072+ 1970 32 A4 80             ld      (NULFLG),A      ; Reset null flag
1073+ 1973 79           PROCES: ld      A,C             ; Get character
1074+ 1974 FE 07                cp      CTRLG           ; Bell?
1075+ 1976 CA B3 19             jp      Z,PUTCTL        ; Yes - Save it
1076+ 1979 FE 03                cp      CTRLC           ; Is it control "C"?
1077+ 197B CC A8 19             call    Z,GMNCR         ; Yes - exit from graphic mode & Output CRLF
1078+ 197E 37                   scf                     ; Flag break
1079+ 197F C8                   ret     Z               ; Return if control "C"
1080+ 1980 FE 0D                cp      CR              ; Is it enter?
1081+ 1982 CA D5 1E             jp      Z,ENDINP        ; Yes - Terminate input
1082+ 1985 FE 15                cp      CTRLU           ; Is it control "U"?
1083+ 1987 CA 4B 19             jp      Z,KILIN         ; Yes - Get another line
1084+ 198A FE 08                cp      BKSP            ; Is it backspace?
1085+ 198C CA 40 19             jp      Z,DELCHR        ; Yes - Delete character
1086+ 198F FE 12                cp      CTRLR           ; Is it control "R"?
1087+ 1991 C2 AE 19             jp      NZ,PUTBUF       ; No - Put in buffer
1088+ 1994 C5                   push    BC              ; Save buffer length
1089+ 1995 D5                   push    DE              ; Save DE
1090+ 1996 E5                   push    HL              ; Save buffer address
1091+ 1997 36 00                ld      (HL),$00        ; Mark end of buffer
1092+ 1999 CD D8 3F             call    OUTNCR          ; Output and do CRLF
1093+ 199C 21 38 81             ld      HL,BUFFER       ; Point to buffer start
1094+ 199F CD A3 25             call    PRS             ; Output buffer
1095+ 19A2 E1                   pop     HL              ; Restore buffer address
1096+ 19A3 D1                   pop     DE              ; Restore DE
1097+ 19A4 C1                   pop     BC              ; Restore buffer length
1098+ 19A5 C3 5A 19             jp      MORINP          ; Get another character
1099+ 19A8 CD C9 16     GMNCR:  call    EXITGM          ; exit from graphic mode
1100+ 19AB C3 DF 1E             jp      PRNTCRLF        ; output CRLF
1101+ 19AE
1102+ 19AE FE 20        PUTBUF: cp      SPC             ; Is it a control code?
1103+ 19B0 DA 5A 19             jp      C,MORINP        ; Yes - Ignore
1104+ 19B3 78           PUTCTL: ld      A,B             ; Get number of bytes in buffer
1105+ 19B4 FE 59                cp      $58+$01         ; Test for line overflow
1106+ 19B6 3E 08                ld      A,BKSP          ; Set a bell
1107+ 19B8 D2 C5 19             jp      NC,OUTNBS       ; Ring bell if buffer full
1108+ 19BB 79                   ld      A,C             ; Get character
1109+ 19BC 71                   ld      (HL),C          ; Save in buffer
1110+ 19BD 32 B3 81             ld      (LSTBIN),A      ; Save last input byte
1111+ 19C0 23                   inc     HL              ; Move up buffer
1112+ 19C1 04                   inc     B               ; Increment length
1113+ 19C2 C3 5A 19     OUTIT:  jp      MORINP          ; Get another character
1114+ 19C5
1115+ 19C5 CD DC 19     OUTNBS: call    OUTC            ; Output bell and back over it
1116+ 19C8 C3 C2 19             jp      OUTIT           ; get more chars
1117+ 19CB
1118+ 19CB 7C           CPDEHL: ld      A,H             ; Get H
1119+ 19CC 92                   sub     D               ; Compare with D
1120+ 19CD C0                   ret     NZ              ; Different - Exit
1121+ 19CE 7D                   ld      A,L             ; Get L
1122+ 19CF 93                   sub     E               ; Compare with E
1123+ 19D0 C9                   ret                     ; Return status
1124+ 19D1
1125+ 19D1 7E           CHKSYN: ld      A,(HL)          ; Check syntax of character
1126+ 19D2 E3                   ex      (SP),HL         ; Address of test byte
1127+ 19D3 BE                   cp      (HL)            ; Same as in code string?
1128+ 19D4 23                   inc     HL              ; Return address
1129+ 19D5 E3                   ex      (SP),HL         ; Put it back
1130+ 19D6 CA 12 1C             jp      Z,GETCHR        ; Yes - Get next character
1131+ 19D9 C3 EF 16             jp      SNERR           ; Different - ?SN Error
1132+ 19DC
1133+ 19DC F5           OUTC:   push    AF              ; Save character
1134+ 19DD 3A A5 80             ld      A,(CTLOFG)      ; Get control "O" flag
1135+ 19E0 B7                   or      A               ; Is it set?
1136+ 19E1 C2 D8 25             jp      NZ,POPAF        ; Yes - don't output
1137+ 19E4 F1                   pop     AF              ; Restore character
1138+ 19E5 C5                   push    BC              ; Save buffer length
1139+ 19E6 F5                   push    AF              ; Save character
1140+ 19E7 FE 20                cp      SPC             ; Is it a control code?
1141+ 19E9 DA 00 1A             jp      C,DINPOS        ; Yes - Don't inc POS(X)
1142+ 19EC 3A A2 80             ld      A,(LWIDTH)      ; Get line width
1143+ 19EF 47                   ld      B,A             ; To B
1144+ 19F0 3A 92 81             ld      A,(CURPOS)      ; Get cursor position
1145+ 19F3 04                   inc     B               ; Width 255?
1146+ 19F4 CA FC 19             jp      Z,INCLEN        ; Yes - No width limit
1147+ 19F7 05                   dec     B               ; Restore width
1148+ 19F8 B8                   cp      B               ; At end of line?
1149+ 19F9 CC DF 1E             call    Z,PRNTCRLF      ; Yes - output CRLF
1150+ 19FC 3C           INCLEN: inc     A               ; Move on one character
1151+ 19FD 32 92 81             ld      (CURPOS),A      ; Save new position
1152+ 1A00 AF           DINPOS: xor     A
1153+ 1A01 32 18 82             ld      (KBDNPT),A      ; set flag for no char from keyboard
1154+ 1A04 F1                   pop     AF              ; Restore character
1155+ 1A05 C1                   pop     BC              ; Restore buffer length
1156+ 1A06 F5                   push    AF
1157+ 1A07 CD 0F 1A             call    SND2VID         ; send char to video
1158+ 1A0A F1                   pop     AF
1159+ 1A0B CD B7 3F             call    MONOUT          ; send char to serial if enabled
1160+ 1A0E C9                   ret
1161+ 1A0F
1162+ 1A0F              ; print char to video if cursor is on
1163+ 1A0F 32 DB 81     SND2VID:ld      (CHR4VID),A     ; store A
1164+ 1A12 3A DA 81             ld      A,(PRNTVIDEO)   ; check print-on-video
1165+ 1A15 B7                   or      A               ; is it off?
1166+ 1A16 C8                   ret     Z               ; yes, so return
1167+ 1A17 F3                   di                      ; disable INTs
1168+ 1A18 CD 6E 07             call    CHAR2VID        ; cursor is on, so print char on screen
1169+ 1A1B FB                   ei                      ; re-enable INTs
1170+ 1A1C C9                   ret                     ; return to caller
1171+ 1A1D
1172+ 1A1D CD 5E 33     CLOTST: call    GETINP          ; Get input character
1173+ 1A20 FE 0F                cp      CTRLO           ; Is it control "O"?
1174+ 1A22 C0                   ret     NZ              ; No don't flip flag
1175+ 1A23 3A A5 80             ld      A,(CTLOFG)      ; Get flag
1176+ 1A26 2F                   cpl                     ; Flip it
1177+ 1A27 32 A5 80             ld      (CTLOFG),A      ; Put it back
1178+ 1A2A A7                   and     A               ; is output enabled?
1179+ 1A2B CC 39 09             call    Z,CURSOR_ON     ; yes, so cursor on
1180+ 1A2E AF                   xor     A               ; Null character
1181+ 1A2F C9                   ret
1182+ 1A30
1183+ 1A30              ; LIST: list the program stored into memory
1184+ 1A30 C1           LIST:   pop     BC              ; rubbish - not needed (legacy from original call of LIST)
1185+ 1A31 2B                   dec     HL              ; dec 'cos GETCHR INCs
1186+ 1A32 CD 12 1C             call    GETCHR          ; Get next character
1187+ 1A35 CA 8B 1A             jp      Z,LSTALL        ; list all if nothing follows
1188+ 1A38 FE BE                cp      ZMINUS          ; is it '-'?
1189+ 1A3A 20 20                jr      NZ,LST01        ; no, look for a line number
1190+ 1A3C 11 00 00             ld      DE,$0000        ; yes, set search from 0
1191+ 1A3F CD 2C 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1192+ 1A42 ED 43 DE 81          ld      (TMPBFR1),BC    ; store address of starting line
1193+ 1A46 CD D1 19             call    CHKSYN          ; skip '-'
1194+ 1A49 BE                   defb    ZMINUS
1195+ 1A4A CD E2 1C             call    ATOH            ; now, look for another number (ASCII number to DE)
1196+ 1A4D CD 32 1B             call    SRCLN           ; find a line, getting the previous if it doesn't exist
1197+ 1A50 ED 43 E0 81          ld      (TMPBFR2),BC    ; store address of ending line
1198+ 1A54 ED 4B DE 81          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1199+ 1A58 C5                   push    BC              ; store address of line for later use
1200+ 1A59 C3 C3 1A             jp      LISTLP          ; go listing
1201+ 1A5C CD E2 1C     LST01:  call    ATOH            ; get a line number (ASCII number to DE)
1202+ 1A5F ED 53 E4 81  LST01H: ld      (TMPBFR4),DE    ; store ending line address for later use - N.B.: this is a hook for HELP command
1203+ 1A63 CD 2C 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1204+ 1A66 ED 43 DE 81          ld      (TMPBFR1),BC    ; store address of starting line
1205+ 1A6A ED 43 E0 81          ld      (TMPBFR2),BC    ; same address for ending line (we'll change it later if needed)
1206+ 1A6E 2B                   dec     HL              ; dec 'cos GETCHR INCs
1207+ 1A6F CD 12 1C             call    GETCHR          ; Get next character
1208+ 1A72 CA 7E 1A             jp      Z,LSTNOT        ; nothing follows, so ending & starting lines are the same
1209+ 1A75 FE BE                cp      ZMINUS          ; is it '-'?
1210+ 1A77 CA A3 1A             jp      Z,LST03         ; yes, read ending line
1211+ 1A7A C5           LST06:  push    BC              ; store address for later use
1212+ 1A7B C3 C3 1A             jp      LISTLP          ; jump to list
1213+ 1A7E ED 5B E4 81  LSTNOT: ld      DE,(TMPBFR4)
1214+ 1A82 CD 2C 1B             call    SRCHLIN         ; find address of line number, getting the following if it doesn't exist
1215+ 1A85 DA 7A 1A             jp      C,LST06
1216+ 1A88 C3 49 17             jp      PRNTOK
1217+ 1A8B 11 F9 FF     LSTALL: ld      DE,65529        ; set ending line to max. allowed line number
1218+ 1A8E CD 2C 1B             call    SRCHLIN         ; get address of last line
1219+ 1A91 ED 43 E0 81          ld      (TMPBFR2),BC    ; store it
1220+ 1A95 11 00 00             ld      DE,$0000        ; set start to first line in memory
1221+ 1A98 CD 2C 1B             call    SRCHLIN         ; get address of first line
1222+ 1A9B ED 43 DE 81          ld      (TMPBFR1),BC    ; store it
1223+ 1A9F C5                   push    BC              ; store address of starting line for later use
1224+ 1AA0 C3 C3 1A             jp      LISTLP          ; start printing
1225+ 1AA3 CD D1 19     LST03:  call    CHKSYN          ; skip '-'
1226+ 1AA6 BE                   defb    ZMINUS
1227+ 1AA7 CD E2 1C             call    ATOH            ; look for another number (return into DE)
1228+ 1AAA 7A                   ld      A,D
1229+ 1AAB B3                   or      E               ; is line=0?
1230+ 1AAC 20 09                jr      NZ,LST05        ; no, jump over
1231+ 1AAE 11 F9 FF             ld      DE,65529        ; yes set last valid line number
1232+ 1AB1 CD 2C 1B             call    SRCHLIN         ; get address of last line
1233+ 1AB4 C3 BA 1A             jp      LST02
1234+ 1AB7 CD 32 1B     LST05:  call    SRCLN           ; find a line, getting the previous if it doesn't exist
1235+ 1ABA ED 43 E0 81  LST02:  ld      (TMPBFR2),BC    ; store address of ending line
1236+ 1ABE ED 4B DE 81          ld      BC,(TMPBFR1)    ; retrieve address of starting line
1237+ 1AC2 C5                   push    BC              ; store it for later use
1238+ 1AC3 E1           LISTLP: pop     HL              ; Restore address of line
1239+ 1AC4 4E                   ld      C,(HL)          ; Get LSB of next line
1240+ 1AC5 23                   inc     HL
1241+ 1AC6 46                   ld      B,(HL)          ; Get MSB of next line
1242+ 1AC7 23                   inc     HL
1243+ 1AC8 78                   ld      A,B             ; BC = 0 (End of program)?
1244+ 1AC9 B1                   or      C
1245+ 1ACA CA 49 17             jp      Z,PRNTOK        ; Yes - Go to command mode
1246+ 1ACD CD 3D 1C             call    TSTBRK          ; Test for break key
1247+ 1AD0 CD 40 1B             call    TSTSPC          ; test for space
1248+ 1AD3 C5                   push    BC              ; Save address of next line
1249+ 1AD4 3A D3 81             ld      A,(SCR_CURS_X)  ; load current X pos of cursor
1250+ 1AD7 A7                   and     A               ; is it at the beginning of a new line?
1251+ 1AD8 20 0B                jr      NZ,LST08        ; No, jump over
1252+ 1ADA 3E 0D                ld      A,CR            ; yes, so just send a CR
1253+ 1ADC CD B7 3F             call    MONOUT          ; to serial if it's open
1254+ 1ADF AF                   xor     A               ; then, set cursor
1255+ 1AE0 32 92 81             ld      (CURPOS),A      ; to position 0
1256+ 1AE3 18 03                jr      LST07           ; and continue
1257+ 1AE5 CD DF 1E     LST08:  call    PRNTCRLF        ; output CRLF
1258+ 1AE8 5E           LST07:  ld      E,(HL)          ; Get LSB of line number
1259+ 1AE9 23                   inc     HL
1260+ 1AEA 56                   ld      D,(HL)          ; Get MSB of line number
1261+ 1AEB 23                   inc     HL
1262+ 1AEC E5                   push    HL              ; Save address of line start
1263+ 1AED EB                   ex      DE,HL           ; Line number to HL
1264+ 1AEE CD 42 30             call    PRNTHL          ; Output line number in decimal
1265+ 1AF1 3E 20                ld      A,SPC           ; Space after line number
1266+ 1AF3 E1                   pop     HL              ; Restore start of line address
1267+ 1AF4 CD DC 19     LSTLP2: call    OUTC            ; Output character in A
1268+ 1AF7 7E           LSTLP3: ld      A,(HL)          ; Get next byte in line
1269+ 1AF8 B7                   or      A               ; End of line?
1270+ 1AF9 23                   inc     HL              ; To next byte in line
1271+ 1AFA CA 1E 1B             jp      Z,NXTLN         ; Yes - check next line
1272+ 1AFD F2 F4 1A             jp      P,LSTLP2        ; No token - output it
1273+ 1B00 D6 7F                sub     ZEND-1          ; Find and output word
1274+ 1B02 4F                   ld      C,A             ; Token offset+1 to C
1275+ 1B03 11 71 13             ld      DE,WORDS        ; Reserved word list
1276+ 1B06 1A           FNDTOK: ld      A,(DE)          ; Get character in list
1277+ 1B07 13                   inc     DE              ; Move on to next
1278+ 1B08 B7                   or      A               ; Is it start of word?
1279+ 1B09 F2 06 1B             jp      P,FNDTOK        ; No - Keep looking for word
1280+ 1B0C 0D                   dec     C               ; Count words
1281+ 1B0D C2 06 1B             jp      NZ,FNDTOK       ; Not there - keep looking
1282+ 1B10 E6 7F        OUTWRD: and     %01111111       ; Strip bit 7
1283+ 1B12 CD DC 19             call    OUTC            ; Output character
1284+ 1B15 1A                   ld      A,(DE)          ; Get next character
1285+ 1B16 13                   inc     DE              ; Move on to next
1286+ 1B17 B7                   or      A               ; Is it end of word?
1287+ 1B18 F2 10 1B             jp      P,OUTWRD        ; No - output the rest
1288+ 1B1B C3 F7 1A             jp      LSTLP3          ; Next byte in line
1289+ 1B1E D1           NXTLN:  pop     DE              ; recover address of current line
1290+ 1B1F 2A E0 81             ld      HL,(TMPBFR2)    ; address of last line to print
1291+ 1B22 CD DE 3F             call    CMP16           ; check if current line is over last printable line
1292+ 1B25 DA 49 17             jp      C,PRNTOK        ; finish - leave & print OK
1293+ 1B28 D5                   push    DE              ; store address of current line
1294+ 1B29 C3 C3 1A             jp      LISTLP          ; continue listing
1295+ 1B2C              ; look for the address of a program line
1296+ 1B2C E5           SRCHLIN:push    HL              ; store HL (this is needed because HL store the pointer to the input buffer)
1297+ 1B2D CD F5 17             call    SRCHLN          ; search for line number in DE
1298+ 1B30 E1                   pop     HL              ; retrieve HL
1299+ 1B31 C9                   ret                     ; return to caller
1300+ 1B32              ; look for the address of a program line - if the line isn't found,
1301+ 1B32              ; it look backward for the previous line
1302+ 1B32 E5           SRCLN:  push    HL              ; store HL
1303+ 1B33 CD F5 17     SRCLN1: call    SRCHLN          ; search for line in DE
1304+ 1B36 DA 3E 1B             jp      C,LVSRLN        ; found it, leave loop
1305+ 1B39 1B                   dec     DE              ; not found, decrement number to look backward for an existing line
1306+ 1B3A 7B                   ld      A,E
1307+ 1B3B B2                   or      D               ; is line number zero?
1308+ 1B3C 20 F5                jr      NZ,SRCLN1       ; no, continue
1309+ 1B3E E1           LVSRLN: pop     HL              ; retrieve HL
1310+ 1B3F C9                   ret                     ; return to caller
1311+ 1B40
1312+ 1B40              ; during LISTing, check if PAUSE is pressed, then pause listing and
1313+ 1B40              ; wait for another pressing of PAUSE to continue or CTRL-C/BREAK to exit
1314+ 1B40 3A 1A 82     TSTSPC: ld      A,(TMPKEYBFR)   ; Get input character
1315+ 1B43 FE 20                cp      SPC             ; Is it SPACE?
1316+ 1B45 C0                   ret     NZ              ; No, return
1317+ 1B46 CD 5E 33     WTSPC:  call    GETINP          ; Yes, stop listing and wait for another space or BREAK
1318+ 1B49 FE 20                cp      SPC             ; is it SPACE?
1319+ 1B4B 20 05                jr      NZ,CNTWTSP      ; no, continue
1320+ 1B4D AF                   xor     A
1321+ 1B4E 32 1A 82             ld      (TMPKEYBFR),A   ; reset key
1322+ 1B51 C9                   ret                     ; return to caller
1323+ 1B52 FE 03        CNTWTSP:cp      CTRLC           ; is it CTRL-C/BREAK?
1324+ 1B54 20 F0                jr      NZ,WTSPC        ; no, loop
1325+ 1B56 C3 BE 12             jp      BRKRET          ; exit and output "Ok"
1326+ 1B59
1327+ 1B59
1328+ 1B59 3E 64        FOR:    ld      A,$64           ; Flag "FOR" assignment
1329+ 1B5B 32 B2 81             ld      (FORFLG),A      ; Save "FOR" flag
1330+ 1B5E CD D2 1D             call    LET             ; Set up initial index
1331+ 1B61 C1                   pop     BC              ; Drop RETurn address
1332+ 1B62 E5                   push    HL              ; Save code string address
1333+ 1B63 CD BB 1D             call    DATA            ; Get next statement address
1334+ 1B66 22 AE 81             ld      (LOOPST),HL     ; Save it for start of loop
1335+ 1B69 21 02 00             ld      HL,$0002        ; Offset for "FOR" block
1336+ 1B6C 39                   add     HL,SP           ; Point to it
1337+ 1B6D CD 7C 16     FORSLP: call    LOKFOR          ; Look for existing "FOR" block
1338+ 1B70 D1                   pop     DE              ; Get code string address
1339+ 1B71 C2 89 1B             jp      NZ,FORFND       ; No nesting found
1340+ 1B74 09                   add     HL,BC           ; Move into "FOR" block
1341+ 1B75 D5                   push    DE              ; Save code string address
1342+ 1B76 2B                   dec     HL
1343+ 1B77 56                   ld      D,(HL)          ; Get MSB of loop statement
1344+ 1B78 2B                   dec     HL
1345+ 1B79 5E                   ld      E,(HL)          ; Get LSB of loop statement
1346+ 1B7A 23                   inc     HL
1347+ 1B7B 23                   inc     HL
1348+ 1B7C E5                   push    HL              ; Save block address
1349+ 1B7D 2A AE 81             ld      HL,(LOOPST)     ; Get address of loop statement
1350+ 1B80 CD CB 19             call    CPDEHL          ; Compare the FOR loops
1351+ 1B83 E1                   pop     HL              ; Restore block address
1352+ 1B84 C2 6D 1B             jp      NZ,FORSLP       ; Different FORs - Find another
1353+ 1B87 D1                   pop     DE              ; Restore code string address
1354+ 1B88 F9                   ld      SP,HL           ; Remove all nested loops
1355+ 1B89
1356+ 1B89 EB           FORFND: ex      DE,HL           ; Code string address to HL
1357+ 1B8A 0E 08                ld      C,$08
1358+ 1B8C CD AC 16             call    CHKSTK          ; Check for 8 levels of stack
1359+ 1B8F E5                   push    HL              ; Save code string address
1360+ 1B90 2A AE 81             ld      HL,(LOOPST)     ; Get first statement of loop
1361+ 1B93 E3                   ex      (SP),HL         ; Save and restore code string
1362+ 1B94 E5                   push    HL              ; Re-save code string address
1363+ 1B95 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
1364+ 1B98 E3                   ex      (SP),HL         ; Save and restore code string
1365+ 1B99 CD 9E 20             call    TSTNUM          ; Make sure it's a number
1366+ 1B9C CD D1 19             call    CHKSYN          ; Make sure "TO" is next
1367+ 1B9F B7                   defb    ZTO             ; "TO" token
1368+ 1BA0 CD 9B 20             call    GETNUM          ; Get "TO" expression value
1369+ 1BA3 E5                   push    HL              ; Save code string address
1370+ 1BA4 CD F4 2E             call    BCDEFP          ; Move "TO" value to BCDE
1371+ 1BA7 E1                   pop     HL              ; Restore code string address
1372+ 1BA8 C5                   push    BC              ; Save "TO" value in block
1373+ 1BA9 D5                   push    DE
1374+ 1BAA 01 00 81             ld      BC,$8100        ; BCDE - 1 (default STEP)
1375+ 1BAD 51                   ld      D,C             ; C=0
1376+ 1BAE 5A                   ld      E,D             ; D=0
1377+ 1BAF 7E                   ld      A,(HL)          ; Get next byte in code string
1378+ 1BB0 FE BC                cp      ZSTEP           ; See if "STEP" is stated
1379+ 1BB2 3E 01                ld      A,$01           ; Sign of step = 1
1380+ 1BB4 C2 C5 1B             jp      NZ,SAVSTP       ; No STEP given - Default to 1
1381+ 1BB7 CD 12 1C             call    GETCHR          ; Jump over "STEP" token
1382+ 1BBA CD 9B 20             call    GETNUM          ; Get step value
1383+ 1BBD E5                   push    HL              ; Save code string address
1384+ 1BBE CD F4 2E             call    BCDEFP          ; Move STEP to BCDE
1385+ 1BC1 CD A8 2E             call    TSTSGN          ; Test sign of FPREG
1386+ 1BC4 E1                   pop     HL              ; Restore code string address
1387+ 1BC5 C5           SAVSTP: push    BC              ; Save the STEP value in block
1388+ 1BC6 D5                   push    DE
1389+ 1BC7 F5                   push    AF              ; Save sign of STEP
1390+ 1BC8 33                   inc     SP              ; Don't save flags
1391+ 1BC9 E5                   push    HL              ; Save code string address
1392+ 1BCA 2A B5 81             ld      HL,(BRKLIN)     ; Get address of index variable
1393+ 1BCD E3                   ex      (SP),HL         ; Save and restore code string
1394+ 1BCE 06 81        PUTFID: ld      B,ZFOR          ; "FOR" block marker
1395+ 1BD0 C5                   push    BC              ; Save it
1396+ 1BD1 33                   inc     SP              ; Don't save C
1397+ 1BD2
1398+ 1BD2 CD 3D 1C     RUNCNT: call    TSTBRK          ; Execution driver - Test break
1399+ 1BD5 22 B5 81             ld      (BRKLIN),HL     ; Save code address for break
1400+ 1BD8 7E                   ld      A,(HL)          ; Get next byte in code string
1401+ 1BD9 FE 3A                cp      ':'             ; Multi statement line?
1402+ 1BDB CA F2 1B             jp      Z,EXCUTE        ; Yes - Execute it
1403+ 1BDE B7                   or      A               ; End of line?
1404+ 1BDF C2 EF 16             jp      NZ,SNERR        ; No - Syntax error
1405+ 1BE2 23                   inc     HL              ; Point to address of next line
1406+ 1BE3 7E                   ld      A,(HL)          ; Get LSB of line pointer
1407+ 1BE4 23                   inc     HL
1408+ 1BE5 B6                   or      (HL)            ; Is it zero (End of prog)?
1409+ 1BE6 CA 64 1C             jp      Z,ENDPRG        ; Yes - Terminate execution
1410+ 1BE9 23                   inc     HL              ; Point to line number
1411+ 1BEA 5E                   ld      E,(HL)          ; Get LSB of line number
1412+ 1BEB 23                   inc     HL
1413+ 1BEC 56                   ld      D,(HL)          ; Get MSB of line number
1414+ 1BED EB                   ex      DE,HL           ; Line number to HL
1415+ 1BEE 22 AF 80             ld      (LINEAT),HL     ; Save as current line number
1416+ 1BF1 EB                   ex      DE,HL           ; Line number back to DE
1417+ 1BF2 CD 12 1C     EXCUTE: call    GETCHR          ; Get key word
1418+ 1BF5 11 D2 1B             ld      DE,RUNCNT       ; Where to RETurn to
1419+ 1BF8 D5                   push    DE              ; Save for RETurn
1420+ 1BF9 C8           IFJMP:  ret     Z               ; Go to RUNCNT if end of STMT
1421+ 1BFA
1422+ 1BFA D6 80        ONJMP:  sub     ZEND            ; Is it a token?
1423+ 1BFC DA D2 1D             jp      C,LET           ; No - try to assign it
1424+ 1BFF FE 36                cp      ZNEW+1-ZEND     ; END to NEW ?
1425+ 1C01 D2 EF 16             jp      NC,SNERR        ; Not a key word - ?SN Error
1426+ 1C04 07                   rlca                    ; Double it
1427+ 1C05 4F                   ld      C,A             ; BC = Offset into table
1428+ 1C06 06 00                ld      B,0
1429+ 1C08 EB                   ex      DE,HL           ; Save code string address
1430+ 1C09 21 FE 14             ld      HL,WORDTB       ; Keyword address table
1431+ 1C0C 09                   add     HL,BC           ; Point to routine address
1432+ 1C0D 4E                   ld      C,(HL)          ; Get LSB of routine address
1433+ 1C0E 23                   inc     HL
1434+ 1C0F 46                   ld      B,(HL)          ; Get MSB of routine address
1435+ 1C10 C5                   push    BC              ; Save routine address
1436+ 1C11 EB                   ex      DE,HL           ; Restore code string address
1437+ 1C12
1438+ 1C12              ; get a char from input buffer: exit with NC if character found is
1439+ 1C12              ; not a number; exit with Z if nothing found; char is into A
1440+ 1C12 23           GETCHR: inc     HL              ; Point to next character
1441+ 1C13 7E                   ld      A,(HL)          ; Get next code string byte
1442+ 1C14 FE 3A                cp      ':'             ; Z if ':'
1443+ 1C16 D0                   ret     NC              ; NC if > "9"
1444+ 1C17 FE 20                cp      SPC
1445+ 1C19 CA 12 1C             jp      Z,GETCHR        ; Skip over spaces
1446+ 1C1C FE 30                cp      '0'
1447+ 1C1E 3F                   ccf                     ; NC if < '0'
1448+ 1C1F 3C                   inc     A               ; Test for zero - Leave carry
1449+ 1C20 3D                   dec     A               ; Z if Null
1450+ 1C21 C9                   ret
1451+ 1C22
1452+ 1C22 EB           RESTOR: ex      DE,HL           ; Save code string address
1453+ 1C23 2A 35 81             ld      HL,(BASTXT)     ; Point to start of program
1454+ 1C26 CA 37 1C             jp      Z,RESTNL        ; Just RESTORE - reset pointer
1455+ 1C29 EB                   ex      DE,HL           ; Restore code string address
1456+ 1C2A CD E2 1C             call    ATOH            ; Get line number to DE
1457+ 1C2D E5                   push    HL              ; Save code string address
1458+ 1C2E CD F5 17             call    SRCHLN          ; Search for line number in DE
1459+ 1C31 60                   ld      H,B             ; HL = Address of line
1460+ 1C32 69                   ld      L,C
1461+ 1C33 D1                   pop     DE              ; Restore code string address
1462+ 1C34 D2 91 1D             jp      NC,ULERR        ; ?UL Error if not found
1463+ 1C37 2B           RESTNL: dec     HL              ; Byte before DATA statement
1464+ 1C38 22 2A 82     UPDATA: ld      (NXTDAT),HL     ; Update DATA pointer
1465+ 1C3B EB                   ex      DE,HL           ; Restore code string address
1466+ 1C3C C9                   ret
1467+ 1C3D
1468+ 1C3D
1469+ 1C3D              ; check if CTRL-C is into input buffer
1470+ 1C3D DF           TSTBRK: rst     $18             ; Check input status
1471+ 1C3E C8                   ret     Z               ; No key, go back
1472+ 1C3F D7                   rst     $10             ; Get the key into A
1473+ 1C40 FE 1B                cp      ESC             ; Escape key?
1474+ 1C42 28 11                jr      Z,BRK           ; Yes, break
1475+ 1C44 FE 03                cp      CTRLC           ; <Ctrl-C>
1476+ 1C46 28 0D                jr      Z,BRK           ; Yes, break
1477+ 1C48 FE 13                cp      CTRLS           ; Stop scrolling?
1478+ 1C4A C0                   ret     NZ              ; Other key, ignore
1479+ 1C4B
1480+ 1C4B
1481+ 1C4B              ; wait for a key while listing
1482+ 1C4B D7           STALL:  rst     $10             ; Wait for key
1483+ 1C4C FE 11                cp      CTRLQ           ; Resume scrolling?
1484+ 1C4E C8                   ret     Z               ; Release the chokehold
1485+ 1C4F FE 03                cp      CTRLC           ; Second break?
1486+ 1C51 28 07                jr      Z,STOP          ; Break during hold exits prog
1487+ 1C53 18 F6                jr      STALL           ; Loop until <Ctrl-Q> or <brk>
1488+ 1C55
1489+ 1C55 3E FF        BRK:    ld      A,$FF           ; Set BRKFLG
1490+ 1C57 32 A9 80             ld      (BRKFLG),A      ; Store it
1491+ 1C5A
1492+ 1C5A C0           STOP:   ret     NZ              ; Exit if anything else
1493+ 1C5B F6                   defb    $F6             ; Flag "STOP"
1494+ 1C5C C0           PEND:   ret     NZ              ; Exit if anything else
1495+ 1C5D 22 B5 81             ld      (BRKLIN),HL     ; Save point of break
1496+ 1C60 21                   defb    $21             ; Skip "OR 11111111B"
1497+ 1C61 F6 FF        INPBRK: or      %11111111       ; Flag "Break" wanted
1498+ 1C63 C1                   pop     BC              ; Return not needed and more
1499+ 1C64 2A AF 80     ENDPRG: ld      HL,(LINEAT)     ; Get current line number
1500+ 1C67 F5                   push    AF              ; Save STOP / END status
1501+ 1C68 7D                   ld      A,L             ; Is it direct break?
1502+ 1C69 A4                   and     H
1503+ 1C6A 3C                   inc     A               ; Line is -1 if direct break
1504+ 1C6B CA 77 1C             jp      Z,NOLIN         ; Yes - No line number
1505+ 1C6E 22 B9 81             ld      (ERRLIN),HL     ; Save line of break
1506+ 1C71 2A B5 81             ld      HL,(BRKLIN)     ; Get point of break
1507+ 1C74 22 BB 81             ld      (CONTAD),HL     ; Save point to CONTinue
1508+ 1C77 AF           NOLIN:  xor     A
1509+ 1C78 32 A5 80             ld      (CTLOFG),A      ; Enable output
1510+ 1C7B CD CD 1E             call    STTLIN          ; Start a new line
1511+ 1C7E F1                   pop     AF              ; Restore STOP / END status
1512+ 1C7F 21 72 16             ld      HL,BRKMSG       ; "Break" message
1513+ 1C82 C2 88 1C             jp      NZ,ERRINT       ; "in line" wanted?
1514+ 1C85 C3 49 17             jp      PRNTOK          ; Go to command mode
1515+ 1C88 CD C9 16     ERRINT: call    EXITGM          ; exit from graphics mode
1516+ 1C8B C3 27 17             jp      ERRIN           ; print message
1517+ 1C8E
1518+ 1C8E
1519+ 1C8E              ; CONTinue after a break/error
1520+ 1C8E 21 FF FF     CONT:   ld      HL,-1           ; reset...
1521+ 1C91 22 B1 80             ld      (HLPLN),HL      ; ...HELP line register
1522+ 1C94 2A BB 81             ld      HL,(CONTAD)     ; Get CONTinue address
1523+ 1C97 7C                   ld      A,H             ; Is it zero?
1524+ 1C98 B5                   or      L
1525+ 1C99 1E 20                ld      E,CN            ; ?CN Error
1526+ 1C9B CA 03 17             jp      Z,ERROR         ; Yes - output "?CN Error"
1527+ 1C9E EB                   ex      DE,HL           ; Save code string address
1528+ 1C9F 2A B9 81             ld      HL,(ERRLIN)     ; Get line of last break
1529+ 1CA2 22 AF 80             ld      (LINEAT),HL     ; Set up current line number
1530+ 1CA5 EB                   ex      DE,HL           ; Restore code string address
1531+ 1CA6 C9                   ret                     ; CONTinue where left off
1532+ 1CA7
1533+ 1CA7 E5           ACCSUM: push    HL              ; Save address in array
1534+ 1CA8 2A A6 80             ld      HL,(CHKSUM)     ; Get check sum
1535+ 1CAB 06 00                ld      B,$00           ; BC - Value of byte
1536+ 1CAD 4F                   ld      C,A
1537+ 1CAE 09                   add     HL,BC           ; Add byte to check sum
1538+ 1CAF 22 A6 80             ld      (CHKSUM),HL     ; Re-save check sum
1539+ 1CB2 E1                   pop     HL              ; Restore address in array
1540+ 1CB3 C9                   ret
1541+ 1CB4
1542+ 1CB4 7E           CHKLTR: ld      A,(HL)          ; Get byte
1543+ 1CB5 FE 41                cp      'A'             ; < 'a' ?
1544+ 1CB7 D8                   ret     C               ; Carry set if not letter
1545+ 1CB8 FE 5B                cp      'Z'+1           ; > 'z' ?
1546+ 1CBA 3F                   ccf
1547+ 1CBB C9                   ret                     ; Carry set if not letter
1548+ 1CBC
1549+ 1CBC CD 12 1C     FPSINT: call    GETCHR          ; Get next character
1550+ 1CBF CD 9B 20     POSINT: call    GETNUM          ; Get integer 0 to 32767
1551+ 1CC2 CD A8 2E     DEPINT: call    TSTSGN          ; Test sign of FPREG
1552+ 1CC5 FA DD 1C             jp      M,FCERR         ; Negative - ?FC Error
1553+ 1CC8 3A 35 82     DEINT:  ld      A,(FPEXP)       ; Get integer value to DE
1554+ 1CCB FE 90                cp      $80+$10         ; Exponent in range (16 bits)?
1555+ 1CCD DA 50 2F             jp      C,FPINT         ; Yes - convert it
1556+ 1CD0 01 80 90             ld      BC,$9080        ; BCDE = -32768
1557+ 1CD3 11 00 00             ld      DE,$0000
1558+ 1CD6 E5                   push    HL              ; Save code string address
1559+ 1CD7 CD 23 2F             call    CMPNUM          ; Compare FPREG with BCDE
1560+ 1CDA E1                   pop     HL              ; Restore code string address
1561+ 1CDB 51                   ld      D,C             ; MSB to D
1562+ 1CDC C8                   ret     Z               ; Return if in range
1563+ 1CDD 1E 08        FCERR:  ld      E,FC            ; ?FC Error
1564+ 1CDF C3 03 17             jp      ERROR           ; Output error-
1565+ 1CE2
1566+ 1CE2
1567+ 1CE2              ; convert a number in ASCII chars into an integer into DE
1568+ 1CE2 2B           ATOH:   dec     HL              ; ASCII number to DE binary
1569+ 1CE3 11 00 00     GETLN:  ld      DE,$0000        ; Get number to DE
1570+ 1CE6 CD 12 1C     GTLNLP: call    GETCHR          ; Get next character
1571+ 1CE9 D0                   ret     NC              ; Exit if not a digit
1572+ 1CEA E5                   push    HL              ; Save code string address
1573+ 1CEB F5                   push    AF              ; Save digit
1574+ 1CEC 21 98 19             ld      HL,65529/10     ; Largest number 65529
1575+ 1CEF CD CB 19             call    CPDEHL          ; Number in range?
1576+ 1CF2 DA EF 16             jp      C,SNERR         ; No - ?SN Error
1577+ 1CF5 62                   ld      H,D             ; HL = Number
1578+ 1CF6 6B                   ld      L,E
1579+ 1CF7 19                   add     HL,DE           ; Times 2
1580+ 1CF8 29                   add     HL,HL           ; Times 4
1581+ 1CF9 19                   add     HL,DE           ; Times 5
1582+ 1CFA 29                   add     HL,HL           ; Times 10
1583+ 1CFB F1                   pop     AF              ; Restore digit
1584+ 1CFC D6 30                sub     '0'             ; Make it 0 to 9
1585+ 1CFE 5F                   ld      E,A             ; DE = Value of digit
1586+ 1CFF 16 00                ld      D,0
1587+ 1D01 19                   add     HL,DE           ; Add to number
1588+ 1D02 EB                   ex      DE,HL           ; Number to DE
1589+ 1D03 E1                   pop     HL              ; Restore code string address
1590+ 1D04 C3 E6 1C             jp      GTLNLP          ; Go to next character
1591+ 1D07
1592+ 1D07 CA 25 18     CLEAR:  jp      Z,INTVAR        ; Just "CLEAR" Keep parameters
1593+ 1D0A CD 9B 20             call    GETNUM          ; Evaluate a number
1594+ 1D0D CD C8 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1595+ 1D10 2B                   dec     HL              ; Cancel increment
1596+ 1D11 CD 12 1C             call    GETCHR          ; Get next character
1597+ 1D14 E5                   push    HL              ; Save code string address
1598+ 1D15 2A 96 81             ld      HL,(LSTRAM)     ; Get end of RAM
1599+ 1D18 CA 30 1D             jp      Z,STORED        ; No value given - Use stored
1600+ 1D1B E1                   pop     HL              ; Restore code string address
1601+ 1D1C CD D1 19             call    CHKSYN          ; Check for comma
1602+ 1D1F 2C                   defb    ','
1603+ 1D20 D5                   push    DE              ; Save number
1604+ 1D21 CD 9B 20             call    GETNUM          ; Evaluate a number
1605+ 1D24 CD C8 1C             call    DEINT           ; Get integer -32768 to 32767 into DE
1606+ 1D27 2B                   dec     HL              ; Cancel increment
1607+ 1D28 CD 12 1C             call    GETCHR          ; Get next character
1608+ 1D2B C2 EF 16             jp      NZ,SNERR        ; ?SN Error if more on line
1609+ 1D2E E3                   ex      (SP),HL         ; Save code string address
1610+ 1D2F EB                   ex      DE,HL           ; Number to DE
1611+ 1D30 7D           STORED: ld      A,L             ; Get LSB of new RAM top
1612+ 1D31 93                   sub     E               ; Subtract LSB of string space
1613+ 1D32 5F                   ld      E,A             ; Save LSB
1614+ 1D33 7C                   ld      A,H             ; Get MSB of new RAM top
1615+ 1D34 9A                   sbc     A,D             ; Subtract MSB of string space
1616+ 1D35 57                   ld      D,A             ; Save MSB
1617+ 1D36 DA C4 16             jp      C,OMERR         ; ?OM Error if not enough mem
1618+ 1D39 E5                   push    HL              ; Save RAM top
1619+ 1D3A 2A 24 82             ld      HL,(PROGND)     ; Get program end
1620+ 1D3D 01 28 00             ld      BC,$28          ; 40 Bytes minimum working RAM
1621+ 1D40 09                   add     HL,BC           ; Get lowest address
1622+ 1D41 CD CB 19             call    CPDEHL          ; Enough memory?
1623+ 1D44 D2 C4 16             jp      NC,OMERR        ; No - ?OM Error
1624+ 1D47 EB                   ex      DE,HL           ; RAM top to HL
1625+ 1D48 22 AD 80             ld      (STRSPC),HL     ; Set new string space
1626+ 1D4B E1                   pop     HL              ; End of memory to use
1627+ 1D4C 22 96 81             ld      (LSTRAM),HL     ; Set new top of RAM
1628+ 1D4F E1                   pop     HL              ; Restore code string address
1629+ 1D50 C3 25 18             jp      INTVAR          ; Initialise variables
1630+ 1D53
1631+ 1D53 E5           RUN:    push    HL              ; store HL
1632+ 1D54 21 FF FF             ld      HL,-1           ; reset...
1633+ 1D57 22 B1 80             ld      (HLPLN),HL      ; ...HELP line register
1634+ 1D5A E1                   pop     HL              ; retrieve HL
1635+ 1D5B CA 21 18             jp      Z,RUNFST        ; RUN from start if just RUN
1636+ 1D5E CD 25 18             call    INTVAR          ; Initialise variables
1637+ 1D61 01 D2 1B             ld      BC,RUNCNT       ; Execution driver loop
1638+ 1D64 C3 77 1D             jp      RUNLIN          ; RUN from line number
1639+ 1D67
1640+ 1D67 0E 03        GOSUB:  ld      C,$03           ; 3 Levels of stack needed
1641+ 1D69 CD AC 16             call    CHKSTK          ; Check for 3 levels of stack
1642+ 1D6C C1                   pop     BC              ; Get return address
1643+ 1D6D E5                   push    HL              ; Save code string for RETURN
1644+ 1D6E E5                   push    HL              ; And for GOSUB routine
1645+ 1D6F 2A AF 80             ld      HL,(LINEAT)     ; Get current line
1646+ 1D72 E3                   ex      (SP),HL         ; Into stack - Code string out
1647+ 1D73 3E 8C                ld      A,ZGOSUB        ; "GOSUB" token
1648+ 1D75 F5                   push    AF              ; Save token
1649+ 1D76 33                   inc     SP              ; Don't save flags
1650+ 1D77
1651+ 1D77 C5           RUNLIN: push    BC              ; Save return address
1652+ 1D78 CD E2 1C     GOTO:   call    ATOH            ; ASCII number to DE binary
1653+ 1D7B CD BD 1D             call    REM             ; Get end of line
1654+ 1D7E E5                   push    HL              ; Save end of line
1655+ 1D7F 2A AF 80             ld      HL,(LINEAT)     ; Get current line
1656+ 1D82 CD CB 19             call    CPDEHL          ; Line after current?
1657+ 1D85 E1                   pop     HL              ; Restore end of line
1658+ 1D86 23                   inc     HL              ; Start of next line
1659+ 1D87 DC F8 17             call    C,SRCHLP        ; Line is after current line
1660+ 1D8A D4 F5 17             call    NC,SRCHLN       ; Line is before current line
1661+ 1D8D 60                   ld      H,B             ; Set up code string address
1662+ 1D8E 69                   ld      L,C
1663+ 1D8F 2B                   dec     HL              ; Incremented after
1664+ 1D90 D8                   ret     C               ; Line found
1665+ 1D91 1E 0E        ULERR:  ld      E,UL            ; ?UL Error
1666+ 1D93 C3 03 17             jp      ERROR           ; Output error message
1667+ 1D96
1668+ 1D96 C0           RETURN: ret     NZ              ; Return if not just RETURN
1669+ 1D97 16 FF                ld      D,-1            ; Flag "GOSUB" search
1670+ 1D99 CD 78 16             call    BAKSTK          ; Look "GOSUB" block
1671+ 1D9C F9                   ld      SP,HL           ; Kill all FORs in subroutine
1672+ 1D9D FE 8C                cp      ZGOSUB          ; Test for "GOSUB" token
1673+ 1D9F 1E 04                ld      E,RG            ; ?RG Error
1674+ 1DA1 C2 03 17             jp      NZ,ERROR        ; Error if no "GOSUB" found
1675+ 1DA4 E1                   pop     HL              ; Get RETURN line number
1676+ 1DA5 22 AF 80             ld      (LINEAT),HL     ; Save as current
1677+ 1DA8 23                   inc     HL              ; Was it from direct statement?
1678+ 1DA9 7C                   ld      A,H
1679+ 1DAA B5                   or      L               ; Return to line
1680+ 1DAB C2 B5 1D             jp      NZ,RETLIN       ; No - Return to line
1681+ 1DAE 3A B3 81             ld      A,(LSTBIN)      ; Any INPUT in subroutine?
1682+ 1DB1 B7                   or      A               ; If so buffer is corrupted
1683+ 1DB2 C2 48 17             jp      NZ,POPNOK       ; Yes - Go to command mode
1684+ 1DB5 21 D2 1B     RETLIN: ld      HL,RUNCNT       ; Execution driver loop
1685+ 1DB8 E3                   ex      (SP),HL         ; Into stack - Code string out
1686+ 1DB9 3E                   defb    $3E             ; Skip "pop HL"
1687+ 1DBA E1           NXTDTA: pop     HL              ; Restore code string address
1688+ 1DBB
1689+ 1DBB 01 3A        DATA:   defb    $01,$3A         ; ':' End of statement (stands for LD BC,$0E3A - NOP)
1690+ 1DBD 0E 00        REM:    ld      C,$00           ; 00  End of statement
1691+ 1DBF 06 00                ld      B,$00
1692+ 1DC1 79           NXTSTL: ld      A,C             ; Statement and byte
1693+ 1DC2 48                   ld      C,B
1694+ 1DC3 47                   ld      B,A             ; Statement end byte
1695+ 1DC4 7E           NXTSTT: ld      A,(HL)          ; Get byte
1696+ 1DC5 B7                   or      A               ; End of line?
1697+ 1DC6 C8                   ret     Z               ; Yes - Exit
1698+ 1DC7 B8                   cp      B               ; End of statement?
1699+ 1DC8 C8                   ret     Z               ; Yes - Exit
1700+ 1DC9 23                   inc     HL              ; Next byte
1701+ 1DCA FE 22                cp      $22             ; '"'             ; Literal string?
1702+ 1DCC CA C1 1D             jp      Z,NXTSTL        ; Yes - Look for another '"'
1703+ 1DCF C3 C4 1D             jp      NXTSTT          ; Keep looking
1704+ 1DD2
1705+ 1DD2 CD AA 22     LET:    call    GETVAR          ; Get variable name
1706+ 1DD5 CD D1 19             call    CHKSYN          ; Make sure "=" follows
1707+ 1DD8 C8                   defb    ZEQUAL          ; "=" token
1708+ 1DD9 D5                   push    DE              ; Save address of variable
1709+ 1DDA 3A 94 81             ld      A,(TYPE)        ; Get data type
1710+ 1DDD F5                   push    AF              ; Save type
1711+ 1DDE CD AD 20             call    EVAL            ; Evaluate expression
1712+ 1DE1 F1                   pop     AF              ; Restore type
1713+ 1DE2 E3                   ex      (SP),HL         ; Save code - Get var addr
1714+ 1DE3 22 B5 81             ld      (BRKLIN),HL     ; Save address of variable
1715+ 1DE6 1F                   rra                     ; Adjust type
1716+ 1DE7 CD A0 20             call    CHKTYP          ; Check types are the same
1717+ 1DEA CA 25 1E             jp      Z,LETNUM        ; Numeric - Move value
1718+ 1DED E5           LETSTR: push    HL              ; Save address of string var
1719+ 1DEE 2A 32 82             ld      HL,(FPREG)      ; Pointer to string entry
1720+ 1DF1 E5                   push    HL              ; Save it on stack
1721+ 1DF2 23                   inc     HL              ; Skip over length
1722+ 1DF3 23                   inc     HL
1723+ 1DF4 5E                   ld      E,(HL)          ; LSB of string address
1724+ 1DF5 23                   inc     HL
1725+ 1DF6 56                   ld      D,(HL)          ; MSB of string address
1726+ 1DF7 2A 35 81             ld      HL,(BASTXT)     ; Point to start of program
1727+ 1DFA CD CB 19             call    CPDEHL          ; Is string before program?
1728+ 1DFD D2 14 1E             jp      NC,CRESTR       ; Yes - Create string entry
1729+ 1E00 2A AD 80             ld      HL,(STRSPC)     ; Point to string space
1730+ 1E03 CD CB 19             call    CPDEHL          ; Is string literal in program?
1731+ 1E06 D1                   pop     DE              ; Restore address of string
1732+ 1E07 D2 1C 1E             jp      NC,MVSTPT       ; Yes - Set up pointer
1733+ 1E0A 21 A6 81             ld      HL,TMPSTR       ; Temporary string pool
1734+ 1E0D CD CB 19             call    CPDEHL          ; Is string in temporary pool?
1735+ 1E10 D2 1C 1E             jp      NC,MVSTPT       ; No - Set up pointer
1736+ 1E13 3E                   defb    $3E             ; Skip "pop DE"
1737+ 1E14 D1           CRESTR: pop     DE              ; Restore address of string
1738+ 1E15 CD 04 27             call    BAKTMP          ; Back to last tmp-str entry
1739+ 1E18 EB                   ex      DE,HL           ; Address of string entry
1740+ 1E19 CD 3D 25             call    SAVSTR          ; Save string in string area
1741+ 1E1C CD 04 27     MVSTPT: call    BAKTMP          ; Back to last tmp-str entry
1742+ 1E1F E1                   pop     HL              ; Get string pointer
1743+ 1E20 CD 03 2F             call    DETHL4          ; Move string pointer to var
1744+ 1E23 E1                   pop     HL              ; Restore code string address
1745+ 1E24 C9                   ret
1746+ 1E25
1747+ 1E25 E5           LETNUM: push    HL              ; Save address of variable
1748+ 1E26 CD 00 2F             call    FPTHL           ; Move value to variable
1749+ 1E29 D1                   pop     DE              ; Restore address of variable
1750+ 1E2A E1                   pop     HL              ; Restore code string address
1751+ 1E2B C9                   ret
1752+ 1E2C
1753+ 1E2C CD 21 29     ON:     call    GETINT          ; Get integer 0-255
1754+ 1E2F 7E                   ld      A,(HL)          ; Get "GOTO" or "GOSUB" token
1755+ 1E30 47                   ld      B,A             ; Save in B
1756+ 1E31 FE 8C                cp      ZGOSUB          ; "GOSUB" token?
1757+ 1E33 CA 3B 1E             jp      Z,ONGO          ; Yes - Find line number
1758+ 1E36 CD D1 19             call    CHKSYN          ; Make sure it's "GOTO"
1759+ 1E39 88                   defb    ZGOTO           ; "GOTO" token
1760+ 1E3A 2B                   dec     HL              ; Cancel increment
1761+ 1E3B 4B           ONGO:   ld      C,E             ; Integer of branch value
1762+ 1E3C 0D           ONGOLP: dec     C               ; Count branches
1763+ 1E3D 78                   ld      A,B             ; Get "GOTO" or "GOSUB" token
1764+ 1E3E CA FA 1B             jp      Z,ONJMP         ; Go to that line if right one
1765+ 1E41 CD E3 1C             call    GETLN           ; Get line number to DE
1766+ 1E44 FE 2C                cp      ','             ; Another line number?
1767+ 1E46 C0                   ret     NZ              ; No - Drop through
1768+ 1E47 C3 3C 1E             jp      ONGOLP          ; Yes - loop
1769+ 1E4A
1770+ 1E4A CD AD 20     IF:     call    EVAL            ; Evaluate expression
1771+ 1E4D 7E                   ld      A,(HL)          ; Get token
1772+ 1E4E FE 88                cp      ZGOTO           ; "GOTO" token?
1773+ 1E50 CA 58 1E             jp      Z,IFGO          ; Yes - Get line
1774+ 1E53 CD D1 19             call    CHKSYN          ; Make sure it's "THEN"
1775+ 1E56 BA                   defb    ZTHEN           ; "THEN" token
1776+ 1E57 2B                   dec     HL              ; Cancel increment
1777+ 1E58 CD 9E 20     IFGO:   call    TSTNUM          ; Make sure it's numeric
1778+ 1E5B CD A8 2E             call    TSTSGN          ; Test state of expression
1779+ 1E5E CA 6A 1E             jp      Z,IF1           ; False - Jump over
1780+ 1E61 CD 12 1C     IF0:    call    GETCHR          ; Get next character
1781+ 1E64 DA 78 1D             jp      C,GOTO          ; Number - GOTO that line
1782+ 1E67 C3 F9 1B             jp      IFJMP           ; Otherwise do statement
1783+ 1E6A 0E AE        IF1:    ld      C,ZELSE
1784+ 1E6C CD BF 1D             call    REM+2           ; check statement
1785+ 1E6F B7                   or      A               ; end of line?
1786+ 1E70 C8                   ret     Z               ; yes, leave
1787+ 1E71 FE AE                cp      ZELSE
1788+ 1E73 20 F5                jr      NZ,IF1          ; ELSE not found, continue check
1789+ 1E75 C3 61 1E             jp      IF0             ; return to IF
1790+ 1E78
1791+ 1E78
1792+ 1E78 2B           MRPRNT: dec     HL              ; dec 'cos GETCHR INCs
1793+ 1E79 CD 12 1C             call    GETCHR          ; Get next character
1794+ 1E7C CA DF 1E     PRINT:  jp      Z,PRNTCRLF      ; CRLF if just PRINT
1795+ 1E7F C8           PRNTLP: ret     Z               ; End of list - Exit
1796+ 1E80 FE B6                cp      ZTAB            ; "TAB(" token?
1797+ 1E82 CA 07 1F             jp      Z,DOTAB         ; Yes - Do TAB routine
1798+ 1E85 FE B9                cp      ZSPC            ; "SPC(" token?
1799+ 1E87 CA 07 1F             jp      Z,DOTAB         ; Yes - Do SPC routine
1800+ 1E8A E5                   push    HL              ; Save code string address
1801+ 1E8B FE 2C                cp      ','             ; Comma?
1802+ 1E8D CA EE 1E             jp      Z,DOCOM         ; Yes - Move to next zone
1803+ 1E90 FE 3B                cp      ';'             ; Semi-colon?
1804+ 1E92 CA 2B 1F             jp      Z,NEXITM        ; Do semi-colon routine
1805+ 1E95 C1                   pop     BC              ; Code string address to BC
1806+ 1E96 CD AD 20             call    EVAL            ; Evaluate expression
1807+ 1E99 E5                   push    HL              ; Save code string address
1808+ 1E9A 3A 94 81             ld      A,(TYPE)        ; Get variable type
1809+ 1E9D B7                   or      A               ; Is it a string variable?
1810+ 1E9E C2 C6 1E             jp      NZ,PRNTST       ; Yes - Output string contents
1811+ 1EA1 CD 4D 30             call    NUMASC          ; Convert number to text
1812+ 1EA4 CD 61 25             call    CRTST           ; Create temporary string
1813+ 1EA7 36 00                ld      (HL),NLLCR      ; Followed by a NULL char (was SPC, space)
1814+ 1EA9 2A 32 82             ld      HL,(FPREG)      ; Get length of output
1815+ 1EAC 34                   inc     (HL)            ; Plus 1 for the space
1816+ 1EAD 2A 32 82             ld      HL,(FPREG)      ; < Not needed >
1817+ 1EB0 3A A2 80             ld      A,(LWIDTH)      ; Get width of line
1818+ 1EB3 47                   ld      B,A             ; To B
1819+ 1EB4 04                   inc     B               ; Width 255 (No limit)?
1820+ 1EB5 CA C2 1E             jp      Z,PRNTNB        ; Yes - Output number string
1821+ 1EB8 04                   inc     B               ; Adjust it
1822+ 1EB9 3A 92 81             ld      A,(CURPOS)      ; Get cursor position
1823+ 1EBC 86                   add     A,(HL)          ; Add length of string
1824+ 1EBD 3D                   dec     A               ; Adjust it
1825+ 1EBE B8                   cp      B               ; Will output fit on this line?
1826+ 1EBF D4 DF 1E             call    NC,PRNTCRLF     ; No - CRLF first
1827+ 1EC2 CD A6 25     PRNTNB: call    PRS1            ; Output string at (HL)
1828+ 1EC5 AF                   xor     A               ; Skip call by setting 'z' flag
1829+ 1EC6 C4 A6 25     PRNTST: call    NZ,PRS1         ; Output string at (HL)
1830+ 1EC9 E1                   pop     HL              ; Restore code string address
1831+ 1ECA C3 78 1E             jp      MRPRNT          ; See if more to PRINT
1832+ 1ECD
1833+ 1ECD 3A 92 81     STTLIN: ld      A,(CURPOS)      ; Make sure on new line
1834+ 1ED0 B7                   or      A               ; Already at start?
1835+ 1ED1 C8                   ret     Z               ; Yes - Do nothing
1836+ 1ED2 C3 DF 1E             jp      PRNTCRLF        ; Start a new line
1837+ 1ED5
1838+ 1ED5 AF           ENDINP: xor     A
1839+ 1ED6 32 18 82             ld      (KBDNPT),A      ; char is not from keyboard
1840+ 1ED9 77                   ld      (HL),A          ; Mark end of buffer
1841+ 1EDA 21 37 81             ld      HL,BUFFER-1     ; Point to buffer
1842+ 1EDD 18 0A                jr      CNTEND
1843+ 1EDF 3E 0D        PRNTCRLF:ld     A,CR            ; Load a CR
1844+ 1EE1 CD DC 19             call    OUTC            ; Output character
1845+ 1EE4 3E 0A                ld      A,LF            ; Load a LF
1846+ 1EE6 CD DC 19             call    OUTC            ; Output character
1847+ 1EE9 AF           CNTEND: xor     A               ; Set to position 0
1848+ 1EEA 32 92 81             ld      (CURPOS),A      ; Store it
1849+ 1EED C9                   ret                     ; return to caller
1850+ 1EEE
1851+ 1EEE 3A A3 80     DOCOM:  ld      A,(COMMAN)      ; Get comma width
1852+ 1EF1 47                   ld      B,A             ; Save in B
1853+ 1EF2 3A D3 81             ld      A,(SCR_CURS_X)  ; Get current position
1854+ 1EF5 B8                   cp      B               ; Within the limit?
1855+ 1EF6 D4 DF 1E             call    NC,PRNTCRLF     ; No - output CRLF
1856+ 1EF9 D2 2B 1F             jp      NC,NEXITM       ; Get next item
1857+ 1EFC D6 0A        ZONELP: sub     $0A             ; Next zone of 10 characters
1858+ 1EFE D2 FC 1E             jp      NC,ZONELP       ; Repeat if more zones
1859+ 1F01 2F                   cpl                     ; Number of null chars to output
1860+ 1F02 0E 00                ld      C,NLLCR         ; null char
1861+ 1F04 C3 21 1F             jp      ASPCS           ; Output them
1862+ 1F07
1863+ 1F07 F5           DOTAB:  push    AF              ; Save token
1864+ 1F08 CD 1E 29             call    FNDNUM          ; Evaluate expression
1865+ 1F0B CD D1 19             call    CHKSYN          ; Make sure ")" follows
1866+ 1F0E 29                   defb    ')'
1867+ 1F0F 2B                   dec     HL              ; Back space on to ")"
1868+ 1F10 F1                   pop     AF              ; Restore token
1869+ 1F11 0E 00                ld      C,NLLCR         ; for SPC we use NULL char (was SPACE)
1870+ 1F13 D6 B9                sub     ZSPC            ; Was it "SPC(" ?
1871+ 1F15 E5                   push    HL              ; Save code string address
1872+ 1F16 CA 1C 1F             jp      Z,DOSPC         ; Yes - Do 'E' spaces
1873+ 1F19 3A D3 81             ld      A,(SCR_CURS_X)  ; Get current X position
1874+ 1F1C 2F           DOSPC:  cpl                     ; Number of spaces to print to
1875+ 1F1D 83                   add     A,E             ; Total number to print
1876+ 1F1E D2 2B 1F             jp      NC,NEXITM       ; TAB < Current POS(X)
1877+ 1F21 3C           ASPCS:  inc     A               ; Output A spaces
1878+ 1F22 47                   ld      B,A             ; Save number to print
1879+ 1F23 79           SPCLP:  ld      A,C             ; char to print
1880+ 1F24 CD DC 19             call    OUTC            ; Output character in A
1881+ 1F27 05                   dec     B               ; Count them
1882+ 1F28 C2 23 1F             jp      NZ,SPCLP        ; Repeat if more
1883+ 1F2B E1           NEXITM: pop     HL              ; Restore code string address
1884+ 1F2C CD 12 1C             call    GETCHR          ; Get next character
1885+ 1F2F C3 7F 1E             jp      PRNTLP          ; More to print
1886+ 1F32
1887+ 1F32 3F 52 65 64  REDO:   defb    "?Redo from start",CR,0
1887+ 1F36 6F 20 66 72
1887+ 1F3A 6F 6D 20 73
1887+ 1F3E 74 61 72 74
1887+ 1F42 0D 00
1888+ 1F44
1889+ 1F44 3A B4 81     BADINP: ld      A,(READFG)      ; READ or INPUT?
1890+ 1F47 B7                   or      A
1891+ 1F48 C2 E9 16             jp      NZ,DATSNR       ; READ - ?SN Error
1892+ 1F4B C1                   pop     BC              ; Throw away code string addr
1893+ 1F4C 21 32 1F             ld      HL,REDO         ; "Redo from start" message
1894+ 1F4F CD A3 25             call    PRS             ; Output string
1895+ 1F52 C3 54 18             jp      DOAGN           ; Do last INPUT again
1896+ 1F55
1897+ 1F55 CD 0E 25     INPUT:  call    IDTEST          ; Test for illegal direct
1898+ 1F58 7E                   ld      A,(HL)          ; Get character after "INPUT"
1899+ 1F59 FE 22                cp      $22             ; '"' ; Is there a prompt string?
1900+ 1F5B 3E 00                ld      A,$00           ; Clear A and leave flags
1901+ 1F5D 32 A5 80             ld      (CTLOFG),A      ; Enable output
1902+ 1F60 C2 6F 1F             jp      NZ,NOPMPT       ; No prompt - get input
1903+ 1F63 CD 62 25             call    QTSTR           ; Get string terminated by '"'
1904+ 1F66 CD D1 19             call    CHKSYN          ; Check for ';' after prompt
1905+ 1F69 3B                   defb    ";"
1906+ 1F6A E5                   push    HL              ; Save code string address
1907+ 1F6B CD A6 25             call    PRS1            ; Output prompt string
1908+ 1F6E 3E                   defb    $3E             ; Skip "push HL"
1909+ 1F6F E5           NOPMPT: push    HL              ; Save code string address
1910+ 1F70 CD 58 18             call    PROMPT          ; Get input with "? " prompt
1911+ 1F73 C1                   pop     BC              ; Restore code string address
1912+ 1F74 DA 61 1C             jp      C,INPBRK        ; Break pressed - Exit
1913+ 1F77 23                   inc     HL              ; Next byte
1914+ 1F78 7E                   ld      A,(HL)          ; Get it
1915+ 1F79 B7                   or      A               ; End of line?
1916+ 1F7A 2B                   dec     HL              ; Back again
1917+ 1F7B C5                   push    BC              ; Re-save code string address
1918+ 1F7C CD 4E 09             call    CURSOR_OFF      ; disable cursor
1919+ 1F7F CA BA 1D             jp      Z,NXTDTA        ; Yes - Find next DATA stmt
1920+ 1F82 36 2C                ld      (HL),','        ; Store comma as separator
1921+ 1F84 C3 8C 1F             jp      NXTITM          ; Get next item
1922+ 1F87
1923+ 1F87 E5           READ:   push    HL              ; Save code string address
1924+ 1F88 2A 2A 82             ld      HL,(NXTDAT)     ; Next DATA statement
1925+ 1F8B F6                   defb    $F6             ; Flag "READ"
1926+ 1F8C AF           NXTITM: xor     A               ; Flag "INPUT"
1927+ 1F8D 32 B4 81             ld      (READFG),A      ; Save "READ"/"INPUT" flag
1928+ 1F90 E3                   ex      (SP),HL         ; Get code str' , Save pointer
1929+ 1F91 C3 98 1F             jp      GTVLUS          ; Get values
1930+ 1F94
1931+ 1F94 CD D1 19     NEDMOR: call    CHKSYN          ; Check for comma between items
1932+ 1F97 2C                   defb    ','
1933+ 1F98 CD AA 22     GTVLUS: call    GETVAR          ; Get variable name
1934+ 1F9B E3                   ex      (SP),HL         ; Save code str" , Get pointer
1935+ 1F9C D5                   push    DE              ; Save variable address
1936+ 1F9D 7E                   ld      A,(HL)          ; Get next "INPUT"/"DATA" byte
1937+ 1F9E FE 2C                cp      ','             ; Comma?
1938+ 1FA0 CA C0 1F             jp      Z,ANTVLU        ; Yes - Get another value
1939+ 1FA3 3A B4 81             ld      A,(READFG)      ; Is it READ?
1940+ 1FA6 B7                   or      A
1941+ 1FA7 C2 2C 20             jp      NZ,FDTLP        ; Yes - Find next DATA stmt
1942+ 1FAA 3E 3F                ld      A,'?'           ; More INPUT needed
1943+ 1FAC CD DC 19             call    OUTC            ; Output character
1944+ 1FAF CD 58 18             call    PROMPT          ; Get INPUT with prompt
1945+ 1FB2 D1                   pop     DE              ; Variable address
1946+ 1FB3 C1                   pop     BC              ; Code string address
1947+ 1FB4 DA 61 1C             jp      C,INPBRK        ; Break pressed
1948+ 1FB7 23                   inc     HL              ; Point to next DATA byte
1949+ 1FB8 7E                   ld      A,(HL)          ; Get byte
1950+ 1FB9 B7                   or      A               ; Is it zero (No input) ?
1951+ 1FBA 2B                   dec     HL              ; Back space INPUT pointer
1952+ 1FBB C5                   push    BC              ; Save code string address
1953+ 1FBC CA BA 1D             jp      Z,NXTDTA        ; Find end of buffer
1954+ 1FBF D5                   push    DE              ; Save variable address
1955+ 1FC0 3A 94 81     ANTVLU: ld      A,(TYPE)        ; Check data type
1956+ 1FC3 B7                   or      A               ; Is it numeric?
1957+ 1FC4 CA EA 1F             jp      Z,INPBIN        ; Yes - Convert to binary
1958+ 1FC7 CD 12 1C             call    GETCHR          ; Get next character
1959+ 1FCA 57                   ld      D,A             ; Save input character
1960+ 1FCB 47                   ld      B,A             ; Again
1961+ 1FCC FE 22                cp      $22             ; '"'     ; Start of literal sting?
1962+ 1FCE CA DE 1F             jp      Z,STRENT        ; Yes - Create string entry
1963+ 1FD1 3A B4 81             ld      A,(READFG)      ; "READ" or "INPUT" ?
1964+ 1FD4 B7                   or      A
1965+ 1FD5 57                   ld      D,A             ; Save 00 if "INPUT"
1966+ 1FD6 CA DB 1F             jp      Z,ITMSEP        ; "INPUT" - End with 00
1967+ 1FD9 16 3A                ld      D,':'           ; "DATA" - End with 00 or ':'
1968+ 1FDB 06 2C        ITMSEP: ld      B,','           ; Item separator
1969+ 1FDD 2B                   dec     HL              ; Back space for DTSTR
1970+ 1FDE CD 65 25     STRENT: call    DTSTR           ; Get string terminated by D
1971+ 1FE1 EB                   ex      DE,HL           ; String address to DE
1972+ 1FE2 21 F5 1F             ld      HL,LTSTND       ; Where to go after LETSTR
1973+ 1FE5 E3                   ex      (SP),HL         ; Save HL , get input pointer
1974+ 1FE6 D5                   push    DE              ; Save address of string
1975+ 1FE7 C3 ED 1D             jp      LETSTR          ; Assign string to variable
1976+ 1FEA
1977+ 1FEA CD 12 1C     INPBIN: call    GETCHR          ; Get next character
1978+ 1FED CD AF 2F             call    ASCTFP          ; Convert ASCII to FP number
1979+ 1FF0 E3                   ex      (SP),HL         ; Save input ptr, Get var addr
1980+ 1FF1 CD 00 2F             call    FPTHL           ; Move FPREG to variable
1981+ 1FF4 E1                   pop     HL              ; Restore input pointer
1982+ 1FF5 2B           LTSTND: dec     HL              ; dec 'cos GETCHR INCs
1983+ 1FF6 CD 12 1C             call    GETCHR          ; Get next character
1984+ 1FF9 CA 01 20             jp      Z,MORDT         ; End of line - More needed?
1985+ 1FFC FE 2C                cp      ','             ; Another value?
1986+ 1FFE C2 44 1F             jp      NZ,BADINP       ; No - Bad input
1987+ 2001 E3           MORDT:  ex      (SP),HL         ; Get code string address
1988+ 2002 2B                   dec     HL              ; dec 'cos GETCHR INCs
1989+ 2003 CD 12 1C             call    GETCHR          ; Get next character
1990+ 2006 C2 94 1F             jp      NZ,NEDMOR       ; More needed - Get it
1991+ 2009 D1                   pop     DE              ; Restore DATA pointer
1992+ 200A 3A B4 81             ld      A,(READFG)      ; "READ" or "INPUT" ?
1993+ 200D B7                   or      A
1994+ 200E EB                   ex      DE,HL           ; DATA pointer to HL
1995+ 200F C2 38 1C             jp      NZ,UPDATA       ; Update DATA pointer if "READ"
1996+ 2012 D5                   push    DE              ; Save code string address
1997+ 2013 B6                   or      (HL)            ; More input given?
1998+ 2014 21 1C 20             ld      HL,EXTIG        ; "?Extra ignored" message
1999+ 2017 C4 A3 25             call    NZ,PRS          ; Output string if extra given
2000+ 201A E1                   pop     HL              ; Restore code string address
2001+ 201B C9                   ret
2002+ 201C
2003+ 201C 3F 45 78 74  EXTIG:  defb    "?Extra ignored",CR,0
2003+ 2020 72 61 20 69
2003+ 2024 67 6E 6F 72
2003+ 2028 65 64 0D 00
2004+ 202C
2005+ 202C CD BB 1D     FDTLP:  call    DATA            ; Get next statement
2006+ 202F B7                   or      A               ; End of line?
2007+ 2030 C2 45 20             jp      NZ,FANDT        ; No - See if DATA statement
2008+ 2033 23                   inc     HL
2009+ 2034 7E                   ld      A,(HL)          ; End of program?
2010+ 2035 23                   inc     HL
2011+ 2036 B6                   or      (HL)            ; 00 00 Ends program
2012+ 2037 1E 06                ld      E,OD            ; ?OD Error
2013+ 2039 CA 03 17             jp      Z,ERROR         ; Yes - Out of DATA
2014+ 203C 23                   inc     HL
2015+ 203D 5E                   ld      E,(HL)          ; LSB of line number
2016+ 203E 23                   inc     HL
2017+ 203F 56                   ld      D,(HL)          ; MSB of line number
2018+ 2040 EB                   ex      DE,HL
2019+ 2041 22 B0 81             ld      (DATLIN),HL     ; Set line of current DATA item
2020+ 2044 EB                   ex      DE,HL
2021+ 2045 CD 12 1C     FANDT:  call    GETCHR          ; Get next character
2022+ 2048 FE 83                cp      ZDATA           ; "DATA" token
2023+ 204A C2 2C 20             jp      NZ,FDTLP        ; No "DATA" - Keep looking
2024+ 204D C3 C0 1F             jp      ANTVLU          ; Found - Convert input
2025+ 2050
2026+ 2050 11 00 00     NEXT:   ld      DE,$0000        ; In case no index given
2027+ 2053 C4 AA 22     NEXT1:  call    NZ,GETVAR       ; Get index address
2028+ 2056 22 B5 81             ld      (BRKLIN),HL     ; Save code string address
2029+ 2059 CD 78 16             call    BAKSTK          ; Look for "FOR" block
2030+ 205C C2 F5 16             jp      NZ,NFERR        ; No "FOR" - ?NF Error
2031+ 205F F9                   ld      SP,HL           ; Clear nested loops
2032+ 2060 D5                   push    DE              ; Save index address
2033+ 2061 7E                   ld      A,(HL)          ; Get sign of STEP
2034+ 2062 23                   inc     HL
2035+ 2063 F5                   push    AF              ; Save sign of STEP
2036+ 2064 D5                   push    DE              ; Save index address
2037+ 2065 CD E6 2E             call    PHLTFP          ; Move index value to FPREG
2038+ 2068 E3                   ex      (SP),HL         ; Save address of TO value
2039+ 2069 E5                   push    HL              ; Save address of index
2040+ 206A CD 02 2C             call    ADDPHL          ; Add STEP to index value
2041+ 206D E1                   pop     HL              ; Restore address of index
2042+ 206E CD 00 2F             call    FPTHL           ; Move value to index variable
2043+ 2071 E1                   pop     HL              ; Restore address of TO value
2044+ 2072 CD F7 2E             call    LOADFP          ; Move TO value to BCDE
2045+ 2075 E5                   push    HL              ; Save address of line of FOR
2046+ 2076 CD 23 2F             call    CMPNUM          ; Compare index with TO value
2047+ 2079 E1                   pop     HL              ; Restore address of line num
2048+ 207A C1                   pop     BC              ; Address of sign of STEP
2049+ 207B 90                   sub     B               ; Compare with expected sign
2050+ 207C CD F7 2E             call    LOADFP          ; BC = Loop stmt,DE = Line num
2051+ 207F CA 8B 20             jp      Z,KILFOR        ; Loop finished - Terminate it
2052+ 2082 EB                   ex      DE,HL           ; Loop statement line number
2053+ 2083 22 AF 80             ld      (LINEAT),HL     ; Set loop line number
2054+ 2086 69                   ld      L,C             ; Set code string to loop
2055+ 2087 60                   ld      H,B
2056+ 2088 C3 CE 1B             jp      PUTFID          ; Put back "FOR" and continue
2057+ 208B
2058+ 208B F9           KILFOR: ld      SP,HL           ; Remove "FOR" block
2059+ 208C 2A B5 81             ld      HL,(BRKLIN)     ; Code string after "NEXT"
2060+ 208F 7E                   ld      A,(HL)          ; Get next byte in code string
2061+ 2090 FE 2C                cp      ','             ; More NEXTs ?
2062+ 2092 C2 D2 1B             jp      NZ,RUNCNT       ; No - Do next statement
2063+ 2095 CD 12 1C             call    GETCHR          ; Position to index name
2064+ 2098 CD 53 20             call    NEXT1           ; Re-enter NEXT routine
2065+ 209B              ; < will not RETurn to here , Exit to RUNCNT or Loop >
2066+ 209B
2067+ 209B CD AD 20     GETNUM: call    EVAL            ; Get a numeric expression
2068+ 209E F6           TSTNUM: defb    $F6             ; Clear carry (numeric)
2069+ 209F 37           TSTSTR: scf                     ; Set carry (string)
2070+ 20A0 3A 94 81     CHKTYP: ld      A,(TYPE)        ; Check types match
2071+ 20A3 8F                   adc     A,A             ; Expected + actual
2072+ 20A4 B7                   or      A               ; Clear carry , set parity
2073+ 20A5 E8                   ret     PE              ; Even parity - Types match
2074+ 20A6 C3 01 17             jp      TMERR           ; Different types - Error
2075+ 20A9
2076+ 20A9 CD D1 19     OPNPAR: call    CHKSYN          ; Make sure "(" follows
2077+ 20AC 28                   defb    '('
2078+ 20AD 2B           EVAL:   dec     HL              ; Evaluate expression & save
2079+ 20AE 16 00                ld      D,$00           ; Precedence value
2080+ 20B0 D5           EVAL1:  push    DE              ; Save precedence
2081+ 20B1 0E 01                ld      C,$01
2082+ 20B3 CD AC 16             call    CHKSTK          ; Check for 1 level of stack
2083+ 20B6 CD 24 21             call    OPRND           ; Get next expression value
2084+ 20B9 22 B7 81     EVAL2:  ld      (NXTOPR),HL     ; Save address of next operator
2085+ 20BC 2A B7 81     EVAL3:  ld      HL,(NXTOPR)     ; Restore address of next opr
2086+ 20BF C1                   pop     BC              ; Precedence value and operator
2087+ 20C0 78                   ld      A,B             ; Get precedence value
2088+ 20C1 FE 78                cp      $78             ; "AND", "OR", or "XOR" ?
2089+ 20C3 D4 9E 20             call    NC,TSTNUM       ; No - Make sure it's a number
2090+ 20C6 7E                   ld      A,(HL)          ; Get next operator / function
2091+ 20C7 16 00                ld      D,$00           ; Clear Last relation
2092+ 20C9 D6 C7        RLTLP:  sub     ZGTR            ; ">" Token
2093+ 20CB DA E5 20             jp      C,FOPRND        ; + - * / ^ AND OR XOR - Test it
2094+ 20CE FE 03                cp      ZLTH+1-ZGTR     ; < = >
2095+ 20D0 D2 E5 20             jp      NC,FOPRND       ; Function - Call it
2096+ 20D3 FE 01                cp      ZEQUAL-ZGTR     ; "="
2097+ 20D5 17                   rla                     ; <- Test for legal
2098+ 20D6 AA                   xor     D               ; <- combinations of < = >
2099+ 20D7 BA                   cp      D               ; <- by combining last token
2100+ 20D8 57                   ld      D,A             ; <- with current one
2101+ 20D9 DA EF 16             jp      C,SNERR         ; Error if "<<' '==" or ">>"
2102+ 20DC 22 AC 81             ld      (CUROPR),HL     ; Save address of current token
2103+ 20DF CD 12 1C             call    GETCHR          ; Get next character
2104+ 20E2 C3 C9 20             jp      RLTLP           ; Treat the two as one
2105+ 20E5
2106+ 20E5 7A           FOPRND: ld      A,D             ; < = > found ?
2107+ 20E6 B7                   or      A
2108+ 20E7 C2 25 22             jp      NZ,TSTRED       ; Yes - Test for reduction
2109+ 20EA 7E                   ld      A,(HL)          ; Get operator token
2110+ 20EB 22 AC 81             ld      (CUROPR),HL     ; Save operator address
2111+ 20EE D6 BD                sub     ZPLUS           ; Operator or function?
2112+ 20F0 D8                   ret     C               ; Neither - Exit
2113+ 20F1 FE 0A                cp      ZOR+1-ZPLUS     ; Is it + - * / ^ AND XOR OR ?
2114+ 20F3 D0                   ret     NC              ; No - Exit
2115+ 20F4 5F                   ld      E,A             ; Coded operator
2116+ 20F5 3A 94 81             ld      A,(TYPE)        ; Get data type
2117+ 20F8 3D                   dec     A               ; FF = numeric , 00 = string
2118+ 20F9 B3                   or      E               ; Combine with coded operator
2119+ 20FA 7B                   ld      A,E             ; Get coded operator
2120+ 20FB CA 99 26             jp      Z,CONCAT        ; String concatenation
2121+ 20FE 07                   rlca                    ; Times 2
2122+ 20FF 83                   add     A,E             ; Times 3
2123+ 2100 5F                   ld      E,A             ; To DE (D is 0)
2124+ 2101 21 6A 15             ld      HL,PRITAB       ; Precedence table
2125+ 2104 19                   add     HL,DE           ; To the operator concerned
2126+ 2105 78                   ld      A,B             ; Last operator precedence
2127+ 2106 56                   ld      D,(HL)          ; Get evaluation precedence
2128+ 2107 BA                   cp      D               ; Compare with eval precedence
2129+ 2108 D0                   ret     NC              ; Exit if higher precedence
2130+ 2109 23                   inc     HL              ; Point to routine address
2131+ 210A CD 9E 20             call    TSTNUM          ; Make sure it's a number
2132+ 210D
2133+ 210D C5           STKTHS: push    BC              ; Save last precedence & token
2134+ 210E 01 BC 20             ld      BC,EVAL3        ; Where to go on prec' break
2135+ 2111 C5                   push    BC              ; Save on stack for return
2136+ 2112 43                   ld      B,E             ; Save operator
2137+ 2113 4A                   ld      C,D             ; Save precedence
2138+ 2114 CD D9 2E             call    STAKFP          ; Move value to stack
2139+ 2117 58                   ld      E,B             ; Restore operator
2140+ 2118 51                   ld      D,C             ; Restore precedence
2141+ 2119 4E                   ld      C,(HL)          ; Get LSB of routine address
2142+ 211A 23                   inc     HL
2143+ 211B 46                   ld      B,(HL)          ; Get MSB of routine address
2144+ 211C 23                   inc     HL
2145+ 211D C5                   push    BC              ; Save routine address
2146+ 211E 2A AC 81             ld      HL,(CUROPR)     ; Address of current operator
2147+ 2121 C3 B0 20             jp      EVAL1           ; Loop until prec' break
2148+ 2124
2149+ 2124 AF           OPRND:  xor     A               ; Get operand routine
2150+ 2125 32 94 81             ld      (TYPE),A        ; Set numeric expected
2151+ 2128 CD 12 1C             call    GETCHR          ; Get next character
2152+ 212B 1E 24                ld      E,MO            ; ?MO Error
2153+ 212D CA 03 17             jp      Z,ERROR         ; No operand - Error
2154+ 2130 DA AF 2F             jp      C,ASCTFP        ; Number - Get value
2155+ 2133 CD B4 1C             call    CHKLTR          ; See if a letter
2156+ 2136 D2 8B 21             jp      NC,CONVAR       ; Letter - Find variable
2157+ 2139 FE 26                cp      '&'             ; &H = HEX, &B = BINARY
2158+ 213B 20 12                jr      NZ,NOTAMP
2159+ 213D CD 12 1C             call    GETCHR          ; Get next character
2160+ 2140 FE 48                cp      'H'             ; Hex number indicated? [function added]
2161+ 2142 CA 17 3F             jp      Z,HEXTFP        ; Convert Hex to FPREG
2162+ 2145 FE 42                cp      'B'             ; Binary number indicated? [function added]
2163+ 2147 CA 87 3F             jp      Z,BINTFP        ; Convert Bin to FPREG
2164+ 214A 1E 02                ld      E,SN            ; If neither then a ?SN Error
2165+ 214C CA 03 17             jp      Z,ERROR         ;
2166+ 214F FE BD        NOTAMP: cp      ZPLUS           ; '+' Token ?
2167+ 2151 CA 24 21             jp      Z,OPRND         ; Yes - Look for operand
2168+ 2154 FE 2E                cp      '.'             ; '.' ?
2169+ 2156 CA AF 2F             jp      Z,ASCTFP        ; Yes - Create FP number
2170+ 2159 FE BE                cp      ZMINUS          ; '-' Token ?
2171+ 215B CA 7A 21             jp      Z,MINUS         ; Yes - Do minus
2172+ 215E FE 22                cp      $22             ; '"'             ; Literal string ?
2173+ 2160 CA 62 25             jp      Z,QTSTR         ; Get string terminated by '"'
2174+ 2163 FE BB                cp      ZNOT            ; "NOT" Token ?
2175+ 2165 CA 85 22             jp      Z,EVNOT         ; Yes - Eval NOT expression
2176+ 2168 FE B8                cp      ZFN             ; "FN" Token ?
2177+ 216A CA C6 24             jp      Z,DOFN          ; Yes - Do FN routine
2178+ 216D D6 CA                sub     ZSGN            ; Is it a function?
2179+ 216F D2 9C 21             jp      NC,FNOFST       ; Yes - Evaluate function
2180+ 2172 CD A9 20     EVLPAR: call    OPNPAR          ; Evaluate expression in "()"
2181+ 2175 CD D1 19             call    CHKSYN          ; Make sure ")" follows
2182+ 2178 29                   defb    ')'
2183+ 2179 C9                   ret
2184+ 217A
2185+ 217A 16 7D        MINUS:  ld      D,$7D           ; '-' precedence
2186+ 217C CD B0 20             call    EVAL1           ; Evaluate until prec' break
2187+ 217F 2A B7 81             ld      HL,(NXTOPR)     ; Get next operator address
2188+ 2182 E5                   push    HL              ; Save next operator address
2189+ 2183 CD D1 2E             call    INVSGN          ; Negate value
2190+ 2186 CD 9E 20     RETNUM: call    TSTNUM          ; Make sure it's a number
2191+ 2189 E1                   pop     HL              ; Restore next operator address
2192+ 218A C9                   ret
2193+ 218B
2194+ 218B CD AA 22     CONVAR: call    GETVAR          ; Get variable address to DE
2195+ 218E E5           FRMEVL: push    HL              ; Save code string address
2196+ 218F EB                   ex      DE,HL           ; Variable address to HL
2197+ 2190 22 32 82             ld      (FPREG),HL      ; Save address of variable
2198+ 2193 3A 94 81             ld      A,(TYPE)        ; Get type
2199+ 2196 B7                   or      A               ; Numeric?
2200+ 2197 CC E6 2E             call    Z,PHLTFP        ; Yes - Move contents to FPREG
2201+ 219A E1                   pop     HL              ; Restore code string address
2202+ 219B C9                   ret
2203+ 219C
2204+ 219C 06 00        FNOFST: ld      B,$00           ; Get address of function
2205+ 219E 07                   rlca                    ; Double function offset
2206+ 219F 4F                   ld      C,A             ; BC = Offset in function table
2207+ 21A0 C5                   push    BC              ; Save adjusted token value
2208+ 21A1 CD 12 1C             call    GETCHR          ; Get next character
2209+ 21A4 79                   ld      A,C             ; Get adjusted token value
2210+ 21A5 FE 2C                cp      2*(ZPOINT-ZSGN) ; "POINT" token?
2211+ 21A7 CA D5 36             jp      Z,POINT         ; Yes, do "POINT"
2212+ 21AA FE 2E                cp      2*(ZINSTR-ZSGN) ; "INSTR" token?
2213+ 21AC CA 75 27             jp      Z,INSTR         ; Yes, do "INSTR"
2214+ 21AF FE 3D                cp      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2215+ 21B1 DA CD 21             jp      C,FNVAL         ; No - Do function
2216+ 21B4 CD A9 20             call    OPNPAR          ; Evaluate expression  (X,...
2217+ 21B7 CD D1 19             call    CHKSYN          ; Make sure ',' follows
2218+ 21BA 2C                   defb    ','
2219+ 21BB CD 9F 20             call    TSTSTR          ; Make sure it's a string
2220+ 21BE EB                   ex      DE,HL           ; Save code string address
2221+ 21BF 2A 32 82             ld      HL,(FPREG)      ; Get address of string
2222+ 21C2 E3                   ex      (SP),HL         ; Save address of string
2223+ 21C3 E5                   push    HL              ; Save adjusted token value
2224+ 21C4 EB                   ex      DE,HL           ; Restore code string address
2225+ 21C5 CD 21 29             call    GETINT          ; Get integer 0-255
2226+ 21C8 EB                   ex      DE,HL           ; Save code string address
2227+ 21C9 E3                   ex      (SP),HL         ; Save integer,HL = adj' token
2228+ 21CA C3 D5 21             jp      GOFUNC          ; Jump to string function
2229+ 21CD
2230+ 21CD CD 72 21     FNVAL:  call    EVLPAR          ; Evaluate expression
2231+ 21D0 E3                   ex      (SP),HL         ; HL = Adjusted token value
2232+ 21D1 11 86 21             ld      DE,RETNUM       ; Return number from function
2233+ 21D4 D5                   push    DE              ; Save on stack
2234+ 21D5 01 2D 13     GOFUNC: ld      BC,FNCTAB       ; Function routine addresses
2235+ 21D8 09                   add     HL,BC           ; Point to right address
2236+ 21D9 4E                   ld      C,(HL)          ; Get LSB of address
2237+ 21DA 23                   inc     HL              ;
2238+ 21DB 66                   ld      H,(HL)          ; Get MSB of address
2239+ 21DC 69                   ld      L,C             ; Address to HL
2240+ 21DD E9                   jp      (HL)            ; Jump to function
2241+ 21DE
2242+ 21DE 15           SGNEXP: dec     D               ; Dee to flag negative exponent
2243+ 21DF FE BE                cp      ZMINUS          ; '-' token ?
2244+ 21E1 C8                   ret     Z               ; Yes - Return
2245+ 21E2 FE 2D                cp      '-'             ; '-' ASCII ?
2246+ 21E4 C8                   ret     Z               ; Yes - Return
2247+ 21E5 14                   inc     D               ; Inc to flag positive exponent
2248+ 21E6 FE 2B                cp      '+'             ; '+' ASCII ?
2249+ 21E8 C8                   ret     Z               ; Yes - Return
2250+ 21E9 FE BD                cp      ZPLUS           ; '+' token ?
2251+ 21EB C8                   ret     Z               ; Yes - Return
2252+ 21EC 2B                   dec     HL              ; dec 'cos GETCHR INCs
2253+ 21ED C9                   ret                     ; Return "NZ"
2254+ 21EE
2255+ 21EE              ; execute OR, AND, and XOR operations
2256+ 21EE AF           PAND:   xor     A               ; for AND, Z=1
2257+ 21EF 18 07                jr      CNTLGC
2258+ 21F1 AF           POR:    xor     A               ; for OR, Z=0, S=1
2259+ 21F2 D6 01                sub     $01
2260+ 21F4 18 02                jr      CNTLGC
2261+ 21F6 AF           PXOR:   xor     A               ; for XOR, Z=0, S=0
2262+ 21F7 3C                   inc     A
2263+ 21F8 F5           CNTLGC: push    AF              ; store operand's flags
2264+ 21F9 CD 9E 20             call    TSTNUM          ; Make sure it's a number
2265+ 21FC CD C8 1C             call    DEINT           ; Get integer -32768 to 32767
2266+ 21FF F1                   pop     AF              ; retrieve operand's flags
2267+ 2200 EB                   ex      DE,HL           ; <- Get last
2268+ 2201 C1                   pop     BC              ; <-  value
2269+ 2202 E3                   ex      (SP),HL         ; <-  from
2270+ 2203 EB                   ex      DE,HL           ; <-  stack
2271+ 2204 CD E9 2E             call    FPBCDE          ; Move last value to FPREG
2272+ 2207 F5                   push    AF              ; store operand's flags
2273+ 2208 CD C8 1C             call    DEINT           ; Get integer -32768 to 32767
2274+ 220B F1                   pop     AF              ; retrieve operand's flags
2275+ 220C C1                   pop     BC              ; Get value
2276+ 220D 79                   ld      A,C             ; Get LSB
2277+ 220E 21 84 24             ld      HL,ACPASS       ; Address of save AC as current
2278+ 2211 20 05                jr      NZ,POR1         ; if X/OR, jump over
2279+ 2213 A3           PAND1:  and     E               ; "AND" LSBs
2280+ 2214 4F                   ld      C,A             ; Save LSB
2281+ 2215 78                   ld      A,B             ; Get MSB
2282+ 2216 A2                   and     D               ; "AND" MSBs
2283+ 2217 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2284+ 2218 F2 20 22     POR1:   jp      P,PXOR1         ; if S=0, jump to XOR
2285+ 221B B3                   or      E               ; "OR" LSBs
2286+ 221C 4F                   ld      C,A             ; Save LSB
2287+ 221D 78                   ld      A,B             ; Get MSB
2288+ 221E B2                   or      D               ; "OR" MSBs
2289+ 221F E9                   jp      (HL)            ; Save AC as current (ACPASS)
2290+ 2220 AB           PXOR1:  xor     E               ; "XOR" LSBs
2291+ 2221 4F                   ld      C,A             ; Save LSB
2292+ 2222 78                   ld      A,B             ; Get MSB
2293+ 2223 AA                   xor     D               ; "XOR" MSBs
2294+ 2224 E9                   jp      (HL)            ; Save AC as current (ACPASS)
2295+ 2225
2296+ 2225 21 37 22     TSTRED: ld      HL,CMPLOG       ; Logical compare routine
2297+ 2228 3A 94 81             ld      A,(TYPE)        ; Get data type
2298+ 222B 1F                   rra                     ; Carry set = string
2299+ 222C 7A                   ld      A,D             ; Get last precedence value
2300+ 222D 17                   rla                     ; Times 2 plus carry
2301+ 222E 5F                   ld      E,A             ; To E
2302+ 222F 16 64                ld      D,$64           ; Relational precedence
2303+ 2231 78                   ld      A,B             ; Get current precedence
2304+ 2232 BA                   cp      D               ; Compare with last
2305+ 2233 D0                   ret     NC              ; Eval if last was rel' or log'
2306+ 2234 C3 0D 21             jp      STKTHS          ; Stack this one and get next
2307+ 2237
2308+ 2237 39 22        CMPLOG: defw    CMPLG1          ; Compare two values / strings
2309+ 2239 79           CMPLG1: ld      A,C             ; Get data type
2310+ 223A B7                   or      A
2311+ 223B 1F                   rra
2312+ 223C C1                   pop     BC              ; Get last expression to BCDE
2313+ 223D D1                   pop     DE
2314+ 223E F5                   push    AF              ; Save status
2315+ 223F CD A0 20             call    CHKTYP          ; Check that types match
2316+ 2242 21 7B 22             ld      HL,CMPRES       ; Result to comparison
2317+ 2245 E5                   push    HL              ; Save for RETurn
2318+ 2246 CA 23 2F             jp      Z,CMPNUM        ; Compare values if numeric
2319+ 2249 AF                   xor     A               ; Compare two strings
2320+ 224A 32 94 81             ld      (TYPE),A        ; Set type to numeric
2321+ 224D D5                   push    DE              ; Save string name
2322+ 224E CD E6 26             call    GSTRCU          ; Get current string
2323+ 2251 7E                   ld      A,(HL)          ; Get length of string
2324+ 2252 23                   inc     HL
2325+ 2253 23                   inc     HL
2326+ 2254 4E                   ld      C,(HL)          ; Get LSB of address
2327+ 2255 23                   inc     HL
2328+ 2256 46                   ld      B,(HL)          ; Get MSB of address
2329+ 2257 D1                   pop     DE              ; Restore string name
2330+ 2258 C5                   push    BC              ; Save address of string
2331+ 2259 F5                   push    AF              ; Save length of string
2332+ 225A CD EA 26             call    GSTRDE          ; Get second string
2333+ 225D CD F7 2E             call    LOADFP          ; Get address of second string
2334+ 2260 F1                   pop     AF              ; Restore length of string 1
2335+ 2261 57                   ld      D,A             ; Length to D
2336+ 2262 E1                   pop     HL              ; Restore address of string 1
2337+ 2263 7B           CMPSTR: ld      A,E             ; Bytes of string 2 to do
2338+ 2264 B2                   or      D               ; Bytes of string 1 to do
2339+ 2265 C8                   ret     Z               ; Exit if all bytes compared
2340+ 2266 7A                   ld      A,D             ; Get bytes of string 1 to do
2341+ 2267 D6 01                sub     $01
2342+ 2269 D8                   ret     C               ; Exit if end of string 1
2343+ 226A AF                   xor     A
2344+ 226B BB                   cp      E               ; Bytes of string 2 to do
2345+ 226C 3C                   inc     A
2346+ 226D D0                   ret     NC              ; Exit if end of string 2
2347+ 226E 15                   dec     D               ; Count bytes in string 1
2348+ 226F 1D                   dec     E               ; Count bytes in string 2
2349+ 2270 0A                   ld      A,(BC)          ; Byte in string 2
2350+ 2271 BE                   cp      (HL)            ; Compare to byte in string 1
2351+ 2272 23                   inc     HL              ; Move up string 1
2352+ 2273 03                   inc     BC              ; Move up string 2
2353+ 2274 CA 63 22             jp      Z,CMPSTR        ; Same - Try next bytes
2354+ 2277 3F                   ccf                     ; Flag difference (">" or "<")
2355+ 2278 C3 B3 2E             jp      FLGDIF          ; "<" gives -1 , ">" gives +1
2356+ 227B
2357+ 227B 3C           CMPRES: inc     A               ; Increment current value
2358+ 227C 8F                   adc     A,A             ; Double plus carry
2359+ 227D C1                   pop     BC              ; Get other value
2360+ 227E A0                   and     B               ; Combine them
2361+ 227F C6 FF                add     A,-1            ; Carry set if different
2362+ 2281 9F                   sbc     A,A             ; 00 - Equal , FF - Different
2363+ 2282 C3 BA 2E             jp      FLGREL          ; Set current value & continue
2364+ 2285
2365+ 2285 16 5A        EVNOT:  ld      D,$5A           ; Precedence value for "NOT"
2366+ 2287 CD B0 20             call    EVAL1           ; Eval until precedence break
2367+ 228A CD 9E 20             call    TSTNUM          ; Make sure it's a number
2368+ 228D CD C8 1C             call    DEINT           ; Get integer -32768 - 32767
2369+ 2290 7B                   ld      A,E             ; Get LSB
2370+ 2291 2F                   cpl                     ; Invert LSB
2371+ 2292 4F                   ld      C,A             ; Save "NOT" of LSB
2372+ 2293 7A                   ld      A,D             ; Get MSB
2373+ 2294 2F                   cpl                     ; Invert MSB
2374+ 2295 CD 84 24             call    ACPASS          ; Save AC as current
2375+ 2298 C1                   pop     BC              ; Clean up stack
2376+ 2299 C3 BC 20             jp      EVAL3           ; Continue evaluation
2377+ 229C
2378+ 229C 2B           DIMRET: dec     HL              ; dec 'cos GETCHR INCs
2379+ 229D CD 12 1C             call    GETCHR          ; Get next character
2380+ 22A0 C8                   ret     Z               ; End of DIM statement
2381+ 22A1 CD D1 19             call    CHKSYN          ; Make sure ',' follows
2382+ 22A4 2C                   defb    ','
2383+ 22A5 01 9C 22     DIM:    ld      BC,DIMRET       ; Return to "DIMRET"
2384+ 22A8 C5                   push    BC              ; Save on stack
2385+ 22A9 F6                   defb    $F6             ; Flag "Create" variable
2386+ 22AA AF           GETVAR: xor     A               ; Find variable address,to DE
2387+ 22AB 32 93 81             ld      (LCRFLG),A      ; Set locate / create flag
2388+ 22AE 46                   ld      B,(HL)          ; Get First byte of name
2389+ 22AF CD B4 1C     GTFNAM: call    CHKLTR          ; See if a letter
2390+ 22B2 DA EF 16             jp      C,SNERR         ; ?SN Error if not a letter
2391+ 22B5 AF                   xor     A
2392+ 22B6 4F                   ld      C,A             ; Clear second byte of name
2393+ 22B7 32 94 81             ld      (TYPE),A        ; Set type to numeric
2394+ 22BA CD 12 1C             call    GETCHR          ; Get next character
2395+ 22BD DA C6 22             jp      C,SVNAM2        ; Numeric - Save in name
2396+ 22C0 CD B4 1C             call    CHKLTR          ; See if a letter
2397+ 22C3 DA D3 22             jp      C,CHARTY        ; Not a letter - Check type
2398+ 22C6 4F           SVNAM2: ld      C,A             ; Save second byte of name
2399+ 22C7 CD 12 1C     ENDNAM: call    GETCHR          ; Get next character
2400+ 22CA DA C7 22             jp      C,ENDNAM        ; Numeric - Get another
2401+ 22CD CD B4 1C             call    CHKLTR          ; See if a letter
2402+ 22D0 D2 C7 22             jp      NC,ENDNAM       ; Letter - Get another
2403+ 22D3 D6 24        CHARTY: sub     '$'             ; String variable?
2404+ 22D5 C2 E2 22             jp      NZ,NOTSTR       ; No - Numeric variable
2405+ 22D8 3C                   inc     A               ; A = 1 (string type)
2406+ 22D9 32 94 81             ld      (TYPE),A        ; Set type to string
2407+ 22DC 0F                   rrca                    ; A = 80H , Flag for string
2408+ 22DD 81                   add     A,C             ; 2nd byte of name has bit 7 on
2409+ 22DE 4F                   ld      C,A             ; Resave second byte on name
2410+ 22DF CD 12 1C             call    GETCHR          ; Get next character
2411+ 22E2 3A B2 81     NOTSTR: ld      A,(FORFLG)      ; Array name needed ?
2412+ 22E5 3D                   dec     A
2413+ 22E6 CA 8F 23             jp      Z,ARLDSV        ; Yes - Get array name
2414+ 22E9 F2 F2 22             jp      P,NSCFOR        ; No array with "FOR" or "FN"
2415+ 22EC 7E                   ld      A,(HL)          ; Get byte again
2416+ 22ED D6 28                sub     '('             ; Subscripted variable?
2417+ 22EF CA 67 23             jp      Z,SBSCPT        ; Yes - Sort out subscript
2418+ 22F2
2419+ 22F2 AF           NSCFOR: xor     A               ; Simple variable
2420+ 22F3 32 B2 81             ld      (FORFLG),A      ; Clear "FOR" flag
2421+ 22F6 E5                   push    HL              ; Save code string address
2422+ 22F7 50                   ld      D,B             ; DE = Variable name to find
2423+ 22F8 59                   ld      E,C
2424+ 22F9 2A 2C 82             ld      HL,(FNRGNM)     ; FN argument name
2425+ 22FC CD CB 19             call    CPDEHL          ; Is it the FN argument?
2426+ 22FF 11 2E 82             ld      DE,FNARG        ; Point to argument value
2427+ 2302 CA 98 2D             jp      Z,POPHRT        ; Yes - Return FN argument value
2428+ 2305 2A 26 82             ld      HL,(VAREND)     ; End of variables
2429+ 2308 EB                   ex      DE,HL           ; Address of end of search
2430+ 2309 2A 24 82             ld      HL,(PROGND)     ; Start of variables address
2431+ 230C CD CB 19     FNDVAR: call    CPDEHL          ; End of variable list table?
2432+ 230F CA 25 23             jp      Z,CFEVAL        ; Yes - Called from EVAL?
2433+ 2312 79                   ld      A,C             ; Get second byte of name
2434+ 2313 96                   sub     (HL)            ; Compare with name in list
2435+ 2314 23                   inc     HL              ; Move on to first byte
2436+ 2315 C2 1A 23             jp      NZ,FNTHR        ; Different - Find another
2437+ 2318 78                   ld      A,B             ; Get first byte of name
2438+ 2319 96                   sub     (HL)            ; Compare with name in list
2439+ 231A 23           FNTHR:  inc     HL              ; Move on to LSB of value
2440+ 231B CA 59 23             jp      Z,RETADR        ; Found - Return address
2441+ 231E 23                   inc     HL              ; <- Skip
2442+ 231F 23                   inc     HL              ; <- over
2443+ 2320 23                   inc     HL              ; <- F.P.
2444+ 2321 23                   inc     HL              ; <- value
2445+ 2322 C3 0C 23             jp      FNDVAR          ; Keep looking
2446+ 2325
2447+ 2325 E1           CFEVAL: pop     HL              ; Restore code string address
2448+ 2326 E3                   ex      (SP),HL         ; Get return address
2449+ 2327 D5                   push    DE              ; Save address of variable
2450+ 2328 11 8E 21             ld      DE,FRMEVL       ; Return address in EVAL
2451+ 232B CD CB 19             call    CPDEHL          ; Called from EVAL ?
2452+ 232E D1                   pop     DE              ; Restore address of variable
2453+ 232F CA 5C 23             jp      Z,RETNUL        ; Yes - Return null variable
2454+ 2332 E3                   ex      (SP),HL         ; Put back return
2455+ 2333 E5                   push    HL              ; Save code string address
2456+ 2334 C5                   push    BC              ; Save variable name
2457+ 2335 01 06 00             ld      BC,$0006        ; 2 byte name plus 4 byte data
2458+ 2338 2A 28 82             ld      HL,(ARREND)     ; End of arrays
2459+ 233B E5                   push    HL              ; Save end of arrays
2460+ 233C 09                   add     HL,BC           ; Move up 6 bytes
2461+ 233D C1                   pop     BC              ; Source address in BC
2462+ 233E E5                   push    HL              ; Save new end address
2463+ 233F CD 9B 16             call    MOVUP           ; Move arrays up
2464+ 2342 E1                   pop     HL              ; Restore new end address
2465+ 2343 22 28 82             ld      (ARREND),HL     ; Set new end address
2466+ 2346 60                   ld      H,B             ; End of variables to HL
2467+ 2347 69                   ld      L,C
2468+ 2348 22 26 82             ld      (VAREND),HL     ; Set new end address
2469+ 234B
2470+ 234B 2B           ZEROLP: dec     HL              ; Back through to zero variable
2471+ 234C 36 00                ld      (HL),$00        ; Zero byte in variable
2472+ 234E CD CB 19             call    CPDEHL          ; Done them all?
2473+ 2351 C2 4B 23             jp      NZ,ZEROLP       ; No - Keep on going
2474+ 2354 D1                   pop     DE              ; Get variable name
2475+ 2355 73                   ld      (HL),E          ; Store second character
2476+ 2356 23                   inc     HL
2477+ 2357 72                   ld      (HL),D          ; Store first character
2478+ 2358 23                   inc     HL
2479+ 2359 EB           RETADR: ex      DE,HL           ; Address of variable in DE
2480+ 235A E1                   pop     HL              ; Restore code string address
2481+ 235B C9                   ret
2482+ 235C
2483+ 235C 32 35 82     RETNUL: ld      (FPEXP),A       ; Set result to zero
2484+ 235F 21 6C 16             ld      HL,ZERBYT       ; Also set a null string
2485+ 2362 22 32 82             ld      (FPREG),HL      ; Save for EVAL
2486+ 2365 E1                   pop     HL              ; Restore code string address
2487+ 2366 C9                   ret
2488+ 2367
2489+ 2367 E5           SBSCPT: push    HL              ; Save code string address
2490+ 2368 2A 93 81             ld      HL,(LCRFLG)     ; Locate/Create and Type
2491+ 236B E3                   ex      (SP),HL         ; Save and get code string
2492+ 236C 57                   ld      D,A             ; Zero number of dimensions
2493+ 236D D5           SCPTLP: push    DE              ; Save number of dimensions
2494+ 236E C5                   push    BC              ; Save array name
2495+ 236F CD BC 1C             call    FPSINT          ; Get subscript (0-32767)
2496+ 2372 C1                   pop     BC              ; Restore array name
2497+ 2373 F1                   pop     AF              ; Get number of dimensions
2498+ 2374 EB                   ex      DE,HL
2499+ 2375 E3                   ex      (SP),HL         ; Save subscript value
2500+ 2376 E5                   push    HL              ; Save LCRFLG and TYPE
2501+ 2377 EB                   ex      DE,HL
2502+ 2378 3C                   inc     A               ; Count dimensions
2503+ 2379 57                   ld      D,A             ; Save in D
2504+ 237A 7E                   ld      A,(HL)          ; Get next byte in code string
2505+ 237B FE 2C                cp      ','             ; Comma (more to come)?
2506+ 237D CA 6D 23             jp      Z,SCPTLP        ; Yes - More subscripts
2507+ 2380 CD D1 19             call    CHKSYN          ; Make sure ")" follows
2508+ 2383 29                   defb    ')'
2509+ 2384 22 B7 81             ld      (NXTOPR),HL     ; Save code string address
2510+ 2387 E1                   pop     HL              ; Get LCRFLG and TYPE
2511+ 2388 22 93 81             ld      (LCRFLG),HL     ; Restore Locate/create & type
2512+ 238B 1E 00                ld      E,$00           ; Flag not CSAVE* or CLOAD*
2513+ 238D D5                   push    DE              ; Save number of dimensions (D)
2514+ 238E 11                   defb    $11             ; Skip "push HL" and "push AF'
2515+ 238F
2516+ 238F E5           ARLDSV: push    HL              ; Save code string address
2517+ 2390 F5                   push    AF              ; A = 00 , Flags set = Z,N
2518+ 2391 2A 26 82             ld      HL,(VAREND)     ; Start of arrays
2519+ 2394 3E                   defb    $3E             ; Skip "add HL,DE"
2520+ 2395 19           FNDARY: add     HL,DE           ; Move to next array start
2521+ 2396 EB                   ex      DE,HL
2522+ 2397 2A 28 82             ld      HL,(ARREND)     ; End of arrays
2523+ 239A EB                   ex      DE,HL           ; Current array pointer
2524+ 239B CD CB 19             call    CPDEHL          ; End of arrays found?
2525+ 239E CA C7 23             jp      Z,CREARY        ; Yes - Create array
2526+ 23A1 7E                   ld      A,(HL)          ; Get second byte of name
2527+ 23A2 B9                   cp      C               ; Compare with name given
2528+ 23A3 23                   inc     HL              ; Move on
2529+ 23A4 C2 A9 23             jp      NZ,NXTARY       ; Different - Find next array
2530+ 23A7 7E                   ld      A,(HL)          ; Get first byte of name
2531+ 23A8 B8                   cp      B               ; Compare with name given
2532+ 23A9 23           NXTARY: inc     HL              ; Move on
2533+ 23AA 5E                   ld      E,(HL)          ; Get LSB of next array address
2534+ 23AB 23                   inc     HL
2535+ 23AC 56                   ld      D,(HL)          ; Get MSB of next array address
2536+ 23AD 23                   inc     HL
2537+ 23AE C2 95 23             jp      NZ,FNDARY       ; Not found - Keep looking
2538+ 23B1 3A 93 81             ld      A,(LCRFLG)      ; Found Locate or Create it?
2539+ 23B4 B7                   or      A
2540+ 23B5 C2 F8 16             jp      NZ,DDERR        ; Create - ?DD Error
2541+ 23B8 F1                   pop     AF              ; Locate - Get number of dim'ns
2542+ 23B9 44                   ld      B,H             ; BC Points to array dim'ns
2543+ 23BA 4D                   ld      C,L
2544+ 23BB CA 98 2D             jp      Z,POPHRT        ; Jump if array load/save
2545+ 23BE 96                   sub     (HL)            ; Same number of dimensions?
2546+ 23BF CA 25 24             jp      Z,FINDEL        ; Yes - Find element
2547+ 23C2 1E 10        BSERR:  ld      E,BS            ; ?BS Error
2548+ 23C4 C3 03 17             jp      ERROR           ; Output error
2549+ 23C7
2550+ 23C7 11 04 00     CREARY: ld      DE,$0004        ; 4 Bytes per entry
2551+ 23CA F1                   pop     AF              ; Array to save or 0 dim'ns?
2552+ 23CB CA DD 1C             jp      Z,FCERR         ; Yes - ?FC Error
2553+ 23CE 71                   ld      (HL),C          ; Save second byte of name
2554+ 23CF 23                   inc     HL
2555+ 23D0 70                   ld      (HL),B          ; Save first byte of name
2556+ 23D1 23                   inc     HL
2557+ 23D2 4F                   ld      C,A             ; Number of dimensions to C
2558+ 23D3 CD AC 16             call    CHKSTK          ; Check if enough memory
2559+ 23D6 23                   inc     HL              ; Point to number of dimensions
2560+ 23D7 23                   inc     HL
2561+ 23D8 22 AC 81             ld      (CUROPR),HL     ; Save address of pointer
2562+ 23DB 71                   ld      (HL),C          ; Set number of dimensions
2563+ 23DC 23                   inc     HL
2564+ 23DD 3A 93 81             ld      A,(LCRFLG)      ; Locate of Create?
2565+ 23E0 17                   rla                     ; Carry set = Create
2566+ 23E1 79                   ld      A,C             ; Get number of dimensions
2567+ 23E2 01 0B 00     CRARLP: ld      BC,10+1         ; Default dimension size 10
2568+ 23E5 D2 EA 23             jp      NC,DEFSIZ       ; Locate - Set default size
2569+ 23E8 C1                   pop     BC              ; Get specified dimension size
2570+ 23E9 03                   inc     BC              ; Include zero element
2571+ 23EA 71           DEFSIZ: ld      (HL),C          ; Save LSB of dimension size
2572+ 23EB 23                   inc     HL
2573+ 23EC 70                   ld      (HL),B          ; Save MSB of dimension size
2574+ 23ED 23                   inc     HL
2575+ 23EE F5                   push    AF              ; Save num' of dim'ns an status
2576+ 23EF E5                   push    HL              ; Save address of dim'n size
2577+ 23F0 CD 94 2F             call    MLDEBC          ; Multiply DE by BC to find
2578+ 23F3 EB                   ex      DE,HL           ; amount of mem needed (to DE)
2579+ 23F4 E1                   pop     HL              ; Restore address of dimension
2580+ 23F5 F1                   pop     AF              ; Restore number of dimensions
2581+ 23F6 3D                   dec     A               ; Count them
2582+ 23F7 C2 E2 23             jp      NZ,CRARLP       ; Do next dimension if more
2583+ 23FA F5                   push    AF              ; Save locate/create flag
2584+ 23FB 42                   ld      B,D             ; MSB of memory needed
2585+ 23FC 4B                   ld      C,E             ; LSB of memory needed
2586+ 23FD EB                   ex      DE,HL
2587+ 23FE 19                   add     HL,DE           ; Add bytes to array start
2588+ 23FF DA C4 16             jp      C,OMERR         ; Too big - Error
2589+ 2402 CD B5 16             call    ENFMEM          ; See if enough memory
2590+ 2405 22 28 82             ld      (ARREND),HL     ; Save new end of array
2591+ 2408
2592+ 2408 2B           ZERARY: dec     HL              ; Back through array data
2593+ 2409 36 00                ld      (HL),$00        ; Set array element to zero
2594+ 240B CD CB 19             call    CPDEHL          ; All elements zeroed?
2595+ 240E C2 08 24             jp      NZ,ZERARY       ; No - Keep on going
2596+ 2411 03                   inc     BC              ; Number of bytes + 1
2597+ 2412 57                   ld      D,A             ; A=0
2598+ 2413 2A AC 81             ld      HL,(CUROPR)     ; Get address of array
2599+ 2416 5E                   ld      E,(HL)          ; Number of dimensions
2600+ 2417 EB                   ex      DE,HL           ; To HL
2601+ 2418 29                   add     HL,HL           ; Two bytes per dimension size
2602+ 2419 09                   add     HL,BC           ; Add number of bytes
2603+ 241A EB                   ex      DE,HL           ; Bytes needed to DE
2604+ 241B 2B                   dec     HL
2605+ 241C 2B                   dec     HL
2606+ 241D 73                   ld      (HL),E          ; Save LSB of bytes needed
2607+ 241E 23                   inc     HL
2608+ 241F 72                   ld      (HL),D          ; Save MSB of bytes needed
2609+ 2420 23                   inc     HL
2610+ 2421 F1                   pop     AF              ; Locate / Create?
2611+ 2422 DA 49 24             jp      C,ENDDIM        ; A is 0 , End if create
2612+ 2425 47           FINDEL: ld      B,A             ; Find array element
2613+ 2426 4F                   ld      C,A
2614+ 2427 7E                   ld      A,(HL)          ; Number of dimensions
2615+ 2428 23                   inc     HL
2616+ 2429 16                   defb    $16             ; Skip "pop HL"
2617+ 242A E1           FNDELP: pop     HL              ; Address of next dim' size
2618+ 242B 5E                   ld      E,(HL)          ; Get LSB of dim'n size
2619+ 242C 23                   inc     HL
2620+ 242D 56                   ld      D,(HL)          ; Get MSB of dim'n size
2621+ 242E 23                   inc     HL
2622+ 242F E3                   ex      (SP),HL         ; Save address - Get index
2623+ 2430 F5                   push    AF              ; Save number of dim'ns
2624+ 2431 CD CB 19             call    CPDEHL          ; Dimension too large?
2625+ 2434 D2 C2 23             jp      NC,BSERR        ; Yes - ?BS Error
2626+ 2437 E5                   push    HL              ; Save index
2627+ 2438 CD 94 2F             call    MLDEBC          ; Multiply previous by size
2628+ 243B D1                   pop     DE              ; Index supplied to DE
2629+ 243C 19                   add     HL,DE           ; Add index to pointer
2630+ 243D F1                   pop     AF              ; Number of dimensions
2631+ 243E 3D                   dec     A               ; Count them
2632+ 243F 44                   ld      B,H             ; MSB of pointer
2633+ 2440 4D                   ld      C,L             ; LSB of pointer
2634+ 2441 C2 2A 24             jp      NZ,FNDELP       ; More - Keep going
2635+ 2444 29                   add     HL,HL           ; 4 Bytes per element
2636+ 2445 29                   add     HL,HL
2637+ 2446 C1                   pop     BC              ; Start of array
2638+ 2447 09                   add     HL,BC           ; Point to element
2639+ 2448 EB                   ex      DE,HL           ; Address of element to DE
2640+ 2449 2A B7 81     ENDDIM: ld      HL,(NXTOPR)     ; Got code string address
2641+ 244C C9                   ret
2642+ 244D
2643+ 244D
2644+ 244D              ; returns the value of the 32-bit system tick counter as
2645+ 244D              ; two 16-bit words
2646+ 244D CD 9E 20     TMR:    call    TSTNUM          ; Make sure it's a number
2647+ 2450 CD C8 1C             call    DEINT           ; Get integer (-32768 to 32767)
2648+ 2453 2A BD 81             ld      HL,(TMRCNT)     ; load the LSBytes of timer
2649+ 2456 7B                   ld      A,E
2650+ 2457 B2                   or      D               ; is it 0?
2651+ 2458 CA 5E 24             jp      Z,ENDTMR        ; yes, jump over
2652+ 245B 2A BF 81             ld      HL,(TMRCNT+2)   ; load the MSBytes of timer
2653+ 245E 45           ENDTMR: ld      B,L             ; move bytes...
2654+ 245F 7C                   ld      A,H             ; ...into AB
2655+ 2460 C3 85 24             jp      ABPASS          ; return word into AB
2656+ 2463
2657+ 2463
2658+ 2463              ; returns the free space for BASIC or into the string pool
2659+ 2463 2A 28 82     FRE:    ld      HL,(ARREND)     ; Start of free memory
2660+ 2466 EB                   ex      DE,HL           ; To DE
2661+ 2467 21 00 00             ld      HL,$0000        ; End of free memory
2662+ 246A 39                   add     HL,SP           ; Current stack value
2663+ 246B 3A 94 81             ld      A,(TYPE)        ; Dummy argument type
2664+ 246E B7                   or      A
2665+ 246F CA 7F 24             jp      Z,FRENUM        ; Numeric - Free variable space
2666+ 2472 CD E6 26             call    GSTRCU          ; Current string to pool
2667+ 2475 CD E6 25             call    GARBGE          ; Garbage collection
2668+ 2478 2A AD 80             ld      HL,(STRSPC)     ; Bottom of string space in use
2669+ 247B EB                   ex      DE,HL           ; To DE
2670+ 247C 2A AA 81             ld      HL,(STRBOT)     ; Bottom of string space
2671+ 247F 7D           FRENUM: ld      A,L             ; Get LSB of end
2672+ 2480 93                   sub     E               ; Subtract LSB of beginning
2673+ 2481 4F                   ld      C,A             ; Save difference if C
2674+ 2482 7C                   ld      A,H             ; Get MSB of end
2675+ 2483 9A                   sbc     A,D             ; Subtract MSB of beginning
2676+ 2484 41           ACPASS: ld      B,C             ; Return integer AC
2677+ 2485 50           ABPASS: ld      D,B             ; Return integer AB
2678+ 2486 1E 00                ld      E,$00
2679+ 2488 21 94 81             ld      HL,TYPE         ; Point to type
2680+ 248B 73                   ld      (HL),E          ; Set type to numeric
2681+ 248C 06 90                ld      B,$80+$10       ; 16 bit integer
2682+ 248E C3 BF 2E             jp      RETINT          ; Return the integer
2683+ 2491
2684+ 2491              ; returns the X position of the cursor during a print
2685+ 2491 3A 92 81     POS:    ld      A,(CURPOS)      ; Get cursor position
2686+ 2494 47           PASSA:  ld      B,A             ; Put A into AB
2687+ 2495 AF                   xor     A               ; Zero A
2688+ 2496 C3 85 24             jp      ABPASS          ; Return integer AB
2689+ 2499
2690+ 2499 CD 1C 25     DEF:    call    CHEKFN          ; Get "FN" and name
2691+ 249C CD 0E 25             call    IDTEST          ; Test for illegal direct
2692+ 249F 01 BB 1D             ld      BC,DATA         ; To get next statement
2693+ 24A2 C5                   push    BC              ; Save address for RETurn
2694+ 24A3 D5                   push    DE              ; Save address of function ptr
2695+ 24A4 CD D1 19             call    CHKSYN          ; Make sure "(" follows
2696+ 24A7 28                   defb    '('
2697+ 24A8 CD AA 22             call    GETVAR          ; Get argument variable name
2698+ 24AB E5                   push    HL              ; Save code string address
2699+ 24AC EB                   ex      DE,HL           ; Argument address to HL
2700+ 24AD 2B                   dec     HL
2701+ 24AE 56                   ld      D,(HL)          ; Get first byte of arg name
2702+ 24AF 2B                   dec     HL
2703+ 24B0 5E                   ld      E,(HL)          ; Get second byte of arg name
2704+ 24B1 E1                   pop     HL              ; Restore code string address
2705+ 24B2 CD 9E 20             call    TSTNUM          ; Make sure numeric argument
2706+ 24B5 CD D1 19             call    CHKSYN          ; Make sure ")" follows
2707+ 24B8 29                   defb    ')'
2708+ 24B9 CD D1 19             call    CHKSYN          ; Make sure "=" follows
2709+ 24BC C8                   defb    ZEQUAL          ; "=" token
2710+ 24BD 44                   ld      B,H             ; Code string address to BC
2711+ 24BE 4D                   ld      C,L
2712+ 24BF E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2713+ 24C0 71                   ld      (HL),C          ; Save LSB of FN code string
2714+ 24C1 23                   inc     HL
2715+ 24C2 70                   ld      (HL),B          ; Save MSB of FN code string
2716+ 24C3 C3 5B 25             jp      SVSTAD          ; Save address and do function
2717+ 24C6
2718+ 24C6 CD 1C 25     DOFN:   call    CHEKFN          ; Make sure FN follows
2719+ 24C9 D5                   push    DE              ; Save function pointer address
2720+ 24CA CD 72 21             call    EVLPAR          ; Evaluate expression in "()"
2721+ 24CD CD 9E 20             call    TSTNUM          ; Make sure numeric result
2722+ 24D0 E3                   ex      (SP),HL         ; Save code str , Get FN ptr
2723+ 24D1 5E                   ld      E,(HL)          ; Get LSB of FN code string
2724+ 24D2 23                   inc     HL
2725+ 24D3 56                   ld      D,(HL)          ; Get MSB of FN code string
2726+ 24D4 23                   inc     HL
2727+ 24D5 7A                   ld      A,D             ; And function DEFined?
2728+ 24D6 B3                   or      E
2729+ 24D7 CA FB 16             jp      Z,UFERR         ; No - ?UF Error
2730+ 24DA 7E                   ld      A,(HL)          ; Get LSB of argument address
2731+ 24DB 23                   inc     HL
2732+ 24DC 66                   ld      H,(HL)          ; Get MSB of argument address
2733+ 24DD 6F                   ld      L,A             ; HL = Arg variable address
2734+ 24DE E5                   push    HL              ; Save it
2735+ 24DF 2A 2C 82             ld      HL,(FNRGNM)     ; Get old argument name
2736+ 24E2 E3                   ex      (SP),HL         ; Save old , Get new
2737+ 24E3 22 2C 82             ld      (FNRGNM),HL     ; Set new argument name
2738+ 24E6 2A 30 82             ld      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2739+ 24E9 E5                   push    HL              ; Save it
2740+ 24EA 2A 2E 82             ld      HL,(FNARG)      ; Get MSB,EXP of old arg value
2741+ 24ED E5                   push    HL              ; Save it
2742+ 24EE 21 2E 82             ld      HL,FNARG        ; HL = Value of argument
2743+ 24F1 D5                   push    DE              ; Save FN code string address
2744+ 24F2 CD 00 2F             call    FPTHL           ; Move FPREG to argument
2745+ 24F5 E1                   pop     HL              ; Get FN code string address
2746+ 24F6 CD 9B 20             call    GETNUM          ; Get value from function
2747+ 24F9 2B                   dec     HL              ; dec 'cos GETCHR INCs
2748+ 24FA CD 12 1C             call    GETCHR          ; Get next character
2749+ 24FD C2 EF 16             jp      NZ,SNERR        ; Bad character in FN - Error
2750+ 2500 E1                   pop     HL              ; Get MSB,EXP of old arg
2751+ 2501 22 2E 82             ld      (FNARG),HL      ; Restore it
2752+ 2504 E1                   pop     HL              ; Get LSB,NLSB of old arg
2753+ 2505 22 30 82             ld      (FNARG+2),HL    ; Restore it
2754+ 2508 E1                   pop     HL              ; Get name of old arg
2755+ 2509 22 2C 82             ld      (FNRGNM),HL     ; Restore it
2756+ 250C E1                   pop     HL              ; Restore code string address
2757+ 250D C9                   ret
2758+ 250E
2759+ 250E E5           IDTEST: push    HL              ; Save code string address
2760+ 250F 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
2761+ 2512 23                   inc     HL              ; -1 means direct statement
2762+ 2513 7C                   ld      A,H
2763+ 2514 B5                   or      L
2764+ 2515 E1                   pop     HL              ; Restore code string address
2765+ 2516 C0                   ret     NZ              ; Return if in program
2766+ 2517 1E 16                ld      E,ID            ; ?ID Error
2767+ 2519 C3 03 17             jp      ERROR
2768+ 251C
2769+ 251C CD D1 19     CHEKFN: call    CHKSYN          ; Make sure FN follows
2770+ 251F B8                   defb    ZFN             ; "FN" token
2771+ 2520 3E 80                ld      A,$80
2772+ 2522 32 B2 81             ld      (FORFLG),A      ; Flag FN name to find
2773+ 2525 B6                   or      (HL)            ; FN name has bit 7 set
2774+ 2526 47                   ld      B,A             ; in first byte of name
2775+ 2527 CD AF 22             call    GTFNAM          ; Get FN name
2776+ 252A C3 9E 20             jp      TSTNUM          ; Make sure numeric function
2777+ 252D
2778+ 252D CD 9E 20     STR:    call    TSTNUM          ; Make sure it's a number
2779+ 2530 CD 4D 30             call    NUMASC          ; Turn number into text
2780+ 2533 CD 61 25     STR1:   call    CRTST           ; Create string entry for it
2781+ 2536 CD E6 26             call    GSTRCU          ; Current string to pool
2782+ 2539 01 41 27             ld      BC,TOPOOL       ; Save in string pool
2783+ 253C C5                   push    BC              ; Save address on stack
2784+ 253D
2785+ 253D 7E           SAVSTR: ld      A,(HL)          ; Get string length
2786+ 253E 23                   inc     HL
2787+ 253F 23                   inc     HL
2788+ 2540 E5                   push    HL              ; Save pointer to string
2789+ 2541 CD BC 25             call    TESTR           ; See if enough string space
2790+ 2544 E1                   pop     HL              ; Restore pointer to string
2791+ 2545 4E                   ld      C,(HL)          ; Get LSB of address
2792+ 2546 23                   inc     HL
2793+ 2547 46                   ld      B,(HL)          ; Get MSB of address
2794+ 2548 CD 55 25             call    CRTMST          ; Create string entry
2795+ 254B E5                   push    HL              ; Save pointer to MSB of addr
2796+ 254C 6F                   ld      L,A             ; Length of string
2797+ 254D CD D9 26             call    TOSTRA          ; Move to string area
2798+ 2550 D1                   pop     DE              ; Restore pointer to MSB
2799+ 2551 C9                   ret
2800+ 2552
2801+ 2552 CD BC 25     MKTMST: call    TESTR           ; See if enough string space
2802+ 2555 21 A6 81     CRTMST: ld      HL,TMPSTR       ; Temporary string
2803+ 2558 E5                   push    HL              ; Save it
2804+ 2559 77                   ld      (HL),A          ; Save length of string
2805+ 255A 23                   inc     HL
2806+ 255B 23           SVSTAD: inc     HL
2807+ 255C 73                   ld      (HL),E          ; Save LSB of address
2808+ 255D 23                   inc     HL
2809+ 255E 72                   ld      (HL),D          ; Save MSB of address
2810+ 255F E1                   pop     HL              ; Restore pointer
2811+ 2560 C9                   ret
2812+ 2561
2813+ 2561 2B           CRTST:  dec     HL              ; dec - INCed after
2814+ 2562 06 22        QTSTR:  ld      B,$22           ; '"'           ; Terminating quote
2815+ 2564 50                   ld      D,B             ; Quote to D
2816+ 2565 E5           DTSTR:  push    HL              ; Save start
2817+ 2566 0E FF                ld      C,-1            ; Set counter to -1
2818+ 2568 23           QTSTLP: inc     HL              ; Move on
2819+ 2569 7E                   ld      A,(HL)          ; Get byte
2820+ 256A 0C                   inc     C               ; Count bytes
2821+ 256B B7                   or      A               ; End of line?
2822+ 256C CA 77 25             jp      Z,CRTSTE        ; Yes - Create string entry
2823+ 256F BA                   cp      D               ; Terminator D found?
2824+ 2570 CA 77 25             jp      Z,CRTSTE        ; Yes - Create string entry
2825+ 2573 B8                   cp      B               ; Terminator B found?
2826+ 2574 C2 68 25             jp      NZ,QTSTLP       ; No - Keep looking
2827+ 2577 FE 22        CRTSTE: cp      $22             ; '"'             ; End with '"'?
2828+ 2579 CC 12 1C             call    Z,GETCHR        ; Yes - Get next character
2829+ 257C E3                   ex      (SP),HL         ; Starting quote
2830+ 257D 23                   inc     HL              ; First byte of string
2831+ 257E EB                   ex      DE,HL           ; To DE
2832+ 257F 79                   ld      A,C             ; Get length
2833+ 2580 CD 55 25             call    CRTMST          ; Create string entry
2834+ 2583 11 A6 81     TSTOPL: ld      DE,TMPSTR       ; Temporary string
2835+ 2586 2A 98 81             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2836+ 2589 22 32 82             ld      (FPREG),HL      ; Save address of string ptr
2837+ 258C 3E 01                ld      A,$01
2838+ 258E 32 94 81             ld      (TYPE),A        ; Set type to string
2839+ 2591 CD 03 2F             call    DETHL4          ; Move string to pool
2840+ 2594 CD CB 19             call    CPDEHL          ; Out of string pool?
2841+ 2597 22 98 81             ld      (TMSTPT),HL     ; Save new pointer
2842+ 259A E1                   pop     HL              ; Restore code string address
2843+ 259B 7E                   ld      A,(HL)          ; Get next code byte
2844+ 259C C0                   ret     NZ              ; Return if pool OK
2845+ 259D 1E 1E                ld      E,ST            ; ?ST Error
2846+ 259F C3 03 17             jp      ERROR           ; String pool overflow
2847+ 25A2
2848+ 25A2 23           PRNUMS: inc     HL              ; Skip leading space
2849+ 25A3 CD 61 25     PRS:    call    CRTST           ; Create string entry for it
2850+ 25A6 CD E6 26     PRS1:   call    GSTRCU          ; Current string to pool
2851+ 25A9 CD F7 2E             call    LOADFP          ; Move string block to BCDE
2852+ 25AC 1C                   inc     E               ; Length + 1
2853+ 25AD 1D           PRSLP:  dec     E               ; Count characters
2854+ 25AE C8                   ret     Z               ; End of string
2855+ 25AF 0A                   ld      A,(BC)          ; Get byte to output
2856+ 25B0 CD DC 19             call    OUTC            ; Output character in A
2857+ 25B3 FE 0D                cp      CR              ; Return?
2858+ 25B5 CC E9 1E             call    Z,CNTEND        ; Yes - Position cursor to 0
2859+ 25B8 03                   inc     BC              ; Next byte in string
2860+ 25B9 C3 AD 25             jp      PRSLP           ; More characters to output
2861+ 25BC
2862+ 25BC B7           TESTR:  or      A               ; Test if enough room
2863+ 25BD 0E                   defb    $0E             ; No garbage collection done
2864+ 25BE F1           GRBDON: pop     AF              ; Garbage collection done
2865+ 25BF F5                   push    AF              ; Save status
2866+ 25C0 2A AD 80             ld      HL,(STRSPC)     ; Bottom of string space in use
2867+ 25C3 EB                   ex      DE,HL           ; To DE
2868+ 25C4 2A AA 81             ld      HL,(STRBOT)     ; Bottom of string area
2869+ 25C7 2F                   cpl                     ; Negate length (Top down)
2870+ 25C8 4F                   ld      C,A             ; -Length to BC
2871+ 25C9 06 FF                ld      B,-1            ; BC = -ve length of string
2872+ 25CB 09                   add     HL,BC           ; Add to bottom of space in use
2873+ 25CC 23                   inc     HL              ; Plus one for 2's complement
2874+ 25CD CD CB 19             call    CPDEHL          ; Below string RAM area?
2875+ 25D0 DA DA 25             jp      C,TESTOS        ; Tidy up if not done else err
2876+ 25D3 22 AA 81             ld      (STRBOT),HL     ; Save new bottom of area
2877+ 25D6 23                   inc     HL              ; Point to first byte of string
2878+ 25D7 EB                   ex      DE,HL           ; Address to DE
2879+ 25D8 F1           POPAF:  pop     AF              ; Throw away status push
2880+ 25D9 C9                   ret
2881+ 25DA
2882+ 25DA F1           TESTOS: pop     AF              ; Garbage collect been done?
2883+ 25DB 1E 1A                ld      E,OS            ; ?OS Error
2884+ 25DD CA 03 17             jp      Z,ERROR         ; Yes - Not enough string space
2885+ 25E0 BF                   cp      A               ; Flag garbage collect done
2886+ 25E1 F5                   push    AF              ; Save status
2887+ 25E2 01 BE 25             ld      BC,GRBDON       ; Garbage collection done
2888+ 25E5 C5                   push    BC              ; Save for RETurn
2889+ 25E6 2A 96 81     GARBGE: ld      HL,(LSTRAM)     ; Get end of RAM pointer
2890+ 25E9 22 AA 81     GARBLP: ld      (STRBOT),HL     ; Reset string pointer
2891+ 25EC 21 00 00             ld      HL,$0000
2892+ 25EF E5                   push    HL              ; Flag no string found
2893+ 25F0 2A AD 80             ld      HL,(STRSPC)     ; Get bottom of string space
2894+ 25F3 E5                   push    HL              ; Save bottom of string space
2895+ 25F4 21 9A 81             ld      HL,TMSTPL       ; Temporary string pool
2896+ 25F7 EB           GRBLP:  ex      DE,HL
2897+ 25F8 2A 98 81             ld      HL,(TMSTPT)     ; Temporary string pool pointer
2898+ 25FB EB                   ex      DE,HL
2899+ 25FC CD CB 19             call    CPDEHL          ; Temporary string pool done?
2900+ 25FF 01 F7 25             ld      BC,GRBLP        ; Loop until string pool done
2901+ 2602 C2 4B 26             jp      NZ,STPOOL       ; No - See if in string area
2902+ 2605 2A 24 82             ld      HL,(PROGND)     ; Start of simple variables
2903+ 2608 EB           SMPVAR: ex      DE,HL
2904+ 2609 2A 26 82             ld      HL,(VAREND)     ; End of simple variables
2905+ 260C EB                   ex      DE,HL
2906+ 260D CD CB 19             call    CPDEHL          ; All simple strings done?
2907+ 2610 CA 1E 26             jp      Z,ARRLP         ; Yes - Do string arrays
2908+ 2613 7E                   ld      A,(HL)          ; Get type of variable
2909+ 2614 23                   inc     HL
2910+ 2615 23                   inc     HL
2911+ 2616 B7                   or      A               ; "S" flag set if string
2912+ 2617 CD 4E 26             call    STRADD          ; See if string in string area
2913+ 261A C3 08 26             jp      SMPVAR          ; Loop until simple ones done
2914+ 261D
2915+ 261D C1           GNXARY: pop     BC              ; Scrap address of this array
2916+ 261E EB           ARRLP:  ex      DE,HL
2917+ 261F 2A 28 82             ld      HL,(ARREND)     ; End of string arrays
2918+ 2622 EB                   ex      DE,HL
2919+ 2623 CD CB 19             call    CPDEHL          ; All string arrays done?
2920+ 2626 CA 74 26             jp      Z,SCNEND        ; Yes - Move string if found
2921+ 2629 CD F7 2E             call    LOADFP          ; Get array name to BCDE
2922+ 262C 7B                   ld      A,E             ; Get type of array
2923+ 262D E5                   push    HL              ; Save address of num of dim'ns
2924+ 262E 09                   add     HL,BC           ; Start of next array
2925+ 262F B7                   or      A               ; Test type of array
2926+ 2630 F2 1D 26             jp      P,GNXARY        ; Numeric array - Ignore it
2927+ 2633 22 AC 81             ld      (CUROPR),HL     ; Save address of next array
2928+ 2636 E1                   pop     HL              ; Get address of num of dim'ns
2929+ 2637 4E                   ld      C,(HL)          ; BC = Number of dimensions
2930+ 2638 06 00                ld      B,$00
2931+ 263A 09                   add     HL,BC           ; Two bytes per dimension size
2932+ 263B 09                   add     HL,BC
2933+ 263C 23                   inc     HL              ; Plus one for number of dim'ns
2934+ 263D EB           GRBARY: ex      DE,HL
2935+ 263E 2A AC 81             ld      HL,(CUROPR)     ; Get address of next array
2936+ 2641 EB                   ex      DE,HL
2937+ 2642 CD CB 19             call    CPDEHL          ; Is this array finished?
2938+ 2645 CA 1E 26             jp      Z,ARRLP         ; Yes - Get next one
2939+ 2648 01 3D 26             ld      BC,GRBARY       ; Loop until array all done
2940+ 264B C5           STPOOL: push    BC              ; Save return address
2941+ 264C F6 80                or      $80             ; Flag string type
2942+ 264E 7E           STRADD: ld      A,(HL)          ; Get string length
2943+ 264F 23                   inc     HL
2944+ 2650 23                   inc     HL
2945+ 2651 5E                   ld      E,(HL)          ; Get LSB of string address
2946+ 2652 23                   inc     HL
2947+ 2653 56                   ld      D,(HL)          ; Get MSB of string address
2948+ 2654 23                   inc     HL
2949+ 2655 F0                   ret     P               ; Not a string - Return
2950+ 2656 B7                   or      A               ; Set flags on string length
2951+ 2657 C8                   ret     Z               ; Null string - Return
2952+ 2658 44                   ld      B,H             ; Save variable pointer
2953+ 2659 4D                   ld      C,L
2954+ 265A 2A AA 81             ld      HL,(STRBOT)     ; Bottom of new area
2955+ 265D CD CB 19             call    CPDEHL          ; String been done?
2956+ 2660 60                   ld      H,B             ; Restore variable pointer
2957+ 2661 69                   ld      L,C
2958+ 2662 D8                   ret     C               ; String done - Ignore
2959+ 2663 E1                   pop     HL              ; Return address
2960+ 2664 E3                   ex      (SP),HL         ; Lowest available string area
2961+ 2665 CD CB 19             call    CPDEHL          ; String within string area?
2962+ 2668 E3                   ex      (SP),HL         ; Lowest available string area
2963+ 2669 E5                   push    HL              ; Re-save return address
2964+ 266A 60                   ld      H,B             ; Restore variable pointer
2965+ 266B 69                   ld      L,C
2966+ 266C D0                   ret     NC              ; Outside string area - Ignore
2967+ 266D C1                   pop     BC              ; Get return , Throw 2 away
2968+ 266E F1                   pop     AF              ;
2969+ 266F F1                   pop     AF              ;
2970+ 2670 E5                   push    HL              ; Save variable pointer
2971+ 2671 D5                   push    DE              ; Save address of current
2972+ 2672 C5                   push    BC              ; Put back return address
2973+ 2673 C9                   ret                     ; Go to it
2974+ 2674
2975+ 2674 D1           SCNEND: pop     DE              ; Addresses of strings
2976+ 2675 E1                   pop     HL              ;
2977+ 2676 7D                   ld      A,L             ; HL = 0 if no more to do
2978+ 2677 B4                   or      H
2979+ 2678 C8                   ret     Z               ; No more to do - Return
2980+ 2679 2B                   dec     HL
2981+ 267A 46                   ld      B,(HL)          ; MSB of address of string
2982+ 267B 2B                   dec     HL
2983+ 267C 4E                   ld      C,(HL)          ; LSB of address of string
2984+ 267D E5                   push    HL              ; Save variable address
2985+ 267E 2B                   dec     HL
2986+ 267F 2B                   dec     HL
2987+ 2680 6E                   ld      L,(HL)          ; HL = Length of string
2988+ 2681 26 00                ld      H,$00
2989+ 2683 09                   add     HL,BC           ; Address of end of string+1
2990+ 2684 50                   ld      D,B             ; String address to DE
2991+ 2685 59                   ld      E,C
2992+ 2686 2B                   dec     HL              ; Last byte in string
2993+ 2687 44                   ld      B,H             ; Address to BC
2994+ 2688 4D                   ld      C,L
2995+ 2689 2A AA 81             ld      HL,(STRBOT)     ; Current bottom of string area
2996+ 268C CD 9E 16             call    MOVSTR          ; Move string to new address
2997+ 268F E1                   pop     HL              ; Restore variable address
2998+ 2690 71                   ld      (HL),C          ; Save new LSB of address
2999+ 2691 23                   inc     HL
3000+ 2692 70                   ld      (HL),B          ; Save new MSB of address
3001+ 2693 69                   ld      L,C             ; Next string area+1 to HL
3002+ 2694 60                   ld      H,B
3003+ 2695 2B                   dec     HL              ; Next string area address
3004+ 2696 C3 E9 25             jp      GARBLP          ; Look for more strings
3005+ 2699
3006+ 2699 C5           CONCAT: push    BC              ; Save prec' opr & code string
3007+ 269A E5                   push    HL              ;
3008+ 269B 2A 32 82             ld      HL,(FPREG)      ; Get first string
3009+ 269E E3                   ex      (SP),HL         ; Save first string
3010+ 269F CD 24 21             call    OPRND           ; Get second string
3011+ 26A2 E3                   ex      (SP),HL         ; Restore first string
3012+ 26A3 CD 9F 20             call    TSTSTR          ; Make sure it's a string
3013+ 26A6 7E                   ld      A,(HL)          ; Get length of second string
3014+ 26A7 E5                   push    HL              ; Save first string
3015+ 26A8 2A 32 82             ld      HL,(FPREG)      ; Get second string
3016+ 26AB E5                   push    HL              ; Save second string
3017+ 26AC 86                   add     A,(HL)          ; Add length of second string
3018+ 26AD 1E 1C                ld      E,LS            ; ?LS Error
3019+ 26AF DA 03 17             jp      C,ERROR         ; String too long - Error
3020+ 26B2 CD 52 25             call    MKTMST          ; Make temporary string
3021+ 26B5 D1                   pop     DE              ; Get second string to DE
3022+ 26B6 CD EA 26             call    GSTRDE          ; Move to string pool if needed
3023+ 26B9 E3                   ex      (SP),HL         ; Get first string
3024+ 26BA CD E9 26             call    GSTRHL          ; Move to string pool if needed
3025+ 26BD E5                   push    HL              ; Save first string
3026+ 26BE 2A A8 81             ld      HL,(TMPSTR+2)   ; Temporary string address
3027+ 26C1 EB                   ex      DE,HL           ; To DE
3028+ 26C2 CD D0 26             call    SSTSA           ; First string to string area
3029+ 26C5 CD D0 26             call    SSTSA           ; Second string to string area
3030+ 26C8 21 B9 20             ld      HL,EVAL2        ; Return to evaluation loop
3031+ 26CB E3                   ex      (SP),HL         ; Save return,get code string
3032+ 26CC E5                   push    HL              ; Save code string address
3033+ 26CD C3 83 25             jp      TSTOPL          ; To temporary string to pool
3034+ 26D0
3035+ 26D0 E1           SSTSA:  pop     HL              ; Return address
3036+ 26D1 E3                   ex      (SP),HL         ; Get string block,save return
3037+ 26D2 7E                   ld      A,(HL)          ; Get length of string
3038+ 26D3 23                   inc     HL
3039+ 26D4 23                   inc     HL
3040+ 26D5 4E                   ld      C,(HL)          ; Get LSB of string address
3041+ 26D6 23                   inc     HL
3042+ 26D7 46                   ld      B,(HL)          ; Get MSB of string address
3043+ 26D8 6F                   ld      L,A             ; Length to L
3044+ 26D9 2C           TOSTRA: inc     L               ; inc - DECed after
3045+ 26DA 2D           TSALP:  dec     L               ; Count bytes moved
3046+ 26DB C8                   ret     Z               ; End of string - Return
3047+ 26DC 0A                   ld      A,(BC)          ; Get source
3048+ 26DD 12                   ld      (DE),A          ; Save destination
3049+ 26DE 03                   inc     BC              ; Next source
3050+ 26DF 13                   inc     DE              ; Next destination
3051+ 26E0 C3 DA 26             jp      TSALP           ; Loop until string moved
3052+ 26E3
3053+ 26E3 CD 9F 20     GETSTR: call    TSTSTR          ; Make sure it's a string
3054+ 26E6 2A 32 82     GSTRCU: ld      HL,(FPREG)      ; Get current string
3055+ 26E9 EB           GSTRHL: ex      DE,HL           ; Save DE
3056+ 26EA CD 04 27     GSTRDE: call    BAKTMP          ; Was it last tmp-str?
3057+ 26ED EB                   ex      DE,HL           ; Restore DE
3058+ 26EE C0                   ret     NZ              ; No - Return
3059+ 26EF D5                   push    DE              ; Save string
3060+ 26F0 50                   ld      D,B             ; String block address to DE
3061+ 26F1 59                   ld      E,C
3062+ 26F2 1B                   dec     DE              ; Point to length
3063+ 26F3 4E                   ld      C,(HL)          ; Get string length
3064+ 26F4 2A AA 81             ld      HL,(STRBOT)     ; Current bottom of string area
3065+ 26F7 CD CB 19             call    CPDEHL          ; Last one in string area?
3066+ 26FA C2 02 27             jp      NZ,POPHL        ; No - Return
3067+ 26FD 47                   ld      B,A             ; Clear B (A=0)
3068+ 26FE 09                   add     HL,BC           ; Remove string from str' area
3069+ 26FF 22 AA 81             ld      (STRBOT),HL     ; Save new bottom of str' area
3070+ 2702 E1           POPHL:  pop     HL              ; Restore string
3071+ 2703 C9                   ret
3072+ 2704
3073+ 2704 2A 98 81     BAKTMP: ld      HL,(TMSTPT)     ; Get temporary string pool top
3074+ 2707 2B                   dec     HL              ; Back
3075+ 2708 46                   ld      B,(HL)          ; Get MSB of address
3076+ 2709 2B                   dec     HL              ; Back
3077+ 270A 4E                   ld      C,(HL)          ; Get LSB of address
3078+ 270B 2B                   dec     HL              ; Back
3079+ 270C 2B                   dec     HL              ; Back
3080+ 270D CD CB 19             call    CPDEHL          ; String last in string pool?
3081+ 2710 C0                   ret     NZ              ; Yes - Leave it
3082+ 2711 22 98 81             ld      (TMSTPT),HL     ; Save new string pool top
3083+ 2714 C9                   ret
3084+ 2715
3085+ 2715 01 94 24     LEN:    ld      BC,PASSA        ; To return integer A
3086+ 2718 C5                   push    BC              ; Save address
3087+ 2719 CD E3 26     GETLEN: call    GETSTR          ; Get string and its length
3088+ 271C AF                   xor     A
3089+ 271D 57                   ld      D,A             ; Clear D
3090+ 271E 32 94 81             ld      (TYPE),A        ; Set type to numeric
3091+ 2721 7E                   ld      A,(HL)          ; Get length of string
3092+ 2722 B7                   or      A               ; Set status flags
3093+ 2723 C9                   ret
3094+ 2724
3095+ 2724 01 94 24     ASC:    ld      BC,PASSA        ; To return integer A
3096+ 2727 C5                   push    BC              ; Save address
3097+ 2728 CD 19 27     GTFLNM: call    GETLEN          ; Get length of string
3098+ 272B CA DD 1C             jp      Z,FCERR         ; Null string - Error
3099+ 272E 23                   inc     HL
3100+ 272F 23                   inc     HL
3101+ 2730 5E                   ld      E,(HL)          ; Get LSB of address
3102+ 2731 23                   inc     HL
3103+ 2732 56                   ld      D,(HL)          ; Get MSB of address
3104+ 2733 1A                   ld      A,(DE)          ; Get first byte of string
3105+ 2734 C9                   ret
3106+ 2735
3107+ 2735 3E 01        CHR:    ld      A,$01           ; One character string
3108+ 2737 CD 52 25             call    MKTMST          ; Make a temporary string
3109+ 273A CD 24 29             call    MAKINT          ; Make it integer A
3110+ 273D 2A A8 81             ld      HL,(TMPSTR+2)   ; Get address of string
3111+ 2740 73                   ld      (HL),E          ; Save character
3112+ 2741 C1           TOPOOL: pop     BC              ; Clean up stack
3113+ 2742 C3 83 25             jp      TSTOPL          ; Temporary string to pool
3114+ 2745
3115+ 2745 CD D4 28     LEFT:   call    LFRGNM          ; Get number and ending ")"
3116+ 2748 AF                   xor     A               ; Start at first byte in string
3117+ 2749 E3           RIGHT1: ex      (SP),HL         ; Save code string,Get string
3118+ 274A 4F                   ld      C,A             ; Starting position in string
3119+ 274B E5           MID1:   push    HL              ; Save string block address
3120+ 274C 7E                   ld      A,(HL)          ; Get length of string
3121+ 274D B8                   cp      B               ; Compare with number given
3122+ 274E DA 53 27             jp      C,ALLFOL        ; All following bytes required
3123+ 2751 78                   ld      A,B             ; Get new length
3124+ 2752 11                   defb    $11             ; Skip "ld C,0"
3125+ 2753 0E 00        ALLFOL: ld      C,$00           ; First byte of string
3126+ 2755 C5                   push    BC              ; Save position in string
3127+ 2756 CD BC 25             call    TESTR           ; See if enough string space
3128+ 2759 C1                   pop     BC              ; Get position in string
3129+ 275A E1                   pop     HL              ; Restore string block address
3130+ 275B E5                   push    HL              ; And re-save it
3131+ 275C 23                   inc     HL
3132+ 275D 23                   inc     HL
3133+ 275E 46                   ld      B,(HL)          ; Get LSB of address
3134+ 275F 23                   inc     HL
3135+ 2760 66                   ld      H,(HL)          ; Get MSB of address
3136+ 2761 68                   ld      L,B             ; HL = address of string
3137+ 2762 06 00                ld      B,$00           ; BC = starting address
3138+ 2764 09                   add     HL,BC           ; Point to that byte
3139+ 2765 44                   ld      B,H             ; BC = source string
3140+ 2766 4D                   ld      C,L
3141+ 2767 CD 55 25             call    CRTMST          ; Create a string entry
3142+ 276A 6F                   ld      L,A             ; Length of new string
3143+ 276B CD D9 26             call    TOSTRA          ; Move string to string area
3144+ 276E D1                   pop     DE              ; Clear stack
3145+ 276F CD EA 26             call    GSTRDE          ; Move to string pool if needed
3146+ 2772 C3 83 25             jp      TSTOPL          ; Temporary string to pool
3147+ 2775
3148+ 2775
3149+ 2775              ; INSTR statement - look for a string inside another string
3150+ 2775              ; usage: INSTR(A$,B$) -> search for B$ into A$
3151+ 2775              ; return 0 if B$ is not found into A$, or LEN(A$)<LEN(B$)
3152+ 2775              ; return 1~255 to indicate the starting position of B$ into A$
3153+ 2775              ; ex.: INSTR("HELLO","LO") returns 4 - INSTR("HOME","PC") returns 0
3154+ 2775              LNS1    equ     TMPBFR1
3155+ 2775              ADRS1   equ     TMPBFR2
3156+ 2775              LNS2    equ     TMPBFR3
3157+ 2775              ADRS2   equ     TMPBFR4
3158+ 2775              PT      equ     VIDEOBUFF
3159+ 2775              PT1     equ     VIDEOBUFF+2
3160+ 2775              PT2     equ     VIDEOBUFF+4
3161+ 2775              TP      equ     VIDEOBUFF+6
3162+ 2775              TF      equ     VIDEOBUFF+8
3163+ 2775 CD D1 19     INSTR:  call    CHKSYN          ; make sure "(" follows
3164+ 2778 28                   defb    '('
3165+ 2779 2B                   dec     HL              ; dec 'cause GETCHR increments
3166+ 277A CD 12 1C             call    GETCHR          ; check if something follows
3167+ 277D CA EF 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3168+ 2780 CD AD 20             call    EVAL            ; Evaluate expression
3169+ 2783 CD 9F 20             call    TSTSTR          ; Make sure it's a string
3170+ 2786 22 E6 81             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3171+ 2789 CD E6 26             call    GSTRCU          ; check that a string follows
3172+ 278C CD F7 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3173+ 278F ED 53 DE 81          ld      (LNS1),DE       ; store values into
3174+ 2793 ED 43 E0 81          ld      (ADRS1),BC      ; temp buffers
3175+ 2797 2A E6 81             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3176+ 279A CD D1 19             call    CHKSYN          ; Make sure ',' follows
3177+ 279D 2C                   defb    ','
3178+ 279E 2B                   dec     HL              ; dec 'cause GETCHR increments
3179+ 279F CD 12 1C             call    GETCHR          ; check if something follows
3180+ 27A2 CA EF 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
3181+ 27A5 CD AD 20             call    EVAL            ; Evaluate expression
3182+ 27A8 CD 9F 20             call    TSTSTR          ; Make sure it's a string
3183+ 27AB 22 E6 81             ld      (VIDEOBUFF),HL  ; store code string pointer into a temp buffer
3184+ 27AE CD E6 26             call    GSTRCU          ; check that a string follows
3185+ 27B1 CD F7 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
3186+ 27B4 ED 53 E2 81          ld      (LNS2),DE       ; store values into
3187+ 27B8 ED 43 E4 81          ld      (ADRS2),BC      ; temp buffers
3188+ 27BC 2A E6 81             ld      HL,(VIDEOBUFF)  ; retrieve code string pointer from temp buffer
3189+ 27BF CD D1 19             call    CHKSYN          ; make sure ")" follows
3190+ 27C2 29                   defb    ')'
3191+ 27C3 E5                   push    HL              ; store current code string pointer (the point after the ")" ) ...
3192+ 27C4 FD E1                pop     IY              ; ...into IY
3193+ 27C6 AF                   xor     A               ; reset 10 RAM cells
3194+ 27C7 06 0A                ld      B,$0A           ; (INSTR registers)
3195+ 27C9 21 E6 81             ld      HL,PT           ; first cell
3196+ 27CC 77           EMPTINS:ld      (HL),A          ; reset cell
3197+ 27CD 23                   inc     HL              ; next cell
3198+ 27CE 10 FC                djnz    EMPTINS         ; repeat
3199+ 27D0 ED 5B E2 81          ld      DE,(LNS2)       ; load len(S2) into DE
3200+ 27D4 2A DE 81             ld      HL,(LNS1)       ; load len(S1) into HL
3201+ 27D7 CD DE 3F             call    CMP16           ; check that len(S1)>=len(S2)
3202+ 27DA DA 4F 28             jp      C,RZINSTR       ; if len(S2)>len(S1) then return 0
3203+ 27DD AF           RPTINST:xor     A               ; reset...
3204+ 27DE 32 EC 81             ld      (TP),A          ; ...TP...
3205+ 27E1 32 EE 81             ld      (TF),A          ; ...and TF
3206+ 27E4 ED 4B E6 81          ld      BC,(PT)         ; pointer to S1
3207+ 27E8 2A E0 81             ld      HL,(ADRS1)      ; first cell of S1
3208+ 27EB 09                   add     HL,BC           ; get current position into RAM
3209+ 27EC 7E                   ld      A,(HL)          ; load S1(PT)
3210+ 27ED 2A E4 81             ld      HL,(ADRS2)      ; pointer to first char of S2
3211+ 27F0 BE                   cp      (HL)            ; is S1(PT)=S2(0)?
3212+ 27F1 20 3A                jr      NZ,CNT1INS      ; no, continue
3213+ 27F3 3A E6 81             ld      A,(PT)          ; load current PT
3214+ 27F6 32 EC 81             ld      (TP),A          ; TP=PT
3215+ 27F9 32 E8 81             ld      (PT1),A         ; P1=PT
3216+ 27FC AF                   xor     A               ; set...
3217+ 27FD 32 EA 81             ld      (PT2),A         ; ...PT2=0
3218+ 2800 3C                   inc     A               ;
3219+ 2801 32 EE 81             ld      (TF),A          ; set TF=1
3220+ 2804 ED 4B E8 81  RP2INST:ld      BC,(PT1)        ; load pointer PT1
3221+ 2808 2A E0 81             ld      HL,(ADRS1)      ; load address of S1
3222+ 280B 09                   add     HL,BC           ; find char of S1 pointed by PT1
3223+ 280C 7E                   ld      A,(HL)          ; load S1(PT1)
3224+ 280D ED 4B EA 81          ld      BC,(PT2)        ; load pointer PT2
3225+ 2811 2A E4 81             ld      HL,(ADRS2)      ; load char of S2 pointed by PT2
3226+ 2814 09                   add     HL,BC           ; find S2(PT2)
3227+ 2815 BE                   cp      (HL)            ; is S1(PT1)=S2(PT2)?
3228+ 2816 20 4C                jr      NZ,CNTZIN       ; no, exit inner loop
3229+ 2818 21 E8 81             ld      HL,PT1
3230+ 281B 34                   inc     (HL)            ; increment PT1
3231+ 281C 3A EA 81             ld      A,(PT2)
3232+ 281F 3C                   inc     A               ; increment PT2
3233+ 2820 32 EA 81             ld      (PT2),A
3234+ 2823 CA 2D 28             jp      Z,CNT1INS       ; if PT2>255 then exit
3235+ 2826 21 E2 81             ld      HL,LNS2         ; len(S2)
3236+ 2829 BE                   cp      (HL)            ; PT2=len(S2)?
3237+ 282A DA 04 28             jp      C,RP2INST       ; no (PT2<len(S2) - repeat
3238+ 282D 3A EE 81     CNT1INS:ld      A,(TF)          ; check TF
3239+ 2830 A7                   and     A               ; TF=0? (clears also Carry for next SBC)
3240+ 2831 20 1C                jr      NZ,RZINSTR      ; no, exit
3241+ 2833 2A DE 81             ld      HL,(LNS1)       ; load len(S1)
3242+ 2836 ED 4B E2 81          ld      BC,(LNS2)       ; load len(S2)
3243+ 283A ED 42                sbc     HL,BC           ; HL=len(S1)-len(S2)
3244+ 283C ED 5B E6 81          ld      DE,(PT)         ; load pointer
3245+ 2840 1C                   inc     E               ; PT=PT+1
3246+ 2841 ED 53 E6 81          ld      (PT),DE         ; store new value
3247+ 2845 EB                   ex      DE,HL           ; invert registers
3248+ 2846 CD DE 3F             call    CMP16           ; check if PT>len(S1)-len(S2)
3249+ 2849 DA DD 27             jp      C,RPTINST       ; repeat if <
3250+ 284C CA DD 27             jp      Z,RPTINST       ; repeat if =
3251+ 284F 3A EE 81     RZINSTR:ld      A,(TF)          ; current value of TF
3252+ 2852 A7                   and     A               ; is it 0?
3253+ 2853 CA 5A 28             jp      Z,LVINSTR       ; yes, return 0
3254+ 2856 3A EC 81             ld      A,(TP)          ; return TP...
3255+ 2859 3C                   inc     A               ; ...incremented by 1
3256+ 285A E1           LVINSTR:pop     HL              ; drop original return point
3257+ 285B FD E5                push    IY              ; load current string address from IY into stack
3258+ 285D 11 86 21             ld      DE,RETNUM       ; Address of Return number from function...
3259+ 2860 D5                   push    DE              ; ...saved on stack
3260+ 2861 C3 94 24             jp      PASSA           ; return TP
3261+ 2864 AF           CNTZIN: xor     A               ; set...
3262+ 2865 32 EE 81             ld      (TF),A          ; TF=0
3263+ 2868 C3 2D 28             jp      CNT1INS         ; continue
3264+ 286B
3265+ 286B
3266+ 286B              ; returns the right portion of a string
3267+ 286B CD D4 28     RIGHT:  call    LFRGNM          ; Get number and ending ")"
3268+ 286E D1                   pop     DE              ; Get string length
3269+ 286F D5                   push    DE              ; And re-save
3270+ 2870 1A                   ld      A,(DE)          ; Get length
3271+ 2871 90                   sub     B               ; Move back N bytes
3272+ 2872 C3 49 27             jp      RIGHT1          ; Go and get sub-string
3273+ 2875
3274+ 2875              ; returns a piece of a string
3275+ 2875 EB           MID:    ex      DE,HL           ; Get code string address
3276+ 2876 7E                   ld      A,(HL)          ; Get next byte ',' or ")"
3277+ 2877 CD D9 28             call    MIDNUM          ; Get number supplied
3278+ 287A 04                   inc     B               ; Is it character zero?
3279+ 287B 05                   dec     B
3280+ 287C CA DD 1C             jp      Z,FCERR         ; Yes - Error
3281+ 287F C5                   push    BC              ; Save starting position
3282+ 2880 1E FF                ld      E,$FF           ; All of string
3283+ 2882 FE 29                cp      ')'             ; Any length given?
3284+ 2884 CA 8E 28             jp      Z,RSTSTR        ; No - Rest of string
3285+ 2887 CD D1 19             call    CHKSYN          ; Make sure ',' follows
3286+ 288A 2C                   defb    ','
3287+ 288B CD 21 29             call    GETINT          ; Get integer 0-255
3288+ 288E CD D1 19     RSTSTR: call    CHKSYN          ; Make sure ")" follows
3289+ 2891 29                   defb    ')'
3290+ 2892 F1                   pop     AF              ; Restore starting position
3291+ 2893 E3                   ex      (SP),HL         ; Get string,save code string
3292+ 2894 01 4B 27             ld      BC,MID1         ; Continuation of MID$ routine
3293+ 2897 C5                   push    BC              ; Save for return
3294+ 2898 3D                   dec     A               ; Starting position-1
3295+ 2899 BE                   cp      (HL)            ; Compare with length
3296+ 289A 06 00                ld      B,$00           ; Zero bytes length
3297+ 289C D0                   ret     NC              ; Null string if start past end
3298+ 289D 4F                   ld      C,A             ; Save starting position-1
3299+ 289E 7E                   ld      A,(HL)          ; Get length of string
3300+ 289F 91                   sub     C               ; Subtract start
3301+ 28A0 BB                   cp      E               ; Enough string for it?
3302+ 28A1 47                   ld      B,A             ; Save maximum length available
3303+ 28A2 D8                   ret     C               ; Truncate string if needed
3304+ 28A3 43                   ld      B,E             ; Set specified length
3305+ 28A4 C9                   ret                     ; Go and create string
3306+ 28A5
3307+ 28A5
3308+ 28A5              ; return the value of a numeric string
3309+ 28A5 CD 19 27     VAL:    call    GETLEN          ; Get length of string
3310+ 28A8 CA 77 2C             jp      Z,RESZER        ; Result zero
3311+ 28AB 5F                   ld      E,A             ; Save length
3312+ 28AC 23                   inc     HL
3313+ 28AD 23                   inc     HL
3314+ 28AE 7E                   ld      A,(HL)          ; Get LSB of address
3315+ 28AF 23                   inc     HL
3316+ 28B0 66                   ld      H,(HL)          ; Get MSB of address
3317+ 28B1 6F                   ld      L,A             ; HL = String address
3318+ 28B2 E5                   push    HL              ; Save string address
3319+ 28B3 19                   add     HL,DE
3320+ 28B4 46                   ld      B,(HL)          ; Get end of string+1 byte
3321+ 28B5 72                   ld      (HL),D          ; Zero it to terminate
3322+ 28B6 E3                   ex      (SP),HL         ; Save string end,get start
3323+ 28B7 C5                   push    BC              ; Save end+1 byte
3324+ 28B8 7E                   ld      A,(HL)          ; Get starting byte
3325+ 28B9 FE 24                cp      '$'             ; Hex number indicated? [function added]
3326+ 28BB C2 C3 28             jp      NZ,VAL1
3327+ 28BE CD 17 3F             call    HEXTFP          ; Convert Hex to FPREG
3328+ 28C1 18 0D                jr      VAL3
3329+ 28C3 FE 25        VAL1:   cp      '%'             ; Binary number indicated? [function added]
3330+ 28C5 C2 CD 28             jp      NZ,VAL2
3331+ 28C8 CD 87 3F             call    BINTFP          ; Convert Bin to FPREG
3332+ 28CB 18 03                jr      VAL3
3333+ 28CD CD AF 2F     VAL2:   call    ASCTFP          ; Convert ASCII string to FP
3334+ 28D0 C1           VAL3:   pop     BC              ; Restore end+1 byte
3335+ 28D1 E1                   pop     HL              ; Restore end+1 address
3336+ 28D2 70                   ld      (HL),B          ; Put back original byte
3337+ 28D3 C9                   ret
3338+ 28D4
3339+ 28D4 EB           LFRGNM: ex      DE,HL           ; Code string address to HL
3340+ 28D5 CD D1 19             call    CHKSYN          ; Make sure ")" follows
3341+ 28D8 29                   defb    ')'
3342+ 28D9 C1           MIDNUM: pop     BC              ; Get return address
3343+ 28DA D1                   pop     DE              ; Get number supplied
3344+ 28DB C5                   push    BC              ; Re-save return address
3345+ 28DC 43                   ld      B,E             ; Number to B
3346+ 28DD C9                   ret
3347+ 28DE
3348+ 28DE CD 24 29     INP:    call    MAKINT          ; Make it integer A
3349+ 28E1 32 A0 80             ld      (INPORT),A      ; Set input port
3350+ 28E4 CD 9F 80             call    INPSUB          ; Get input from port
3351+ 28E7 C3 94 24             jp      PASSA           ; Return integer A
3352+ 28EA
3353+ 28EA CD 0E 29     POUT:   call    SETIO           ; Set up port number
3354+ 28ED C3 67 80             jp      OUTSUB          ; Output data and return
3355+ 28F0
3356+ 28F0 CD 0E 29     WAIT:   call    SETIO           ; Set up port number
3357+ 28F3 F5                   push    AF              ; Save AND mask
3358+ 28F4 1E 00                ld      E,$00           ; Assume zero if none given
3359+ 28F6 2B                   dec     HL              ; dec 'cos GETCHR INCs
3360+ 28F7 CD 12 1C             call    GETCHR          ; Get next character
3361+ 28FA CA 04 29             jp      Z,NOXOR         ; No XOR byte given
3362+ 28FD CD D1 19             call    CHKSYN          ; Make sure ',' follows
3363+ 2900 2C                   defb    ','
3364+ 2901 CD 21 29             call    GETINT          ; Get integer 0-255 to XOR with
3365+ 2904 C1           NOXOR:  pop     BC              ; Restore AND mask
3366+ 2905 CD 9F 80     WAITLP: call    INPSUB          ; Get input
3367+ 2908 AB                   xor     E               ; Flip selected bits
3368+ 2909 A0                   and     B               ; Result non-zero?
3369+ 290A CA 05 29             jp      Z,WAITLP        ; No = keep waiting
3370+ 290D C9                   ret
3371+ 290E
3372+ 290E CD 21 29     SETIO:  call    GETINT          ; Get integer 0-255
3373+ 2911 32 A0 80             ld      (INPORT),A      ; Set input port
3374+ 2914 32 68 80             ld      (OTPORT),A      ; Set output port
3375+ 2917 CD D1 19             call    CHKSYN          ; Make sure ',' follows
3376+ 291A 2C                   defb    ','
3377+ 291B C3 21 29             jp      GETINT          ; Get integer 0-255 and return
3378+ 291E
3379+ 291E CD 12 1C     FNDNUM: call    GETCHR          ; Get next character
3380+ 2921 CD 9B 20     GETINT: call    GETNUM          ; Get a number from 0 to 255
3381+ 2924 CD C2 1C     MAKINT: call    DEPINT          ; Make sure value 0 - 255
3382+ 2927 7A                   ld      A,D             ; Get MSB of number
3383+ 2928 B7                   or      A               ; Zero?
3384+ 2929 C2 DD 1C             jp      NZ,FCERR        ; No - Error
3385+ 292C 2B                   dec     HL              ; dec 'cos GETCHR INCs
3386+ 292D CD 12 1C             call    GETCHR          ; Get next character
3387+ 2930 7B                   ld      A,E             ; Get number to A
3388+ 2931 C9                   ret
3389+ 2932
3390+ 2932
3391+ 2932              ; activate a Non-Maskable Interrupt hooked to VDP interrupt signal
3392+ 2932              ; address must point to an ISR routine that terminates with EI/RETN instructions
3393+ 2932 CD 9B 20     NMI:    call    GETNUM          ; Get memory address
3394+ 2935 CD C8 1C             call    DEINT           ; get integer -32768 to 32767
3395+ 2938 7B                   ld      A,E             ; check if address is 0
3396+ 2939 B2                   or      D
3397+ 293A 20 11                jr      NZ,NM1          ; no, so jump over
3398+ 293C F3           DISNMI: di                      ; disable INTs
3399+ 293D CD 69 29             call    NMIDINT         ; disable VDP INT
3400+ 2940 E5                   push    HL              ; store HL
3401+ 2941 21 ED 45             ld      HL,$45ED        ; these are the op-codes for "RETN"
3402+ 2944 22 61 80             ld      (NMIUSR),HL     ; store RETN
3403+ 2947 AF                   xor     A
3404+ 2948 32 63 80             ld      (NMIUSR+2),A    ; "NOP"
3405+ 294B 18 11                jr      NMI2            ; execute the last part of code
3406+ 294D E5           NM1:    push    HL              ; store current HL
3407+ 294E EB                   ex      DE,HL           ; move address argument into HL
3408+ 294F F3                   di                      ; disable INTs
3409+ 2950 CD 69 29             call    NMIDINT         ; disable VDP INT, if enabled
3410+ 2953 3E C3                ld      A,$C3           ; "jp" instruction
3411+ 2955 32 61 80             ld      (NMIUSR),A      ; store it
3412+ 2958 22 62 80             ld      (NMIUSR+1),HL   ; store address
3413+ 295B CD 62 29             call    NMIEINT         ; re-enable VDP INT
3414+ 295E FB           NMI2:   ei                      ; re-enable INTS
3415+ 295F 00                   nop                     ; wait for INTs
3416+ 2960 E1                   pop    HL               ; retrieve HL
3417+ 2961 C9                   ret                     ; return to caller
3418+ 2962              ; enable VDP INT
3419+ 2962 CD 78 29     NMIEINT:call    NMIVR1          ; load default VReg #1 setting
3420+ 2965 F6 20                or      %00100000       ; enable VDP INT
3421+ 2967 18 03                jr      NMIINT          ; rest of code is shared
3422+ 2969              ; disable VDP INT
3423+ 2969 CD 78 29     NMIDINT:call    NMIVR1          ; load default VReg #1 setting
3424+ 296C D5           NMIINT: push    DE              ; store DE
3425+ 296D 5F                   ld      E,A             ; move value into E
3426+ 296E 3E 01                ld      A,$01           ; VREG #1
3427+ 2970 F3                   di                      ; disable INTs
3428+ 2971 CD C7 06             call    WRITE_VREG      ; disable VDP INT
3429+ 2974 FB                   ei                      ; re-enable INTs
3430+ 2975 00                   nop                     ; wait for INTs being enabled
3431+ 2976 D1                   pop     DE              ; retrieve DE
3432+ 2977 C9                   ret                     ; return to caller
3433+ 2978
3434+ 2978              ; load VREG #1 setting for current screen mode and return it into A
3435+ 2978 E5           NMIVR1: push    HL              ; store HL
3436+ 2979 D5                   push    DE              ; store DE
3437+ 297A 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
3438+ 297D 87                   add     A,A             ; multiply A by 8...
3439+ 297E 87                   add     A,A             ; ...so that reg. A can points..
3440+ 297F 87                   add     A,A             ; to the correct settings
3441+ 2980 3C                   inc     A               ; need to change VREG 1
3442+ 2981 5F                   ld      E,A             ; copy A into E
3443+ 2982 16 00                ld      D,$00           ; reset D
3444+ 2984 21 39 0B             ld      HL,VDPMODESET   ; pointer to register #1 setting...
3445+ 2987 19                   add     HL,DE           ; ...for current screen mode
3446+ 2988 7E                   ld      A,(HL)          ; load current setting
3447+ 2989 D1                   pop     DE              ; retrieve DE
3448+ 298A E1                   pop     HL              ; retrieve HL
3449+ 298B C9                   ret                     ; return to caller
3450+ 298C
3451+ 298C              ; execute a machine language routine, eventually passing a param into A
3452+ 298C CD 9B 20     SYS:    call    GETNUM          ; Get memory address
3453+ 298F CD C8 1C             call    DEINT           ; Get integer -32768 to 32767
3454+ 2992 ED 53 E0 81          ld      (TMPBFR2),DE    ; store user routine's address
3455+ 2996 AF                   xor     A               ; reset A
3456+ 2997 32 DE 81             ld      (TMPBFR1),A     ; store into temp buffer
3457+ 299A 2B                   dec     HL              ; dec 'cos GETCHR INCs
3458+ 299B CD 12 1C             call    GETCHR          ; check next character
3459+ 299E 28 0A                jr      Z,NOSYSPR       ; jump if nothing follows
3460+ 29A0 CD D1 19             call    CHKSYN          ; Make sure ',' follows
3461+ 29A3 2C                   defb    ','
3462+ 29A4 CD 21 29             call    GETINT          ; get byte value (0~255) if something follows
3463+ 29A7 32 DE 81             ld      (TMPBFR1),A     ; store into temp buffer
3464+ 29AA 3A DE 81     NOSYSPR:ld      A,(TMPBFR1)     ; recover A
3465+ 29AD ED 5B E0 81          ld      DE,(TMPBFR2)    ; recover user routine's address
3466+ 29B1 E5                   push    HL              ; save code string address
3467+ 29B2 EB                   ex      DE,HL           ; move user routine's address into HL
3468+ 29B3 11 B8 29             ld      DE,SYSRET       ; set point of return after the user routine
3469+ 29B6 D5                   push    DE              ; store into stack
3470+ 29B7 E9                   jp      (HL)            ; call user routine
3471+ 29B8 E1           SYSRET: pop     HL              ; retrieve code string address
3472+ 29B9 C9                   ret                     ; return to caller
3473+ 29BA
3474+ 29BA
3475+ 29BA              ; read the contents of a RAM location
3476+ 29BA CD C8 1C     PEEK:   call    DEINT           ; Get memory address into DE
3477+ 29BD 1A                   ld      A,(DE)          ; Read value of memory cell
3478+ 29BE C3 94 24             jp      PASSA           ; Return into A
3479+ 29C1
3480+ 29C1              ; read the contents of a VRAM location
3481+ 29C1 CD C8 1C     VPEEK:  call    DEINT           ; Get VRAM address into DE
3482+ 29C4 EB                   ex      DE,HL           ; Copy param into HL
3483+ 29C5 F3                   di                      ; Disable interrupts
3484+ 29C6 CD 9D 06             call    READ_VIDEO_LOC  ; Read data from VRAM at address HL
3485+ 29C9 FB                   ei                      ; Re-enable interrupts
3486+ 29CA EB                   ex      DE,HL           ; Restore HL
3487+ 29CB C3 94 24             jp      PASSA           ; Return value into A
3488+ 29CE
3489+ 29CE              ; recover params for POKE/VPOKE commands
3490+ 29CE              ; returns address into DE and byte to be written into A
3491+ 29CE CD 9B 20     PKEPRMS:call    GETNUM          ; Get memory address
3492+ 29D1 CD C8 1C             call    DEINT           ; Get integer -32768 to 32767
3493+ 29D4 ED 53 DE 81          ld      (TMPBFR1),DE    ; Store DE into a temp. buffer
3494+ 29D8 CD D1 19             call    CHKSYN          ; Make sure ',' follows
3495+ 29DB 2C                   defb    ','
3496+ 29DC CD 21 29             call    GETINT          ; Get integer 0-255
3497+ 29DF ED 5B DE 81          ld      DE,(TMPBFR1)    ; Restore memory address
3498+ 29E3 C9                   ret                     ; Return to caller
3499+ 29E4
3500+ 29E4              ; write a byte into a RAM location
3501+ 29E4 CD CE 29     POKE:   call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3502+ 29E7 12                   ld      (DE),A          ; Load it into memory
3503+ 29E8 C9                   ret
3504+ 29E9
3505+ 29E9              ; write a byte into a VRAM location
3506+ 29E9 CD CE 29     VPOKE:  call    PKEPRMS         ; Get params: address and value, return into DE and A, resp.
3507+ 29EC EB                   ex      DE,HL           ; Copy address into HL
3508+ 29ED F3                   di                      ; Disable interrupts
3509+ 29EE CD B2 06             call    WRITE_VIDEO_LOC ; write data into VRAM at address HL
3510+ 29F1 FB                   ei                      ; Re-enable interrupts
3511+ 29F2 EB                   ex      DE,HL           ; Restore HL
3512+ 29F3 C9                   ret                     ; Return to caller
3513+ 29F4
3514+ 29F4              ; position the cursor at a specific X,Y location onto screen
3515+ 29F4 CD 21 29     LOCATE: call    GETINT          ; get the first param into A
3516+ 29F7 E5                   push    HL              ; store HL
3517+ 29F8 21 CD 81             ld      HL,SCR_SIZE_W   ; load address of screen width
3518+ 29FB 5E                   ld      E,(HL)          ; load screen width into E
3519+ 29FC E1                   pop     HL              ; restore HL
3520+ 29FD BB                   cp      E               ; compare witdh with param
3521+ 29FE D2 DD 1C             jp      NC,FCERR        ; value over the width of the screen, exit with Illegal F.C. error
3522+ 2A01 32 DE 81             ld      (TMPBFR1),A     ; Store X into a temp. buffer
3523+ 2A04 CD D1 19             call    CHKSYN          ; Make sure ',' follows
3524+ 2A07 2C                   defb    ','
3525+ 2A08 CD 21 29             call    GETINT          ; Get the second param into A
3526+ 2A0B E5                   push    HL              ; store HL
3527+ 2A0C 21 CE 81             ld      HL,SCR_SIZE_H   ; load address of screen width
3528+ 2A0F 5E                   ld      E,(HL)          ; load screen width into A
3529+ 2A10 E1                   pop     HL              ; restore HL
3530+ 2A11 BB                   cp      E               ; compare witdh with param
3531+ 2A12 D2 DD 1C             jp      NC,FCERR        ; value over the height of the screen, exit with Illegal F.C. error
3532+ 2A15 32 D6 81             ld      (SCR_CUR_NY),A  ; store new Y
3533+ 2A18 3A DE 81             ld      A,(TMPBFR1)     ; recover the new X
3534+ 2A1B 32 D5 81             ld      (SCR_CUR_NX),A  ; store new X
3535+ 2A1E E5                   push    HL              ; store HL
3536+ 2A1F F3                   di                      ; disable INTs
3537+ 2A20 CD E3 06             call    MOVCRS          ; move cursor to new location
3538+ 2A23 FB                   ei                      ; re-enable INTs
3539+ 2A24 E1                   pop     HL              ; restore HL
3540+ 2A25 C9                   ret                     ; return to caller
3541+ 2A26
3542+ 2A26              ; write a byte into one of the PSG registers
3543+ 2A26 CD 21 29     SREG:   call    GETINT          ; Get register number back into A
3544+ 2A29 FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3545+ 2A2B D2 DD 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3546+ 2A2E 32 DE 81             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3547+ 2A31 CD D1 19             call    CHKSYN          ; Make sure ',' follows
3548+ 2A34 2C                   defb    ','
3549+ 2A35 CD 21 29             call    GETINT          ; get second value (0-255), returned into A
3550+ 2A38 5F                   ld      E,A             ; store value into E
3551+ 2A39 3A DE 81             ld      A,(TMPBFR1)     ; recover VDP register and store into D
3552+ 2A3C F3                   di                      ; disable INTs
3553+ 2A3D 0E 40                ld      C,PSG_REG       ; output port to access PSG registers
3554+ 2A3F ED 79                out     (C),A           ; send register # to PSG
3555+ 2A41 0E 41                ld      C,PSG_DAT       ; output port to send data to PSG
3556+ 2A43 ED 59                out     (C),E           ; send byte to write into selected register
3557+ 2A45 FB                   ei                      ; re-enable INTs
3558+ 2A46 C9                   ret                     ; return to caller
3559+ 2A47
3560+ 2A47              ; VOLUME ch,vol
3561+ 2A47              ; set the volume for the audio channels
3562+ 2A47              ; "ch" is 1~3 for corresponding channel, or 0 for all; "vol" is 0~15 (0=OFF, 15=MAX)
3563+ 2A47 CD 21 29     VOLUME: call    GETINT          ; get integer 0-255 (recover channel)
3564+ 2A4A FE 04                cp      $04             ; check if it's in the range 0~3
3565+ 2A4C D2 DD 1C             jp      NC,FCERR        ; if not, exit with Illegal function call error
3566+ 2A4F 32 DE 81             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3567+ 2A52 CD D1 19             call    CHKSYN          ; Make sure ',' follows
3568+ 2A55 2C                   defb    ','
3569+ 2A56 CD 21 29             call    GETINT          ; get integer 0-255 (recover channel)
3570+ 2A59 FE 10                cp      $10             ; check if it's in the range 0~15
3571+ 2A5B D2 DD 1C             jp      NC,FCERR        ; if not, exit with Illegal funcion call
3572+ 2A5E 57                   ld      D,A             ; store volume into D
3573+ 2A5F 3A DE 81             ld      A,(TMPBFR1)     ; retrieve channel
3574+ 2A62 A7                   and     A               ; is it 0? (0=every channel)
3575+ 2A63 20 10                jr      NZ,VOLCH        ; no, jump over
3576+ 2A65 06 03                ld      B,$03           ; yes, set every channel
3577+ 2A67 1E 08                ld      E,$08           ; register volume of first channel
3578+ 2A69 0E 40        RPVOLCG:ld      C,PSG_REG       ; PSG register port
3579+ 2A6B ED 59                out     (C),E           ; set register #
3580+ 2A6D 0E 41                ld      C,PSG_DAT       ; PSG data port
3581+ 2A6F ED 51                out     (C),D           ; send volume
3582+ 2A71 1C                   inc     E               ; next register
3583+ 2A72 10 F5                djnz    RPVOLCG         ; repeat for each channel
3584+ 2A74 C9                   ret                     ; return to caller
3585+ 2A75 0E 40        VOLCH:  ld      C,PSG_REG       ; PSG register port
3586+ 2A77 C6 07                add     $07             ; add 7 to A so that we have the correct register (1->8, 2->9, 3->10)
3587+ 2A79 ED 79                out     (C),A           ; set register
3588+ 2A7B 0E 41                ld      C,PSG_DAT       ; PSG data port
3589+ 2A7D ED 51                out     (C),D           ; send volume level
3590+ 2A7F C9                   ret                     ; return to caller
3591+ 2A80
3592+ 2A80              ; SOUND ch,tone,dur
3593+ 2A80              ; play a tone or noise of "tone" frequency from selected channel "ch" for duration "dur"
3594+ 2A80              ; "ch" is 1~6 (0=means sound OFF,1~3 for tone, 4~6 for noise) / "tone" is 1~4,095 (0=means no tone) /
3595+ 2A80              ; "dur" is 1~16383 h.o.s.,0.001~163s (0=means non-stop tone)
3596+ 2A80 CD 21 29     SOUND:  call    GETINT          ; get integer 0-255 (recover channel)
3597+ 2A83 A7                   and     A               ; is it zero?
3598+ 2A84 20 08                jr      NZ,CTSNDC       ; no, continue with checking of params
3599+ 2A86 E5                   push    HL              ; store HL
3600+ 2A87 F3                   di                      ; disable INTs
3601+ 2A88 CD AB 0C             call    CLRPSGREGS      ; yes, it's zero, so reset PSG registers to shut down every sound
3602+ 2A8B FB                   ei                      ; re-enable INTs
3603+ 2A8C E1                   pop     HL              ; retrieve HL
3604+ 2A8D C9                   ret                     ; return to caller
3605+ 2A8E 32 DE 81     CTSNDC: ld      (TMPBFR1),A     ; no, continue by storing A into a temp. buffer
3606+ 2A91 FE 04                cp      $04             ; is channel >3?
3607+ 2A93 D2 12 2B             jp      NC,NOISUP       ; Yes - check to see if it's a noise channel
3608+ 2A96 CD D1 19             call    CHKSYN          ; No, continue checking by making sure ',' follows
3609+ 2A99 2C                   defb    ','
3610+ 2A9A CD 9B 20             call    GETNUM          ; Get tone frequency
3611+ 2A9D CD C8 1C             call    DEINT           ; Get integer -32768 to 32767
3612+ 2AA0 ED 53 E0 81          ld      (TMPBFR2),DE    ; Store frequency
3613+ 2AA4 CD D1 19             call    CHKSYN          ; Make sure ',' follows
3614+ 2AA7 2C                   defb    ','
3615+ 2AA8 CD 9B 20             call    GETNUM          ; Get duration
3616+ 2AAB CD C8 1C             call    DEINT           ; Get integer -32768 to 32767
3617+ 2AAE ED 53 E2 81          ld      (TMPBFR3),DE    ; Store duration
3618+ 2AB2                                              ; CHECK CHANNEL
3619+ 2AB2 3A DE 81             ld      A,(TMPBFR1)     ; recover channel
3620+ 2AB5 FE 01                cp      $01             ; is channel <1?
3621+ 2AB7 DA DD 1C             jp      C,FCERR         ; Yes - Illegal function call error
3622+ 2ABA                                              ; CHECK FREQUENCY
3623+ 2ABA ED 5B E0 81          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3624+ 2ABE 7A                   ld      A,D             ; move D into A and check if it is in the range 0~4095...
3625+ 2ABF FE 10                cp      $10             ; ...so D must not be greater than $0F (15)
3626+ 2AC1 D2 DD 1C             jp      NC,FCERR        ; if not in the range, exit with an Illegal function call error
3627+ 2AC4                                              ; CHECK DURATION
3628+ 2AC4 ED 5B E2 81          ld      DE,(TMPBFR3)    ; restore duration from temp buffer
3629+ 2AC8 7A                   ld      A,D             ; check if it is in the range 0~16383...
3630+ 2AC9 E6 C0                and     $C0             ; ...(15th & 14th bits must not be set)
3631+ 2ACB C2 DD 1C             jp      NZ,FCERR        ; if not in the range, exit with an Illegal function call error
3632+ 2ACE                                              ;
3633+ 2ACE                                              ; SET TONE:
3634+ 2ACE                                              ; let's start by setting up the channel
3635+ 2ACE 3A DE 81             ld      A,(TMPBFR1)     ; restore channel value
3636+ 2AD1 FE 03                cp      $03             ; is it 3?
3637+ 2AD3 20 02                jr      NZ,SND1         ; no, jump over
3638+ 2AD5 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3639+ 2AD7 2F           SND1:   cpl                     ; complement of A - this is used later to set on the channel into the mixer
3640+ 2AD8 CD 5F 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3641+ 2ADB                                              ; SET FREQUENCY
3642+ 2ADB                                              ; we simply get frequency and subtract from 4096. The result
3643+ 2ADB                                              ; is put into register pair of the corresponding freq tone channel
3644+ 2ADB ED 5B E0 81          ld      DE,(TMPBFR2)    ; restore frequency from temp buffer
3645+ 2ADF E5                   push    HL              ; store HL (it will be used by the subroutine)
3646+ 2AE0 21 00 10             ld      HL,$1000        ; load 4096 into HL
3647+ 2AE3 A7                   and     A               ; reset C flag
3648+ 2AE4 ED 52                sbc     HL,DE           ; subtract freq from HL - now the frequency is inverted, so we will send the low as high and vice-versa
3649+ 2AE6 3A DE 81             ld      A,(TMPBFR1)     ; restore channel value
3650+ 2AE9 3D                   dec     A               ; set A into the range 0~2
3651+ 2AEA 87                   add     A,A             ; double A to find the register pair that correspond to the channel (A->0,1 / B->2,3, C->4,5)
3652+ 2AEB 0E 40                ld      C,PSG_REG       ; PSG register port
3653+ 2AED ED 79                out     (C),A           ; select first register of the pair
3654+ 2AEF 0E 41                ld      C,PSG_DAT       ; PSG data port
3655+ 2AF1 ED 69                out     (C),L           ; send high byte
3656+ 2AF3 0E 40                ld      C,PSG_REG       ; PSG register support
3657+ 2AF5 3C                   inc     A               ; second register of the pair
3658+ 2AF6 ED 79                out     (C),A           ; select register
3659+ 2AF8 0E 41                ld      C,PSG_DAT       ; PSG data port
3660+ 2AFA ED 61                out     (C),H           ; send low byte
3661+ 2AFC ED 5B E2 81          ld      DE,(TMPBFR3)    ; recover duration
3662+ 2B00 3A DE 81             ld      A,(TMPBFR1)     ; recover channel value
3663+ 2B03 3D                   dec     A               ; set channel into the range 0~2
3664+ 2B04 87                   add     A,A             ; double A to find the correct offset
3665+ 2B05 21 12 82             ld      HL,CHASNDDTN    ; set duration into...
3666+ 2B08 85                   add     A,L             ; ...the proper...
3667+ 2B09 30 01                jr      NC,SNDOVR       ; (is there a rest? no, jump over
3668+ 2B0B 24                   inc     H               ; yes, increment H)
3669+ 2B0C 6F           SNDOVR: ld      L,A             ; ...register pair...
3670+ 2B0D 73                   ld      (HL),E          ; ...and store the value
3671+ 2B0E 23                   inc     HL
3672+ 2B0F 72                   ld      (HL),D
3673+ 2B10 E1                   pop     HL              ; retrieve HL
3674+ 2B11 C9                   ret                     ; Return to caller
3675+ 2B12 FE 07        NOISUP: cp      $07             ; is channel in range 4 to 6 (for a noise)?
3676+ 2B14 D2 DD 1C             jp      NC,FCERR        ; no, so ILLEGAL FUNCTION CALL
3677+ 2B17 CD D1 19             call    CHKSYN          ; yes, continue checking by making sure ',' follows
3678+ 2B1A 2C                   defb    ','
3679+ 2B1B CD 21 29             call    GETINT          ; get integer 0-255 (frequency)
3680+ 2B1E FE 20                cp      $20             ; make sure it's in range 0~31
3681+ 2B20 D2 DD 1C             jp      NC,FCERR        ; no, so Illegal function call
3682+ 2B23 32 E0 81             ld      (TMPBFR2),A     ; store freq.
3683+ 2B26 2B                   dec     HL              ; dec 'cos GETCHR INCs
3684+ 2B27 CD 12 1C             call    GETCHR          ; check that nothing follows
3685+ 2B2A C2 EF 16             jp      NZ,SNERR        ; error if no empty line
3686+ 2B2D 3A E0 81             ld      A,(TMPBFR2)     ; retrieve freq.
3687+ 2B30 5F                   ld      E,A             ; store freq into E
3688+ 2B31 3A DE 81             ld      A,(TMPBFR1)     ; retrieve channel
3689+ 2B34 D6 03                sub     $03             ; subtract 3 to get channel in range 1~3
3690+ 2B36 FE 03                cp      $03             ; is it 3?
3691+ 2B38 20 02                jr      NZ,NOS1         ; no, jump over
3692+ 2B3A 3E 04                ld      A,%00000100     ; yes, for ch.3, set 3rd bit only (so A=001, B=010, C=100)
3693+ 2B3C 87           NOS1:   add     A,A
3694+ 2B3D 87                   add     A,A
3695+ 2B3E 87                   add     A,A             ; let's move A 3 bits to left
3696+ 2B3F 47                   ld      B,A             ; store channel into B
3697+ 2B40 7B                   ld      A,E             ; check if
3698+ 2B41 A7                   and     A               ; freq is 0 (means that noise reproduction must be halted)
3699+ 2B42 F3                   di                      ; disable INts
3700+ 2B43 20 0A                jr      NZ,NOS2         ; no, so jump over
3701+ 2B45 3E 07                ld      A,$07           ; mixer register
3702+ 2B47 CD F9 0C             call    SETSNDREG       ; set mixer register
3703+ 2B4A ED 78                in      A,(C)           ; load current mixer value
3704+ 2B4C B0                   or      B               ; disable noise
3705+ 2B4D 18 19                jr      NOS3            ; continue over
3706+ 2B4F 78           NOS2:   ld      A,B             ; recover channel
3707+ 2B50 2F                   cpl                     ; complement of A - this is used to set on the channel into the mixer
3708+ 2B51 CD 5F 2B             call    WRTSND          ; enable line into mixer of channel stored in A
3709+ 2B54 3E 06                ld      A,$06           ; write into noise register
3710+ 2B56 CD F9 0C             call    SETSNDREG       ; set register into PSG
3711+ 2B59 7B                   ld      A,E             ; load value for noise frequency
3712+ 2B5A CD FE 0C             call    WRTSNDREG       ; write data into register $06
3713+ 2B5D FB                   ei                      ; re-enable INTs
3714+ 2B5E C9                   ret
3715+ 2B5F                      ; enable line into mixer of channel stored in A
3716+ 2B5F 47           WRTSND: ld      B,A             ; move channel into B
3717+ 2B60 3E 07                ld      A,$07           ; mixer register
3718+ 2B62 CD F9 0C             call    SETSNDREG       ; set mixer register
3719+ 2B65 ED 78                in      A,(C)           ; load current value
3720+ 2B67 A0                   and     B               ; set on the channel into the mixer (remember that 0=ON)
3721+ 2B68                                              ; example: if channel is A (1), complement of 1 is 254 (11111110). So, 255 (in case
3722+ 2B68                                              ; the register is still unchanged after reset) is 11111111 and
3723+ 2B68                                              ; 11111111 AND 11111110 is equal to 11111110
3724+ 2B68                                              ; 11111001 AND 11111110 is equal to 11111000 (in case channels B & C are ON)
3725+ 2B68 47           NOS3:   ld      B,A             ; store new mixer value into B
3726+ 2B69 3E 07                ld      A,$07           ; mixer address
3727+ 2B6B CD F9 0C             call    SETSNDREG       ; set register
3728+ 2B6E 78                   ld      A,B             ; retrieve new mixer value from B
3729+ 2B6F CD FE 0C             call    WRTSNDREG       ; send new value for the mixer
3730+ 2B72 FB                   ei                      ; re-enable INTs
3731+ 2B73 C9                   ret                     ; return to caller
3732+ 2B74
3733+ 2B74              ; write a byte into one of the VDP registers
3734+ 2B74 CD 21 29     VREG:   call    GETINT          ; Get register number back into A
3735+ 2B77 FE 08                cp      $08             ; check if value is equal or greater than 8 (VDP registers are only 8, from 0 to 7)
3736+ 2B79 D2 DD 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3737+ 2B7C 32 DE 81             ld      (TMPBFR1),A     ; Store A into a temp. buffer
3738+ 2B7F CD D1 19             call    CHKSYN          ; Make sure ',' follows
3739+ 2B82 2C                   defb    ','
3740+ 2B83 CD 21 29             call    GETINT          ; get value (0-255)
3741+ 2B86 5F                   ld      E,A             ; store value into E
3742+ 2B87 3A DE 81             ld      A,(TMPBFR1)     ; recover VDP register and store into A
3743+ 2B8A F3                   di                      ; disable INTs
3744+ 2B8B CD C7 06             call    WRITE_VREG      ; write value into VDP register
3745+ 2B8E FB                   ei                      ; re-enable INTs
3746+ 2B8F C9                   ret                     ; return to caller
3747+ 2B90
3748+ 2B90              ; read the VDP status register and return it into A
3749+ 2B90 CD C8 1C     VSTAT:  call    DEINT           ; Get integer -32768 to 32767 (Note: we do NOT use it)
3750+ 2B93 F3                   di                      ; disable INTs
3751+ 2B94 CD D2 06             call    READ_VSTAT      ; read VDP register status
3752+ 2B97 FB                   ei                      ; re-enable INTs
3753+ 2B98 C3 94 24             jp      PASSA           ; Return integer A
3754+ 2B9B
3755+ 2B9B              ; read from PSG register and return it into A
3756+ 2B9B CD C8 1C     SSTAT:  call    DEINT           ; get integer -32768 to 32767
3757+ 2B9E 7B                   ld      A,E             ; consider LSB
3758+ 2B9F FE 10                cp      $10             ; check if value >= 16 (PSG registers go from 0 to 15)
3759+ 2BA1 D2 DD 1C             jp      NC,FCERR        ; If yes, exit and raise an Illegal function call Error
3760+ 2BA4 F3                   di                      ; disable INts
3761+ 2BA5 0E 40                ld      C,PSG_REG       ; output port to set PSG register
3762+ 2BA7 ED 79                out     (C),A           ; send register to read from
3763+ 2BA9 ED 78                in      A,(C)           ; read register's contents and store into A
3764+ 2BAB FB                   ei                      ; re-enable INTs
3765+ 2BAC C3 94 24             jp      PASSA           ; return A
3766+ 2BAF
3767+ 2BAF              ; read the temp key buffer and return the value of the current key being pressed
3768+ 2BAF              ; can wait for the number of 100thds of second before to return
3769+ 2BAF CD 0E 25     INKEY:  call    IDTEST          ; Test for illegal direct
3770+ 2BB2 CD C8 1C             call    DEINT           ; get number param (100thds of second to wait) into DE
3771+ 2BB5 C5                   push    BC              ; store BC
3772+ 2BB6 3A BD 81             ld      A,(TMRCNT)      ; Load current value of system timer
3773+ 2BB9 47                   ld      B,A             ; move it into B
3774+ 2BBA 3A BD 81     CMP_A:  ld      A,(TMRCNT)      ; make a little delay of 1/100 sec...
3775+ 2BBD B8                   cp      B               ; ...to let the sniffer collect...
3776+ 2BBE 20 FA                jr      NZ,CMP_A        ; ...at least 1 char before to continue
3777+ 2BC0 7A                   ld      A,D             ; check the param
3778+ 2BC1 B3                   or      E               ; if DE<>0 then...
3779+ 2BC2 20 05                jr      NZ,INKEY2       ; ...jump over...
3780+ 2BC4 3A 1A 82             ld      A,(TMPKEYBFR)   ; ...else read the buffer and...
3781+ 2BC7 18 2A                jr      ENDINK          ; ...return it
3782+ 2BC9 7A           INKEY2: ld      A,D             ; check if param>1023
3783+ 2BCA FE 04                cp      $04             ; to do this we check if MSB>3
3784+ 2BCC D2 DD 1C             jp      NC,FCERR        ; if MSB >=4 then error
3785+ 2BCF E5                   push    HL              ; store HL
3786+ 2BD0 21 09 00             ld      HL,$0009        ; check if value
3787+ 2BD3 CD DE 3F             call    CMP16           ; is < 10
3788+ 2BD6 E1                   pop     HL              ; retrieve HL
3789+ 2BD7 DA DD 2B             jp      C,SRTINK        ; if value >= 10 then jump over
3790+ 2BDA 11 0A 00             ld      DE,$000A        ; else, use 10 (no intervals shorter than 10/100s)
3791+ 2BDD 3A BD 81     SRTINK: ld      A,(TMRCNT)      ; Load the first byte of the system timer
3792+ 2BE0 47                   ld      B,A             ; move it into B
3793+ 2BE1 3A 1A 82     CHKINK: ld      A,(TMPKEYBFR)   ; load char code from buffer
3794+ 2BE4 A7                   and     A               ; is it 0?
3795+ 2BE5 20 0C                jr      NZ,ENDINK       ; no, so we can return it
3796+ 2BE7 3A BD 81             ld      A,(TMRCNT)      ; load the first byte of the system timer
3797+ 2BEA B8                   cp      B               ; is it the same value?
3798+ 2BEB 28 F4                jr      Z,CHKINK        ; yes, so read again
3799+ 2BED 47                   ld      B,A             ; store new value
3800+ 2BEE 1B                   dec     DE              ; no, decrement timer
3801+ 2BEF 7A                   ld      A,D             ; check if zero reached
3802+ 2BF0 B3                   or      E               ; by ORing D and E
3803+ 2BF1 20 EE                jr      NZ,CHKINK       ; if not 0, repeat
3804+ 2BF3 C1           ENDINK: pop     BC              ; restore BC
3805+ 2BF4 F5                   push    AF              ; store A
3806+ 2BF5 F3                   di                      ; disable INTs
3807+ 2BF6 AF                   xor     A               ; clear the...
3808+ 2BF7 32 1A 82             ld      (TMPKEYBFR),A   ; ...TMP KEY buffer for the next read
3809+ 2BFA FB                   ei                      ; re-enable INTs
3810+ 2BFB F1                   pop     AF              ; retrieve A
3811+ 2BFC C3 94 24     ENDINK2:jp      PASSA           ; return A as ASCII value
3812+ 2BFF
3813+ 2BFF
3814+ 2BFF 21 26 31     ROUND:  ld      HL,HALF         ; Add 0.5 to FPREG
3815+ 2C02 CD F7 2E     ADDPHL: call    LOADFP          ; Load FP at (HL) to BCDE
3816+ 2C05 C3 11 2C             jp      FPADD           ; Add BCDE to FPREG
3817+ 2C08
3818+ 2C08
3819+ 2C08 CD F7 2E     SUBPHL: call    LOADFP          ; FPREG = -FPREG + number at HL
3820+ 2C0B 21                   defb    $21             ; Skip "pop BC" and "pop DE"
3821+ 2C0C C1           PSUB:   pop     BC              ; Get FP number from stack
3822+ 2C0D D1                   pop     DE
3823+ 2C0E CD D1 2E     SUBCDE: call    INVSGN          ; Negate FPREG
3824+ 2C11 78           FPADD:  ld      A,B             ; Get FP exponent
3825+ 2C12 B7                   or      A               ; Is number zero?
3826+ 2C13 C8                   ret     Z               ; Yes - Nothing to add
3827+ 2C14 3A 35 82             ld      A,(FPEXP)       ; Get FPREG exponent
3828+ 2C17 B7                   or      A               ; Is this number zero?
3829+ 2C18 CA E9 2E             jp      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3830+ 2C1B 90                   sub     B               ; BCDE number larger?
3831+ 2C1C D2 2B 2C             jp      NC,NOSWAP       ; No - Don't swap them
3832+ 2C1F 2F                   cpl                     ; Two's complement
3833+ 2C20 3C                   inc     A               ;  FP exponent
3834+ 2C21 EB                   ex      DE,HL
3835+ 2C22 CD D9 2E             call    STAKFP          ; Put FPREG on stack
3836+ 2C25 EB                   ex      DE,HL
3837+ 2C26 CD E9 2E             call    FPBCDE          ; Move BCDE to FPREG
3838+ 2C29 C1                   pop     BC              ; Restore number from stack
3839+ 2C2A D1                   pop     DE
3840+ 2C2B FE 19        NOSWAP: cp      24+1            ; Second number insignificant?
3841+ 2C2D D0                   ret     NC              ; Yes - First number is result
3842+ 2C2E F5                   push    AF              ; Save number of bits to scale
3843+ 2C2F CD 0E 2F             call    SIGNS           ; Set MSBs & sign of result
3844+ 2C32 67                   ld      H,A             ; Save sign of result
3845+ 2C33 F1                   pop     AF              ; Restore scaling factor
3846+ 2C34 CD D6 2C             call    SCALE           ; Scale BCDE to same exponent
3847+ 2C37 B4                   or      H               ; Result to be positive?
3848+ 2C38 21 32 82             ld      HL,FPREG        ; Point to FPREG
3849+ 2C3B F2 51 2C             jp      P,MINCDE        ; No - Subtract FPREG from CDE
3850+ 2C3E CD B6 2C             call    PLUCDE          ; Add FPREG to CDE
3851+ 2C41 D2 97 2C             jp      NC,RONDUP       ; No overflow - Round it up
3852+ 2C44 23                   inc     HL              ; Point to exponent
3853+ 2C45 34                   inc     (HL)            ; Increment it
3854+ 2C46 CA FE 16             jp      Z,OVERR         ; Number overflowed - Error
3855+ 2C49 2E 01                ld      L,$01           ; 1 bit to shift right
3856+ 2C4B CD EC 2C             call    SHRT1           ; Shift result right
3857+ 2C4E C3 97 2C             jp      RONDUP          ; Round it up
3858+ 2C51
3859+ 2C51 AF           MINCDE: xor     A               ; Clear A and carry
3860+ 2C52 90                   sub     B               ; Negate exponent
3861+ 2C53 47                   ld      B,A             ; Re-save exponent
3862+ 2C54 7E                   ld      A,(HL)          ; Get LSB of FPREG
3863+ 2C55 9B                   sbc     A, E            ; Subtract LSB of BCDE
3864+ 2C56 5F                   ld      E,A             ; Save LSB of BCDE
3865+ 2C57 23                   inc     HL
3866+ 2C58 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3867+ 2C59 9A                   sbc     A,D             ; Subtract NMSB of BCDE
3868+ 2C5A 57                   ld      D,A             ; Save NMSB of BCDE
3869+ 2C5B 23                   inc     HL
3870+ 2C5C 7E                   ld      A,(HL)          ; Get MSB of FPREG
3871+ 2C5D 99                   sbc     A,C             ; Subtract MSB of BCDE
3872+ 2C5E 4F                   ld      C,A             ; Save MSB of BCDE
3873+ 2C5F DC C2 2C     CONPOS: call    C,COMPL         ; Overflow - Make it positive
3874+ 2C62
3875+ 2C62 68           BNORM:  ld      L,B             ; L = Exponent
3876+ 2C63 63                   ld      H,E             ; H = LSB
3877+ 2C64 AF                   xor     A
3878+ 2C65 47           BNRMLP: ld      B,A             ; Save bit count
3879+ 2C66 79                   ld      A,C             ; Get MSB
3880+ 2C67 B7                   or      A               ; Is it zero?
3881+ 2C68 C2 84 2C             jp      NZ,PNORM        ; No - Do it bit at a time
3882+ 2C6B 4A                   ld      C,D             ; MSB = NMSB
3883+ 2C6C 54                   ld      D,H             ; NMSB= LSB
3884+ 2C6D 65                   ld      H,L             ; LSB = VLSB
3885+ 2C6E 6F                   ld      L,A             ; VLSB= 0
3886+ 2C6F 78                   ld      A,B             ; Get exponent
3887+ 2C70 D6 08                sub     $08             ; Count 8 bits
3888+ 2C72 FE E0                cp      -24-8           ; Was number zero?
3889+ 2C74 C2 65 2C             jp      NZ,BNRMLP       ; No - Keep normalising
3890+ 2C77 AF           RESZER: xor     A               ; Result is zero
3891+ 2C78 32 35 82     SAVEXP: ld      (FPEXP),A       ; Save result as zero
3892+ 2C7B C9                   ret
3893+ 2C7C
3894+ 2C7C 05           NORMAL: dec     B               ; Count bits
3895+ 2C7D 29                   add     HL,HL           ; Shift HL left
3896+ 2C7E 7A                   ld      A,D             ; Get NMSB
3897+ 2C7F 17                   rla                     ; Shift left with last bit
3898+ 2C80 57                   ld      D,A             ; Save NMSB
3899+ 2C81 79                   ld      A,C             ; Get MSB
3900+ 2C82 8F                   adc     A,A             ; Shift left with last bit
3901+ 2C83 4F                   ld      C,A             ; Save MSB
3902+ 2C84 F2 7C 2C     PNORM:  jp      P,NORMAL        ; Not done - Keep going
3903+ 2C87 78                   ld      A,B             ; Number of bits shifted
3904+ 2C88 5C                   ld      E,H             ; Save HL in EB
3905+ 2C89 45                   ld      B,L
3906+ 2C8A B7                   or      A               ; Any shifting done?
3907+ 2C8B CA 97 2C             jp      Z,RONDUP        ; No - Round it up
3908+ 2C8E 21 35 82             ld      HL,FPEXP        ; Point to exponent
3909+ 2C91 86                   add     A,(HL)          ; Add shifted bits
3910+ 2C92 77                   ld      (HL),A          ; Re-save exponent
3911+ 2C93 D2 77 2C             jp      NC,RESZER       ; Underflow - Result is zero
3912+ 2C96 C8                   ret     Z               ; Result is zero
3913+ 2C97 78           RONDUP: ld      A,B             ; Get VLSB of number
3914+ 2C98 21 35 82     RONDB:  ld      HL,FPEXP        ; Point to exponent
3915+ 2C9B B7                   or      A               ; Any rounding?
3916+ 2C9C FC A9 2C             call    M,FPROND        ; Yes - Round number up
3917+ 2C9F 46                   ld      B,(HL)          ; B = Exponent
3918+ 2CA0 23                   inc     HL
3919+ 2CA1 7E                   ld      A,(HL)          ; Get sign of result
3920+ 2CA2 E6 80                and     %10000000       ; Only bit 7 needed
3921+ 2CA4 A9                   xor     C               ; Set correct sign
3922+ 2CA5 4F                   ld      C,A             ; Save correct sign in number
3923+ 2CA6 C3 E9 2E             jp      FPBCDE          ; Move BCDE to FPREG
3924+ 2CA9
3925+ 2CA9 1C           FPROND: inc     E               ; Round LSB
3926+ 2CAA C0                   ret     NZ              ; Return if ok
3927+ 2CAB 14                   inc     D               ; Round NMSB
3928+ 2CAC C0                   ret     NZ              ; Return if ok
3929+ 2CAD 0C                   inc     C               ; Round MSB
3930+ 2CAE C0                   ret     NZ              ; Return if ok
3931+ 2CAF 0E 80                ld      C,$80           ; Set normal value
3932+ 2CB1 34                   inc     (HL)            ; Increment exponent
3933+ 2CB2 C0                   ret     NZ              ; Return if ok
3934+ 2CB3 C3 FE 16             jp      OVERR           ; Overflow error
3935+ 2CB6
3936+ 2CB6 7E           PLUCDE: ld      A,(HL)          ; Get LSB of FPREG
3937+ 2CB7 83                   add     A,E             ; Add LSB of BCDE
3938+ 2CB8 5F                   ld      E,A             ; Save LSB of BCDE
3939+ 2CB9 23                   inc     HL
3940+ 2CBA 7E                   ld      A,(HL)          ; Get NMSB of FPREG
3941+ 2CBB 8A                   adc     A,D             ; Add NMSB of BCDE
3942+ 2CBC 57                   ld      D,A             ; Save NMSB of BCDE
3943+ 2CBD 23                   inc     HL
3944+ 2CBE 7E                   ld      A,(HL)          ; Get MSB of FPREG
3945+ 2CBF 89                   adc     A,C             ; Add MSB of BCDE
3946+ 2CC0 4F                   ld      C,A             ; Save MSB of BCDE
3947+ 2CC1 C9                   ret
3948+ 2CC2
3949+ 2CC2 21 36 82     COMPL:  ld      HL,SGNRES       ; Sign of result
3950+ 2CC5 7E                   ld      A,(HL)          ; Get sign of result
3951+ 2CC6 2F                   cpl                     ; Negate it
3952+ 2CC7 77                   ld      (HL),A          ; Put it back
3953+ 2CC8 AF                   xor     A
3954+ 2CC9 6F                   ld      L,A             ; Set L to zero
3955+ 2CCA 90                   sub     B               ; Negate exponent,set carry
3956+ 2CCB 47                   ld      B,A             ; Re-save exponent
3957+ 2CCC 7D                   ld      A,L             ; Load zero
3958+ 2CCD 9B                   sbc     A,E             ; Negate LSB
3959+ 2CCE 5F                   ld      E,A             ; Re-save LSB
3960+ 2CCF 7D                   ld      A,L             ; Load zero
3961+ 2CD0 9A                   sbc     A,D             ; Negate NMSB
3962+ 2CD1 57                   ld      D,A             ; Re-save NMSB
3963+ 2CD2 7D                   ld      A,L             ; Load zero
3964+ 2CD3 99                   sbc     A,C             ; Negate MSB
3965+ 2CD4 4F                   ld      C,A             ; Re-save MSB
3966+ 2CD5 C9                   ret
3967+ 2CD6
3968+ 2CD6 06 00        SCALE:  ld      B,$00           ; Clear underflow
3969+ 2CD8 D6 08        SCALLP: sub     $08             ; 8 bits (a whole byte)?
3970+ 2CDA DA E5 2C             jp      C,SHRITE        ; No - Shift right A bits
3971+ 2CDD 43                   ld      B,E             ; <- Shift
3972+ 2CDE 5A                   ld      E,D             ; <- right
3973+ 2CDF 51                   ld      D,C             ; <- eight
3974+ 2CE0 0E 00                ld      C,$00           ; <- bits
3975+ 2CE2 C3 D8 2C             jp      SCALLP          ; More bits to shift
3976+ 2CE5
3977+ 2CE5 C6 09        SHRITE: add     A,8+1           ; Adjust count
3978+ 2CE7 6F                   ld      L,A             ; Save bits to shift
3979+ 2CE8 AF           SHRLP:  xor     A               ; Flag for all done
3980+ 2CE9 2D                   dec     L               ; All shifting done?
3981+ 2CEA C8                   ret     Z               ; Yes - Return
3982+ 2CEB 79                   ld      A,C             ; Get MSB
3983+ 2CEC 1F           SHRT1:  rra                     ; Shift it right
3984+ 2CED 4F                   ld      C,A             ; Re-save
3985+ 2CEE 7A                   ld      A,D             ; Get NMSB
3986+ 2CEF 1F                   rra                     ; Shift right with last bit
3987+ 2CF0 57                   ld      D,A             ; Re-save it
3988+ 2CF1 7B                   ld      A,E             ; Get LSB
3989+ 2CF2 1F                   rra                     ; Shift right with last bit
3990+ 2CF3 5F                   ld      E,A             ; Re-save it
3991+ 2CF4 78                   ld      A,B             ; Get underflow
3992+ 2CF5 1F                   rra                     ; Shift right with last bit
3993+ 2CF6 47                   ld      B,A             ; Re-save underflow
3994+ 2CF7 C3 E8 2C             jp      SHRLP           ; More bits to do
3995+ 2CFA
3996+ 2CFA 00 00 00 81  UNITY:  defb    $00,$00,$00,$81 ; 1.00000
3997+ 2CFE
3998+ 2CFE 03           LOGTAB: defb    $03             ; Table used by LOG
3999+ 2CFF AA 56 19 80          defb    $AA,$56,$19,$80 ; 0.59898
4000+ 2D03 F1 22 76 80          defb    $F1,$22,$76,$80 ; 0.96147
4001+ 2D07 45 AA 38 82          defb    $45,$AA,$38,$82 ; 2.88539
4002+ 2D0B
4003+ 2D0B CD A8 2E     LOG:    call    TSTSGN          ; Test sign of value
4004+ 2D0E B7                   or      A
4005+ 2D0F EA DD 1C             jp      PE,FCERR        ; ?FC Error if <= zero
4006+ 2D12 21 35 82             ld      HL,FPEXP        ; Point to exponent
4007+ 2D15 7E                   ld      A,(HL)          ; Get exponent
4008+ 2D16 01 35 80             ld      BC,$8035        ; BCDE = SQR(1/2)
4009+ 2D19 11 F3 04             ld      DE,$04F3
4010+ 2D1C 90                   sub     B               ; Scale value to be < 1
4011+ 2D1D F5                   push    AF              ; Save scale factor
4012+ 2D1E 70                   ld      (HL),B          ; Save new exponent
4013+ 2D1F D5                   push    DE              ; Save SQR(1/2)
4014+ 2D20 C5                   push    BC
4015+ 2D21 CD 11 2C             call    FPADD           ; Add SQR(1/2) to value
4016+ 2D24 C1                   pop     BC              ; Restore SQR(1/2)
4017+ 2D25 D1                   pop     DE
4018+ 2D26 04                   inc     B               ; Make it SQR(2)
4019+ 2D27 CD FE 2D             call    DVBCDE          ; Divide by SQR(2)
4020+ 2D2A 21 FA 2C             ld      HL,UNITY        ; Point to 1.
4021+ 2D2D CD 08 2C             call    SUBPHL          ; Subtract FPREG from 1
4022+ 2D30 21 FE 2C             ld      HL,LOGTAB       ; Coefficient table
4023+ 2D33 CD F0 31             call    SUMSER          ; Evaluate sum of series
4024+ 2D36 01 80 80             ld      BC,$8080        ; BCDE = -0.5
4025+ 2D39 11 00 00             ld      DE,$0000
4026+ 2D3C CD 11 2C             call    FPADD           ; Subtract 0.5 from FPREG
4027+ 2D3F F1                   pop     AF              ; Restore scale factor
4028+ 2D40 CD 23 30             call    RSCALE          ; Re-scale number
4029+ 2D43 01 31 80     MULLN2: ld      BC,$8031        ; BCDE = Ln(2)
4030+ 2D46 11 18 72             ld      DE,$7218
4031+ 2D49 21                   defb    $21             ; Skip "pop BC" and "pop DE"
4032+ 2D4A
4033+ 2D4A C1           MULT:   pop     BC              ; Get number from stack
4034+ 2D4B D1                   pop     DE
4035+ 2D4C CD A8 2E     FPMULT: call    TSTSGN          ; Test sign of FPREG
4036+ 2D4F C8                   ret     Z               ; Return zero if zero
4037+ 2D50 2E 00                ld      L,$00           ; Flag add exponents
4038+ 2D52 CD 66 2E             call    ADDEXP          ; Add exponents
4039+ 2D55 79                   ld      A,C             ; Get MSB of multiplier
4040+ 2D56 32 44 82             ld      (MULVAL),A      ; Save MSB of multiplier
4041+ 2D59 EB                   ex      DE,HL
4042+ 2D5A 22 45 82             ld      (MULVAL+1),HL   ; Save rest of multiplier
4043+ 2D5D 01 00 00             ld      BC,$0000        ; Partial product (BCDE) = zero
4044+ 2D60 50                   ld      D,B
4045+ 2D61 58                   ld      E,B
4046+ 2D62 21 62 2C             ld      HL,BNORM        ; Address of normalise
4047+ 2D65 E5                   push    HL              ; Save for return
4048+ 2D66 21 6E 2D             ld      HL,MULT8        ; Address of 8 bit multiply
4049+ 2D69 E5                   push    HL              ; Save for NMSB,MSB
4050+ 2D6A E5                   push    HL              ;
4051+ 2D6B 21 32 82             ld      HL,FPREG        ; Point to number
4052+ 2D6E 7E           MULT8:  ld      A,(HL)          ; Get LSB of number
4053+ 2D6F 23                   inc     HL              ; Point to NMSB
4054+ 2D70 B7                   or      A               ; Test LSB
4055+ 2D71 CA 9A 2D             jp      Z,BYTSFT        ; Zero - shift to next byte
4056+ 2D74 E5                   push    HL              ; Save address of number
4057+ 2D75 2E 08                ld      L,$08           ; 8 bits to multiply by
4058+ 2D77 1F           MUL8LP: rra                     ; Shift LSB right
4059+ 2D78 67                   ld      H,A             ; Save LSB
4060+ 2D79 79                   ld      A,C             ; Get MSB
4061+ 2D7A D2 88 2D             jp      NC,NOMADD       ; Bit was zero - Don't add
4062+ 2D7D E5                   push    HL              ; Save LSB and count
4063+ 2D7E 2A 45 82             ld      HL,(MULVAL+1)   ; Get LSB and NMSB
4064+ 2D81 19                   add     HL,DE           ; Add NMSB and LSB
4065+ 2D82 EB                   ex      DE,HL           ; Leave sum in DE
4066+ 2D83 E1                   pop     HL              ; Restore MSB and count
4067+ 2D84 3A 44 82             ld      A,(MULVAL)      ; Get MSB of multiplier
4068+ 2D87 89                   adc     A,C             ; Add MSB
4069+ 2D88 1F           NOMADD: rra                     ; Shift MSB right
4070+ 2D89 4F                   ld      C,A             ; Re-save MSB
4071+ 2D8A 7A                   ld      A,D             ; Get NMSB
4072+ 2D8B 1F                   rra                     ; Shift NMSB right
4073+ 2D8C 57                   ld      D,A             ; Re-save NMSB
4074+ 2D8D 7B                   ld      A,E             ; Get LSB
4075+ 2D8E 1F                   rra                     ; Shift LSB right
4076+ 2D8F 5F                   ld      E,A             ; Re-save LSB
4077+ 2D90 78                   ld      A,B             ; Get VLSB
4078+ 2D91 1F                   rra                     ; Shift VLSB right
4079+ 2D92 47                   ld      B,A             ; Re-save VLSB
4080+ 2D93 2D                   dec     L               ; Count bits multiplied
4081+ 2D94 7C                   ld      A,H             ; Get LSB of multiplier
4082+ 2D95 C2 77 2D             jp      NZ,MUL8LP       ; More - Do it
4083+ 2D98 E1           POPHRT: pop     HL              ; Restore address of number
4084+ 2D99 C9                   ret
4085+ 2D9A
4086+ 2D9A 43           BYTSFT: ld      B,E             ; Shift partial product left
4087+ 2D9B 5A                   ld      E,D
4088+ 2D9C 51                   ld      D,C
4089+ 2D9D 4F                   ld      C,A
4090+ 2D9E C9                   ret
4091+ 2D9F
4092+ 2D9F
4093+ 2D9F              ; WORKING ââ
4094+ 2D9F C1           DINT:   pop     BC              ; Get number from stack
4095+ 2DA0 D1                   pop     DE
4096+ 2DA1 CD FE 2D             call    DVBCDE          ; get BCDE/FPREG and store result into FPREG
4097+ 2DA4 C3 7B 2F             jp      INT             ; return INT(FPREG)
4098+ 2DA7
4099+ 2DA7
4100+ 2DA7              ; A MODULO B - return remainder of the integer division A/B where:
4101+ 2DA7              ; A is in stack; B is in FPREG
4102+ 2DA7              ; math is:
4103+ 2DA7              ; A=INT(A); B=INT(B); R=A-(B*INT(A/B))
4104+ 2DA7 CD 7B 2F     MOD:    call    INT             ; B=INT(B)
4105+ 2DAA CD F4 2E             call    BCDEFP          ; copy B (from FPREG) into BCDE
4106+ 2DAD ED 53 E2 81          ld      (TMPBFR3),DE    ; store B into...
4107+ 2DB1 ED 43 E4 81          ld      (TMPBFR4),BC    ; ...a temp buffer
4108+ 2DB5 C1                   pop     BC              ; recover A...
4109+ 2DB6 D1                   pop     DE              ; ...from stack
4110+ 2DB7 CD E9 2E             call    FPBCDE          ; store A into FPREG
4111+ 2DBA CD 7B 2F             call    INT             ; get integer part: A=INT(A)
4112+ 2DBD CD F4 2E             call    BCDEFP          ; copy A (from FPREG) into BCDE
4113+ 2DC0 ED 53 DE 81          ld      (TMPBFR1),DE    ; store A into...
4114+ 2DC4 ED 43 E0 81          ld      (TMPBFR2),BC    ; ...a temp buffer
4115+ 2DC8                                              ; begin calculation
4116+ 2DC8 2A E2 81             ld      HL,(TMPBFR3)    ; move B...
4117+ 2DCB 22 32 82             ld      (FPREG),HL      ; ...from...
4118+ 2DCE 2A E4 81             ld      HL,(TMPBFR4)    ; ...temp buffer...
4119+ 2DD1 22 34 82             ld      (FPREG+2),HL    ; ...into FPREG
4120+ 2DD4 CD FE 2D             call    DVBCDE          ; compute A/B and store into FPREG
4121+ 2DD7 CD 7B 2F             call    INT             ; get integer part of result: now FPREG = INT(A/B)
4122+ 2DDA ED 5B E2 81          ld      DE,(TMPBFR3)    ; load B...
4123+ 2DDE ED 4B E4 81          ld      BC,(TMPBFR4)    ; ...into BCDE
4124+ 2DE2 CD 4C 2D             call    FPMULT          ; get B*INT(A/B) and store into FPREG
4125+ 2DE5 ED 5B DE 81          ld      DE,(TMPBFR1)    ; retrieve A from...
4126+ 2DE9 ED 4B E0 81          ld      BC,(TMPBFR2)    ; ...temp buffer
4127+ 2DED C3 0E 2C             jp      SUBCDE          ; return result of A-(B*INT(A/B))
4128+ 2DF0
4129+ 2DF0
4130+ 2DF0 CD D9 2E     DIV10:  call    STAKFP          ; Save FPREG on stack
4131+ 2DF3 01 20 84             ld      BC,$8420        ; BCDE = 10.
4132+ 2DF6 11 00 00             ld      DE,$0000
4133+ 2DF9 CD E9 2E             call    FPBCDE          ; Move 10 to FPREG
4134+ 2DFC
4135+ 2DFC C1           DIV:    pop     BC              ; Get number from stack
4136+ 2DFD D1                   pop     DE
4137+ 2DFE CD A8 2E     DVBCDE: call    TSTSGN          ; Test sign of FPREG
4138+ 2E01 CA F2 16             jp      Z,DZERR         ; Error if division by zero
4139+ 2E04 2E FF                ld      L,-1            ; Flag subtract exponents
4140+ 2E06 CD 66 2E             call    ADDEXP          ; Subtract exponents
4141+ 2E09 34                   inc     (HL)            ; Add 2 to exponent to adjust
4142+ 2E0A 34                   inc     (HL)
4143+ 2E0B 2B                   dec     HL              ; Point to MSB
4144+ 2E0C 7E                   ld      A,(HL)          ; Get MSB of dividend
4145+ 2E0D 32 73 80             ld      (DIV3),A        ; Save for subtraction
4146+ 2E10 2B                   dec     HL
4147+ 2E11 7E                   ld      A,(HL)          ; Get NMSB of dividend
4148+ 2E12 32 6F 80             ld      (DIV2),A        ; Save for subtraction
4149+ 2E15 2B                   dec     HL
4150+ 2E16 7E                   ld      A,(HL)          ; Get MSB of dividend
4151+ 2E17 32 6B 80             ld      (DIV1),A        ; Save for subtraction
4152+ 2E1A 41                   ld      B,C             ; Get MSB
4153+ 2E1B EB                   ex      DE,HL           ; NMSB,LSB to HL
4154+ 2E1C AF                   xor     A
4155+ 2E1D 4F                   ld      C,A             ; Clear MSB of quotient
4156+ 2E1E 57                   ld      D,A             ; Clear NMSB of quotient
4157+ 2E1F 5F                   ld      E,A             ; Clear LSB of quotient
4158+ 2E20 32 76 80             ld      (DIV4),A        ; Clear overflow count
4159+ 2E23 E5           DIVLP:  push    HL              ; Save divisor
4160+ 2E24 C5                   push    BC
4161+ 2E25 7D                   ld      A,L             ; Get LSB of number
4162+ 2E26 CD 6A 80             call    DIVSUP          ; Subt' divisor from dividend
4163+ 2E29 DE 00                sbc     A,$00           ; Count for overflows
4164+ 2E2B 3F                   ccf
4165+ 2E2C D2 36 2E             jp      NC,RESDIV       ; Restore divisor if borrow
4166+ 2E2F 32 76 80             ld      (DIV4),A        ; Re-save overflow count
4167+ 2E32 F1                   pop     AF              ; Scrap divisor
4168+ 2E33 F1                   pop     AF
4169+ 2E34 37                   scf                     ; Set carry to
4170+ 2E35 D2                   defb    $D2             ; Skip "pop BC" and "pop HL"
4171+ 2E36
4172+ 2E36 C1           RESDIV: pop     BC              ; Restore divisor
4173+ 2E37 E1                   pop     HL
4174+ 2E38 79                   ld      A,C             ; Get MSB of quotient
4175+ 2E39 3C                   inc     A
4176+ 2E3A 3D                   dec     A
4177+ 2E3B 1F                   rra                     ; Bit 0 to bit 7
4178+ 2E3C FA 98 2C             jp      M,RONDB         ; Done - Normalise result
4179+ 2E3F 17                   rla                     ; Restore carry
4180+ 2E40 7B                   ld      A,E             ; Get LSB of quotient
4181+ 2E41 17                   rla                     ; Double it
4182+ 2E42 5F                   ld      E,A             ; Put it back
4183+ 2E43 7A                   ld      A,D             ; Get NMSB of quotient
4184+ 2E44 17                   rla                     ; Double it
4185+ 2E45 57                   ld      D,A             ; Put it back
4186+ 2E46 79                   ld      A,C             ; Get MSB of quotient
4187+ 2E47 17                   rla                     ; Double it
4188+ 2E48 4F                   ld      C,A             ; Put it back
4189+ 2E49 29                   add     HL,HL           ; Double NMSB,LSB of divisor
4190+ 2E4A 78                   ld      A,B             ; Get MSB of divisor
4191+ 2E4B 17                   rla                     ; Double it
4192+ 2E4C 47                   ld      B,A             ; Put it back
4193+ 2E4D 3A 76 80             ld      A,(DIV4)        ; Get VLSB of quotient
4194+ 2E50 17                   rla                     ; Double it
4195+ 2E51 32 76 80             ld      (DIV4),A        ; Put it back
4196+ 2E54 79                   ld      A,C             ; Get MSB of quotient
4197+ 2E55 B2                   or      D               ; Merge NMSB
4198+ 2E56 B3                   or      E               ; Merge LSB
4199+ 2E57 C2 23 2E             jp      NZ,DIVLP        ; Not done - Keep dividing
4200+ 2E5A E5                   push    HL              ; Save divisor
4201+ 2E5B 21 35 82             ld      HL,FPEXP        ; Point to exponent
4202+ 2E5E 35                   dec     (HL)            ; Divide by 2
4203+ 2E5F E1                   pop     HL              ; Restore divisor
4204+ 2E60 C2 23 2E             jp      NZ,DIVLP        ; Ok - Keep going
4205+ 2E63 C3 FE 16             jp      OVERR           ; Overflow error
4206+ 2E66
4207+ 2E66
4208+ 2E66 78           ADDEXP: ld      A,B             ; Get exponent of dividend
4209+ 2E67 B7                   or      A               ; Test it
4210+ 2E68 CA 8A 2E             jp      Z,OVTST3        ; Zero - Result zero
4211+ 2E6B 7D                   ld      A,L             ; Get add/subtract flag
4212+ 2E6C 21 35 82             ld      HL,FPEXP        ; Point to exponent
4213+ 2E6F AE                   xor     (HL)            ; Add or subtract it
4214+ 2E70 80                   add     A,B             ; Add the other exponent
4215+ 2E71 47                   ld      B,A             ; Save new exponent
4216+ 2E72 1F                   rra                     ; Test exponent for overflow
4217+ 2E73 A8                   xor     B
4218+ 2E74 78                   ld      A,B             ; Get exponent
4219+ 2E75 F2 89 2E             jp      P,OVTST2        ; Positive - Test for overflow
4220+ 2E78 C6 80                add     A,$80           ; Add excess 128
4221+ 2E7A 77                   ld      (HL),A          ; Save new exponent
4222+ 2E7B CA 98 2D             jp      Z,POPHRT        ; Zero - Result zero
4223+ 2E7E CD 0E 2F             call    SIGNS           ; Set MSBs and sign of result
4224+ 2E81 77                   ld      (HL),A          ; Save new exponent
4225+ 2E82 2B                   dec     HL              ; Point to MSB
4226+ 2E83 C9                   ret
4227+ 2E84
4228+ 2E84 CD A8 2E     OVTST1: call    TSTSGN          ; Test sign of FPREG
4229+ 2E87 2F                   cpl                     ; Invert sign
4230+ 2E88 E1                   pop     HL              ; Clean up stack
4231+ 2E89 B7           OVTST2: or      A               ; Test if new exponent zero
4232+ 2E8A E1           OVTST3: pop     HL              ; Clear off return address
4233+ 2E8B F2 77 2C             jp      P,RESZER        ; Result zero
4234+ 2E8E C3 FE 16             jp      OVERR           ; Overflow error
4235+ 2E91
4236+ 2E91 CD F4 2E     MLSP10: call    BCDEFP          ; Move FPREG to BCDE
4237+ 2E94 78                   ld      A,B             ; Get exponent
4238+ 2E95 B7                   or      A               ; Is it zero?
4239+ 2E96 C8                   ret     Z               ; Yes - Result is zero
4240+ 2E97 C6 02                add     A,$02           ; Multiply by 4
4241+ 2E99 DA FE 16             jp      C,OVERR         ; Overflow - ?OV Error
4242+ 2E9C 47                   ld      B,A             ; Re-save exponent
4243+ 2E9D CD 11 2C             call    FPADD           ; Add BCDE to FPREG (Times 5)
4244+ 2EA0 21 35 82             ld      HL,FPEXP        ; Point to exponent
4245+ 2EA3 34                   inc     (HL)            ; Double number (Times 10)
4246+ 2EA4 C0                   ret     NZ              ; Ok - Return
4247+ 2EA5 C3 FE 16             jp      OVERR           ; Overflow error
4248+ 2EA8
4249+ 2EA8 3A 35 82     TSTSGN: ld      A,(FPEXP)       ; Get sign of FPREG
4250+ 2EAB B7                   or      A
4251+ 2EAC C8                   ret     Z               ; RETurn if number is zero
4252+ 2EAD 3A 34 82             ld      A,(FPREG+2)     ; Get MSB of FPREG
4253+ 2EB0 FE                   defb    0FEH            ; Test sign
4254+ 2EB1 2F           RETREL: cpl                     ; Invert sign
4255+ 2EB2 17                   rla                     ; Sign bit to carry
4256+ 2EB3 9F           FLGDIF: sbc     A,A             ; Carry to all bits of A
4257+ 2EB4 C0                   ret     NZ              ; Return -1 if negative
4258+ 2EB5 3C                   inc     A               ; Bump to +1
4259+ 2EB6 C9                   ret                     ; Positive - Return +1
4260+ 2EB7
4261+ 2EB7 CD A8 2E     SGN:    call    TSTSGN          ; Test sign of FPREG
4262+ 2EBA 06 88        FLGREL: ld      B,$80+8         ; 8 bit integer in exponent
4263+ 2EBC 11 00 00             ld      DE,0            ; Zero NMSB and LSB
4264+ 2EBF 21 35 82     RETINT: ld      HL,FPEXP        ; Point to exponent
4265+ 2EC2 4F                   ld      C,A             ; CDE = MSB,NMSB and LSB
4266+ 2EC3 70                   ld      (HL),B          ; Save exponent
4267+ 2EC4 06 00                ld      B,0             ; CDE = integer to normalise
4268+ 2EC6 23                   inc     HL              ; Point to sign of result
4269+ 2EC7 36 80                ld      (HL),$80        ; Set sign of result
4270+ 2EC9 17                   rla                     ; Carry = sign of integer
4271+ 2ECA C3 5F 2C             jp      CONPOS          ; Set sign of result
4272+ 2ECD
4273+ 2ECD CD A8 2E     ABS_:   call    TSTSGN          ; Test sign of FPREG
4274+ 2ED0 F0                   ret     P               ; Return if positive
4275+ 2ED1 21 34 82     INVSGN: ld      HL,FPREG+2      ; Point to MSB
4276+ 2ED4 7E                   ld      A,(HL)          ; Get sign of mantissa
4277+ 2ED5 EE 80                xor     $80             ; Invert sign of mantissa
4278+ 2ED7 77                   ld      (HL),A          ; Re-save sign of mantissa
4279+ 2ED8 C9                   ret
4280+ 2ED9
4281+ 2ED9 EB           STAKFP: ex      DE,HL           ; Save code string address
4282+ 2EDA 2A 32 82             ld      HL,(FPREG)      ; LSB,NLSB of FPREG
4283+ 2EDD E3                   ex      (SP),HL         ; Stack them,get return
4284+ 2EDE E5                   push    HL              ; Re-save return
4285+ 2EDF 2A 34 82             ld      HL,(FPREG+2)    ; MSB and exponent of FPREG
4286+ 2EE2 E3                   ex      (SP),HL         ; Stack them,get return
4287+ 2EE3 E5                   push    HL              ; Re-save return
4288+ 2EE4 EB                   ex      DE,HL           ; Restore code string address
4289+ 2EE5 C9                   ret
4290+ 2EE6
4291+ 2EE6              ; store F.P. number from BCDE into (FPREG)
4292+ 2EE6 CD F7 2E     PHLTFP: call    LOADFP          ; Number at HL to BCDE
4293+ 2EE9 EB           FPBCDE: ex      DE,HL           ; Save code string address
4294+ 2EEA 22 32 82             ld      (FPREG),HL      ; Save LSB,NLSB of number
4295+ 2EED 60                   ld      H,B             ; Exponent of number
4296+ 2EEE 69                   ld      L,C             ; MSB of number
4297+ 2EEF 22 34 82             ld      (FPREG+2),HL    ; Save MSB and exponent
4298+ 2EF2 EB                   ex      DE,HL           ; Restore code string address
4299+ 2EF3 C9                   ret
4300+ 2EF4
4301+ 2EF4              ; load F.P. number from (FPREG) into BCDE
4302+ 2EF4 21 32 82     BCDEFP: ld      HL,FPREG        ; Point to FPREG
4303+ 2EF7 5E           LOADFP: ld      E,(HL)          ; Get LSB of number
4304+ 2EF8 23                   inc     HL
4305+ 2EF9 56                   ld      D,(HL)          ; Get NMSB of number
4306+ 2EFA 23                   inc     HL
4307+ 2EFB 4E                   ld      C,(HL)          ; Get MSB of number
4308+ 2EFC 23                   inc     HL
4309+ 2EFD 46                   ld      B,(HL)          ; Get exponent of number
4310+ 2EFE 23           INCHL:  inc     HL              ; Used for conditional "inc HL"
4311+ 2EFF C9                   ret
4312+ 2F00
4313+ 2F00              ; move floating point from (FPREG) into (HL)
4314+ 2F00 11 32 82     FPTHL:  ld      DE,FPREG        ; Point to FPREG
4315+ 2F03 06 04        DETHL4: ld      B,$04           ; 4 bytes to move
4316+ 2F05 1A           DETHLB: ld      A,(DE)          ; Get source
4317+ 2F06 77                   ld      (HL),A          ; Save destination
4318+ 2F07 13                   inc     DE              ; Next source
4319+ 2F08 23                   inc     HL              ; Next destination
4320+ 2F09 05                   dec     B               ; Count bytes
4321+ 2F0A C2 05 2F             jp      NZ,DETHLB       ; Loop if more
4322+ 2F0D C9                   ret
4323+ 2F0E
4324+ 2F0E 21 34 82     SIGNS:  ld      HL,FPREG+2      ; Point to MSB of FPREG
4325+ 2F11 7E                   ld      A,(HL)          ; Get MSB
4326+ 2F12 07                   rlca                    ; Old sign to carry
4327+ 2F13 37                   scf                     ; Set MSBit
4328+ 2F14 1F                   rra                     ; Set MSBit of MSB
4329+ 2F15 77                   ld      (HL),A          ; Save new MSB
4330+ 2F16 3F                   ccf                     ; Complement sign
4331+ 2F17 1F                   rra                     ; Old sign to carry
4332+ 2F18 23                   inc     HL
4333+ 2F19 23                   inc     HL
4334+ 2F1A 77                   ld      (HL),A          ; Set sign of result
4335+ 2F1B 79                   ld      A,C             ; Get MSB
4336+ 2F1C 07                   rlca                    ; Old sign to carry
4337+ 2F1D 37                   scf                     ; Set MSBit
4338+ 2F1E 1F                   rra                     ; Set MSBit of MSB
4339+ 2F1F 4F                   ld      C,A             ; Save MSB
4340+ 2F20 1F                   rra
4341+ 2F21 AE                   xor     (HL)            ; New sign of result
4342+ 2F22 C9                   ret
4343+ 2F23
4344+ 2F23 78           CMPNUM: ld      A,B             ; Get exponent of number
4345+ 2F24 B7                   or      A
4346+ 2F25 CA A8 2E             jp      Z,TSTSGN        ; Zero - Test sign of FPREG
4347+ 2F28 21 B1 2E             ld      HL,RETREL       ; Return relation routine
4348+ 2F2B E5                   push    HL              ; Save for return
4349+ 2F2C CD A8 2E             call    TSTSGN          ; Test sign of FPREG
4350+ 2F2F 79                   ld      A,C             ; Get MSB of number
4351+ 2F30 C8                   ret     Z               ; FPREG zero - Number's MSB
4352+ 2F31 21 34 82             ld      HL,FPREG+2      ; MSB of FPREG
4353+ 2F34 AE                   xor     (HL)            ; Combine signs
4354+ 2F35 79                   ld      A,C             ; Get MSB of number
4355+ 2F36 F8                   ret     M               ; Exit if signs different
4356+ 2F37 CD 3D 2F             call    CMPFP           ; Compare FP numbers
4357+ 2F3A 1F                   rra                     ; Get carry to sign
4358+ 2F3B A9                   xor     C               ; Combine with MSB of number
4359+ 2F3C C9                   ret
4360+ 2F3D
4361+ 2F3D 23           CMPFP:  inc     HL              ; Point to exponent
4362+ 2F3E 78                   ld      A,B             ; Get exponent
4363+ 2F3F BE                   cp      (HL)            ; Compare exponents
4364+ 2F40 C0                   ret     NZ              ; Different
4365+ 2F41 2B                   dec     HL              ; Point to MBS
4366+ 2F42 79                   ld      A,C             ; Get MSB
4367+ 2F43 BE                   cp      (HL)            ; Compare MSBs
4368+ 2F44 C0                   ret     NZ              ; Different
4369+ 2F45 2B                   dec     HL              ; Point to NMSB
4370+ 2F46 7A                   ld      A,D             ; Get NMSB
4371+ 2F47 BE                   cp      (HL)            ; Compare NMSBs
4372+ 2F48 C0                   ret     NZ              ; Different
4373+ 2F49 2B                   dec     HL              ; Point to LSB
4374+ 2F4A 7B                   ld      A,E             ; Get LSB
4375+ 2F4B 96                   sub     (HL)            ; Compare LSBs
4376+ 2F4C C0                   ret     NZ              ; Different
4377+ 2F4D E1                   pop     HL              ; Drop RETurn
4378+ 2F4E E1                   pop     HL              ; Drop another RETurn
4379+ 2F4F C9                   ret
4380+ 2F50
4381+ 2F50 47           FPINT:  ld      B,A             ; <- Move
4382+ 2F51 4F                   ld      C,A             ; <- exponent
4383+ 2F52 57                   ld      D,A             ; <- to all
4384+ 2F53 5F                   ld      E,A             ; <- bits
4385+ 2F54 B7                   or      A               ; Test exponent
4386+ 2F55 C8                   ret     Z               ; Zero - Return zero
4387+ 2F56 E5                   push    HL              ; Save pointer to number
4388+ 2F57 CD F4 2E             call    BCDEFP          ; Move FPREG to BCDE
4389+ 2F5A CD 0E 2F             call    SIGNS           ; Set MSBs & sign of result
4390+ 2F5D AE                   xor     (HL)            ; Combine with sign of FPREG
4391+ 2F5E 67                   ld      H,A             ; Save combined signs
4392+ 2F5F FC 74 2F             call    M,DCBCDE        ; Negative - Decrement BCDE
4393+ 2F62 3E 98                ld      A,$80+24        ; 24 bits
4394+ 2F64 90                   sub     B               ; Bits to shift
4395+ 2F65 CD D6 2C             call    SCALE           ; Shift BCDE
4396+ 2F68 7C                   ld      A,H             ; Get combined sign
4397+ 2F69 17                   rla                     ; Sign to carry
4398+ 2F6A DC A9 2C             call    C,FPROND        ; Negative - Round number up
4399+ 2F6D 06 00                ld      B,$00           ; Zero exponent
4400+ 2F6F DC C2 2C             call    C,COMPL         ; If negative make positive
4401+ 2F72 E1                   pop     HL              ; Restore pointer to number
4402+ 2F73 C9                   ret
4403+ 2F74
4404+ 2F74 1B           DCBCDE: dec     DE              ; Decrement BCDE
4405+ 2F75 7A                   ld      A,D             ; Test LSBs
4406+ 2F76 A3                   and     E
4407+ 2F77 3C                   inc     A
4408+ 2F78 C0                   ret     NZ              ; Exit if LSBs not FFFF
4409+ 2F79 0B                   dec     BC              ; Decrement MSBs
4410+ 2F7A C9                   ret
4411+ 2F7B
4412+ 2F7B 21 35 82     INT:    ld      HL,FPEXP        ; Point to exponent
4413+ 2F7E 7E                   ld      A,(HL)          ; Get exponent
4414+ 2F7F FE 98                cp      $80+24          ; Integer accuracy only?
4415+ 2F81 3A 32 82             ld      A,(FPREG)       ; Get LSB
4416+ 2F84 D0                   ret     NC              ; Yes - Already integer
4417+ 2F85 7E                   ld      A,(HL)          ; Get exponent
4418+ 2F86 CD 50 2F             call    FPINT           ; F.P to integer
4419+ 2F89 36 98                ld      (HL),$80+24     ; Save 24 bit integer
4420+ 2F8B 7B                   ld      A,E             ; Get LSB of number
4421+ 2F8C F5                   push    AF              ; Save LSB
4422+ 2F8D 79                   ld      A,C             ; Get MSB of number
4423+ 2F8E 17                   rla                     ; Sign to carry
4424+ 2F8F CD 5F 2C             call    CONPOS          ; Set sign of result
4425+ 2F92 F1                   pop     AF              ; Restore LSB of number
4426+ 2F93 C9                   ret
4427+ 2F94
4428+ 2F94 21 00 00     MLDEBC: ld      HL,$0000        ; Clear partial product
4429+ 2F97 78                   ld      A,B             ; Test multiplier
4430+ 2F98 B1                   or      C
4431+ 2F99 C8                   ret     Z               ; Return zero if zero
4432+ 2F9A 3E 10                ld      A,$10           ; 16 bits
4433+ 2F9C 29           MLDBLP: add     HL,HL           ; Shift P.P left
4434+ 2F9D DA C2 23             jp      C,BSERR         ; ?BS Error if overflow
4435+ 2FA0 EB                   ex      DE,HL
4436+ 2FA1 29                   add     HL,HL           ; Shift multiplier left
4437+ 2FA2 EB                   ex      DE,HL
4438+ 2FA3 D2 AA 2F             jp      NC,NOMLAD       ; Bit was zero - No add
4439+ 2FA6 09                   add     HL,BC           ; Add multiplicand
4440+ 2FA7 DA C2 23             jp      C,BSERR         ; ?BS Error if overflow
4441+ 2FAA 3D           NOMLAD: dec     A               ; Count bits
4442+ 2FAB C2 9C 2F             jp      NZ,MLDBLP       ; More
4443+ 2FAE C9                   ret
4444+ 2FAF
4445+ 2FAF FE 2D        ASCTFP: cp      '-'             ; Negative?
4446+ 2FB1 F5                   push    AF              ; Save it and flags
4447+ 2FB2 CA BB 2F             jp      Z,CNVNUM        ; Yes - Convert number
4448+ 2FB5 FE 2B                cp      '+'             ; Positive?
4449+ 2FB7 CA BB 2F             jp      Z,CNVNUM        ; Yes - Convert number
4450+ 2FBA 2B                   dec     HL              ; dec 'cos GETCHR INCs
4451+ 2FBB CD 77 2C     CNVNUM: call    RESZER          ; Set result to zero
4452+ 2FBE 47                   ld      B,A             ; Digits after point counter
4453+ 2FBF 57                   ld      D,A             ; Sign of exponent
4454+ 2FC0 5F                   ld      E,A             ; Exponent of ten
4455+ 2FC1 2F                   cpl
4456+ 2FC2 4F                   ld      C,A             ; Before or after point flag
4457+ 2FC3 CD 12 1C     MANLP:  call    GETCHR          ; Get next character
4458+ 2FC6 DA 0C 30             jp      C,ADDIG         ; Digit - Add to number
4459+ 2FC9 FE 2E                cp      '.'
4460+ 2FCB CA E7 2F             jp      Z,DPOINT        ; '.' - Flag point
4461+ 2FCE FE 45                cp      'E'
4462+ 2FD0 C2 EB 2F             jp      NZ,CONEXP       ; Not 'E' - Scale number
4463+ 2FD3 CD 12 1C             call    GETCHR          ; Get next character
4464+ 2FD6 CD DE 21             call    SGNEXP          ; Get sign of exponent
4465+ 2FD9 CD 12 1C     EXPLP:  call    GETCHR          ; Get next character
4466+ 2FDC DA 2E 30             jp      C,EDIGIT        ; Digit - Add to exponent
4467+ 2FDF 14                   inc     D               ; Is sign negative?
4468+ 2FE0 C2 EB 2F             jp      NZ,CONEXP       ; No - Scale number
4469+ 2FE3 AF                   xor     A
4470+ 2FE4 93                   sub     E               ; Negate exponent
4471+ 2FE5 5F                   ld      E,A             ; And re-save it
4472+ 2FE6 0C                   inc     C               ; Flag end of number
4473+ 2FE7 0C           DPOINT: inc     C               ; Flag point passed
4474+ 2FE8 CA C3 2F             jp      Z,MANLP         ; Zero - Get another digit
4475+ 2FEB E5           CONEXP: push    HL              ; Save code string address
4476+ 2FEC 7B                   ld      A,E             ; Get exponent
4477+ 2FED 90                   sub     B               ; Subtract digits after point
4478+ 2FEE F4 04 30     SCALMI: call    P,SCALPL        ; Positive - Multiply number
4479+ 2FF1 F2 FA 2F             jp      P,ENDCON        ; Positive - All done
4480+ 2FF4 F5                   push    AF              ; Save number of times to /10
4481+ 2FF5 CD F0 2D             call    DIV10           ; Divide by 10
4482+ 2FF8 F1                   pop     AF              ; Restore count
4483+ 2FF9 3C                   inc     A               ; Count divides
4484+ 2FFA
4485+ 2FFA C2 EE 2F     ENDCON: jp      NZ,SCALMI       ; More to do
4486+ 2FFD D1                   pop     DE              ; Restore code string address
4487+ 2FFE F1                   pop     AF              ; Restore sign of number
4488+ 2FFF CC D1 2E             call    Z,INVSGN        ; Negative - Negate number
4489+ 3002 EB                   ex      DE,HL           ; Code string address to HL
4490+ 3003 C9                   ret
4491+ 3004
4492+ 3004 C8           SCALPL: ret     Z               ; Exit if no scaling needed
4493+ 3005 F5           MULTEN: push    AF              ; Save count
4494+ 3006 CD 91 2E             call    MLSP10          ; Multiply number by 10
4495+ 3009 F1                   pop     AF              ; Restore count
4496+ 300A 3D                   dec     A               ; Count multiplies
4497+ 300B C9                   ret
4498+ 300C
4499+ 300C D5           ADDIG:  push    DE              ; Save sign of exponent
4500+ 300D 57                   ld      D,A             ; Save digit
4501+ 300E 78                   ld      A,B             ; Get digits after point
4502+ 300F 89                   adc     A,C             ; Add one if after point
4503+ 3010 47                   ld      B,A             ; Re-save counter
4504+ 3011 C5                   push    BC              ; Save point flags
4505+ 3012 E5                   push    HL              ; Save code string address
4506+ 3013 D5                   push    DE              ; Save digit
4507+ 3014 CD 91 2E             call    MLSP10          ; Multiply number by 10
4508+ 3017 F1                   pop     AF              ; Restore digit
4509+ 3018 D6 30                sub     '0'             ; Make it absolute
4510+ 301A CD 23 30             call    RSCALE          ; Re-scale number
4511+ 301D E1                   pop     HL              ; Restore code string address
4512+ 301E C1                   pop     BC              ; Restore point flags
4513+ 301F D1                   pop     DE              ; Restore sign of exponent
4514+ 3020 C3 C3 2F             jp      MANLP           ; Get another digit
4515+ 3023
4516+ 3023 CD D9 2E     RSCALE: call    STAKFP          ; Put number on stack
4517+ 3026 CD BA 2E             call    FLGREL          ; Digit to add to FPREG
4518+ 3029 C1           PADD:   pop     BC              ; Restore number
4519+ 302A D1                   pop     DE
4520+ 302B C3 11 2C             jp      FPADD           ; Add BCDE to FPREG and return
4521+ 302E
4522+ 302E 7B           EDIGIT: ld      A,E             ; Get digit
4523+ 302F 07                   rlca                    ; Times 2
4524+ 3030 07                   rlca                    ; Times 4
4525+ 3031 83                   add     A,E             ; Times 5
4526+ 3032 07                   rlca                    ; Times 10
4527+ 3033 86                   add     A,(HL)          ; Add next digit
4528+ 3034 D6 30                sub     '0'             ; Make it absolute
4529+ 3036 5F                   ld      E,A             ; Save new digit
4530+ 3037 C3 D9 2F             jp      EXPLP           ; Look for another digit
4531+ 303A
4532+ 303A E5           LINEIN: push    HL              ; Save code string address
4533+ 303B 21 68 16             ld      HL,INMSG        ; Output " in "
4534+ 303E CD A3 25             call    PRS             ; Output string at HL
4535+ 3041 E1                   pop     HL              ; Restore code string address
4536+ 3042 EB           PRNTHL: ex      DE,HL           ; Code string address to DE
4537+ 3043 AF                   xor     A
4538+ 3044 06 98                ld      B,$80+24        ; 24 bits
4539+ 3046 CD BF 2E             call    RETINT          ; Return the integer
4540+ 3049 21 A2 25             ld      HL,PRNUMS       ; Print number string
4541+ 304C E5                   push    HL              ; Save for return
4542+ 304D 21 37 82     NUMASC: ld      HL,PBUFF        ; Convert number to ASCII
4543+ 3050 E5                   push    HL              ; Save for return
4544+ 3051 CD A8 2E             call    TSTSGN          ; Test sign of FPREG
4545+ 3054 36 20                ld      (HL),SPC        ; Space at start
4546+ 3056 F2 5B 30             jp      P,SPCFST        ; Positive - Space to start
4547+ 3059 36 2D                ld      (HL),'-'        ; '-' sign at start
4548+ 305B 23           SPCFST: inc     HL              ; First byte of number
4549+ 305C 36 30                ld      (HL),'0'        ; '0' if zero
4550+ 305E CA 11 31             jp      Z,JSTZER        ; Return '0' if zero
4551+ 3061 E5                   push    HL              ; Save buffer address
4552+ 3062 FC D1 2E             call    M,INVSGN        ; Negate FPREG if negative
4553+ 3065 AF                   xor     A               ; Zero A
4554+ 3066 F5                   push    AF              ; Save it
4555+ 3067 CD 17 31             call    RNGTST          ; Test number is in range
4556+ 306A 01 43 91     SIXDIG: ld      BC,$9143        ; BCDE - 99999.9
4557+ 306D 11 F8 4F             ld      DE,$4FF8
4558+ 3070 CD 23 2F             call    CMPNUM          ; Compare numbers
4559+ 3073 B7                   or      A
4560+ 3074 E2 88 30             jp      PO,INRNG        ; > 99999.9 - Sort it out
4561+ 3077 F1                   pop     AF              ; Restore count
4562+ 3078 CD 05 30             call    MULTEN          ; Multiply by ten
4563+ 307B F5                   push    AF              ; Re-save count
4564+ 307C C3 6A 30             jp      SIXDIG          ; Test it again
4565+ 307F
4566+ 307F CD F0 2D     GTSIXD: call    DIV10           ; Divide by 10
4567+ 3082 F1                   pop     AF              ; Get count
4568+ 3083 3C                   inc     A               ; Count divides
4569+ 3084 F5                   push    AF              ; Re-save count
4570+ 3085 CD 17 31             call    RNGTST          ; Test number is in range
4571+ 3088 CD FF 2B     INRNG:  call    ROUND           ; Add 0.5 to FPREG
4572+ 308B 3C                   inc     A
4573+ 308C CD 50 2F             call    FPINT           ; F.P to integer
4574+ 308F CD E9 2E             call    FPBCDE          ; Move BCDE to FPREG
4575+ 3092 01 06 03             ld      BC,$0306        ; 1E+06 to 1E-03 range
4576+ 3095 F1                   pop     AF              ; Restore count
4577+ 3096 81                   add     A,C             ; 6 digits before point
4578+ 3097 3C                   inc     A               ; Add one
4579+ 3098 FA A4 30             jp      M,MAKNUM        ; Do it in 'E' form if < 1E-02
4580+ 309B FE 08                cp      6+1+1           ; More than 999999 ?
4581+ 309D D2 A4 30             jp      NC,MAKNUM       ; Yes - Do it in 'E' form
4582+ 30A0 3C                   inc     A               ; Adjust for exponent
4583+ 30A1 47                   ld      B,A             ; Exponent of number
4584+ 30A2 3E 02                ld      A,2             ; Make it zero after
4585+ 30A4
4586+ 30A4 3D           MAKNUM: dec     A               ; Adjust for digits to do
4587+ 30A5 3D                   dec     A
4588+ 30A6 E1                   pop     HL              ; Restore buffer address
4589+ 30A7 F5                   push    AF              ; Save count
4590+ 30A8 11 2A 31             ld      DE,POWERS       ; Powers of ten
4591+ 30AB 05                   dec     B               ; Count digits before point
4592+ 30AC C2 B5 30             jp      NZ,DIGTXT       ; Not zero - Do number
4593+ 30AF 36 2E                ld      (HL),'.'        ; Save point
4594+ 30B1 23                   inc     HL              ; Move on
4595+ 30B2 36 30                ld      (HL),'0'        ; Save zero
4596+ 30B4 23                   inc     HL              ; Move on
4597+ 30B5 05           DIGTXT: dec     B               ; Count digits before point
4598+ 30B6 36 2E                ld      (HL),'.'        ; Save point in case
4599+ 30B8 CC FE 2E             call    Z,INCHL         ; Last digit - move on
4600+ 30BB C5                   push    BC              ; Save digits before point
4601+ 30BC E5                   push    HL              ; Save buffer address
4602+ 30BD D5                   push    DE              ; Save powers of ten
4603+ 30BE CD F4 2E             call    BCDEFP          ; Move FPREG to BCDE
4604+ 30C1 E1                   pop     HL              ; Powers of ten table
4605+ 30C2 06 2F                ld      B,'0'-1         ; ASCII '0' - 1
4606+ 30C4 04           TRYAGN: inc     B               ; Count subtractions
4607+ 30C5 7B                   ld      A,E             ; Get LSB
4608+ 30C6 96                   sub     (HL)            ; Subtract LSB
4609+ 30C7 5F                   ld      E,A             ; Save LSB
4610+ 30C8 23                   inc     HL
4611+ 30C9 7A                   ld      A,D             ; Get NMSB
4612+ 30CA 9E                   sbc     A,(HL)          ; Subtract NMSB
4613+ 30CB 57                   ld      D,A             ; Save NMSB
4614+ 30CC 23                   inc     HL
4615+ 30CD 79                   ld      A,C             ; Get MSB
4616+ 30CE 9E                   sbc     A,(HL)          ; Subtract MSB
4617+ 30CF 4F                   ld      C,A             ; Save MSB
4618+ 30D0 2B                   dec     HL              ; Point back to start
4619+ 30D1 2B                   dec     HL
4620+ 30D2 D2 C4 30             jp      NC,TRYAGN       ; No overflow - Try again
4621+ 30D5 CD B6 2C             call    PLUCDE          ; Restore number
4622+ 30D8 23                   inc     HL              ; Start of next number
4623+ 30D9 CD E9 2E             call    FPBCDE          ; Move BCDE to FPREG
4624+ 30DC EB                   ex      DE,HL           ; Save point in table
4625+ 30DD E1                   pop     HL              ; Restore buffer address
4626+ 30DE 70                   ld      (HL),B          ; Save digit in buffer
4627+ 30DF 23                   inc     HL              ; And move on
4628+ 30E0 C1                   pop     BC              ; Restore digit count
4629+ 30E1 0D                   dec     C               ; Count digits
4630+ 30E2 C2 B5 30             jp      NZ,DIGTXT       ; More - Do them
4631+ 30E5 05                   dec     B               ; Any decimal part?
4632+ 30E6 CA F5 30             jp      Z,DOEBIT        ; No - Do 'E' bit
4633+ 30E9 2B           SUPTLZ: dec     HL              ; Move back through buffer
4634+ 30EA 7E                   ld      A,(HL)          ; Get character
4635+ 30EB FE 30                cp      '0'             ; '0' character?
4636+ 30ED CA E9 30             jp      Z,SUPTLZ        ; Yes - Look back for more
4637+ 30F0 FE 2E                cp      '.'             ; A decimal point?
4638+ 30F2 C4 FE 2E             call    NZ,INCHL        ; Move back over digit
4639+ 30F5
4640+ 30F5 F1           DOEBIT: pop     AF              ; Get 'E' flag
4641+ 30F6 CA 14 31             jp      Z,NOENED        ; No 'E' needed - End buffer
4642+ 30F9 36 45                ld      (HL),'E'        ; Put 'E' in buffer
4643+ 30FB 23                   inc     HL              ; And move on
4644+ 30FC 36 2B                ld      (HL),'+'        ; Put '+' in buffer
4645+ 30FE F2 05 31             jp      P,OUTEXP        ; Positive - Output exponent
4646+ 3101 36 2D                ld      (HL),'-'        ; Put '-' in buffer
4647+ 3103 2F                   cpl                     ; Negate exponent
4648+ 3104 3C                   inc     A
4649+ 3105 06 2F        OUTEXP: ld      B,'0'-1         ; ASCII '0' - 1
4650+ 3107 04           EXPTEN: inc     B               ; Count subtractions
4651+ 3108 D6 0A                sub     $0A             ; Tens digit
4652+ 310A D2 07 31             jp      NC,EXPTEN       ; More to do
4653+ 310D C6 3A                add     A,'0'+10        ; Restore and make ASCII
4654+ 310F 23                   inc     HL              ; Move on
4655+ 3110 70                   ld      (HL),B          ; Save MSB of exponent
4656+ 3111 23           JSTZER: inc     HL              ;
4657+ 3112 77                   ld      (HL),A          ; Save LSB of exponent
4658+ 3113 23                   inc     HL
4659+ 3114 71           NOENED: ld      (HL),C          ; Mark end of buffer
4660+ 3115 E1                   pop     HL              ; Restore code string address
4661+ 3116 C9                   ret
4662+ 3117
4663+ 3117 01 74 94     RNGTST: ld      BC,$9474        ; BCDE = 999999.
4664+ 311A 11 F7 23             ld      DE,$23F7
4665+ 311D CD 23 2F             call    CMPNUM          ; Compare numbers
4666+ 3120 B7                   or      A
4667+ 3121 E1                   pop     HL              ; Return address to HL
4668+ 3122 E2 7F 30             jp      PO,GTSIXD       ; Too big - Divide by ten
4669+ 3125 E9                   jp      (HL)            ; Otherwise return to caller
4670+ 3126
4671+ 3126 00 00 00 80  HALF:   defb    $00,$00,$00,$80 ; 0.5
4672+ 312A
4673+ 312A A0 86 01     POWERS: defb    $A0,$86,$01  ; 100000
4674+ 312D 10 27 00             defb    $10,$27,$00  ;  10000
4675+ 3130 E8 03 00             defb    $E8,$03,$00  ;   1000
4676+ 3133 64 00 00             defb    $64,$00,$00  ;    100
4677+ 3136 0A 00 00             defb    $0A,$00,$00  ;     10
4678+ 3139 01 00 00             defb    $01,$00,$00  ;      1
4679+ 313C
4680+ 313C 21 D1 2E     NEGAFT: ld      HL,INVSGN       ; Negate result
4681+ 313F E3                   ex      (SP),HL         ; To be done after caller
4682+ 3140 E9                   jp      (HL)            ; Return to caller
4683+ 3141
4684+ 3141 CD D9 2E     SQR:    call    STAKFP          ; Put value on stack
4685+ 3144 21 26 31             ld      HL,HALF         ; Set power to 1/2
4686+ 3147 CD E6 2E             call    PHLTFP          ; Move 1/2 to FPREG
4687+ 314A
4688+ 314A C1           POWER:  pop     BC              ; Get base
4689+ 314B D1                   pop     DE
4690+ 314C CD A8 2E             call    TSTSGN          ; Test sign of power
4691+ 314F 78                   ld      A,B             ; Get exponent of base
4692+ 3150 CA 8F 31             jp      Z,EXP           ; Make result 1 if zero
4693+ 3153 F2 5A 31             jp      P,POWER1        ; Positive base - Ok
4694+ 3156 B7                   or      A               ; Zero to negative power?
4695+ 3157 CA F2 16             jp      Z,DZERR         ; Yes - ?/0 Error
4696+ 315A B7           POWER1: or      A               ; Base zero?
4697+ 315B CA 78 2C             jp      Z,SAVEXP        ; Yes - Return zero
4698+ 315E D5                   push    DE              ; Save base
4699+ 315F C5                   push    BC
4700+ 3160 79                   ld      A,C             ; Get MSB of base
4701+ 3161 F6 7F                or      %01111111       ; Get sign status
4702+ 3163 CD F4 2E             call    BCDEFP          ; Move power to BCDE
4703+ 3166 F2 77 31             jp      P,POWER2        ; Positive base - Ok
4704+ 3169 D5                   push    DE              ; Save power
4705+ 316A C5                   push    BC
4706+ 316B CD 7B 2F             call    INT             ; Get integer of power
4707+ 316E C1                   pop     BC              ; Restore power
4708+ 316F D1                   pop     DE
4709+ 3170 F5                   push    AF              ; MSB of base
4710+ 3171 CD 23 2F             call    CMPNUM          ; Power an integer?
4711+ 3174 E1                   pop     HL              ; Restore MSB of base
4712+ 3175 7C                   ld      A,H             ; but don't affect flags
4713+ 3176 1F                   rra                     ; Exponent odd or even?
4714+ 3177 E1           POWER2: pop     HL              ; Restore MSB and exponent
4715+ 3178 22 34 82             ld      (FPREG+2),HL    ; Save base in FPREG
4716+ 317B E1                   pop     HL              ; LSBs of base
4717+ 317C 22 32 82             ld      (FPREG),HL      ; Save in FPREG
4718+ 317F DC 3C 31             call    C,NEGAFT        ; Odd power - Negate result
4719+ 3182 CC D1 2E             call    Z,INVSGN        ; Negative base - Negate it
4720+ 3185 D5                   push    DE              ; Save power
4721+ 3186 C5                   push    BC
4722+ 3187 CD 0B 2D             call    LOG             ; Get LOG of base
4723+ 318A C1                   pop     BC              ; Restore power
4724+ 318B D1                   pop     DE
4725+ 318C CD 4C 2D             call    FPMULT          ; Multiply LOG by power
4726+ 318F
4727+ 318F CD D9 2E     EXP:    call    STAKFP          ; Put value on stack
4728+ 3192 01 38 81             ld      BC,$8138        ; BCDE = 1/Ln(2)
4729+ 3195 11 3B AA             ld      DE,$AA3B
4730+ 3198 CD 4C 2D             call    FPMULT          ; Multiply value by 1/LN(2)
4731+ 319B 3A 35 82             ld      A,(FPEXP)       ; Get exponent
4732+ 319E FE 88                cp      $80+8           ; Is it in range?
4733+ 31A0 D2 84 2E             jp      NC,OVTST1       ; No - Test for overflow
4734+ 31A3 CD 7B 2F             call    INT             ; Get INT of FPREG
4735+ 31A6 C6 80                add     A,$80           ; For excess 128
4736+ 31A8 C6 02                add     A,$02           ; Exponent > 126?
4737+ 31AA DA 84 2E             jp      C,OVTST1        ; Yes - Test for overflow
4738+ 31AD F5                   push    AF              ; Save scaling factor
4739+ 31AE 21 FA 2C             ld      HL,UNITY        ; Point to 1.
4740+ 31B1 CD 02 2C             call    ADDPHL          ; Add 1 to FPREG
4741+ 31B4 CD 43 2D             call    MULLN2          ; Multiply by LN(2)
4742+ 31B7 F1                   pop     AF              ; Restore scaling factor
4743+ 31B8 C1                   pop     BC              ; Restore exponent
4744+ 31B9 D1                   pop     DE
4745+ 31BA F5                   push    AF              ; Save scaling factor
4746+ 31BB CD 0E 2C             call    SUBCDE          ; Subtract exponent from FPREG
4747+ 31BE CD D1 2E             call    INVSGN          ; Negate result
4748+ 31C1 21 CF 31             ld      HL,EXPTAB       ; Coefficient table
4749+ 31C4 CD FF 31             call    SMSER1          ; Sum the series
4750+ 31C7 11 00 00             ld      DE,$0000        ; Zero LSBs
4751+ 31CA C1                   pop     BC              ; Scaling factor
4752+ 31CB 4A                   ld      C,D             ; Zero MSB
4753+ 31CC C3 4C 2D             jp      FPMULT          ; Scale result to correct value
4754+ 31CF
4755+ 31CF 08           EXPTAB: defb    $08             ; Table used by EXP
4756+ 31D0 40 2E 94 74          defb    $40,$2E,$94,$74 ; -1/7! (-1/5040)
4757+ 31D4 70 4F 2E 77          defb    $70,$4F,$2E,$77 ;  1/6! ( 1/720)
4758+ 31D8 6E 02 88 7A          defb    $6E,$02,$88,$7A ; -1/5! (-1/120)
4759+ 31DC E6 A0 2A 7C          defb    $E6,$A0,$2A,$7C ;  1/4! ( 1/24)
4760+ 31E0 50 AA AA 7E          defb    $50,$AA,$AA,$7E ; -1/3! (-1/6)
4761+ 31E4 FF FF 7F 7F          defb    $FF,$FF,$7F,$7F ;  1/2! ( 1/2)
4762+ 31E8 00 00 80 81          defb    $00,$00,$80,$81 ; -1/1! (-1/1)
4763+ 31EC 00 00 00 81          defb    $00,$00,$00,$81 ;  1/0! ( 1/1)
4764+ 31F0
4765+ 31F0 CD D9 2E     SUMSER: call    STAKFP          ; Put FPREG on stack
4766+ 31F3 11 4A 2D             ld      DE,MULT         ; Multiply by "X"
4767+ 31F6 D5                   push    DE              ; To be done after
4768+ 31F7 E5                   push    HL              ; Save address of table
4769+ 31F8 CD F4 2E             call    BCDEFP          ; Move FPREG to BCDE
4770+ 31FB CD 4C 2D             call    FPMULT          ; Square the value
4771+ 31FE E1                   pop     HL              ; Restore address of table
4772+ 31FF CD D9 2E     SMSER1: call    STAKFP          ; Put value on stack
4773+ 3202 7E                   ld      A,(HL)          ; Get number of coefficients
4774+ 3203 23                   inc     HL              ; Point to start of table
4775+ 3204 CD E6 2E             call    PHLTFP          ; Move coefficient to FPREG
4776+ 3207 06                   defb    06H             ; Skip "pop AF"
4777+ 3208 F1           SUMLP:  pop     AF              ; Restore count
4778+ 3209 C1                   pop     BC              ; Restore number
4779+ 320A D1                   pop     DE
4780+ 320B 3D                   dec     A               ; Cont coefficients
4781+ 320C C8                   ret     Z               ; All done
4782+ 320D D5                   push    DE              ; Save number
4783+ 320E C5                   push    BC
4784+ 320F F5                   push    AF              ; Save count
4785+ 3210 E5                   push    HL              ; Save address in table
4786+ 3211 CD 4C 2D             call    FPMULT          ; Multiply FPREG by BCDE
4787+ 3214 E1                   pop     HL              ; Restore address in table
4788+ 3215 CD F7 2E             call    LOADFP          ; Number at HL to BCDE
4789+ 3218 E5                   push    HL              ; Save address in table
4790+ 3219 CD 11 2C             call    FPADD           ; Add coefficient to FPREG
4791+ 321C E1                   pop     HL              ; Restore address in table
4792+ 321D C3 08 32             jp      SUMLP           ; More coefficients
4793+ 3220
4794+ 3220
4795+ 3220              ; random number generator
4796+ 3220              ; a negative argument is used as a seed for the RNG
4797+ 3220              ; 0 is used to repeat the last random number
4798+ 3220              ; a positive argument generates a new random number
4799+ 3220 CD A8 2E     RND:    call    TSTSGN          ; Test sign of FPREG
4800+ 3223 21 7A 80             ld      HL,SEED+2       ; Random number seed
4801+ 3226 FA 81 32             jp      M,RESEED        ; Negative - Re-seed
4802+ 3229 21 9B 80             ld      HL,LSTRND       ; Last random number
4803+ 322C CD E6 2E             call    PHLTFP          ; Move last RND to FPREG
4804+ 322F 21 7A 80             ld      HL,SEED+2       ; Random number seed
4805+ 3232 C8                   ret     Z               ; Return if RND(0)
4806+ 3233 86                   add     A,(HL)          ; Add (SEED)+2)
4807+ 3234 E6 07                and     %00000111       ; 0 to 7
4808+ 3236 06 00                ld      B,$00
4809+ 3238 77                   ld      (HL),A          ; Re-save seed
4810+ 3239 23                   inc     HL              ; Move to coefficient table
4811+ 323A 87                   add     A,A             ; 4 bytes
4812+ 323B 87                   add     A,A             ; per entry
4813+ 323C 4F                   ld      C,A             ; BC = Offset into table
4814+ 323D 09                   add     HL,BC           ; Point to coefficient
4815+ 323E CD F7 2E             call    LOADFP          ; Coefficient to BCDE
4816+ 3241 CD 4C 2D             call    FPMULT  ;       ; Multiply FPREG by coefficient
4817+ 3244 3A 79 80             ld      A,(SEED+1)      ; Get (SEED+1)
4818+ 3247 3C                   inc     A               ; Add 1
4819+ 3248 E6 03                and     %00000011       ; 0 to 3
4820+ 324A 06 00                ld      B,$00
4821+ 324C FE 01                cp      $01             ; Is it zero?
4822+ 324E 88                   adc     A,B             ; Yes - Make it 1
4823+ 324F 32 79 80             ld      (SEED+1),A      ; Re-save seed
4824+ 3252 21 85 32             ld      HL,RNDTAB-4     ; Addition table
4825+ 3255 87                   add     A,A             ; 4 bytes
4826+ 3256 87                   add     A,A             ; per entry
4827+ 3257 4F                   ld      C,A             ; BC = Offset into table
4828+ 3258 09                   add     HL,BC           ; Point to value
4829+ 3259 CD 02 2C             call    ADDPHL          ; Add value to FPREG
4830+ 325C CD F4 2E     RND1:   call    BCDEFP          ; Move FPREG to BCDE
4831+ 325F 7B                   ld      A,E             ; Get LSB
4832+ 3260 59                   ld      E,C             ; LSB = MSB
4833+ 3261 EE 4F                xor     %01001111       ; Fiddle around
4834+ 3263 4F                   ld      C,A             ; New MSB
4835+ 3264 36 80                ld      (HL),$80        ; Set exponent
4836+ 3266 2B                   dec     HL              ; Point to MSB
4837+ 3267 46                   ld      B,(HL)          ; Get MSB
4838+ 3268 36 80                ld      (HL),$80        ; Make value -0.5
4839+ 326A 21 78 80             ld      HL,SEED         ; Random number seed
4840+ 326D 34                   inc     (HL)            ; Count seed
4841+ 326E 7E                   ld      A,(HL)          ; Get seed
4842+ 326F D6 AB                sub     $AB             ; Do it modulo 171
4843+ 3271 C2 78 32             jp      NZ,RND2         ; Non-zero - Ok
4844+ 3274 77                   ld      (HL),A          ; Zero seed
4845+ 3275 0C                   inc     C               ; Fillde about
4846+ 3276 15                   dec     D               ; with the
4847+ 3277 1C                   inc     E               ; number
4848+ 3278 CD 62 2C     RND2:   call    BNORM           ; Normalise number
4849+ 327B 21 9B 80             ld      HL,LSTRND       ; Save random number
4850+ 327E C3 00 2F             jp      FPTHL           ; Move FPREG to last and return
4851+ 3281
4852+ 3281 77           RESEED: ld      (HL),A          ; Re-seed random numbers
4853+ 3282 2B                   dec     HL
4854+ 3283 77                   ld      (HL),A
4855+ 3284 2B                   dec     HL
4856+ 3285 77                   ld      (HL),A
4857+ 3286 C3 5C 32             jp      RND1            ; Return RND seed
4858+ 3289
4859+ 3289 68 B1 46 68  RNDTAB: defb    $68,$B1,$46,$68 ; Table used by RND
4860+ 328D 99 E9 92 69          defb    $99,$E9,$92,$69
4861+ 3291 10 D1 75 68          defb    $10,$D1,$75,$68
4862+ 3295
4863+ 3295              ; COS and SIN functions
4864+ 3295 21 DF 32     COS:    ld      HL,HALFPI       ; Point to PI/2
4865+ 3298 CD 02 2C             call    ADDPHL          ; Add it to PPREG
4866+ 329B CD D9 2E     SIN:    call    STAKFP          ; Put angle on stack
4867+ 329E 01 49 83             ld      BC,$8349        ; BCDE = 2 PI
4868+ 32A1 11 DB 0F             ld      DE,$0FDB
4869+ 32A4 CD E9 2E             call    FPBCDE          ; Move 2 PI to FPREG
4870+ 32A7 C1                   pop     BC              ; Restore angle
4871+ 32A8 D1                   pop     DE
4872+ 32A9 CD FE 2D             call    DVBCDE          ; Divide angle by 2 PI
4873+ 32AC CD D9 2E             call    STAKFP          ; Put it on stack
4874+ 32AF CD 7B 2F             call    INT             ; Get INT of result
4875+ 32B2 C1                   pop     BC              ; Restore number
4876+ 32B3 D1                   pop     DE
4877+ 32B4 CD 0E 2C             call    SUBCDE          ; Make it 0 <= value < 1
4878+ 32B7 21 E3 32             ld      HL,QUARTR       ; Point to 0.25
4879+ 32BA CD 08 2C             call    SUBPHL          ; Subtract value from 0.25
4880+ 32BD CD A8 2E             call    TSTSGN          ; Test sign of value
4881+ 32C0 37                   scf                     ; Flag positive
4882+ 32C1 F2 CB 32             jp      P,SIN1          ; Positive - Ok
4883+ 32C4 CD FF 2B             call    ROUND           ; Add 0.5 to value
4884+ 32C7 CD A8 2E             call    TSTSGN          ; Test sign of value
4885+ 32CA B7                   or      A               ; Flag negative
4886+ 32CB F5           SIN1:   push    AF              ; Save sign
4887+ 32CC F4 D1 2E             call    P,INVSGN        ; Negate value if positive
4888+ 32CF 21 E3 32             ld      HL,QUARTR       ; Point to 0.25
4889+ 32D2 CD 02 2C             call    ADDPHL          ; Add 0.25 to value
4890+ 32D5 F1                   pop     AF              ; Restore sign
4891+ 32D6 D4 D1 2E             call    NC,INVSGN       ; Negative - Make positive
4892+ 32D9 21 E7 32             ld      HL,SINTAB       ; Coefficient table
4893+ 32DC C3 F0 31             jp      SUMSER          ; Evaluate sum of series
4894+ 32DF
4895+ 32DF DB 0F 49 81  HALFPI: defb    $DB,$0F,$49,$81 ; 1.5708 (PI/2)
4896+ 32E3
4897+ 32E3 00 00 00 7F  QUARTR: defb    $00,$00,$00,$7F ; 0.25
4898+ 32E7
4899+ 32E7 05           SINTAB: defb    $05             ; Table used by SIN
4900+ 32E8 BA D7 1E 86          defb    $BA,$D7,$1E,$86 ; 39.711
4901+ 32EC 64 26 99 87          defb    $64,$26,$99,$87 ;-76.575
4902+ 32F0 58 34 23 87          defb    $58,$34,$23,$87 ; 81.602
4903+ 32F4 E0 5D A5 86          defb    $E0,$5D,$A5,$86 ;-41.342
4904+ 32F8 DA 0F 49 83          defb    $DA,$0F,$49,$83 ;  6.2832
4905+ 32FC
4906+ 32FC CD D9 2E     TAN:    call    STAKFP          ; Put angle on stack
4907+ 32FF CD 9B 32             call    SIN             ; Get SIN of angle
4908+ 3302 C1                   pop     BC              ; Restore angle
4909+ 3303 E1                   pop     HL
4910+ 3304 CD D9 2E             call    STAKFP          ; Save SIN of angle
4911+ 3307 EB                   ex      DE,HL           ; BCDE = Angle
4912+ 3308 CD E9 2E             call    FPBCDE          ; Angle to FPREG
4913+ 330B CD 95 32             call    COS             ; Get COS of angle
4914+ 330E C3 FC 2D             jp      DIV             ; TAN = SIN / COS
4915+ 3311
4916+ 3311 CD A8 2E     ATN:    call    TSTSGN          ; Test sign of value
4917+ 3314 FC 3C 31             call    M,NEGAFT        ; Negate result after if -ve
4918+ 3317 FC D1 2E             call    M,INVSGN        ; Negate value if -ve
4919+ 331A 3A 35 82             ld      A,(FPEXP)       ; Get exponent
4920+ 331D FE 81                cp      81H             ; Number less than 1?
4921+ 331F DA 2E 33             jp      C,ATN1          ; Yes - Get arc tangnt
4922+ 3322 01 00 81             ld      BC,$8100        ; BCDE = 1
4923+ 3325 51                   ld      D,C
4924+ 3326 59                   ld      E,C
4925+ 3327 CD FE 2D             call    DVBCDE          ; Get reciprocal of number
4926+ 332A 21 08 2C             ld      HL,SUBPHL       ; Sub angle from PI/2
4927+ 332D E5                   push    HL              ; Save for angle > 1
4928+ 332E 21 38 33     ATN1:   ld      HL,ATNTAB       ; Coefficient table
4929+ 3331 CD F0 31             call    SUMSER          ; Evaluate sum of series
4930+ 3334 21 DF 32             ld      HL,HALFPI       ; PI/2 - angle in case > 1
4931+ 3337 C9                   ret                     ; Number > 1 - Sub from PI/2
4932+ 3338
4933+ 3338 09           ATNTAB: defb    $09             ; Table used by ATN
4934+ 3339 4A D7 3B 78          defb    $4A,$D7,$3B,$78 ; 1/17
4935+ 333D 02 6E 84 7B          defb    $02,$6E,$84,$7B ;-1/15
4936+ 3341 FE C1 2F 7C          defb    $FE,$C1,$2F,$7C ; 1/13
4937+ 3345 74 31 9A 7D          defb    $74,$31,$9A,$7D ;-1/11
4938+ 3349 84 3D 5A 7D          defb    $84,$3D,$5A,$7D ; 1/9
4939+ 334D C8 7F 91 7E          defb    $C8,$7F,$91,$7E ;-1/7
4940+ 3351 E4 BB 4C 7E          defb    $E4,$BB,$4C,$7E ; 1/5
4941+ 3355 6C AA AA 7F          defb    $6C,$AA,$AA,$7F ;-1/3
4942+ 3359 00 00 00 81          defb    $00,$00,$00,$81 ; 1/1
4943+ 335D
4944+ 335D
4945+ 335D C9           ARET:   ret                     ; A RETurn instruction
4946+ 335E
4947+ 335E D7           GETINP: rst     $10             ; input a character
4948+ 335F C9                   ret
4949+ 3360
4950+ 3360 E5           CLS:    push    HL
4951+ 3361 D5                   push    DE
4952+ 3362 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
4953+ 3365 FE 02                cp      $02             ; G2 mode?
4954+ 3367 CC EB 05             call    Z,EMPTYVIDBUF   ; yes, reset video buffer
4955+ 336A D1                   pop     DE
4956+ 336B E1                   pop     HL
4957+ 336C 3E 0C                ld      A,CS            ; ASCII Clear screen
4958+ 336E CD 0F 1A             call    SND2VID         ; send to screen
4959+ 3371 C3 B7 3F             jp      MONOUT          ; Output character
4960+ 3374
4961+ 3374 CD 21 29     WIDTH:  call    GETINT          ; Get integer 0-255
4962+ 3377 7B                   ld      A,E             ; Width to A
4963+ 3378 32 A2 80             ld      (LWIDTH),A      ; Set width
4964+ 337B C9                   ret
4965+ 337C
4966+ 337C
4967+ 337C              ; read a word (2 bytes) from a couple of RAM locations, in little-endian format
4968+ 337C              ; i.e., the first location is the LSB, while the second one is the MSB
4969+ 337C CD C8 1C     DEEK:   call    DEINT           ; Get integer -32768 to 32767
4970+ 337F D5                   push    DE              ; Save number
4971+ 3380 E1                   pop     HL              ; Number to HL
4972+ 3381 46           RECWRD: ld      B,(HL)          ; Get LSB of contents
4973+ 3382 23                   inc     HL
4974+ 3383 7E                   ld      A,(HL)          ; Get MSB of contents
4975+ 3384 C3 85 24             jp      ABPASS          ; Return integer AB
4976+ 3387
4977+ 3387              ; write a word (2 bytes) into a couple of RAM locations, in little-endian format
4978+ 3387              ; i.e., the LSB will go into the first location, while the MSB into the second one
4979+ 3387 CD 9B 20     DOKE:   call    GETNUM          ; Get a number
4980+ 338A CD C8 1C             call    DEINT           ; Get integer -32768 to 32767
4981+ 338D D5                   push    DE              ; Save address
4982+ 338E CD D1 19             call    CHKSYN          ; Make sure ',' follows
4983+ 3391 2C                   defb    ','
4984+ 3392 CD 9B 20             call    GETNUM          ; Get a number
4985+ 3395 CD C8 1C             call    DEINT           ; Get integer -32768 to 32767
4986+ 3398 E3                   ex      (SP),HL         ; Save value,get address
4987+ 3399 73                   ld      (HL),E          ; Save LSB of value
4988+ 339A 23                   inc     HL
4989+ 339B 72                   ld      (HL),D          ; Save MSB of value
4990+ 339C E1                   pop     HL              ; Restore code string address
4991+ 339D C9                   ret
4992+ 339E
4993+ 339E              ; stop the execution of code for a certain bit of time. The pause
4994+ 339E              ; is between $0000 and $FFFF 100ths of a second (0~655.5 secs)
4995+ 339E CD 9B 20     PAUSE:  call    GETNUM          ; Get a number
4996+ 33A1 CD C8 1C             call    DEINT           ; Get integer -32768 to 32767
4997+ 33A4 7A                   ld      A,D             ; load D into A
4998+ 33A5 B3                   or      E               ; are D & E equal to $00?
4999+ 33A6 C8                   ret     Z               ; if yes, then return
5000+ 33A7 C5           DIR_PAU:push    BC              ; store BC
5001+ 33A8 3A BD 81             ld      A,(TMRCNT)      ; Load current value of system timer
5002+ 33AB 47                   ld      B,A             ; move it into B
5003+ 33AC CD 3D 1C     RPTPS:  call    TSTBRK          ; Test for break key
5004+ 33AF 3A BD 81             ld      A,(TMRCNT)      ; Load current value of system timer
5005+ 33B2 B8                   cp      B               ; is it the same value?
5006+ 33B3 28 F7                jr      Z,RPTPS         ; yes, so read again
5007+ 33B5 47                   ld      B,A             ; no, so store the new value
5008+ 33B6 1B                   dec     DE              ; decrement interval
5009+ 33B7 7A                   ld      A,D             ; load D into A
5010+ 33B8 B3                   or      E               ; check if DE is equal to 0 (if D & e are $00 then result is 0)
5011+ 33B9 20 F1                jr      NZ,RPTPS        ; no, repeat
5012+ 33BB C1                   pop     BC              ; yes, recover BC and continue
5013+ 33BC C9                   ret
5014+ 33BD
5015+ 33BD              ; change the screen mode and set some graphic features. Usage: SCREEN X[,Y][,Z]
5016+ 33BD              ; where X is graphic mode:
5017+ 33BD              ; 0=text mode (40x24), 1=graphic mode 1 (32x24 chars); 2=graphic mode 2 (256x192 pixels);
5018+ 33BD              ; 3=multicolor mode (64x48 pixels); 4=extended graphic mode 2 (32x24 chars mixed between G1 and G2)
5019+ 33BD              ; Y is: 0=8x8 sprites, 1=16x16 sprites
5020+ 33BD              ; Z is: 0=no sprite magnification; 1=sprite magnification x2 (8x8=>16x16, and 16x16=32x32)
5021+ 33BD              ; (the latters are accepted only in graphic modes G1, G2, G3, and G4)
5022+ 33BD AF           SCREEN: xor     A
5023+ 33BE 32 E0 81             ld      (TMPBFR2),A     ; sprite size & magnif. byte set to 0
5024+ 33C1 CD 21 29             call    GETINT          ; Get integer 0-255
5025+ 33C4 FE 05                cp      $05             ; is it a valid mode (0~4)?
5026+ 33C6 D2 DD 1C             jp      NC,FCERR        ; No - Illegal function call Error
5027+ 33C9 32 DE 81             ld      (TMPBFR1),A     ; store graphic mode
5028+ 33CC A7                   and     A               ; is it 0 (text mode)?
5029+ 33CD CA E9 33             jp      Z,SCVDP         ; yes, ignore other arguments and set mode immediately
5030+ 33D0 CD 28 34     SETVDP: call    CHKSCAR         ; no, check if sprite size follows
5031+ 33D3 DA DB 33             jp      C,CKMAGN        ; no (set to 0 or missing), so jump over
5032+ 33D6 3E 02                ld      A,$02           ; no, so set sprite size
5033+ 33D8 32 E0 81             ld      (TMPBFR2),A     ; ...to 16x16
5034+ 33DB CD 28 34     CKMAGN: call    CHKSCAR         ; check if sprite magnification follows
5035+ 33DE DA E9 33             jp      C,SCVDP         ; no (set to 0 or missing), so jump over
5036+ 33E1 3A E0 81             ld      A,(TMPBFR2)     ; yes, so retrieve sprite attributes...
5037+ 33E4 F6 01                or      $01             ; ...set sprite magnification to 2x...
5038+ 33E6 32 E0 81             ld      (TMPBFR2),A     ; ...and save flags again
5039+ 33E9 F3           SCVDP:  di                      ; disable INTs
5040+ 33EA D5                   push    DE              ; store DE
5041+ 33EB E5                   push    HL              ; store HL
5042+ 33EC 3A DE 81             ld      A,(TMPBFR1)     ; recover graphic mode
5043+ 33EF 5F                   ld      E,A             ; and store it into E
5044+ 33F0 3A E0 81             ld      A,(TMPBFR2)     ; recover sprite flags
5045+ 33F3 57                   ld      D,A             ; and store them into D
5046+ 33F4 D5                   push    DE              ; store D & E
5047+ 33F5 CD EF 03             call    initVDP         ; initialize VDP with mode pointed by E
5048+ 33F8 D1                   pop     DE              ; retrieve D & E
5049+ 33F9 7B                   ld      A,E             ; move graphic mode into A
5050+ 33FA 87                   add     A,A
5051+ 33FB 87                   add     A,A
5052+ 33FC 87                   add     A,A             ; multiply A times 8 to get offset of graphic mode
5053+ 33FD 5F                   ld      E,A             ; and pass it into E
5054+ 33FE D5                   push    DE              ; store sprite flags in E
5055+ 33FF 16 00                ld      D,$00           ; reset D
5056+ 3401 21 3A 0B             ld      HL,VDPMODESET+1 ; load address of VDP settings for reg#1
5057+ 3404 19                   add     HL,DE           ; load correct reg#1 setting
5058+ 3405 D1                   pop     DE              ; retrieve sprite flags from E
5059+ 3406 7E                   ld      A,(HL)          ; load reg#1 setting
5060+ 3407 E6 FC                and     %11111100       ; reset size & magn. bits
5061+ 3409 B2                   or      D               ; set size & magn. bits
5062+ 340A 5F                   ld      E,A             ; value into E
5063+ 340B 3E 01                ld      A,$01           ; reg #1
5064+ 340D CD C7 06             call    WRITE_VREG      ; send setting to reg #1
5065+ 3410 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
5066+ 3413 23                   inc     HL              ; -1 means direct statement
5067+ 3414 7C                   ld      A,H
5068+ 3415 B5                   or      L
5069+ 3416 CC 39 09             call    Z,CURSOR_ON     ; enable cursor if not in program mode
5070+ 3419 FB                   ei                      ; re-enable interrupts
5071+ 341A E1                   pop     HL              ; restore HL
5072+ 341B D1                   pop     DE              ; restore DE
5073+ 341C 3A CE 81             ld      A,(SCR_SIZE_H)  ; check the screen mode by looking at the screen height
5074+ 341F FE 30                cp      $30             ; is it 48 chars or 192 pixels (MC and G2 modes)?
5075+ 3421 D0                   ret     NC              ; yes, so exit (in graphics 2 and multicolor no print-on-video)
5076+ 3422 3E 01                ld      A,$01           ; no (we are in Text, G1 or ExG2), so activate the...
5077+ 3424 32 DA 81             ld      (PRNTVIDEO),A   ; ...video buffer...
5078+ 3427 C9                   ret                     ; ...and return to caller
5079+ 3428
5080+ 3428              ; check an additional argument for SCREEN - There are 2 ways of working:
5081+ 3428              ; to check if something follows: Carry is 1 is no argument follows, 0 otherwise
5082+ 3428              ; to check the value of the following argument: 0 is argument is 1, 1 is argument is <> 1
5083+ 3428 2B           CHKSCAR:dec     HL              ; dec 'cos GETCHR INCs
5084+ 3429 CD 12 1C             call    GETCHR          ; Get next character
5085+ 342C 37                   scf                     ; set carry flag
5086+ 342D C8                   ret     Z               ; return if nothing follows with Carry=1
5087+ 342E CD D1 19             call    CHKSYN          ; Make sure ',' follows
5088+ 3431 2C                   defb    ','
5089+ 3432 CD 21 29             call    GETINT          ; get value
5090+ 3435 1F                   rra                     ; Carry=bit #0
5091+ 3436 3F                   ccf                     ; invert Carry, so Carry=0 if arg. is 1, and Carry=1 otherwise (arg<>1)
5092+ 3437 C9                   ret                     ; return
5093+ 3438
5094+ 3438
5095+ 3438              ; change the colors of the screen - Syntax is COLOR a,b,c where:
5096+ 3438              ; a=foreground color / b=background color / c=border color
5097+ 3438              ; a,b,c must be in a range between 1 and 15 (0 is transparent and it's not supported)
5098+ 3438              ; the number of arguments is based on the current screen mode
5099+ 3438 CD 21 29     COLOR:  call    GETINT          ; get first value
5100+ 343B CD E1 34             call    CHKCLR1         ; check if it's in range 1~15
5101+ 343E 32 DE 81             ld      (TMPBFR1),A     ; store it
5102+ 3441 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
5103+ 3444 FE 03                cp      $03             ; is it multicolor mode?
5104+ 3446 20 0D                jr      NZ,CNTCKCL      ; no, continue
5105+ 3448 3E 0F                ld      A,$0F           ; white for...
5106+ 344A 32 DC 81             ld      (FRGNDCLR),A    ; ...foreground (even it's not used in MC)
5107+ 344D 3A DE 81             ld      A,(TMPBFR1)     ; yes, so we stop here because in MC mode we just support border color
5108+ 3450 32 E2 81             ld      (TMPBFR3),A     ; move color into temp buffer 3
5109+ 3453 18 31                jr      CLRMC           ; jump to set color
5110+ 3455 CD D1 19     CNTCKCL:call    CHKSYN          ; Make sure ',' follows
5111+ 3458 2C                   defb    ','
5112+ 3459 CD 21 29             call    GETINT          ; get second value
5113+ 345C CD E1 34             call    CHKCLR1         ; check if it's in range 1~15
5114+ 345F 32 E0 81             ld      (TMPBFR2),A     ; store it
5115+ 3462 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
5116+ 3465 A7                   and     A               ; is it text mode?
5117+ 3466 28 1B                jr      Z,CLRTXT        ; yes, stop here because in text mode, background and border colors coincide
5118+ 3468 CD D1 19             call    CHKSYN          ; Make sure ',' follows
5119+ 346B 2C                   defb    ','
5120+ 346C CD 21 29             call    GETINT          ; get third value
5121+ 346F CD E1 34             call    CHKCLR1         ; check if it's in range 1~15
5122+ 3472 32 E2 81             ld      (TMPBFR3),A     ; store it
5123+ 3475 D5                   push    DE              ; store DE
5124+ 3476 3A CF 81             ld      A,(SCR_MODE)    ; check screen mode
5125+ 3479 FE 01                cp      $01             ; is it G1 mode?
5126+ 347B 28 10                jr      Z,CLRG1         ; yes, jump over
5127+ 347D FE 02                cp      $02             ; is it G2 mode?
5128+ 347F 28 15                jr      Z,CLRG2         ; yes, jump over
5129+ 3481 18 1C                jr      CLREX2          ; last case can only be ExG2
5130+ 3483 CD D4 34     CLRTXT: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5131+ 3486 32 E2 81     CLRMC:  ld      (TMPBFR3),A     ; store color settings (for MC mode, we only set border color)
5132+ 3489 D5                   push    DE              ; store DE
5133+ 348A F3                   di                      ; disable INTs
5134+ 348B 18 2E                jr      SETBRCL         ; set colors and exit
5135+ 348D CD D4 34     CLRG1:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5136+ 3490 16 01                ld      D,$01           ; repeat 1 time
5137+ 3492 06 20                ld      B,$20           ; 32 bytes of colors
5138+ 3494 18 10                jr      LOADCLR         ; load colors
5139+ 3496 CD D4 34     CLRG2:  call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5140+ 3499 16 18                ld      D,$18           ; 18 pages of...
5141+ 349B 06 00                ld      B,$00           ; ...256 bytes each
5142+ 349D 18 07                jr      LOADCLR         ; load colors
5143+ 349F CD D4 34     CLREX2: call    MIXCLRS         ; mix foreground and background color nibbles in 1 byte
5144+ 34A2 16 08                ld      D,$08           ; 8 pages of...
5145+ 34A4 06 00                ld      B,$00           ; ...256 bytes each
5146+ 34A6 E5           LOADCLR:push    HL              ; store HL
5147+ 34A7 21 00 20             ld      HL,$2000        ; color table start: $2000
5148+ 34AA F3                   di                      ; disable INTs
5149+ 34AB CD 7D 06             call    SETVDPADRS
5150+ 34AE 0E 30                ld      C,VDP_DAT       ; VDP data mode
5151+ 34B0 ED 79        RPTLDCL:out     (C),A           ; after first byte, the VDP autoincrements VRAM pointer
5152+ 34B2 00                   nop
5153+ 34B3 00                   nop
5154+ 34B4 10 FA                djnz    RPTLDCL         ; repeat for 256 bytes (1 page)
5155+ 34B6 15                   dec     D               ; did we fill up all the pages?
5156+ 34B7 20 F7                jr      NZ,RPTLDCL      ; no, repeat
5157+ 34B9 FB                   ei
5158+ 34BA E1                   pop     HL              ; retrieve HL
5159+ 34BB 3A DE 81     SETBRCL:ld      A,(TMPBFR1)     ; retrieve foreground color
5160+ 34BE 32 DC 81             ld      (FRGNDCLR),A    ; store it
5161+ 34C1 3A E0 81             ld      A,(TMPBFR2)     ; retrieve background color
5162+ 34C4 32 DD 81             ld      (BKGNDCLR),A    ; store it
5163+ 34C7 3A E2 81             ld      A,(TMPBFR3)     ; recover border color
5164+ 34CA 5F                   ld      E,A             ; move it into E
5165+ 34CB 3E 07                ld      A,$07           ; set VDP register 7
5166+ 34CD F3                   di
5167+ 34CE CD C7 06             call    WRITE_VREG      ; send value to VDP: set border color
5168+ 34D1 FB                   ei                      ; re-enable INTs
5169+ 34D2 D1                   pop     DE              ; retrieve DE
5170+ 34D3 C9                   ret                     ; return to caller
5171+ 34D4
5172+ 34D4
5173+ 34D4              ; mix 2 color nibbles in 1 byte
5174+ 34D4 3A E0 81     MIXCLRS:ld      A,(TMPBFR2)     ; retrieve background color
5175+ 34D7 47                   ld      B,A             ; move it into B
5176+ 34D8 3A DE 81             ld      A,(TMPBFR1)     ; retrieve foreground color
5177+ 34DB 87                   add     A,A             ; move foreground color into the high nibble of A
5178+ 34DC 87                   add     A,A
5179+ 34DD 87                   add     A,A
5180+ 34DE 87                   add     A,A
5181+ 34DF B0                   or      B               ; put background color into the low nibble of A
5182+ 34E0 C9                   ret                     ; return to caller
5183+ 34E1
5184+ 34E1
5185+ 34E1              ; check if the color is not 0 and into the range 1~15
5186+ 34E1 A7           CHKCLR1:and     A               ; is it 0?
5187+ 34E2 CA EF 16             jp      Z,SNERR         ; yes, raise a SN error
5188+ 34E5 FE 10        CHKCLR0:cp      $10             ; is it in range 0~15?
5189+ 34E7 D2 EF 16             jp      NC,SNERR        ; no, raise a SN error
5190+ 34EA C9                   ret                     ; param is OK, can return
5191+ 34EB
5192+ 34EB
5193+ 34EB              ; check if in graphics 2 mode
5194+ 34EB 3A CF 81     CHKG2M: ld      A,(SCR_MODE)    ; check screen mode
5195+ 34EE FE 02                cp      $02             ; actually, we can paint only in G2
5196+ 34F0 C2 F1 3A             jp      NZ,GMERR        ; no G2, print a No Graphics Mode Error
5197+ 34F3 C9                   ret                     ; return to caller
5198+ 34F4
5199+ 34F4
5200+ 34F4              ; print a text in screen 2
5201+ 34F4              ; GPRINT text,x,y[,fc[,bc]]
5202+ 34F4              ; where "text" is an expression that can be converted into a sequence of ASCII chars,
5203+ 34F4              ; x & y are the coordinates (0<=x<=31, 0<=y<=23), fc & bc are foreground and background
5204+ 34F4              ; colors (1~15), resp.
5205+ 34F4              ; (portions of code are from nippur72)
5206+ 34F4              GX      equ     TMPBFR3
5207+ 34F4              GY      equ     TMPBFR4
5208+ 34F4              TMPCLR  equ     TMPBFR2
5209+ 34F4              MIXCOL  equ     TMPBFR1
5210+ 34F4              TMPADR  equ     VIDEOBUFF
5211+ 34F4              CHRPNT  equ     VIDEOBUFF+$02
5212+ 34F4              NUMCHR  equ     VIDEOBUFF+$04
5213+ 34F4              TMPHL   equ     VIDEOBUFF+$06
5214+ 34F4 CD EB 34     GPRINT: call    CHKG2M          ; check if in graphic mode 2
5215+ 34F7 2B                   dec     HL              ; dec 'cos GETCHR INCs
5216+ 34F8 CD 12 1C             call    GETCHR          ; check if something follows
5217+ 34FB CA EF 16             jp      Z,SNERR         ; if nothing else, raise a syntax error
5218+ 34FE 22 E6 81             ld      (VIDEOBUFF),HL  ; save current code string pointer
5219+ 3501 CD AD 20             call    EVAL            ; Evaluate expression
5220+ 3504 CD 9F 20             call    TSTSTR          ; Make sure it's a string
5221+ 3507 22 EC 81             ld      (TMPHL),HL      ; store code string pointer
5222+ 350A CD E6 26             call    GSTRCU          ; Current string to pool
5223+ 350D CD F7 2E             call    LOADFP          ; Move string block to BCDE (BC=pointer, E=length)
5224+ 3510 ED 43 E8 81          ld      (CHRPNT),BC     ; store string pointer
5225+ 3514 ED 53 EA 81          ld      (NUMCHR),DE     ; store string lenght
5226+ 3518 2A EC 81             ld      HL,(TMPHL)      ; store code string pointer
5227+ 351B CD D1 19             call    CHKSYN          ; Make sure ',' follows
5228+ 351E 2C                   defb    ','
5229+ 351F CD 21 29             call    GETINT          ; get X coord.
5230+ 3522 FE 20                cp      $20             ; is it in rage 0~31?
5231+ 3524 D2 DD 1C             jp      NC,FCERR        ; Illegal function call error
5232+ 3527 32 E2 81             ld      (GX),A          ; store into temp. buffer
5233+ 352A CD D1 19             call    CHKSYN          ; Make sure ',' follows
5234+ 352D 2C                   defb    ','
5235+ 352E CD 21 29             call    GETINT          ; get Y coord.
5236+ 3531 FE 18                cp      $18             ; is it in range 0~23?
5237+ 3533 D2 DD 1C             jp      NC,FCERR        ; Illegal function call error
5238+ 3536 32 E4 81             ld      (GY),A          ; store into temp. buffer
5239+ 3539 11 E0 81             ld      DE,TMPCLR
5240+ 353C 3A DD 81             ld      A,(BKGNDCLR)    ; load background color
5241+ 353F 12                   ld      (DE),A          ; store into temp buff
5242+ 3540 3A DC 81             ld      A,(FRGNDCLR)    ; load foreground color
5243+ 3543 1B                   dec     DE
5244+ 3544 1B                   dec     DE
5245+ 3545 12                   ld      (DE),A          ; store into temp buff
5246+ 3546 CD D2 35             call    CKCOL           ; check color
5247+ 3549 CA 51 35             jp      Z,CNTGPT2       ; if anything follows, jump over
5248+ 354C 13                   inc     DE
5249+ 354D 13                   inc     DE
5250+ 354E CD D2 35             call    CKCOL           ; check background color
5251+ 3551 CD D4 34     CNTGPT2:call    MIXCLRS         ; mix foreground & background colors
5252+ 3554 32 DE 81             ld      (MIXCOL),A      ; store mixed colors
5253+ 3557 E5                   push    HL              ; store code string address
5254+ 3558 ED 4B E8 81          ld      BC,(CHRPNT)     ; retrieve string pointer
5255+ 355C ED 5B EA 81          ld      DE,(NUMCHR)     ; retrieve string lenght
5256+ 3560 1C                   inc     E               ; Length + 1
5257+ 3561 CD 66 35             call    GPNT            ; print on G2
5258+ 3564 E1                   pop     HL              ; recover HL
5259+ 3565 C9                   ret                     ; return to caller
5260+ 3566 D5           GPNT:   push    DE              ; store string lenght (E)
5261+ 3567                      ; calculate VRAM address of first char
5262+ 3567 3A E2 81             LD      A,(GX)          ; load X
5263+ 356A 6F                   ld      L,A             ;
5264+ 356B 26 00                ld      H,0             ; HL = X
5265+ 356D 29                   add     HL,HL           ;
5266+ 356E 29                   add     HL,HL           ;
5267+ 356F 29                   add     HL,HL           ; X=X*8
5268+ 3570 3A E4 81             ld      A,(GY)          ; load Y
5269+ 3573 57                   ld      D,A             ; move it into D
5270+ 3574 1E 00                ld      E,0             ; DE =Y*256
5271+ 3576 19                   add     HL,DE           ; address = X*8 + Y*256
5272+ 3577 22 E6 81             ld      (TMPADR),HL     ; store VRAM address of first VRAM cell
5273+ 357A D1                   pop     DE              ; retrieve # of chars to be printed yet (E)
5274+ 357B 1D           RPGPNT: dec     E               ; Count characters
5275+ 357C C8                   ret     Z               ; End of string - return
5276+ 357D D5                   push    DE              ; store chars counter
5277+ 357E                      ; calculate dest address in color vram
5278+ 357E 2A E6 81             ld      HL,(TMPADR)     ; recover VRAM address
5279+ 3581 11 00 20             ld      DE,$2000        ; color map address
5280+ 3584 19                   add     HL,DE           ; HL = $2000 + XY address
5281+ 3585 F3                   di                      ; disable INTs
5282+ 3586                      ; send color settings
5283+ 3586 CD 7D 06     GPNTCOL:call    SETVDPADRS      ; set VRAM address for color cell
5284+ 3589 3A DE 81             ld      A,(MIXCOL)      ; load color settings
5285+ 358C 06 08                ld      B,$08           ; repeat for 8 rows
5286+ 358E 0E 30                ld      C,VDP_DAT              ; VDP data mode
5287+ 3590 ED 79        GPNTCO1:out     (C),A           ; send data (VRAM pointer auto-increments)
5288+ 3592 00                   nop                     ; wait...
5289+ 3593 00                   nop                     ; ...a...
5290+ 3594 00                   nop                     ; ...while
5291+ 3595 10 F9                djnz    GPNTCO1         ; repeat for 8 cells
5292+ 3597                      ; calculate source address
5293+ 3597 2A E8 81             ld      HL,(CHRPNT)     ; load char pointer
5294+ 359A 7E                   ld      A,(HL)          ; get char
5295+ 359B 23                   inc     HL              ; increment char pointer
5296+ 359C 22 E8 81             ld      (CHRPNT),HL     ; store char pointer
5297+ 359F 6F                   ld      L,A             ;
5298+ 35A0 26 00                ld      H,$00           ; char into HL
5299+ 35A2 29                   add     HL,HL           ;
5300+ 35A3 29                   add     HL,HL           ;
5301+ 35A4 29                   add     HL,HL           ; get offset of char into ROM (charcode * 8)
5302+ 35A5 11 41 48             ld      DE,CHRST88      ; DE = start of 8x8 fonts in ROM
5303+ 35A8 19                   add     HL,DE           ; HL = start of characters in ROM
5304+ 35A9 EB                   ex      DE,HL           ; store address into DE
5305+ 35AA 2A E6 81     GPCPCHR:ld      HL,(TMPADR)     ; load VRAM address
5306+ 35AD CD 7D 06             call    SETVDPADRS      ; send it to VDP
5307+ 35B0 EB                   ex      DE,HL           ; restore address into HL
5308+ 35B1 06 08                ld      B,$08           ; repeat for 8 rows
5309+ 35B3 0E 30                ld      C,VDP_DAT              ; VDP data mode
5310+ 35B5 ED A3        GPCPCH1:outi                    ; load a byte from ROM and send to VRAM
5311+ 35B7 00                   nop                     ; wait...
5312+ 35B8 00                   nop                     ; ...a...
5313+ 35B9 00                   nop                     ; ...while
5314+ 35BA 20 F9                jr      NZ,GPCPCH1      ; repeat for 8 chars
5315+ 35BC FB                   ei                      ; re-enable INTs
5316+ 35BD 11 08 00             ld      DE,$0008        ; 8 bytes to go to the next video cell
5317+ 35C0 2A E6 81             ld      HL,(TMPADR)     ; load VRAM address
5318+ 35C3 19                   add     HL,DE           ; get address of next VRAM cell
5319+ 35C4 22 E6 81             ld      (TMPADR),HL     ; store new VRAM address
5320+ 35C7 11 00 18             ld      DE,$1800        ; forbidden address
5321+ 35CA CD DE 3F             call    CMP16           ; check if the printing has gone out of the screen
5322+ 35CD D1                   pop     DE              ; retrieve number of chars to be printed
5323+ 35CE D0                   ret     NC              ; if HL>=$1800 then leave
5324+ 35CF C3 7B 35             jp      RPGPNT          ; otherwise, check if more chars to output
5325+ 35D2
5326+ 35D2              ; used by GPRINT to get a color argument (if present)
5327+ 35D2 2B           CKCOL:  dec     HL              ; dec 'cos GETCHR INCs
5328+ 35D3 CD 12 1C             call    GETCHR          ; Get next character
5329+ 35D6 C8                   ret     Z               ; return if nothing follows
5330+ 35D7 CD D1 19             call    CHKSYN          ; Make sure ',' follows
5331+ 35DA 2C                   defb    ','
5332+ 35DB D5                   push    DE              ; store DE
5333+ 35DC CD 21 29             call    GETINT          ; get value
5334+ 35DF CD E1 34             call    CHKCLR1         ; check if color is in range 1~15
5335+ 35E2 D1                   pop     DE              ; retrieve DE
5336+ 35E3 12                   ld      (DE),A          ; store color into temp buffer
5337+ 35E4 C9                   ret                     ; return to caller
5338+ 35E5
5339+ 35E5
5340+ 35E5              ; paint X,Y[,C]: in graphics mode, fills an area starting
5341+ 35E5              ; at point X,Y, using default color or, if used, with
5342+ 35E5              ; color set by C
5343+ 35E5              ; TMPBFR1       X
5344+ 35E5              ; TMPBFR2       Y
5345+ 35E5              ; TMPBFR3       COLOR
5346+ 35E5              PNT     equ     VIDEOBUFF
5347+ 35E5              SPA     equ     VIDEOBUFF+$02
5348+ 35E5              SPB     equ     VIDEOBUFF+$03
5349+ 35E5              ORGSP   equ     VIDEOBUFF+$04
5350+ 35E5 CD EB 34     PAINT:  call    CHKG2M          ; check if in graphic mode 2
5351+ 35E8 CD 21 29             call    GETINT          ; get X
5352+ 35EB 32 DE 81             ld      (TMPBFR1),A     ; store X
5353+ 35EE CD D1 19             call    CHKSYN          ; Make sure ',' follows
5354+ 35F1 2C                   defb    ','
5355+ 35F2 CD 21 29             call    GETINT          ; get Y coords,
5356+ 35F5 FE C0                cp      $C0             ; check if Y is in range 0~191
5357+ 35F7 D2 DD 1C             jp      NC,FCERR        ; no, raise an FC error
5358+ 35FA 32 E0 81             ld      (TMPBFR2),A     ; store Y
5359+ 35FD CD D8 3A             call    CLRPRM          ; check if color has been passed
5360+ 3600 3A E2 81             ld      A,(TMPBFR3)     ; load color
5361+ 3603 A7                   and     A               ; check if 0
5362+ 3604 CA DD 1C             jp      Z,FCERR         ; yes, raise an error
5363+ 3607 E5                   push    HL              ; store HL
5364+ 3608 C5                   push    BC              ; store BC
5365+ 3609 D5                   push    DE              ; store DE
5366+ 360A                      ; start algorithm
5367+ 360A CD 1D 37             call    PNTRTN          ; check if pixel is already set
5368+ 360D C2 C1 36             jp      NZ,EXITPA2      ; if yes, then leave PAINT
5369+ 3610 ED 73 EA 81          ld      (ORGSP),SP      ; no, store current Stack Pointer
5370+ 3614 21 01 00             ld      HL,$0001        ; HL=1
5371+ 3617 22 E6 81             ld      (PNT),HL        ; set PNT
5372+ 361A 3A DE 81             ld      A,(TMPBFR1)     ; load starting X...
5373+ 361D 47                   ld      B,A             ; ...into B
5374+ 361E 3A E0 81             ld      A,(TMPBFR2)     ; load starting Y...
5375+ 3621 4F                   ld      C,A             ; ...into C
5376+ 3622 C5                   push    BC              ; store starting X,Y into stack
5377+ 3623                      ; main loop
5378+ 3623 2A E6 81     NXTLOOP:ld      HL,(PNT)        ; retrieve PNT
5379+ 3626 7C                   ld      A,H             ; check if PNT=0
5380+ 3627 B5                   or      L
5381+ 3628 CA BD 36             jp      Z,EXITPAI       ; yes, no more points to process - exit
5382+ 362B 2B                   dec     HL              ; no, so decrement PNT...
5383+ 362C 22 E6 81             ld      (PNT),HL        ; ...and store it
5384+ 362F C1                   pop     BC              ; retrieve pixel coordinates X,Y into BC
5385+ 3630 CD C5 36     PAINT0: call    CHECKPA         ; check if pixel is set/reset
5386+ 3633 20 09                jr      NZ,PAINT11      ; pixel is set, so jump over
5387+ 3635 78                   ld      A,B             ; pixel is reset, check if X1=0
5388+ 3636 A7                   and     A               ; (reached the limit of the screen)
5389+ 3637 CA 3F 36             jp      Z,PAINT1        ; yes, jump over
5390+ 363A 05                   dec     B               ; no, decrement X1...
5391+ 363B C3 30 36             jp      PAINT0          ; ...and repeat
5392+ 363E 04           PAINT11:inc     B               ; if found a pixel on, the re-increment X1
5393+ 363F AF           PAINT1: xor     A               ; reset A
5394+ 3640 57                   ld      D,A             ; set SA=0
5395+ 3641 5F                   ld      E,A             ; set SB=0
5396+ 3642 CD C5 36     MNPAINT:call    CHECKPA         ; check if pixel is set/reset
5397+ 3645 20 DC                jr      NZ,NXTLOOP      ; it's set, so goto next loop
5398+ 3647 78                   ld      A,B             ; copy X1
5399+ 3648 32 DE 81             ld      (TMPBFR1),A     ; into buffer
5400+ 364B 79                   ld      A,C             ; copy Y
5401+ 364C 32 E0 81             ld      (TMPBFR2),A     ; into buffer
5402+ 364F CD 43 37             call    CNTPLOT         ; plot pixel X1,Y
5403+ 3652 7A                   ld      A,D             ; load SA into A
5404+ 3653 A7                   and     A               ; SA=0?
5405+ 3654 20 1C                jr      NZ,PAINT2       ; no, jump over
5406+ 3656 79                   ld      A,C             ; load Y
5407+ 3657 FE 01                cp      $01             ; Y>0?
5408+ 3659 DA 72 36             jp      C,PAINT2        ; no, jump over
5409+ 365C 3D                   dec     A               ; yes, Y=Y-1
5410+ 365D CD C6 36             call    CHECKPY         ; check pixel X1,Y-1
5411+ 3660 20 10                jr      NZ,PAINT2       ; it's set, so jump over
5412+ 3662 0D                   dec     C               ; Y=Y-1
5413+ 3663 C5                   push    BC              ; insert pixel(X1,Y-1) into stack
5414+ 3664 0C                   inc     C               ; retrieve original Y
5415+ 3665 2A E6 81             ld      HL,(PNT)        ; load PNT
5416+ 3668 23                   inc     HL              ; increment PNT
5417+ 3669 22 E6 81             ld      (PNT),HL        ; store new PNT
5418+ 366C 3E 01                ld      A,$01           ; set SA=1 and...
5419+ 366E 57                   ld      D,A             ; ...store SA into memory
5420+ 366F C3 85 36             jp      PAINT3          ; jump over
5421+ 3672 7A           PAINT2: ld      A,D             ; load SA into A
5422+ 3673 1F                   rra                     ; check if SA=1
5423+ 3674 30 0F                jr      NC,PAINT3       ; no, jump over
5424+ 3676 79                   ld      A,C             ; load Y
5425+ 3677 FE 01                cp      $01             ; Y>0?
5426+ 3679 DA 85 36             jp      C,PAINT3        ; no, jump over
5427+ 367C 3D                   dec     A               ; Y=Y-1
5428+ 367D CD C6 36             call    CHECKPY         ; check pixel X1,Y-1
5429+ 3680 CA 85 36             jp      Z,PAINT3        ; if pixel is off, jump over
5430+ 3683 AF                   xor     A               ; pixel is on, so...
5431+ 3684 57                   ld      D,A             ; ...set SA=0
5432+ 3685 7B           PAINT3: ld      A,E             ; check if...
5433+ 3686 A7                   and     A               ; SB=0
5434+ 3687 20 1B                jr      NZ,PAINT4       ; no, jump over
5435+ 3689 79                   ld      A,C             ; load Y
5436+ 368A FE BF                cp      $BF             ; Y<191?
5437+ 368C 30 16                jr      NC,PAINT4       ; no, jump over
5438+ 368E 3C                   inc     A               ; Y=Y+1
5439+ 368F CD C6 36             call    CHECKPY         ; check pixel X1,Y+1
5440+ 3692 20 10                jr      NZ,PAINT4       ; pixel is on, so jump over
5441+ 3694 0C                   inc     C               ; Y=Y+1
5442+ 3695 C5                   push    BC              ; insert pixel(X1,Y+1) into stack
5443+ 3696 0D                   dec     C               ; retrieve original Y
5444+ 3697 2A E6 81             ld      HL,(PNT)        ; PNT
5445+ 369A 23                   inc     HL              ; PNT=PNT+1
5446+ 369B 22 E6 81             ld      (PNT),HL        ; store PNT
5447+ 369E 3E 01                ld      A,$01           ; SB=1
5448+ 36A0 5F                   ld      E,A             ; set SB
5449+ 36A1 C3 B6 36             jp      PAINT5          ; jump over
5450+ 36A4 7B           PAINT4: ld      A,E             ; load SB
5451+ 36A5 1F                   rra                     ; check if SB=1
5452+ 36A6 30 0E                jr      NC,PAINT5       ; no, jump over
5453+ 36A8 79                   ld      A,C             ; load Y
5454+ 36A9 FE BF                cp      $BF             ; Y<191?
5455+ 36AB 30 09                jr      NC,PAINT5       ; no, jump over
5456+ 36AD 3C                   inc     A               ; Y=Y+1
5457+ 36AE CD C6 36             call    CHECKPY         ; check pixel X1,Y+1
5458+ 36B1 CA B6 36             jp      Z,PAINT5        ; if pixel is off, jump over
5459+ 36B4 AF                   xor     A               ; pixel is on, so...
5460+ 36B5 5F                   ld      E,A             ; ...set SB=0
5461+ 36B6 04           PAINT5: inc     B               ; X1=X1+1
5462+ 36B7 CA 23 36             jp      Z,NXTLOOP       ; if X1>255 (X1=0) then goto next loop
5463+ 36BA C3 42 36             jp      MNPAINT         ; otherwise, repeat for next X
5464+ 36BD ED 7B EA 81  EXITPAI:ld      SP,(ORGSP)      ; retrieve original SP pointer
5465+ 36C1 D1           EXITPA2:pop     DE              ; retrieve DE
5466+ 36C2 C1                   pop     BC              ; retrieve BC
5467+ 36C3 E1                   pop     HL              ; retrieve HL
5468+ 36C4 C9                   ret                     ; return to caller
5469+ 36C5 79           CHECKPA:ld      A,C             ; copy Y into A
5470+ 36C6 32 E0 81     CHECKPY:ld      (TMPBFR2),A     ; store Y
5471+ 36C9 78                   ld      A,B             ; copy X1 into A
5472+ 36CA 32 DE 81             ld      (TMPBFR1),A     ; store X1
5473+ 36CD C5                   push    BC              ; save X1,Y
5474+ 36CE D5                   push    DE
5475+ 36CF CD 1D 37             call    PNTRTN          ; check if pixel is set/reset
5476+ 36D2 D1                   pop     DE
5477+ 36D3 C1                   pop     BC              ; retrieve X1,Y
5478+ 36D4 C9                   ret                     ; return to caller
5479+ 36D5
5480+ 36D5
5481+ 36D5              ; POINT(x,y): return if a pixel is set (returns color) or if it's reset (0)
5482+ 36D5 CD EB 34     POINT:  call    CHKG2M          ; check if in graphic mode 2
5483+ 36D8 CD D1 19             call    CHKSYN          ; make sure "(" follows
5484+ 36DB 28                   defb    '('
5485+ 36DC CD 21 29             call    GETINT          ; get X coords.
5486+ 36DF 32 DE 81             ld      (TMPBFR1),A     ; store it into a temp buffer
5487+ 36E2 CD D1 19             call    CHKSYN          ; Make sure ',' follows
5488+ 36E5 2C                   defb    ','
5489+ 36E6 CD 21 29             call    GETINT          ; get Y coords,
5490+ 36E9 FE C0                cp      $C0             ; check if Y is in range 0~191
5491+ 36EB D2 DD 1C             jp      NC,FCERR        ; no, raise an FC error
5492+ 36EE 32 E0 81             ld      (TMPBFR2),A     ; store into a temp buffer
5493+ 36F1 CD D1 19             call    CHKSYN          ; make sure ")" follows
5494+ 36F4 29                   defb    ')'
5495+ 36F5 E5                   push    HL              ; store current string address - the point after the ")" - ...
5496+ 36F6 FD E1                pop     IY              ; ...into IY
5497+ 36F8 CD 1D 37             call    PNTRTN          ; check if pixel is set or reset
5498+ 36FB 20 0C                jr      NZ,CTPOINT      ; it's ON, jump over
5499+ 36FD AF                   xor     A               ; no, it's OFF. make sure to reset A...
5500+ 36FE 47                   ld      B,A             ; ...and B
5501+ 36FF E1           PNTEND: pop     HL              ; drop original return point
5502+ 3700 FD E5                push    IY              ; load current string address from IY into stack
5503+ 3702 11 86 21             ld      DE,RETNUM       ; Address of Return number from function...
5504+ 3705 D5                   push    DE              ; ...saved on stack
5505+ 3706 C3 85 24             jp      ABPASS          ; return AB
5506+ 3709 CB EC        CTPOINT:set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5507+ 370B F3                   di
5508+ 370C CD 9D 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5509+ 370F FB                   ei
5510+ 3710 CB 3F                srl     A               ; shift A...
5511+ 3712 CB 3F                srl     A               ; ...4 times...
5512+ 3714 CB 3F                srl     A               ; ...to move foreground color...
5513+ 3716 CB 3F                srl     A               ; ...into lowest nibble
5514+ 3718 47                   ld      B,A             ; color into B
5515+ 3719 AF                   xor     A               ; reset MSB
5516+ 371A C3 FF 36             jp      PNTEND          ; return AB
5517+ 371D CD 90 37     PNTRTN: call    XY2HL           ; find HL address of pixel at X,Y
5518+ 3720 57                   ld      D,A             ; store pixel index
5519+ 3721 F3                   di                      ; disable INTs
5520+ 3722 CD 9D 06             call    READ_VIDEO_LOC  ; read contents of VRAM cell addressed by HL
5521+ 3725 FB                   ei                      ; re-enable INTs
5522+ 3726 A2                   and     D               ; is the pixel ON or OFF? (will be checked later)
5523+ 3727 C9                   ret                     ; return to caller
5524+ 3728
5525+ 3728
5526+ 3728              ; PLOT X,Y[,color]
5527+ 3728              ; plot a pixel in graphic mode 2
5528+ 3728 CD EB 34     PLOT:   call    CHKG2M          ; check if in G2 mode
5529+ 372B CD 21 29             call    GETINT          ; get X coords.
5530+ 372E 32 DE 81             ld      (TMPBFR1),A     ; store it into a temp buffer
5531+ 3731 CD D1 19             call    CHKSYN          ; Make sure ',' follows
5532+ 3734 2C                   defb    ','
5533+ 3735 CD 21 29             call    GETINT          ; get Y coords,
5534+ 3738 FE C0                cp      $C0             ; check if Y is in range 0~191
5535+ 373A D2 DD 1C             jp      NC,FCERR        ; no, raise an FC error
5536+ 373D 32 E0 81             ld      (TMPBFR2),A     ; store into a temp buffer
5537+ 3740 CD D8 3A             call    CLRPRM          ; check if param "color" has been passed
5538+ 3743 E5           CNTPLOT:push    HL              ; store HL
5539+ 3744 C5                   push    BC              ; store BC
5540+ 3745 D5                   push    DE              ; store DE
5541+ 3746 CD 90 37             call    XY2HL           ; find VRAM address of byte containing pixel at X,Y & return into HL
5542+ 3749 D2 84 37             jp      NC,NOGD         ; if carry is reset, there was an error -> so leave
5543+ 374C 57                   ld      D,A             ; move pixel value into D
5544+ 374D 3A E2 81             ld      A,(TMPBFR3)     ; retrieve color
5545+ 3750 A7                   and     A               ; is it 0? (background, or reset pixel)
5546+ 3751 20 11                jr      NZ,CNTPLT1      ; no, continue
5547+ 3753 F3                   di                      ; yes - so, disable INTs
5548+ 3754 CD 9D 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5549+ 3757 FB                   ei                      ; re-enable INTs
5550+ 3758 5F                   ld      E,A             ; store value of cell
5551+ 3759 7A                   ld      A,D             ; retrieve pixel
5552+ 375A 2F                   cpl                     ; revert bits
5553+ 375B A3                   and     E               ; set video pixel to off
5554+ 375C F3                   di                      ; disable INTs
5555+ 375D CD B2 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5556+ 3760 FB                   ei                      ; re-enable INTs
5557+ 3761 C3 84 37             jp      NOGD            ; leave
5558+ 3764 87           CNTPLT1:add     A,A             ; now we move low nibble
5559+ 3765 87                   add     A,A             ; in the high nibble
5560+ 3766 87                   add     A,A             ; by adding A to itself
5561+ 3767 87                   add     A,A             ; 4 times (this is a shift left 4)
5562+ 3768 5F                   ld      E,A             ; move it into E
5563+ 3769 F3                   di                      ; disable INTs
5564+ 376A CD 9D 06             call    READ_VIDEO_LOC  ; load original value of VRAM cell pointed by HL
5565+ 376D FB                   ei
5566+ 376E B2                   or      D               ; merge new pixel preserving original pattern
5567+ 376F F3                   di
5568+ 3770 CD B2 06             call    WRITE_VIDEO_LOC ; write new value into VRAM cell
5569+ 3773 FB                   ei
5570+ 3774 CB EC                set     5,H             ; set to read from color VRAM (it's like adding $2000 to HL)
5571+ 3776 F3                   di
5572+ 3777 CD 9D 06             call    READ_VIDEO_LOC  ; load original colors of pixel
5573+ 377A FB                   ei
5574+ 377B E6 0F                and     %00001111       ; reset high nibble (the foreground color)
5575+ 377D B3                   or      E               ; set new foreground color
5576+ 377E F3                   di
5577+ 377F CD B2 06             call    WRITE_VIDEO_LOC ; write new color settings
5578+ 3782 FB                   ei                      ; re-enable INTs
5579+ 3783 00                   nop                     ; wait for INTs to be enabled again
5580+ 3784 D1           NOGD:   pop     DE              ; retrieve DE
5581+ 3785 C1                   pop     BC              ; retrieve BC
5582+ 3786 E1                   pop     HL              ; retrieve HL
5583+ 3787 C9                   ret                     ; return to caller
5584+ 3788 80 40 20 10  PXLSET: defb    $80,$40,$20,$10,$08,$04,$02,$01 ; pixel to be set ON
5584+ 378C 08 04 02 01
5585+ 3790                      ; where R(X/8)=> 0=80h, 1=40h, 2=20h, 3=10h, 4=08h, 5=04h, 6=02h, 7=$01
5586+ 3790
5587+ 3790
5588+ 3790              ; compute the VRAM address of the byte containing the pixel
5589+ 3790              ; being pointed by X,Y (TMPBFR1,TMPBFR1)
5590+ 3790              ; byte address is returned into HL
5591+ 3790              ; pixel is returned into A
5592+ 3790              XY2HL:  ; formula is: ADDRESS=(INT(X/8))*8 + (INT(Y/8))*256 + R(Y/8)
5593+ 3790                      ; where R(Y/8) is the remainder of (Y/8)
5594+ 3790                      ; the pixel to be set is given by R(X/8), and data is taken from the array
5595+ 3790 3A E0 81             ld      A,(TMPBFR2)     ; retrieve Y
5596+ 3793 FE C0                cp      $C0             ; Y>=192?
5597+ 3795 D0                   ret     NC              ; yes, so leave
5598+ 3796 1E 08                ld      E,$08           ; load E with divisor
5599+ 3798 57                   ld      D,A             ; and store into D (dividend)
5600+ 3799 CD 0D 40             call    DIV_8_8         ; get Y/8, D is quotient=INT(Y/8), and A is remainder
5601+ 379C 4F                   ld      C,A             ; store remainder into C
5602+ 379D 42                   ld      B,D             ; B=(INT(Y/8))*256 (we simply copy quotient into B)
5603+ 379E 60 69                ld      HL,BC           ; copy BC into HL: now HL has the VRAM address of the byte being set
5604+ 37A0 3A DE 81             ld      A,(TMPBFR1)     ; retrieve X
5605+ 37A3 57                   ld      D,A             ; and move it into D (dividend)
5606+ 37A4 CD 0D 40             call    DIV_8_8         ; get X/8, D is quotient=INT(X/8), and A is remainder
5607+ 37A7 4F                   ld      C,A             ; store remainder into C
5608+ 37A8 7A                   ld      A,D             ; move quotient into A
5609+ 37A9 87                   add     A,A             ; multiply quotient by 8
5610+ 37AA 87                   add     A,A
5611+ 37AB 87                   add     A,A
5612+ 37AC 5F                   ld      E,A             ; store result into E
5613+ 37AD 16 00                ld      D,$00           ; reset D
5614+ 37AF 19                   add     HL,DE           ; add DE to HL, getting the final VRAM address
5615+ 37B0 EB                   ex      DE,HL           ; move VRAM address into DE
5616+ 37B1 21 88 37             ld      HL,PXLSET       ; starting address of table for pixel to draw
5617+ 37B4 06 00                ld      B,$00           ; reset B
5618+ 37B6 09                   add     HL,BC           ; add C (remainder of X/8) to get address of pixel to turn on
5619+ 37B7 7E                   ld      A,(HL)          ; load pixel data
5620+ 37B8 EB                   ex      DE,HL           ; retrieve VRAM pattern address into HL
5621+ 37B9 37                   scf                     ; set Carry for normal exit
5622+ 37BA C9                   ret                     ; return to caller
5623+ 37BB
5624+ 37BB
5625+ 37BB              ; DRAW X1,Y1,X2,Y2[,color]
5626+ 37BB              ; Draw a line using Bresenham's line algorithm from X1,Y1 to X2,Y2
5627+ 37BB              ; X1,Y1 can be either less than or greater than X2,Y2 (meaning that)
5628+ 37BB              ; the drawing will be ever done from X1,Y2 to X2,Y2, regardless of
5629+ 37BB              ; the values. If color is not specified, the foreground color set
5630+ 37BB              ; with COLOR will be used
5631+ 37BB              X1      equ     TMPBFR1
5632+ 37BB              Y1      equ     TMPBFR2
5633+ 37BB              X2      equ     VIDEOBUFF
5634+ 37BB              Y2      equ     VIDEOBUFF+$02
5635+ 37BB              ER      equ     VIDEOBUFF+$04
5636+ 37BB              E2      equ     VIDEOBUFF+$06
5637+ 37BB              SX      equ     VIDEOBUFF+$08
5638+ 37BB              SY      equ     VIDEOBUFF+$0A
5639+ 37BB              DX      equ     VIDEOBUFF+$0C
5640+ 37BB              DY      equ     VIDEOBUFF+$0E
5641+ 37BB CD EB 34     DRAW:   call    CHKG2M          ; check if in G2 mode
5642+ 37BE CD C0 3A             call    CLRVDBF         ; clear VIDEOBUFF
5643+ 37C1 CD 21 29             call    GETINT          ; get X1 coords.
5644+ 37C4 32 DE 81             ld      (X1),A          ; store it into a temp buffer
5645+ 37C7 CD D1 19             call    CHKSYN          ; Make sure ',' follows
5646+ 37CA 2C                   defb    ','
5647+ 37CB CD 21 29             call    GETINT          ; get Y1 coords.
5648+ 37CE FE C0                cp      $C0             ; check if Y1 is in range 0~191
5649+ 37D0 D2 DD 1C             jp      NC,FCERR        ; no, raise an FC error
5650+ 37D3 32 E0 81             ld      (Y1),A          ; store into a temp buffer
5651+ 37D6 CD D1 19             call    CHKSYN          ; Make sure ',' follows
5652+ 37D9 2C                   defb    ','
5653+ 37DA CD 21 29             call    GETINT          ; get X2 coords.
5654+ 37DD 32 E6 81             ld      (X2),A          ; store it into a temp buffer
5655+ 37E0 CD D1 19             call    CHKSYN          ; Make sure ',' follows
5656+ 37E3 2C                   defb    ','
5657+ 37E4 CD 21 29             call    GETINT          ; get Y2 coords
5658+ 37E7 FE C0                cp      $C0             ; check if Y2 is in range 0~191
5659+ 37E9 D2 DD 1C             jp      NC,FCERR        ; no, raise an FC error
5660+ 37EC 32 E8 81             ld      (Y2),A          ; store it into a temp buffer
5661+ 37EF CD D8 3A             call    CLRPRM          ; check for arg. "color" and store it into TMPBFR3
5662+ 37F2 E5                   push    HL              ; store register we'll use
5663+ 37F3 D5                   push    DE
5664+ 37F4 C5                   push    BC
5665+ 37F5 ED 5B DE 81          ld      DE,(X1)         ; load X1 and
5666+ 37F9 2A E6 81             ld      HL,(X2)         ; X2
5667+ 37FC B7                   or      A               ; clear CARRY
5668+ 37FD ED 52                sbc     HL,DE           ; DX=X2-X1
5669+ 37FF CD 03 40             call    absHL           ; DX=ABS(DX)
5670+ 3802 22 F2 81             ld      (DX),HL         ; store DX
5671+ 3805 01 FF FF             ld      BC,$FFFF        ; SX=-1
5672+ 3808 2A DE 81             ld      HL,(X1)
5673+ 380B ED 5B E6 81          ld      DE,(X2)
5674+ 380F CD DE 3F             call    CMP16           ; X1<X2?
5675+ 3812 CA 1B 38             jp      Z,X1GR          ; no, X1=X2
5676+ 3815 F2 1B 38             jp      P,X1GR          ; no, X1>X2
5677+ 3818 01 01 00             ld      BC,$0001        ; yes, so set SX=1
5678+ 381B ED 43 EE 81  X1GR:   ld      (SX),BC         ; store SX
5679+ 381F ED 5B E0 81          ld      DE,(Y1)
5680+ 3823 2A E8 81             ld      HL,(Y2)
5681+ 3826 B7                   or      A               ; clear Carry
5682+ 3827 ED 52                sbc     HL,DE           ; DY=Y2-Y1
5683+ 3829 CD 03 40             call    absHL           ; DY=ABS(DY)
5684+ 382C 22 F4 81             ld      (DY),HL         ; store DY
5685+ 382F 01 FF FF             ld      BC,$FFFF        ; SY=-1
5686+ 3832 2A E0 81             ld      HL,(Y1)
5687+ 3835 ED 5B E8 81          ld      DE,(Y2)
5688+ 3839 CD DE 3F             call    CMP16           ; is Y1<Y2?
5689+ 383C CA 45 38             jp      Z,Y1GR          ; no, Y1=Y2
5690+ 383F F2 45 38             jp      P,Y1GR          ; no, Y1>Y2 - jump over
5691+ 3842 01 01 00             ld      BC,$0001        ; yes, so set SY=1
5692+ 3845 ED 43 F0 81  Y1GR:   ld      (SY),BC         ; store SY
5693+ 3849 2A F4 81             ld      HL,(DY)         ; ER=DY
5694+ 384C CD 06 40             call    negHL           ; ER=-DY
5695+ 384F 22 EA 81             ld      (ER),HL         ; store ER
5696+ 3852 2A F2 81             ld      HL,(DX)
5697+ 3855 ED 5B F4 81          ld      DE,(DY)
5698+ 3859 CD DE 3F             call    CMP16           ; DX>DY?
5699+ 385C CA 68 38             jp      Z,ER2           ; no, DX=DY
5700+ 385F FA 68 38             jp      M,ER2           ; no, DX<DY
5701+ 3862 2A F2 81             ld      HL,(DX)         ; reload DX
5702+ 3865 22 EA 81             ld      (ER),HL         ; yes: DX>DY, so ER=DX
5703+ 3868 2A EA 81     ER2:    ld      HL,(ER)         ; load ER
5704+ 386B CB 2C                sra     H               ; right shift (and preserve sign)...
5705+ 386D CB 1D                rr      L               ; ...of HL, so ER=INT(ER/2)
5706+ 386F CB 7C                bit     7,H             ; is the number negative?
5707+ 3871 CA 75 38             jp      Z,STRE2         ; no, jump over
5708+ 3874 23                   inc     HL              ; yes, add 1 'cos INT of a negative number needs to be incremented
5709+ 3875 22 EA 81     STRE2:  ld      (ER),HL         ; store ER
5710+ 3878 CD 43 37     RPTDRW: call    CNTPLOT         ; plot first pixel
5711+ 387B 2A DE 81             ld      HL,(X1)
5712+ 387E ED 5B E6 81          ld      DE,(X2)
5713+ 3882 CD DE 3F             call    CMP16           ; X1=X2?
5714+ 3885 20 0D                jr      NZ,CNTDRW       ; no, continue drawing
5715+ 3887 2A E0 81             ld      HL,(Y1)         ; yes, so check
5716+ 388A ED 5B E8 81          ld      DE,(Y2)         ; also Y
5717+ 388E CD DE 3F             call    CMP16           ; Y1=Y2?
5718+ 3891 CA ED 38             jp      Z,ENDDRAW       ; yes, finished drawing: exit
5719+ 3894 ED 5B EA 81  CNTDRW: ld      DE,(ER)
5720+ 3898 ED 53 EC 81          ld      (E2),DE         ; E2=ER
5721+ 389C 2A F2 81             ld      HL,(DX)
5722+ 389F CD 06 40             call    negHL           ; DX=-DX
5723+ 38A2 EB                   ex      DE,HL           ; invert DE and HL => HL=E2, DE=-DX
5724+ 38A3 CD DE 3F             call    CMP16           ; E2>-DX?
5725+ 38A6 CA C4 38             jp      Z,DXGR          ; no, E2=-DX: jump
5726+ 38A9 FA C4 38             jp      M,DXGR          ; no, E2<-DX: jump
5727+ 38AC 2A EA 81             ld      HL,(ER)         ; yes
5728+ 38AF ED 5B F4 81          ld      DE,(DY)
5729+ 38B3 B7                   or      A               ; clear CARRY
5730+ 38B4 ED 52                sbc     HL,DE           ; ER=ER-DY
5731+ 38B6 22 EA 81             ld      (ER),HL
5732+ 38B9 2A DE 81             ld      HL,(X1)
5733+ 38BC ED 5B EE 81          ld      DE,(SX)
5734+ 38C0 19                   add     HL,DE           ; X1=X1+SX (increment X1)
5735+ 38C1 22 DE 81             ld      (X1),HL
5736+ 38C4 2A EC 81     DXGR:   ld      HL,(E2)
5737+ 38C7 ED 5B F4 81          ld      DE,(DY)
5738+ 38CB CD DE 3F             call    CMP16           ; E2<DY?
5739+ 38CE CA 78 38             jp      Z,RPTDRW        ; no, E2=DY: jump
5740+ 38D1 F2 78 38             jp      P,RPTDRW        ; no, E2>DY: jump
5741+ 38D4 2A EA 81             ld      HL,(ER)         ; yes
5742+ 38D7 ED 5B F2 81          ld      DE,(DX)
5743+ 38DB 19                   add     HL,DE           ; ER=ER+DX
5744+ 38DC 22 EA 81             ld      (ER),HL
5745+ 38DF 2A E0 81             ld      HL,(Y1)
5746+ 38E2 ED 5B F0 81          ld      DE,(SY)
5747+ 38E6 19                   add     HL,DE           ; Y1=Y1+SY (increment Y1)
5748+ 38E7 22 E0 81             ld      (Y1),HL
5749+ 38EA C3 78 38             jp      RPTDRW          ; repeat
5750+ 38ED C1           ENDDRAW:pop     BC              ; retrieve BC
5751+ 38EE D1                   pop     DE              ; retrieve DE
5752+ 38EF E1                   pop     HL              ; retrieve HL
5753+ 38F0 C9                   ret                     ; return to caller
5754+ 38F1
5755+ 38F1
5756+ 38F1              ; CIRCLE X,Y,R[,C]
5757+ 38F1              ; Draw a circle using Bresenham's circle algorithm with center in X,Y
5758+ 38F1              ; and radius R, with optional color C. If color is not specified, the
5759+ 38F1              ; foreground color set with COLOR will be used
5760+ 38F1              XC      equ     VIDEOBUFF
5761+ 38F1              YC      equ     VIDEOBUFF+$02
5762+ 38F1              RADIUS  equ     VIDEOBUFF+$04
5763+ 38F1              XI      equ     VIDEOBUFF+$06
5764+ 38F1              YI      equ     VIDEOBUFF+$08
5765+ 38F1              DC      equ     VIDEOBUFF+$0A
5766+ 38F1 CD EB 34     CIRCLE: call    CHKG2M          ; check if in G2 mode
5767+ 38F4 CD C0 3A             call    CLRVDBF         ; clear VIDEOBUFF
5768+ 38F7 CD 21 29             call    GETINT          ; get X coords.
5769+ 38FA 32 E6 81             ld      (XC),A          ; store it into a temp buffer
5770+ 38FD CD D1 19             call    CHKSYN          ; Make sure ',' follows
5771+ 3900 2C                   defb    ','
5772+ 3901 CD 21 29             call    GETINT          ; get Y coords,
5773+ 3904 32 E8 81             ld      (YC),A          ; store it into a temp buffer
5774+ 3907 CD D1 19             call    CHKSYN          ; Make sure ',' follows
5775+ 390A 2C                   defb    ','
5776+ 390B CD 21 29             call    GETINT          ; get radius
5777+ 390E 32 EA 81             ld      (RADIUS),A      ; store it into a temp buffer
5778+ 3911 CD D8 3A             call    CLRPRM          ; check if param "color" has been passed
5779+ 3914 C5                   push    BC              ; store BC
5780+ 3915 D5                   push    DE              ; store DE
5781+ 3916 E5                   push    HL              ; store HL
5782+ 3917 AF                   xor     A               ; clear A,
5783+ 3918 47                   ld      B,A             ; B,
5784+ 3919 4F                   ld      C,A             ; C,
5785+ 391A 57                   ld      D,A             ; D,
5786+ 391B 67                   ld      H,A             ; and H
5787+ 391C ED 43 EC 81          ld      (XI),BC         ; clear XI
5788+ 3920 3A EA 81             ld      A,(RADIUS)      ; load RADIUS into A
5789+ 3923 6F                   ld      L,A             ; HL now contains R
5790+ 3924 22 EE 81             ld      (YI),HL         ; YI=RADIUS
5791+ 3927 29                   add     HL,HL           ; R*2
5792+ 3928 EB                   ex      DE,HL           ; put HL into DE
5793+ 3929 21 03 00             ld      HL,$0003        ; HL = 3
5794+ 392C AF                   xor     A               ; clear Carry
5795+ 392D ED 52                sbc     HL,DE           ; D=3-(2*R) => HL
5796+ 392F 22 F0 81             ld      (DC),HL         ; store D
5797+ 3932 CD 91 39             call    DRWCRL          ; draw initial point
5798+ 3935 ED 5B EC 81  RPTCRL: ld      DE,(XI)         ; load XI
5799+ 3939 2A EE 81             ld      HL,(YI)         ; load YI
5800+ 393C CD DE 3F             call    CMP16           ; is YI<DI?
5801+ 393F CA 48 39             jp      Z,RPTCL1        ; no, YI=XI
5802+ 3942 F2 48 39             jp      P,RPTCL1        ; no, YI>XI
5803+ 3945 C3 8D 39             jp      ENDCRL          ; yes, so we've finished
5804+ 3948 21 EC 81     RPTCL1: ld      HL,XI
5805+ 394B 34                   inc     (HL)            ; XI=XI+1
5806+ 394C 2A F0 81             ld      HL,(DC)         ; load D
5807+ 394F 7C                   ld      A,H
5808+ 3950 B5                   or      L               ; is D=0? Yes, jump over
5809+ 3951 CA 75 39             jp      Z,DLSZ
5810+ 3954 CB 7C                bit     7,H             ; is D<0?
5811+ 3956 20 1D                jr      NZ,DLSZ         ; yes, jump over
5812+ 3958 ED 5B EE 81          ld      DE,(YI)         ; D>0
5813+ 395C 1B                   dec     DE              ; so, YI=YI-1
5814+ 395D ED 53 EE 81          ld      (YI),DE         ; store YI
5815+ 3961 AF                   xor     A               ; clear Carry
5816+ 3962 2A EC 81             ld      HL,(XI)
5817+ 3965 ED 52                sbc     HL,DE           ; HL=XI-YI
5818+ 3967 29                   add     HL,HL
5819+ 3968 29                   add     HL,HL           ; HL=HL*4
5820+ 3969 11 0A 00             ld      DE,10
5821+ 396C 19                   add     HL,DE           ; HL=HL+10
5822+ 396D ED 5B F0 81          ld      DE,(DC)         ; load D
5823+ 3971 EB                   ex      DE,HL           ; invert DE and HL, so that HL=4*(XI-YI)+10 and DE=D
5824+ 3972 19                   add     HL,DE           ; D=D+4*(XI-YI)+10
5825+ 3973 18 0F                jr      PLTCRL          ; plot next pixel
5826+ 3975 2A EC 81     DLSZ:   ld      HL,(XI)         ; load XI
5827+ 3978 29                   add     HL,HL
5828+ 3979 29                   add     HL,HL           ; XI=XI*4
5829+ 397A 11 06 00             ld      DE,$0006
5830+ 397D 19                   add     HL,DE
5831+ 397E ED 5B F0 81          ld      DE,(DC)
5832+ 3982 EB                   ex      DE,HL           ; HL=D and DE=4*XI+6
5833+ 3983 19                   add     HL,DE           ; D=D+4*XI+6
5834+ 3984 22 F0 81     PLTCRL: ld      (DC),HL         ; store new D
5835+ 3987 CD 91 39             call    DRWCRL          ; plot pixel
5836+ 398A C3 35 39             jp      RPTCRL          ; repeat
5837+ 398D E1           ENDCRL: pop     HL
5838+ 398E D1                   pop     DE
5839+ 398F C1                   pop     BC
5840+ 3990 C9                   ret                     ; return to caller
5841+ 3991 2A E6 81     DRWCRL: ld      HL,(XC)
5842+ 3994 ED 5B EC 81          ld      DE,(XI)
5843+ 3998 19                   add     HL,DE           ; X=XC+XI
5844+ 3999 22 DE 81             ld      (X1),HL         ; store X
5845+ 399C CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5846+ 399F DA B3 39             jp      C,CNTCL1        ; if Carry is set, X is not valid
5847+ 39A2 2A E8 81             ld      HL,(YC)
5848+ 39A5 ED 5B EE 81          ld      DE,(YI)
5849+ 39A9 19                   add     HL,DE           ; Y=YC+YI
5850+ 39AA 22 E0 81             ld      (Y1),HL         ; store Y
5851+ 39AD CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5852+ 39B0 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5853+ 39B3 AF           CNTCL1: xor     A               ; clear Carry
5854+ 39B4 2A E6 81             ld      HL,(XC)
5855+ 39B7 ED 5B EC 81          ld      DE,(XI)
5856+ 39BB ED 52                sbc     HL,DE           ; X=XC-XI
5857+ 39BD 22 DE 81             ld      (X1),HL         ; store X
5858+ 39C0 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5859+ 39C3 DA D7 39             jp      C,CNTCL2        ; if Carry is set, X is not valid
5860+ 39C6 2A E8 81             ld      HL,(YC)
5861+ 39C9 ED 5B EE 81          ld      DE,(YI)
5862+ 39CD 19                   add     HL,DE           ; Y=YC+YI
5863+ 39CE 22 E0 81             ld      (Y1),HL         ; store Y
5864+ 39D1 CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5865+ 39D4 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5866+ 39D7 2A E6 81     CNTCL2: ld      HL,(XC)
5867+ 39DA ED 5B EC 81          ld      DE,(XI)
5868+ 39DE 19                   add     HL,DE           ; X=XC+XI
5869+ 39DF 22 DE 81             ld      (X1),HL         ; store X
5870+ 39E2 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5871+ 39E5 DA FB 39             jp      C,CNTCL3        ; if Carry is set, X is not valid
5872+ 39E8 AF                   xor     A               ; clear Carry
5873+ 39E9 2A E8 81             ld      HL,(YC)
5874+ 39EC ED 5B EE 81          ld      DE,(YI)
5875+ 39F0 ED 52                sbc     HL,DE           ; Y=YC-YI
5876+ 39F2 22 E0 81             ld      (Y1),HL         ; store Y
5877+ 39F5 CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5878+ 39F8 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5879+ 39FB AF           CNTCL3: xor     A               ; clear Carry
5880+ 39FC 2A E6 81             ld      HL,(XC)
5881+ 39FF ED 5B EC 81          ld      DE,(XI)
5882+ 3A03 ED 52                sbc     HL,DE           ; X=XC-XI
5883+ 3A05 22 DE 81             ld      (X1),HL         ; store X
5884+ 3A08 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5885+ 3A0B DA 21 3A             jp      C,CNTCL4        ; if Carry is set, X is not valid
5886+ 3A0E AF                   xor     A               ; clear Carry
5887+ 3A0F 2A E8 81             ld      HL,(YC)
5888+ 3A12 ED 5B EE 81          ld      DE,(YI)
5889+ 3A16 ED 52                sbc     HL,DE           ; Y=YC-YI
5890+ 3A18 22 E0 81             ld      (Y1),HL         ; store Y
5891+ 3A1B CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5892+ 3A1E D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5893+ 3A21 2A E6 81     CNTCL4: ld      HL,(XC)
5894+ 3A24 ED 5B EE 81          ld      DE,(YI)
5895+ 3A28 19                   add     HL,DE           ; X=XC+YI
5896+ 3A29 22 DE 81             ld      (X1),HL         ; store X
5897+ 3A2C CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5898+ 3A2F DA 43 3A             jp      C,CNTCL5        ; if Carry is set, X is not valid
5899+ 3A32 2A E8 81             ld      HL,(YC)
5900+ 3A35 ED 5B EC 81          ld      DE,(XI)
5901+ 3A39 19                   add     HL,DE           ; Y=YC+XI
5902+ 3A3A 22 E0 81             ld      (Y1),HL         ; store Y
5903+ 3A3D CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5904+ 3A40 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5905+ 3A43 AF           CNTCL5: xor     A               ; clear Carry
5906+ 3A44 2A E6 81             ld      HL,(XC)
5907+ 3A47 ED 5B EE 81          ld      DE,(YI)
5908+ 3A4B ED 52                sbc     HL,DE           ; X=XC-YI
5909+ 3A4D 22 DE 81             ld      (X1),HL         ; store X
5910+ 3A50 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5911+ 3A53 DA 67 3A             jp      C,CNTCL6        ; if Carry is set, X is not valid
5912+ 3A56 2A E8 81             ld      HL,(YC)
5913+ 3A59 ED 5B EC 81          ld      DE,(XI)
5914+ 3A5D 19                   add     HL,DE           ; Y=YC+XI
5915+ 3A5E 22 E0 81             ld      (Y1),HL         ; store Y
5916+ 3A61 CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5917+ 3A64 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5918+ 3A67 2A E6 81     CNTCL6: ld      HL,(XC)
5919+ 3A6A ED 5B EE 81          ld      DE,(YI)
5920+ 3A6E 19                   add     HL,DE           ; X=XC+YI
5921+ 3A6F 22 DE 81             ld      (X1),HL         ; store X
5922+ 3A72 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5923+ 3A75 DA 8B 3A             jp      C,CNTCL7        ; if Carry is set, X is not valid
5924+ 3A78 AF                   xor     A               ; clear Carry
5925+ 3A79 2A E8 81             ld      HL,(YC)
5926+ 3A7C ED 5B EC 81          ld      DE,(XI)
5927+ 3A80 ED 52                sbc     HL,DE           ; Y=YC-XI
5928+ 3A82 22 E0 81             ld      (Y1),HL         ; store Y
5929+ 3A85 CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5930+ 3A88 D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5931+ 3A8B AF           CNTCL7: xor     A               ; clear Carry
5932+ 3A8C 2A E6 81             ld      HL,(XC)
5933+ 3A8F ED 5B EE 81          ld      DE,(YI)
5934+ 3A93 ED 52                sbc     HL,DE           ; X=XC-YI
5935+ 3A95 22 DE 81             ld      (X1),HL         ; store X
5936+ 3A98 CD B0 3A             call    VALIDX          ; check if X is valid (0~255)
5937+ 3A9B D8                   ret     C               ; if Carry is set, X is not valid
5938+ 3A9C AF                   xor     A               ; clear Carry
5939+ 3A9D 2A E8 81             ld      HL,(YC)
5940+ 3AA0 ED 5B EC 81          ld      DE,(XI)
5941+ 3AA4 ED 52                sbc     HL,DE           ; Y=YC-XI
5942+ 3AA6 22 E0 81             ld      (Y1),HL         ; store Y
5943+ 3AA9 CD B5 3A             call    VALIDY          ; check if Y is valid (0~191)
5944+ 3AAC D4 43 37             call    NC,CNTPLOT      ; if Carry is reset, Y is valid and plot the pixel
5945+ 3AAF C9                   ret                     ; return to caller
5946+ 3AB0
5947+ 3AB0              ; check if X,Y coordinates are valid: 0<=X<=255 and 0<=Y<=191
5948+ 3AB0              ; input: HL (value to check), can be negative
5949+ 3AB0              ; output: CARRY flag: reset => VALID  //  set => NOT VALID
5950+ 3AB0              ; destroys: A
5951+ 3AB0 AF           VALIDX: xor     A               ; reset A
5952+ 3AB1 B4                   or      H               ; check if H is 0 (this means that X is in range 0~255 and not negative)
5953+ 3AB2 C8                   ret     Z               ; yes, we can return (C is clear)
5954+ 3AB3 37                   scf                     ; set Carry flag to raise error
5955+ 3AB4 C9                   ret                     ; return to caller
5956+ 3AB5
5957+ 3AB5 AF           VALIDY: xor     A               ; reset A
5958+ 3AB6 B4                   or      H               ; check if H is 0 (this means that Y is in range 0~255 and not negative)
5959+ 3AB7 28 02                jr      Z,CNTVALY       ; yes, continue checking
5960+ 3AB9 37                   scf                     ; no, raise error by setting Carry flag
5961+ 3ABA C9                   ret                     ; return to caller
5962+ 3ABB 7D           CNTVALY:ld      A,L
5963+ 3ABC FE C0                cp      $C0             ; is Y<192? Carry is set if Y<192
5964+ 3ABE 3F                   ccf                     ; invert Carry, so Carry=0 means OK, Carry=1 means ERROR
5965+ 3ABF C9                   ret                     ; return to caller
5966+ 3AC0
5967+ 3AC0
5968+ 3AC0              ; clear VIDEOBUFF before using it as temp buffer
5969+ 3AC0 AF           CLRVDBF:xor     A               ; clear A
5970+ 3AC1 C5                   push    BC              ; store BC
5971+ 3AC2 E5                   push    HL              ; store HL
5972+ 3AC3 21 DE 81             ld      HL,TMPBFR1      ; address of 1st cell
5973+ 3AC6 06 06                ld      B,$06           ; 6 cells
5974+ 3AC8 77           RPTCVB1:ld      (HL),A          ; clear cell
5975+ 3AC9 23                   inc     HL              ; next cell
5976+ 3ACA 10 FC                djnz    RPTCVB1         ; repeat
5977+ 3ACC 06 28                ld      B,$28           ; 40 cells
5978+ 3ACE 21 E6 81             ld      HL,VIDEOBUFF    ; address of 1st cell
5979+ 3AD1 77           RPTCVB2:ld      (HL),A          ; clear cell
5980+ 3AD2 23                   inc     HL              ; next cell
5981+ 3AD3 10 FC                djnz    RPTCVB2         ; repeat
5982+ 3AD5 E1                   pop     HL              ; retrieve HL
5983+ 3AD6 C1                   pop     BC              ; retrieve BC
5984+ 3AD7 C9                   ret                     ; return to caller
5985+ 3AD8
5986+ 3AD8
5987+ 3AD8              ; check if a color is passed as argument with PLOT, DRAW, and CIRCLE
5988+ 3AD8              ; commands. If not present, the default foreground color will be used
5989+ 3AD8 3A DC 81     CLRPRM: ld      A,(FRGNDCLR)    ; load foreground color
5990+ 3ADB 32 E2 81             ld      (TMPBFR3),A     ; store into temp buffer
5991+ 3ADE 2B                   dec     HL              ; dec 'cos GETCHR INCs
5992+ 3ADF CD 12 1C             call    GETCHR          ; Get next character
5993+ 3AE2 C8                   ret     Z               ; return foreground color if nothing follows
5994+ 3AE3 CD D1 19             call    CHKSYN          ; Make sure ',' follows
5995+ 3AE6 2C                   defb    ','
5996+ 3AE7 CD 21 29             call    GETINT          ; get value
5997+ 3AEA CD E5 34             call    CHKCLR0         ; check if color is in range 0~15
5998+ 3AED 32 E2 81             ld      (TMPBFR3),A     ; store color into temp buffer
5999+ 3AF0 C9                   ret                     ; return to caller
6000+ 3AF1
6001+ 3AF1
6002+ 3AF1              ; no graphics mode error: raised when a graphics command is invoked
6003+ 3AF1              ; out of graphic 2 mode.
6004+ 3AF1 1E 2A        GMERR:  ld      E,GM            ; load Graphics Mode Error flag
6005+ 3AF3 C3 03 17             jp      ERROR           ; print error
6006+ 3AF6
6007+ 3AF6
6008+ 3AF6              ; set a serial port: params are PORT,BPS,DATA,PARITY,STOP
6009+ 3AF6              ; PORT=1/2; BPS=1,200~57,600 (see below), DATA=5/6/7/8
6010+ 3AF6              ; PARITY: 0=no parity; 1=ODD parity; 2=EVEN parity;
6011+ 3AF6              ; STOP=0/1/2/3: 0=0 bit; 1=1 bit; 2=1.5 bits; 3=2 bits
6012+ 3AF6              ; PORT 1 acts as a char device; PORT 2 acts as a block device
6013+ 3AF6              ; DATA,PARITY, and STOP are optional: if nothing follows BPS,
6014+ 3AF6              ; they are assumed to be 8,0,1 resp.
6015+ 3AF6              PRTNUM  equ     VIDEOBUFF
6016+ 3AF6              BPS     equ     VIDEOBUFF+$01
6017+ 3AF6              DATABT  equ     BPS+$02
6018+ 3AF6              PARBT   equ     DATABT+$01
6019+ 3AF6              STPBT   equ     PARBT+$01
6020+ 3AF6              SIOBFR  equ     STPBT+$01
6021+ 3AF6 CD 21 29     SERIAL: call    GETINT          ; get port #
6022+ 3AF9 A7                   and     A               ; is it zero?
6023+ 3AFA CA DD 1C             jp      Z,FCERR         ; yes, error
6024+ 3AFD FE 03                cp      $03             ; is it 1 or 2?
6025+ 3AFF D2 1F 3D             jp      NC,SCERR        ; no, error
6026+ 3B02 32 E6 81             ld      (PRTNUM),A      ; store port number into a temp buffer
6027+ 3B05 CD D1 19             call    CHKSYN          ; Make sure ',' follows
6028+ 3B08 2C                   defb    ','
6029+ 3B09 2B                   dec     HL
6030+ 3B0A CD 12 1C             call    GETCHR          ; check what's following
6031+ 3B0D CA EF 16             jp      Z,SNERR         ; error if nothing follows
6032+ 3B10 30 05                jr      NC,SERVAR       ; it's not a number, try a variable
6033+ 3B12 CD E2 1C             call    ATOH            ; get bps (returned into DE)
6034+ 3B15 18 0F                jr      CHKZSER         ; jump over
6035+ 3B17 CD 9B 20     SERVAR: call    GETNUM          ; get number
6036+ 3B1A CD A8 2E             call    TSTSGN          ; check value
6037+ 3B1D FA DD 1C             jp      M,FCERR         ; negative - illegal function call
6038+ 3B20 3A 35 82             ld      A,(FPEXP)       ; Get integer value to DE
6039+ 3B23 CD 50 2F             call    FPINT           ; get integer number into BCDE - drop BC 'cause isn't necessary
6040+ 3B26 7A           CHKZSER:ld      A,D             ; bps is into DE - move MSB into A
6041+ 3B27 B3                   or      E               ; check if bps=0
6042+ 3B28 20 3A                jr      NZ,CNTSER       ; no, continue checking
6043+ 3B2A                      ; if baud rate is 0, then close the serial comm.
6044+ 3B2A 3A E6 81     RSTSERS:ld      A,(PRTNUM)      ; yes, so reset the channel. First, load port number
6045+ 3B2D 3D                   dec     A               ; subtract 1, so that serial channel is 0=>A and 1=>B
6046+ 3B2E C6 22                add     SIO_CA          ; find correct channel
6047+ 3B30 4F                   ld      C,A             ; store serial channel
6048+ 3B31 F3                   di                      ; disable INTs
6049+ 3B32 AF                   xor     A               ; reset A
6050+ 3B33 16 01                ld      D,$01           ; start from WR1
6051+ 3B35 06 05                ld      B,$05           ; 5 registers
6052+ 3B37 ED 51        RPTRSSR:out     (C),D           ; select register
6053+ 3B39 ED 79                out     (C),A           ; reset register
6054+ 3B3B 14                   inc     D               ; next register
6055+ 3B3C 10 F9                djnz    RPTRSSR         ; repeat
6056+ 3B3E 3E 30                ld      A,%00110000     ; write into WR0: error reset, select WR0
6057+ 3B40 ED 79                out     (C),A           ; send command to serial channel
6058+ 3B42 3E 18                ld      A,%00011000     ; write into WR0: channel reset
6059+ 3B44 ED 79                out     (C),A           ; send command to serial channel
6060+ 3B46 FB                   ei                      ; re-enable INTs
6061+ 3B47 E5                   push    HL              ; store HL
6062+ 3B48 21 20 82             ld      HL,SERIALS_EN   ; serials enabled status byte
6063+ 3B4B DB 01                in      A,(PIO_DB)      ; read status LEDs
6064+ 3B4D CB 41                bit     0,C             ; check serial port
6065+ 3B4F 20 09                jr      NZ,SRPT2        ; if bit is set, jump to port 2
6066+ 3B51 CB B7                res     6,A             ; it's port 1
6067+ 3B53 CB A7                res     4,A             ; remove possible error LED
6068+ 3B55 CB 86                res     0,(HL)          ; disable port 1
6069+ 3B57 C3 60 3B             jp      SERLED          ; jump over
6070+ 3B5A CB BF        SRPT2:  res     7,A             ; it's port 2
6071+ 3B5C CB AF                res     5,A             ; remove possible error LED
6072+ 3B5E CB 8E                res     1,(HL)          ; disable port 2
6073+ 3B60 D3 01        SERLED: out     (PIO_DB),A      ; send new configuration
6074+ 3B62 E1                   pop     HL              ; retrieve HL
6075+ 3B63 C9                   ret                     ; return to caller
6076+ 3B64                      ; check if bps=1, meaning reactivate RX on serial
6077+ 3B64 7A           CNTSER: ld      A,D
6078+ 3B65 B2                   or      D               ; check if bps<>1 by first checking D=0
6079+ 3B66 20 36                jr      NZ,CNTSER2      ; if not, jump over
6080+ 3B68 7B                   ld      A,E             ; then by checking that
6081+ 3B69 FE 01                cp      $01             ; E=1
6082+ 3B6B 20 31                jr      NZ,CNTSER2      ; if not, jump over
6083+ 3B6D 3A E6 81             ld      A,(PRTNUM)      ; load port number
6084+ 3B70 57                   ld      D,A             ; store port on D
6085+ 3B71 3A 20 82             ld      A,(SERIALS_EN)  ; load address of serial status cell
6086+ 3B74 A2                   and     D               ; check status
6087+ 3B75 CA 1F 3D             jp      Z,SCERR         ; port not open, raise error
6088+ 3B78 F3                   di                      ; disable INTs
6089+ 3B79 7A                   ld      A,D             ; move port # into A
6090+ 3B7A 5F                   ld      E,A             ; and also into E
6091+ 3B7B 87                   add     A
6092+ 3B7C 87                   add     A               ; move A to left times 2
6093+ 3B7D 57                   ld      D,A             ; move value into D
6094+ 3B7E 3A 20 82             ld      A,(SERIALS_EN)  ; load serial status byte
6095+ 3B81 B2                   or      D               ; re-enable RX
6096+ 3B82 32 20 82             ld      (SERIALS_EN),A  ; store new serial status
6097+ 3B85 7B                   ld      A,E             ; recover port #
6098+ 3B86 3D                   dec     A               ; check port
6099+ 3B87 20 0A                jr      NZ,CNTRX2       ; port is #2
6100+ 3B89 CD DA 01             call    SIO_A_EI        ; re-enable RX on port 1
6101+ 3B8C DB 01                in      A,(PIO_DB)      ; load status LEDs
6102+ 3B8E CB A7                res     4,A             ; remove error LED
6103+ 3B90 C3 9A 3B             jp      RXEND           ; terminate setting
6104+ 3B93 CD E2 01     CNTRX2: call    SIO_B_EI        ; re-enable RX on port 2
6105+ 3B96 DB 01                in      A,(PIO_DB)      ; load status LEDs
6106+ 3B98 CB AF                res     5,A             ; remove error LED
6107+ 3B9A D3 01        RXEND:  out     (PIO_DB),A      ; set new status for LEDs
6108+ 3B9C FB                   ei                      ; re-enable INTs
6109+ 3B9D C9                   ret                     ; return to caller
6110+ 3B9E                      ; set serial port comm.
6111+ 3B9E D5           CNTSER2:push    DE              ; store BPS
6112+ 3B9F 3A E6 81             ld      A,(PRTNUM)      ; load port number
6113+ 3BA2 57                   ld      D,A             ; move port # into D
6114+ 3BA3 3A 20 82             ld      A,(SERIALS_EN)  ; check if serial port is already open
6115+ 3BA6 A2                   and     D               ; by ANDing A with D
6116+ 3BA7 D1                   pop     DE              ; retrieve BPS
6117+ 3BA8 CA B0 3B             jp      Z,CNTSER3       ; not open, continue
6118+ 3BAB 1E 2E                ld      E,SA            ; already open, so raise a "Serial Port Already Error"
6119+ 3BAD C3 03 17             jp      ERROR           ; and leave
6120+ 3BB0 E5           CNTSER3:push    HL              ; store HL
6121+ 3BB1 21 00 E1             ld      HL,$E100        ; check bps. start with HL=57,600
6122+ 3BB4 CD DE 3F             call    CMP16           ; is bps<=57,600?
6123+ 3BB7 E1                   pop     HL              ; but first, recover HL
6124+ 3BB8 DA 1F 3D             jp      C,SCERR         ; no (bps>57,600) then error
6125+ 3BBB ED 53 E7 81          ld      (BPS),DE        ; store bps
6126+ 3BBF 2B                   dec     HL              ; dec 'cos GETCHR INCs
6127+ 3BC0 CD 12 1C             call    GETCHR          ; Get next character
6128+ 3BC3 CA FB 3B             jp      Z,DEFSER        ; defaults if nothing follows
6129+ 3BC6 CD D1 19             call    CHKSYN          ; Make sure ',' follows
6130+ 3BC9 2C                   defb    ','
6131+ 3BCA CD 21 29             call    GETINT          ; get data bits
6132+ 3BCD FE 05                cp      $05             ; is it <5?
6133+ 3BCF DA 1F 3D             jp      C,SCERR         ; yes, error
6134+ 3BD2 FE 09                cp      $09             ; is it >=9?
6135+ 3BD4 D2 DD 1C             jp      NC,FCERR        ; yes, error
6136+ 3BD7 32 E9 81             ld      (DATABT),A      ; store data bits
6137+ 3BDA CD D1 19             call    CHKSYN          ; Make sure ',' follows
6138+ 3BDD 2C                   defb    ','
6139+ 3BDE CD 21 29             call    GETINT          ; get parity bits
6140+ 3BE1 BF FE 03             cp      A,$03           ; check if parity is in range 0~2
6141+ 3BE4 D2 1F 3D             jp      NC,SCERR        ; no, error
6142+ 3BE7 32 EA 81             ld      (PARBT),A       ; store parity
6143+ 3BEA CD D1 19             call    CHKSYN          ; Make sure ',' follows
6144+ 3BED 2C                   defb    ','
6145+ 3BEE CD 21 29             call    GETINT          ; get stop bits
6146+ 3BF1 FE 03                cp      $03             ; is it >=3?
6147+ 3BF3 D2 1F 3D             jp      NC,SCERR        ; yes, error
6148+ 3BF6 32 EB 81             ld      (STPBT),A       ; store stop bits
6149+ 3BF9 18 0D                jr      SETSER          ; jump to set serial
6150+ 3BFB 3E 08        DEFSER: ld      A,$08           ; 8 bits for data
6151+ 3BFD 32 E9 81             ld      (DATABT),A
6152+ 3C00 AF                   xor     A               ; no parity bit
6153+ 3C01 32 EA 81             ld      (PARBT),A
6154+ 3C04 3C                   inc     A               ; 1 bit for stop
6155+ 3C05 32 EB 81             ld      (STPBT),A
6156+ 3C08                      ; check if bps are legal
6157+ 3C08 E5           SETSER: push    HL              ; store HL
6158+ 3C09 D5                   push    DE              ; store DE
6159+ 3C0A DD E5                push    IX              ; store IX
6160+ 3C0C DD 21 FA 3C          ld      IX,SUP_BPS      ; allowed BPSs
6161+ 3C10 06 0B                ld      B,$0B           ; 11 items
6162+ 3C12 0E 00                ld      C,$00           ; reset pointer
6163+ 3C14 2A E7 81     CKBPS:  ld      HL,(BPS)        ; load BPS
6164+ 3C17 DD 5E 00             ld      E,(IX+0)        ; load LSB of item
6165+ 3C1A DD 56 01             ld      D,(IX+1)        ; load MSB of item
6166+ 3C1D CD DE 3F             call    CMP16           ; is it equal?
6167+ 3C20 CA 2D 3C             jp      Z,SET_PT        ; yes, found a correspondance
6168+ 3C23 DD 23                inc     IX
6169+ 3C25 DD 23                inc     IX              ; no, go to next entry
6170+ 3C27 0C                   inc     C               ; increment pointer
6171+ 3C28 10 EA                djnz    CKBPS           ; repeat for 10 entries
6172+ 3C2A C3 1B 3D             jp      SCERR1          ; if nothing found, raise an error
6173+ 3C2D              SET_PT: ;init CTC CH0: CH0 provides RX/TX clock to SIO port A
6174+ 3C2D                      ; TO0 output frequency=INPUT CLK/time constant. Time constant is set to get 16 times
6175+ 3C2D                      ; the requested baud rate. I.e., if bps is 19,200 then time constast is set to 6 because
6176+ 3C2D                      ; 1,843,200/6 = 307,200 Hz (that is 19,200 x 16)
6177+ 3C2D F3                   di                      ; disable INTs
6178+ 3C2E 06 00                ld      B,$00           ; reset B
6179+ 3C30 21 10 3D             ld      HL,CTC_CFG      ; address of first CTC divider
6180+ 3C33 09                   add     HL,BC           ; adjust for correct CTC divider
6181+ 3C34 0E 10                ld      C,CTC_CH0       ; CTC channel 0
6182+ 3C36 3A E6 81             ld      A,(PRTNUM)      ; load port number
6183+ 3C39 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6184+ 3C3A DA 3E 3C             jp      C,SET_CTC       ; port 1 => ch. 0, so continue
6185+ 3C3D 0C                   inc     C               ; port 2 => ch. 1, increment address port into C
6186+ 3C3E 3E 47        SET_CTC:ld      A,%01000111     ; interrupt off, counter mode, prsc=16 (doesn't matter), ext. start,
6187+ 3C40                                              ; start upon loading time constant, time constant follows, sw reset, command word
6188+ 3C40 ED 79                out     (C),A           ; configure CTC channel
6189+ 3C42 7E                   ld      A,(HL)          ; load CTC divider
6190+ 3C43 ED 79                out     (C),A           ; send divider
6191+ 3C45                      ; configure SIO
6192+ 3C45 21 56 03             ld      HL,SIO_A_SETS   ; load default settings for SIO
6193+ 3C48 11 EC 81             ld      DE,SIOBFR       ; into a temp buffer
6194+ 3C4B 01 0A 00             ld      BC,$000A        ; 10 items to copy
6195+ 3C4E ED B0                ldir                    ; copy SIO settings into TEMP buffer
6196+ 3C50 3A F1 81             ld      A,(SIOBFR+5)    ; load WR5 setting
6197+ 3C53 47                   ld      B,A             ; move it into B
6198+ 3C54 3A E9 81             ld      A,(DATABT)      ; load DATA bits
6199+ 3C57 FE 05                cp      $05             ; is it 5 bits?
6200+ 3C59 20 06                jr      NZ,BITS6        ; no, jump over
6201+ 3C5B CB B0                res     6,B
6202+ 3C5D CB A8                res     5,B             ; set D6 & D5 to 0
6203+ 3C5F 18 19                jr      SETPAR          ; jump to set parity
6204+ 3C61 FE 06        BITS6:  cp      $06             ; is it 6 bits?
6205+ 3C63 20 06                jr      NZ,BITS7        ; no, jump over
6206+ 3C65 CB F0                set     6,B
6207+ 3C67 CB A8                res     5,B             ; set D6 & D5 to 1,0
6208+ 3C69 18 0F                jr      SETPAR          ; jump to set parity
6209+ 3C6B FE 07        BITS7:  cp      $07             ; is it 7 bits?
6210+ 3C6D 20 07                jr      NZ,BITS8        ; no, jump over
6211+ 3C6F CB B0                res     6,B
6212+ 3C71 CB E8                set     5,B             ; set D6 & D5 to 0,1
6213+ 3C73 C3 7A 3C             jp      SETPAR          ; jump to set parity
6214+ 3C76 CB F0        BITS8:  set     6,B
6215+ 3C78 CB E8                set     5,B             ; set D6 & D5 to 1,1
6216+ 3C7A 21 21 82     SETPAR: ld      HL,SERABITS     ; load address for storing data bits
6217+ 3C7D 3A E6 81             ld      A,(PRTNUM)      ; check serial port number
6218+ 3C80 3D                   dec     A               ; is it port #1?
6219+ 3C81 CA 85 3C             jp      Z,SETPAR2       ; yes, jump over
6220+ 3C84 23                   inc     HL              ; port #2, use SERBBITS instead
6221+ 3C85 78           SETPAR2:ld      A,B             ; retrieve DATA bits
6222+ 3C86 32 F1 81             ld      (SIOBFR+5),A    ; save DATA bits
6223+ 3C89 E6 60                and     %01100000       ; filter only D5&D6 bits
6224+ 3C8B 87                   add     A,A             ; shift left times 1
6225+ 3C8C 77                   ld      (HL),A          ; store for SIO_EI & SIO_DI functions
6226+ 3C8D 3A EB 81             ld      A,(STPBT)       ; load STOP bits
6227+ 3C90 87                   add     A,A
6228+ 3C91 87                   add     A,A             ; 2 left shifts
6229+ 3C92 47                   ld      B,A             ; move forming byte into B
6230+ 3C93 3A EA 81             ld      A,(PARBT)       ; load PARITY setting
6231+ 3C96 A7                   and     A               ; is it 0?
6232+ 3C97 CA A2 3C             jp      Z,STRPAR        ; yes, jump over
6233+ 3C9A CB C0                set     0,B             ; set PARITY on
6234+ 3C9C 3D                   dec     A               ; is parity ODD?
6235+ 3C9D CA A2 3C             jp      Z,STRPAR        ; yes, so jump over
6236+ 3CA0 CB C8                set     1,B             ; no, it's EVEN so set the corresponding bit
6237+ 3CA2 3A EF 81     STRPAR: ld      A,(SIOBFR+3)    ; load WR4 setting
6238+ 3CA5 E6 F0                and     %11110000       ; reset STOP & PARITY bits
6239+ 3CA7 B0                   or      B               ; set new STOP & PARITY bits
6240+ 3CA8 32 EF 81             ld      (SIOBFR+3),A    ; store new value
6241+ 3CAB                      ;set up TX and RX:
6242+ 3CAB                      ; the followings are settings for channel A
6243+ 3CAB 21 EC 81             ld      HL,SIOBFR       ; settings for SIO ch. A
6244+ 3CAE 06 06                ld      B,$06           ; 6 bytes to send
6245+ 3CB0 0E 22                ld      C,SIO_CA        ; I/O address of SIO ch.A
6246+ 3CB2 3A E6 81             ld      A,(PRTNUM)      ; load port number
6247+ 3CB5 1F                   rra                     ; is it 1 (Carry=1) or 2 (Carry=0)
6248+ 3CB6 DA BA 3C             jp      C,SRLCNT        ; port 1, continue
6249+ 3CB9 0C                   inc     C               ; port 2, increment address port into C
6250+ 3CBA ED B3        SRLCNT: otir                    ; send bytes to SIO
6251+ 3CBC                      ; the following are settings for channel B (don't need to load HL since settings are contigous)
6252+ 3CBC 06 04                ld      B,$04           ; other 4 bytes to send
6253+ 3CBE 51                   ld      D,C             ; store port address into D
6254+ 3CBF 0E 23                ld      C,SIO_CB        ; I/O address of SIO ch.B
6255+ 3CC1 ED B3                otir                    ; send bytes to SIO
6256+ 3CC3                      ; the following are settings for selected channel
6257+ 3CC3 3E 01                ld      A,$01           ; write into WR0: select WR1
6258+ 3CC5 4A                   ld      C,D             ; retrieve port address
6259+ 3CC6 ED 79                out     (C),A
6260+ 3CC8 3E 18                ld      A,%00011000     ; interrupts on every RX char; parity is no special condition;
6261+ 3CCA                                              ; buffer overrun is special condition
6262+ 3CCA ED 79                out     (C),A
6263+ 3CCC 21 20 82             ld      HL,SERIALS_EN
6264+ 3CCF 3A E6 81             ld      A,(PRTNUM)      ; retrieve serial channel
6265+ 3CD2 3D                   dec     A               ; channel A?
6266+ 3CD3 20 10                jr      NZ,ENCHB        ; no, jump over
6267+ 3CD5 CD DA 01             call    SIO_A_EI        ; enable RX on SIO channel A
6268+ 3CD8 CB C6                set     0,(HL)          ; set serial port 1 status ON
6269+ 3CDA CB D6                set     2,(HL)          ; set serial port 1 RX ON
6270+ 3CDC                      ; back to normal running
6271+ 3CDC FB                   ei                      ; re-enable INTs
6272+ 3CDD DB 01                in      A,(PIO_DB)      ; load status LEDs
6273+ 3CDF CB F7                set     6,A             ; set status LED on
6274+ 3CE1 CB A7                res     4,A             ; set error LED off
6275+ 3CE3 18 0E                jr      EXNRM           ; leave
6276+ 3CE5 CD E2 01     ENCHB:  call    SIO_B_EI        ; enable RX on SIO channel B
6277+ 3CE8 CB CE                set     1,(HL)          ; set serial port 2 status ON
6278+ 3CEA CB DE                set     3,(HL)          ; set serial port 2 RX ON
6279+ 3CEC                      ; back to normal running
6280+ 3CEC FB                   ei                      ; re-enable INTs
6281+ 3CED DB 01                in      A,(PIO_DB)      ; load status LEDs
6282+ 3CEF CB FF                set     7,A             ; set status LED on
6283+ 3CF1 CB AF                res     5,A             ; set error LED off
6284+ 3CF3 D3 01        EXNRM:  out     (PIO_DB),A      ; send new configuration
6285+ 3CF5 DD E1                pop     IX              ; retrieve IX
6286+ 3CF7 D1                   pop     DE              ; retrieve DE
6287+ 3CF8 E1                   pop     HL              ; retrieve HL
6288+ 3CF9 C9                   ret                     ; return to caller
6289+ 3CFA
6290+ 3CFA              ; allowed bps (Bauds per second)
6291+ 3CFA 00 E1 00 96  SUP_BPS:defw    57600,38400,28800,19200,14400,9600,4800,3600,2400,1200,600
6291+ 3CFE 80 70 00 4B
6291+ 3D02 40 38 80 25
6291+ 3D06 C0 12 10 0E
6291+ 3D0A 60 09 B0 04
6291+ 3D0E 58 02
6292+ 3D10              ; corresponding CTC divider
6293+ 3D10 02 03 04 06  CTC_CFG:defb    2,3,4,6,8,12,24,32,48,96,192
6293+ 3D14 08 0C 18 20
6293+ 3D18 30 60 C0
6294+ 3D1B
6295+ 3D1B
6296+ 3D1B              ; serial configuration error
6297+ 3D1B DD E1        SCERR1: pop     IX              ; retrieve IX
6298+ 3D1D D1                   pop     DE              ; retrieve DE
6299+ 3D1E E1                   pop     HL              ; retrieve HL
6300+ 3D1F 1E 2C        SCERR:  ld      E,SC            ; Serial Configuration Error
6301+ 3D21 C3 03 17             jp      ERROR           ; print error
6302+ 3D24
6303+ 3D24
6304+ 3D24              ; serial buffer overrun
6305+ 3D24 CD DF 1E     SOERR:  call    PRNTCRLF
6306+ 3D27 1E 30                ld      E,SO            ; Serial Buffer Overrun
6307+ 3D29 C3 03 17             jp      ERROR
6308+ 3D2C
6309+ 3D2C
6310+ 3D2C              ; check for direct mode
6311+ 3D2C E5           DIRMOD: push    HL              ; Save code string address
6312+ 3D2D 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
6313+ 3D30 23                   inc     HL              ; -1 means direct statement
6314+ 3D31 7C                   ld      A,H
6315+ 3D32 B5                   or      L
6316+ 3D33 E1                   pop     HL              ; Restore code string address
6317+ 3D34 C2 4E 3D             jp      NZ,HLPERR       ; raise error if in indirect mode
6318+ 3D37 C9                   ret
6319+ 3D38
6320+ 3D38
6321+ 3D38              ; HELP lists the line program where an error occured
6322+ 3D38 CD 2C 3D     HELP:   call    DIRMOD          ; check if in direct mode
6323+ 3D3B E5                   push    HL              ; store HL
6324+ 3D3C 2A B1 80             ld      HL,(HLPLN)      ; load HELP line
6325+ 3D3F 23                   inc     HL              ; increment HL
6326+ 3D40 7C                   ld      A,H
6327+ 3D41 B5                   or      L               ; check if there is a line into the HELP reg.
6328+ 3D42 E1                   pop     HL
6329+ 3D43 CA 4E 3D             jp      Z,HLPERR        ; no line found, raise error
6330+ 3D46 ED 5B B1 80          ld      DE,(HLPLN)      ; recover line
6331+ 3D4A C1                   pop     BC              ; remove BC from stack since it's not needed anymore for LIST
6332+ 3D4B C3 5F 1A             jp      LST01H          ; jump to list line
6333+ 3D4E 1E 32        HLPERR: ld      E,HP            ; HELP call error
6334+ 3D50 C3 03 17             jp      ERROR           ; raise error
6335+ 3D53
6336+ 3D53
6337+ 3D53              ; KEY command to list/modify function keys and auto-repeat
6338+ 3D53 2B           KEY:    dec     HL              ; dec 'cos GETCHR INCs
6339+ 3D54 CD 12 1C             call    GETCHR          ; Get next character
6340+ 3D57 CA D7 3D             jp      Z,LSTKEYS       ; jump if nothing follows
6341+ 3D5A                      ; change FN keys
6342+ 3D5A CD 21 29             call    GETINT          ; get a number
6343+ 3D5D A7                   and     A               ; is it 0?
6344+ 3D5E 20 10                jr      NZ,KEYCH        ; no, jump over
6345+ 3D60 E5           RESFN:  push    HL              ; yes - reset FN keys to defaults
6346+ 3D61 D5                   push    DE              ; store HL & DE
6347+ 3D62 21 DD 15             ld      HL,AUTORP       ; pointer to default auto-repeat delays and FN keys texts
6348+ 3D65 11 B3 80             ld      DE,KEYDEL       ; pointer to destination
6349+ 3D68 01 82 00             ld      BC,$0082        ; 130 chars to be copied (2xauto-delay, 128xFN keys)
6350+ 3D6B ED B0                ldir                    ; restore default texts
6351+ 3D6D D1                   pop     DE              ; retrieve DE
6352+ 3D6E E1                   pop     HL              ; retrieve HL
6353+ 3D6F C9                   ret                     ; return to caller
6354+ 3D70 FE 09        KEYCH:  cp      $09             ; is it >= 9?
6355+ 3D72 D2 8A 3E             jp      NC,SETREP       ; yes - jump over
6356+ 3D75 3D                   dec     A               ; FN key in range 0~7
6357+ 3D76 87                   add     A,A             ; multiply A...
6358+ 3D77 87                   add     A,A             ; ... times 4...
6359+ 3D78 87                   add     A,A             ; ... to get the correct...
6360+ 3D79 87                   add     A,A             ; ... offset fo FN key text
6361+ 3D7A 32 DE 81             ld      (TMPBFR1),A     ; store FN key offset...
6362+ 3D7D AF                   xor     A               ; ...in a...
6363+ 3D7E 32 DF 81             ld      (TMPBFR1+1),A   ; ...16-bit register
6364+ 3D81 CD D1 19             call    CHKSYN          ; Make sure ',' follows
6365+ 3D84 2C                   defb    ','
6366+ 3D85 44 4D                ld      BC,HL           ; copy address into BC
6367+ 3D87 CD AD 20             call    EVAL            ; Evaluate expression (in E there is the length)
6368+ 3D8A E5                   push    HL              ; store string pointer
6369+ 3D8B 3A 94 81             ld      A,(TYPE)        ; Get variable type
6370+ 3D8E B7                   or      A               ; Is it a string variable?
6371+ 3D8F CA EF 16             jp      Z,SNERR         ; no - syntax error
6372+ 3D92 CD E6 26             call    GSTRCU          ; Current string to pool
6373+ 3D95 CD F7 2E             call    LOADFP          ; Move string block data to (BC=pointer, DE=length)
6374+ 3D98 7B                   ld      A,E             ; copy length into A
6375+ 3D99 FE 11                cp      $11             ; is length > 16?
6376+ 3D9B DA A0 3D             jp      C,DECLN1        ; no, jump over
6377+ 3D9E 1E 10                ld      E,$10           ; yes, so set length to 16
6378+ 3DA0 3E 10        DECLN1: ld      A,$10           ; calculate how many...
6379+ 3DA2 93                   sub     E               ; ...null chars needed to fill up...
6380+ 3DA3 57                   ld      D,A             ; ...the FN key text
6381+ 3DA4 C5                   push    BC              ; store address of string
6382+ 3DA5 ED 4B DE 81          ld      BC,(TMPBFR1)    ; load FN key offset
6383+ 3DA9 21 B5 80             ld      HL,FNKEYS       ; load address of FN keys texts
6384+ 3DAC 09                   add     HL,BC           ; get corrected address
6385+ 3DAD C1                   pop     BC              ; retrieve address of string chars
6386+ 3DAE 0A           CPKEY:  ld      A,(BC)          ; load char from string
6387+ 3DAF FE 0D                cp      CR              ; return?
6388+ 3DB1 CA BE 3D             jp      Z,CPKEY2        ; yes, store char
6389+ 3DB4 FE 7B                cp      $7B             ; if char > "z" ?
6390+ 3DB6 D2 EF 16             jp      NC,SNERR        ; yes - syntax error
6391+ 3DB9 FE 20                cp      $20             ; is char < space?
6392+ 3DBB DA EF 16             jp      C,SNERR         ; yes - syntax error
6393+ 3DBE FE 61        CPKEY2: cp      $61             ; is it >= 'a'?
6394+ 3DC0 DA C5 3D             jp      C,CPKEY3        ; no, continue
6395+ 3DC3 E6 5F                and     %01011111       ; set letters to uppercase
6396+ 3DC5 77           CPKEY3: ld      (HL),A          ; store char
6397+ 3DC6 23                   inc     HL              ; next string char
6398+ 3DC7 03                   inc     BC              ; next free cell
6399+ 3DC8 1D                   dec     E               ; decrement E
6400+ 3DC9 20 E3                jr      NZ,CPKEY        ; repeat until 0
6401+ 3DCB AF                   xor     A               ; null char
6402+ 3DCC 14                   inc     D               ; +1 to decrement below
6403+ 3DCD 15           CPKEY1: dec     D               ; how many null chars to insert?
6404+ 3DCE CA D5 3D             jp      Z,CPKYEND       ; no more nulls, so exit
6405+ 3DD1 77                   ld      (HL),A          ; store it
6406+ 3DD2 23                   inc     HL              ; next cell
6407+ 3DD3 18 F8                jr      CPKEY1          ; repeat
6408+ 3DD5 E1           CPKYEND:pop     HL              ; retrieve pointer to string
6409+ 3DD6 C9                   ret                     ; return to caller
6410+ 3DD7                                              ; list FN keys
6411+ 3DD7 E5           LSTKEYS:push    HL              ; Save code string address
6412+ 3DD8 2A AF 80             ld      HL,(LINEAT)     ; Get current line number
6413+ 3DDB 23                   inc     HL              ; -1 means direct statement
6414+ 3DDC 7C                   ld      A,H
6415+ 3DDD B5                   or      L
6416+ 3DDE E1                   pop     HL              ; Restore code string address
6417+ 3DDF C2 EF 16             jp      NZ,SNERR        ; raise error if in indirect mode
6418+ 3DE2 E5                   push    HL              ; store HL
6419+ 3DE3 D5                   push    DE              ; store DE
6420+ 3DE4 21 B5 80             ld      HL,FNKEYS       ; load starting address of FN keys text
6421+ 3DE7 0E 01                ld      C,$01           ; 8 function keys
6422+ 3DE9 06 10        PRTK4:  ld      B,$10           ; 16 chars each
6423+ 3DEB 11 AC 3E     PRTK2:  ld      DE,CHKEY1       ; message "KEY "
6424+ 3DEE CD 7B 3E             call    PRTCKEY         ; print it
6425+ 3DF1 79                   ld      A,C             ; load FN key
6426+ 3DF2 C6 30                add     $30             ; get number in ASCI code
6427+ 3DF4 CD DC 19             call    OUTC            ; print it
6428+ 3DF7 11 B1 3E             ld      DE,CHKEY2       ; message ": ""
6429+ 3DFA CD 7B 3E             call    PRTCKEY         ; print it
6430+ 3DFD 3E 01                ld      A,$01           ; " opened
6431+ 3DFF 32 DE 81             ld      (TMPBFR1),A
6432+ 3E02 7E           LDKEY:  ld      A,(HL)          ; retrieve char
6433+ 3E03 A7                   and     A               ; is it zero?
6434+ 3E04 CA 17 3E             jp      Z,CNTLTK        ; yes, go next char
6435+ 3E07 CD 63 3E             call    OPNQT           ; check if quotes are opened
6436+ 3E0A FE 22                cp      $22             ; check if char is "?
6437+ 3E0C CA 2C 3E             jp      Z,PRTCHR        ; yes, print "chr$("
6438+ 3E0F FE 0D                cp      CR              ; is it a CR?
6439+ 3E11 CA 2C 3E             jp      Z,PRTCHR        ; yes, print "chr$("
6440+ 3E14 CD DC 19     PRTK3:  call    OUTC            ; no, just print it
6441+ 3E17 23           CNTLTK: inc     HL              ; next char
6442+ 3E18 10 E8                djnz    LDKEY           ; continue until finished
6443+ 3E1A CD 51 3E             call    CLSQT           ; check if quotes are still open
6444+ 3E1D 3E 0D                ld      A,CR            ; go next line
6445+ 3E1F CD DC 19             call    OUTC            ; print it
6446+ 3E22 0C                   inc     C               ; next FN key
6447+ 3E23 79                   ld      A,C             ; check if...
6448+ 3E24 FE 09                cp      $09             ; finished keys?
6449+ 3E26 DA E9 3D             jp      C,PRTK4         ; no, repeat 1 more time
6450+ 3E29 D1                   pop     DE              ; retrieve DE
6451+ 3E2A E1                   pop     HL              ; retrieve HL
6452+ 3E2B C9                   ret                     ; return to caller
6453+ 3E2C E5           PRTCHR: push    HL              ; store HL
6454+ 3E2D CD 51 3E             call    CLSQT           ; check if quotes are closed
6455+ 3E30 3E 2B                ld      A,'+'           ; '+' char
6456+ 3E32 CD DC 19             call    OUTC            ; print it
6457+ 3E35 11 B4 3E             ld      DE,CHKEY3       ; address of "CHR$("
6458+ 3E38 CD 7B 3E             call    PRTCKEY         ; print it
6459+ 3E3B E1                   pop     HL              ; recover HL
6460+ 3E3C 23                   inc     HL              ; next char
6461+ 3E3D 05                   dec     B               ; increment char counter
6462+ 3E3E 11 BA 3E             ld      DE,CHKEY4       ; load address of RETURN
6463+ 3E41 7E                   ld      A,(HL)          ; load char
6464+ 3E42 FE 0D                cp      CR              ; is it a RETURN?
6465+ 3E44 20 03                jr      NZ,PTCHR1       ; no, jump over
6466+ 3E46 11 BD 3E             ld      DE,CHKEY5       ; yes, load address of "
6467+ 3E49 CD 7B 3E     PTCHR1: call    PRTCKEY         ; print it
6468+ 3E4C 3E 29                ld      A,')'           ; char )
6469+ 3E4E C3 14 3E             jp      PRTK3           ; continue
6470+ 3E51 F5           CLSQT:  push    AF              ; store A
6471+ 3E52 3A DE 81             ld      A,(TMPBFR1)     ; quote status
6472+ 3E55 A7                   and     A               ; are they closed?
6473+ 3E56 28 09                jr      Z,CLSQT1        ; if yes, return
6474+ 3E58 3E 22                ld      A,$22           ; no, so close them
6475+ 3E5A CD DC 19             call    OUTC            ; print "
6476+ 3E5D AF                   xor     A               ; set quotes
6477+ 3E5E 32 DE 81             ld      (TMPBFR1),A     ; as closed
6478+ 3E61 F1           CLSQT1: pop     AF              ; retrieve A
6479+ 3E62 C9                   ret                     ; return to caller
6480+ 3E63 F5           OPNQT:  push    AF              ; store A
6481+ 3E64 3A DE 81             ld      A,(TMPBFR1)     ; quote status
6482+ 3E67 A7                   and     A               ; are they open?
6483+ 3E68 20 0F                jr      NZ,OPNQT1       ; if yes, return
6484+ 3E6A 3E 2B                ld      A,'+'           ; no, so add '+
6485+ 3E6C CD DC 19             call    OUTC            ; print it
6486+ 3E6F 3E 22                ld      A,$22           ; and then open quotes
6487+ 3E71 CD DC 19             call    OUTC            ; print them
6488+ 3E74 3E 01                ld      A,$01           ; set quotes
6489+ 3E76 32 DE 81             ld      (TMPBFR1),A     ; as opened
6490+ 3E79 F1           OPNQT1: pop     AF              ; retrieve A
6491+ 3E7A C9                   ret                     ; return to caller
6492+ 3E7B F5           PRTCKEY:push    AF              ; store original char
6493+ 3E7C 1A           PRTK1:  ld      A,(DE)          ; load char
6494+ 3E7D A7                   and     A               ; is it 0?
6495+ 3E7E CA 88 3E             jp      Z,PRTEND        ; yes, finished printing
6496+ 3E81 CD DC 19             call    OUTC            ; no, print char
6497+ 3E84 13                   inc     DE              ; next char
6498+ 3E85 C3 7C 3E             jp      PRTK1           ; repeat
6499+ 3E88 F1           PRTEND: pop     AF              ; retrieve AF
6500+ 3E89 C9                   ret                     ; return to caller
6501+ 3E8A FE 09        SETREP: cp      $09             ; is it special key 9? (stands for auto-repeat)
6502+ 3E8C C2 EF 16             jp      NZ,SNERR        ; no, raise an error
6503+ 3E8F CD D1 19             call    CHKSYN          ; Check for comma
6504+ 3E92 2C                   defb    ','
6505+ 3E93 CD 21 29             call    GETINT          ; get a number
6506+ 3E96 32 DE 81             ld      (TMPBFR1),A     ; store it
6507+ 3E99 CD D1 19             call    CHKSYN          ; Check for comma
6508+ 3E9C 2C                   defb    ','
6509+ 3E9D CD 21 29             call    GETINT          ; get another number
6510+ 3EA0 E5                   push    HL              ; store HL
6511+ 3EA1 21 B4 80             ld      HL,AUTOKE       ; address of second cell for key auto-repeat
6512+ 3EA4 77                   ld      (HL),A          ; store auto-repeat delay
6513+ 3EA5 2B                   dec     HL              ; previous cell
6514+ 3EA6 3A DE 81             ld      A,(TMPBFR1)     ; retrieve value
6515+ 3EA9 77                   ld      (HL),A          ; store delay for auto-repeat
6516+ 3EAA E1                   pop     HL              ; retrieve HL
6517+ 3EAB C9                   ret
6518+ 3EAC 4B 45 59 20  CHKEY1: defb    "KEY ",0
6518+ 3EB0 00
6519+ 3EB1 3A 22 00     CHKEY2: defb    ":",34,0
6520+ 3EB4 63 68 72 24  CHKEY3: defb    "chr$(",0
6520+ 3EB8 28 00
6521+ 3EBA 31 33 00     CHKEY4: defb    "13",0
6522+ 3EBD 33 34 00     CHKEY5: defb    "34",0
6523+ 3EC0
6524+ 3EC0
6525+ 3EC0              ; LOAD "filename"
6526+ 3EC0              ; load a BASIC program from disk
6527+ 3EC0 C9           LOAD:   ret                     ; currently a stub for LOAD
6528+ 3EC1
6529+ 3EC1
6530+ 3EC1              ; SAVE "filename"
6531+ 3EC1              ; save a BASIC program on disk
6532+ 3EC1 C9           SAVE:   ret                     ; currently a stub for SAVE
6533+ 3EC2
6534+ 3EC2
6535+ 3EC2              ; FILES
6536+ 3EC2              ; list files on disk
6537+ 3EC2 C9           FILES:  ret                     ; currently a stub for FILES
6538+ 3EC3
6539+ 3EC3
6540+ 3EC3              ; ERASE "filename"
6541+ 3EC3              ; erase a file from disk
6542+ 3EC3 C9           ERASE:  ret                     ; currently a stub for ERASE
6543+ 3EC4
6544+ 3EC4
6545+ 3EC4              ; HEX$(nn) Convert 16 bit number to Hexadecimal string
6546+ 3EC4 CD 9E 20     HEX: 	call	TSTNUM          ; Verify it's a number
6547+ 3EC7 CD C8 1C             call	DEINT           ; Get integer -32768 to 32767
6548+ 3ECA C5                   push	BC              ; Save contents of BC
6549+ 3ECB 21 37 82             ld      HL,PBUFF        ; load address of PBUFF into HL
6550+ 3ECE 7A                   ld      A,D             ; Get MSB into A
6551+ 3ECF B7                   or      A               ; OR with LSB to see if param=0
6552+ 3ED0 28 0C                jr      Z,HEX2          ; Skip output if both high digits are zero
6553+ 3ED2 CD FA 3E             call    BYT2ASC         ; Convert D to ASCII
6554+ 3ED5 78                   ld      A,B             ; cechk if B
6555+ 3ED6 FE 30                cp      '0'             ; is 0
6556+ 3ED8 28 02                jr      Z,HEX1          ; Don't store high digit if zero
6557+ 3EDA 70                   ld      (HL),B          ; Store it to PBUFF
6558+ 3EDB 23                   inc     HL              ; Next location
6559+ 3EDC 71           HEX1:   ld      (HL),C          ; Store C to PBUFF+1
6560+ 3EDD 23                   inc     HL              ; Next location
6561+ 3EDE 7B           HEX2:   ld      A,E             ; Get lower byte
6562+ 3EDF CD FA 3E             call    BYT2ASC         ; Convert E to ASCII
6563+ 3EE2 7A                   ld      A,D
6564+ 3EE3 B7                   or      A
6565+ 3EE4 20 05                jr      NZ,HEX3         ; If upper byte was not zero then always print lower byte
6566+ 3EE6 78                   ld      A,B
6567+ 3EE7 FE 30                cp      '0'             ; If high digit of lower byte is zero then don't print
6568+ 3EE9 28 02                jr      Z,HEX4
6569+ 3EEB 70           HEX3:   ld      (HL),B          ; to PBUFF+2
6570+ 3EEC 23                   inc     HL              ; Next location
6571+ 3EED 71           HEX4:   ld      (HL),C          ; to PBUFF+3
6572+ 3EEE 23                   inc     HL              ; PBUFF+4 to zero
6573+ 3EEF AF                   xor     A               ; Terminating character
6574+ 3EF0 77                   ld      (HL),A          ; Store zero to terminate
6575+ 3EF1 23                   inc     HL              ; Make sure PBUFF is terminated
6576+ 3EF2 77                   ld      (HL),A          ; Store the double zero there
6577+ 3EF3 C1                   pop     BC              ; Get BC back
6578+ 3EF4 21 37 82             ld      HL,PBUFF        ; Reset to start of PBUFF
6579+ 3EF7 C3 33 25             jp      STR1            ; Convert the PBUFF to a string and return it
6580+ 3EFA 47           BYT2ASC:ld      B,A             ; Save original value
6581+ 3EFB E6 0F                and     $0F             ; Strip off upper nybble
6582+ 3EFD FE 0A                cp      $0A             ; 0-9?
6583+ 3EFF 38 02                jr      C,ADD30         ; If A-F, add 7 more
6584+ 3F01 C6 07                add     A,$07           ; Bring value up to ASCII A-F
6585+ 3F03 C6 30        ADD30:  add     A,$30           ; And make ASCII
6586+ 3F05 4F                   ld      C,A             ; Save converted char to C
6587+ 3F06 78                   ld      A,B             ; Retrieve original value
6588+ 3F07 0F                   rrca                    ; and Rotate it right
6589+ 3F08 0F                   rrca
6590+ 3F09 0F                   rrca
6591+ 3F0A 0F                   rrca
6592+ 3F0B E6 0F                and     $0F             ; Mask off upper nybble
6593+ 3F0D FE 0A                cp      $0A             ; 0-9? < A hex?
6594+ 3F0F 38 02                jr      C,ADD301        ; Skip Add 7
6595+ 3F11 C6 07                add     A,$07           ; Bring it up to ASCII A-F
6596+ 3F13 C6 30        ADD301: add     A,$30           ; And make it full ASCII
6597+ 3F15 47                   ld      B,A             ; Store high order byte
6598+ 3F16 C9                   ret
6599+ 3F17
6600+ 3F17              ; Convert "&Hnnnn" to FPREG
6601+ 3F17              ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
6602+ 3F17              ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
6603+ 3F17 EB           HEXTFP: ex      DE,HL           ; Move code string pointer to DE
6604+ 3F18 21 00 00             ld      HL,$0000        ; Zero out the value
6605+ 3F1B CD 30 3F             call    GETHEX          ; Check the number for valid hex
6606+ 3F1E DA 50 3F             jp      C,HXERR         ; First value wasn't hex, HX error
6607+ 3F21 18 05                jr      HEXLP1          ; Convert first character
6608+ 3F23 CD 30 3F     HEXLP:  call    GETHEX          ; Get second and addtional characters
6609+ 3F26 38 1F                jr      C,HEXIT         ; Exit if not a hex character
6610+ 3F28 29           HEXLP1: add     HL,HL           ; Rotate 4 bits to the left
6611+ 3F29 29                   add     HL,HL
6612+ 3F2A 29                   add     HL,HL
6613+ 3F2B 29                   add     HL,HL
6614+ 3F2C B5                   or      L               ; Add in D0-D3 into L
6615+ 3F2D 6F                   ld      L,A             ; Save new value
6616+ 3F2E 18 F3                jr      HEXLP           ; And continue until all hex characters are in
6617+ 3F30
6618+ 3F30 13           GETHEX: inc     DE              ; Next location
6619+ 3F31 1A                   ld      A,(DE)          ; Load character at pointer
6620+ 3F32 FE 20                cp      SPC
6621+ 3F34 CA 30 3F             jp      Z,GETHEX        ; Skip spaces
6622+ 3F37 D6 30                sub     $30             ; Get absolute value
6623+ 3F39 D8                   ret     C               ; < "0", error
6624+ 3F3A FE 0A                cp      $0A
6625+ 3F3C 38 05                jr      C,NOSUB7        ; Is already in the range 0-9
6626+ 3F3E D6 07                sub     $07             ; Reduce to A-F
6627+ 3F40 FE 0A                cp      $0A             ; Value should be $0A-$0F at this point
6628+ 3F42 D8                   ret     C               ; CY set if was :            ; < = > ? @
6629+ 3F43 FE 10        NOSUB7: cp      $10             ; > Greater than "F"?
6630+ 3F45 3F                   ccf
6631+ 3F46 C9                   ret                     ; CY set if it wasn't valid hex
6632+ 3F47
6633+ 3F47 EB           HEXIT:  ex      DE,HL           ; Value into DE, Code string into HL
6634+ 3F48 7A                   ld      A,D             ; Load DE into AC
6635+ 3F49 4B                   ld      C,E             ; For prep to
6636+ 3F4A E5                   push    HL
6637+ 3F4B CD 84 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6638+ 3F4E E1                   pop     HL
6639+ 3F4F C9                   ret
6640+ 3F50
6641+ 3F50 DD 5C        HXERR:  ld      E,HX            ; ?HEX Error
6642+ 3F52 C3 03 17             jp      ERROR
6643+ 3F55
6644+ 3F55              ; BIN$(NN) Convert integer to a 1-16 char binary string
6645+ 3F55 CD 9E 20     BIN:    call    TSTNUM          ; Verify it's a number
6646+ 3F58 CD C8 1C             call    DEINT           ; Get integer -32768 to 32767
6647+ 3F5B C5           BIN2:   push    BC              ; Save contents of BC
6648+ 3F5C 21 37 82             ld      HL,PBUFF
6649+ 3F5F 06 11                ld      B,$11           ; One higher than max char count (16+1)
6650+ 3F61              ZEROSUP:                        ; Suppress leading zeros
6651+ 3F61 05                   dec     B               ; Max 16 chars
6652+ 3F62 78                   ld      A,B
6653+ 3F63 FE 01                cp      $01
6654+ 3F65 28 08                jr      Z,BITOUT        ; Always output at least one character
6655+ 3F67 CB 13                rl      E
6656+ 3F69 CB 12                rl      D
6657+ 3F6B 30 F4                jr      NC,ZEROSUP
6658+ 3F6D 18 04                jr      BITOUT2
6659+ 3F6F CB 13        BITOUT: rl      E
6660+ 3F71 CB 12                rl      D               ; Top bit now in carry
6661+ 3F73 3E 30        BITOUT2:ld      A,'0'           ; Char for '0'
6662+ 3F75 CE 00                adc     A,$00           ; If carry set then '0' --> '1'
6663+ 3F77 77                   ld      (HL),A
6664+ 3F78 23                   inc     HL
6665+ 3F79 05                   dec     B
6666+ 3F7A 20 F3                jr      NZ,BITOUT
6667+ 3F7C AF                   xor     A               ; Terminating character
6668+ 3F7D 77                   ld      (HL),A          ; Store zero to terminate
6669+ 3F7E 23                   inc     HL              ; Make sure PBUFF is terminated
6670+ 3F7F 77                   ld      (HL),A          ; Store the double zero there
6671+ 3F80 C1                   pop     BC
6672+ 3F81 21 37 82             ld      HL,PBUFF
6673+ 3F84 C3 33 25             jp      STR1
6674+ 3F87
6675+ 3F87              ; Convert "&Bnnnn" to FPREG
6676+ 3F87              ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
6677+ 3F87 EB           BINTFP: ex      DE,HL           ; Move code string pointer to DE
6678+ 3F88 21 00 00             ld      HL,$0000        ; Zero out the value
6679+ 3F8B CD A4 3F             call    CHKBIN          ; Check the number for valid bin
6680+ 3F8E DA B2 3F             jp      C,BINERR        ; First value wasn't bin, HX error
6681+ 3F91 D6 30        BINIT:  sub     '0'
6682+ 3F93 29                   add     HL,HL           ; Rotate HL left
6683+ 3F94 B5                   or      L
6684+ 3F95 6F                   ld      L,A
6685+ 3F96 CD A4 3F             call    CHKBIN          ; Get second and addtional characters
6686+ 3F99 30 F6                jr      NC,BINIT        ; Process if a bin character
6687+ 3F9B EB                   ex      DE,HL           ; Value into DE, Code string into HL
6688+ 3F9C 7A                   ld      A,D             ; Load DE into AC
6689+ 3F9D 4B                   ld      C,E             ; For prep to
6690+ 3F9E E5                   push    HL
6691+ 3F9F CD 84 24             call    ACPASS          ; ACPASS to set AC as integer into FPREG
6692+ 3FA2 E1                   pop     HL
6693+ 3FA3 C9                   ret
6694+ 3FA4
6695+ 3FA4              ; Char is in A, NC if char is 0 or 1
6696+ 3FA4 13           CHKBIN: inc     DE
6697+ 3FA5 1A                   ld      A,(DE)
6698+ 3FA6 FE 20                cp      SPC
6699+ 3FA8 CA A4 3F             jp      Z,CHKBIN        ; Skip spaces
6700+ 3FAB FE 30                cp      '0'             ; Set C if < '0'
6701+ 3FAD D8                   ret     C
6702+ 3FAE FE 32                cp      '2'
6703+ 3FB0 3F                   ccf                     ; Set C if > '1'
6704+ 3FB1 C9                   ret
6705+ 3FB2
6706+ 3FB2 1E 28        BINERR: ld      E,BN            ; ?BIN Error
6707+ 3FB4 C3 03 17             jp      ERROR
6708+ 3FB7
6709+ 3FB7
6710+ 3FB7 C3 08 00     MONOUT: jp      $0008           ; output a char
6711+ 3FBA
6712+ 3FBA
6713+ 3FBA 3A 20 82     RESET:  ld      A,(SERIALS_EN)
6714+ 3FBD E6 11                and     $11             ; are serial ports open?
6715+ 3FBF C4 2A 3B             call    NZ,RSTSERS      ; yes, reset serials
6716+ 3FC2 CD 3C 29             call    DISNMI          ; disable NMI vector
6717+ 3FC5 F3                   di                      ; disable INTs
6718+ 3FC6                  IFDEF LM80C64K
6719+ 3FC6 ~                    jp      ROM2RAM         ; Restart
6720+ 3FC6                  ELSE
6721+ 3FC6 C3 00 00             jp      $0000           ; Restart
6722+ 3FC9                  ENDIF
6723+ 3FC9
6724+ 3FC9
6725+ 3FC9 3E 00        INITST: ld      A,$00           ; Clear break flag
6726+ 3FCB 32 A9 80             ld      (BRKFLG),A
6727+ 3FCE C3 1B 12             jp      INIT
6728+ 3FD1
6729+ 3FD1
6730+ 3FD1 F5           TSTBIT: push    AF              ; Save bit mask
6731+ 3FD2 A0                   and     B               ; Get common bits
6732+ 3FD3 C1                   pop     BC              ; Restore bit mask
6733+ 3FD4 B8                   cp      B               ; Same bit set?
6734+ 3FD5 3E 00                ld      A,$00           ; Return 0 in A
6735+ 3FD7 C9                   ret
6736+ 3FD8
6737+ 3FD8 CD DC 19     OUTNCR: call    OUTC            ; Output character in A
6738+ 3FDB C3 DF 1E             jp      PRNTCRLF        ; Output CRLF
6739+ 3FDE
# file closed: ../include/basic/basic-1.03.asm
  79  3FDE
  80  3FDE              ; include utils
  81  3FDE                  INCLUDE "../include/utils/utils-r11.asm"
# file opened: ../include/utils/utils-r11.asm
   1+ 3FDE              ; ------------------------------------------------------------------------------
   2+ 3FDE              ; LM80C - UTILITY ROUTINES - R1.1
   3+ 3FDE              ; ------------------------------------------------------------------------------
   4+ 3FDE              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 3FDE              ; designed by Leonardo Miliani. More info at
   6+ 3FDE              ; www DOT leonardomiliani DOT com
   7+ 3FDE              ;
   8+ 3FDE              ; *ALS are routines from "Z80 Assembly Language Subroutines" by Lance
   9+ 3FDE              ; A. Leventhal and Winthrop Saville - Ed. Osborne/McGraw-Hill (1983)
  10+ 3FDE              ;
  11+ 3FDE              ; * WKT are routines from WikiTI:
  12+ 3FDE              ; http://wikiti.brandonw.net/index.php?title=WikiTI_Home
  13+ 3FDE              ;
  14+ 3FDE              ; * LAC are routines from Learn@Cemetch
  15+ 3FDE              ; https://learn.cemetech.net/index.php/Main_Page
  16+ 3FDE              ;
  17+ 3FDE              ; ------------------------------------------------------------------------------
  18+ 3FDE              ; Code Revision:
  19+ 3FDE              ; R1.0 - 20200110 - First release: 16-bit comparision/multiplication/negation
  20+ 3FDE              ; R1.1 - 20200413 - Second release: added ABS(HL)
  21+ 3FDE              ;
  22+ 3FDE              ; ------------------------------------------------------------------------------
  23+ 3FDE
  24+ 3FDE              ; compare two 16-bit registers, HL (minuend) and DE (subtrahend)
  25+ 3FDE              ; values can be both signed or unsigned words
  26+ 3FDE              ; inputs: HL, DE
  27+ 3FDE              ; destroys: A,F,HL
  28+ 3FDE              ;
  29+ 3FDE              ; returns: Z=1 if HL = DE
  30+ 3FDE              ; for UNSIGNED: C=1 if HL<DE  //  C=0 if HL>DE
  31+ 3FDE              ; for SIGNED:   S=1 (M) if HL<DE  //  S=0 (P) if HL>DE
  32+ 3FDE              ; if HL=DE: Z,P,NC  - Z=1, S=0; C=0
  33+ 3FDE              ; if HL>DE: NZ,P,NC - Z=0, S=0; C=0
  34+ 3FDE              ; if HL<DE: NZ,M,C  - Z=0, S=1; C=1
  35+ 3FDE              ; Source: ALS
  36+ 3FDE
  37+ 3FDE B7           CMP16:  or      A           ; clear CARRY
  38+ 3FDF ED 52                sbc     HL,DE       ; subtract DE from HL
  39+ 3FE1 E0                   ret     PO          ; return if no overflow
  40+ 3FE2 7C                   ld      A,H         ; overflow - invert SIGN flag
  41+ 3FE3 1F                   rra                 ; save CARRY flag in bit 7
  42+ 3FE4 EE 40                xor     %01000000   ; complement bit 6 (SIGN bit)
  43+ 3FE6 37                   scf                 ; ensure a Non-Zero result
  44+ 3FE7 8F                   adc     A,A         ; restore CARRY, complemented SIGN
  45+ 3FE8                                          ; ZERO flag = 0 for sure
  46+ 3FE8 C9                   ret                 ; return
  47+ 3FE9
  48+ 3FE9              ; ----------------------------------------------------------------------
  49+ 3FE9
  50+ 3FE9              ; multiply 2 signed/unsigned 16-bit words and return a 16-bit
  51+ 3FE9              ; signed/unsigned product
  52+ 3FE9              ; inputs: HL (multiplicand); DE (multiplier)
  53+ 3FE9              ; destroys: A,F
  54+ 3FE9              ; returns: HL (product)
  55+ 3FE9              ; Source: ALS
  56+ 3FE9
  57+ 3FE9              ; initialize partial product, bit count
  58+ 3FE9 C5           MUL16:  push    BC
  59+ 3FEA 4D                   ld      C,L         ; BC = multiplier
  60+ 3FEB 44                   ld      B,H
  61+ 3FEC 21 00 00             ld      HL,0        ; product = 0
  62+ 3FEF 3E 0F                ld      A,$0F       ; count = bit lenght - 1 (16-1)
  63+ 3FF1                      ; shift-and-add algorithm
  64+ 3FF1                      ; if MSB of multiplier is 1, add multiplicand to partial product
  65+ 3FF1                      ; shift partial product, multiplier left 1 bit
  66+ 3FF1 CB 23        MLP:    sla     E           ; shift multiplier left 1 bit
  67+ 3FF3 CB 12                rl      D
  68+ 3FF5 30 01                jr      NC,MLP1     ; jump if MSB of multiplier = 0
  69+ 3FF7 09                   add     HL,BC       ; add multiplicand to partial product
  70+ 3FF8 29           MLP1:   add     HL,HL       ; shift partial product left
  71+ 3FF9 3D                   dec     A
  72+ 3FFA 20 F5                jr      NZ,MLP      ; continue until count = 0
  73+ 3FFC                      ; add multiplicand one last time if MSB of multiplier is 1
  74+ 3FFC B2                   or      D           ; sign flag = MSB of multiplier
  75+ 3FFD F2 01 40             jp      P,EXMUL16   ; exit if MSB of multiplier is 0
  76+ 4000 09                   add     HL,BC       ; add multiplicand to product
  77+ 4001 C1           EXMUL16:pop     BC
  78+ 4002 C9                   ret
  79+ 4003
  80+ 4003              ; ----------------------------------------------------------------------
  81+ 4003              ; absolute value of HL (same applies to other 16-bit register pairs)
  82+ 4003              ; also, invert value of HL (or any other 16-bit register, just adjust the code)
  83+ 4003              ;
  84+ 4003              ; inputs: HL
  85+ 4003              ; destroys: A
  86+ 4003              ; operation: ABS(HL)
  87+ 4003              ; returns: HL with no sign or negated
  88+ 4003              ; Source: WKT
  89+ 4003
  90+ 4003 CB 7C        absHL:  bit     7,H
  91+ 4005 C8                   ret     Z
  92+ 4006 AF           negHL:  xor     A
  93+ 4007 95                   sub     L
  94+ 4008 6F                   ld      L,A
  95+ 4009 9F                   sbc     A,A
  96+ 400A 94                   sub     H
  97+ 400B 67                   ld      H,A
  98+ 400C C9                   ret
  99+ 400D
 100+ 400D              ; ------------------------------------------------------------------------------
 101+ 400D
 102+ 400D              ; 8/8 division
 103+ 400D              ; INPUT: D (dividend), E (divisor)
 104+ 400D              ; OPERATION: D/E
 105+ 400D              ; OUTPUT: D (quotient), A (remainder)
 106+ 400D AF           DIV_8_8:    xor     A
 107+ 400E C5                       push    BC
 108+ 400F 06 08                    ld      B,08h
 109+ 4011 CB 22        DIV_8_8LOOP:sla     D
 110+ 4013 17                       rla
 111+ 4014 BB                       cp      E
 112+ 4015 38 02                    jr      C,$+4
 113+ 4017 93                       sub     E
 114+ 4018 14                       inc     D
 115+ 4019 10 F6                    djnz    DIV_8_8LOOP
 116+ 401B C1                       pop     BC
 117+ 401C C9                       ret
 118+ 401D
 119+ 401D              ; ----------------------------------------------------------------------
 120+ 401D              ; divide a 16-bit number by an 8-bit number
 121+ 401D              ; (16/8 division)
 122+ 401D              ;
 123+ 401D              ; inputs: HL (Dividend), C (divisor)
 124+ 401D              ; destroys: A
 125+ 401D              ; OPERATION: HL/C
 126+ 401D              ; returns: HL (quotient), A (remainder)
 127+ 401D              ; source: WKT
 128+ 401D
 129+ 401D AF           DIV_16_8:   xor     A
 130+ 401E 06 10                    ld      B,16
 131+ 4020 29           DIV_16_8LP: add     HL,HL
 132+ 4021 17                       rla
 133+ 4022 38 03                    jr      C,$+5
 134+ 4024 B9                       cp      C
 135+ 4025 38 02                    jr      C,$+4
 136+ 4027 91                       sub     C
 137+ 4028 2C                       inc     L
 138+ 4029 10 F5                    djnz    DIV_16_8LP
 139+ 402B C9                       ret
 140+ 402C
 141+ 402C              ; ----------------------------------------------------------------------
 142+ 402C              ; divide a 16-bit number by a 16-bit number
 143+ 402C              ; (16/16 division)
 144+ 402C              ;
 145+ 402C              ; inputs: AC (Dividend), DE (divisor)
 146+ 402C              ; destroys: HL,A,C
 147+ 402C              ; OPERATION: AC/DE
 148+ 402C              ; returns: AC (quotient), HL (remainder)
 149+ 402C              ; source: WKT
 150+ 402C 21 00 00     DIV_16_16:  ld      HL, 0
 151+ 402F 06 10                    ld      B, 16
 152+ 4031 CB 21        DV16_16_LP: sla     C
 153+ 4033 CB C1                    set     0,C         ; this simulates the SLL undocumented instruction
 154+ 4035 17                       rla
 155+ 4036 ED 6A                    adc     HL,HL
 156+ 4038 ED 52                    sbc     HL,DE
 157+ 403A 30 02                    jr      NC, $+4
 158+ 403C 19                       add     HL,DE
 159+ 403D 0D                       dec     C
 160+ 403E 10 F1                    djnz    DV16_16_LP
 161+ 4040 C9                       ret
# file closed: ../include/utils/utils-r11.asm
  82  4041
  83  4041              ; include the latest version of the font sets
  84  4041                  INCLUDE "../include/vdp/6x8fonts-r16.asm"
# file opened: ../include/vdp/6x8fonts-r16.asm
   1+ 4041              ; ------------------------------------------------------------------------------
   2+ 4041              ; LM80C - 6x8 CHARSET - R1.6
   3+ 4041              ; ------------------------------------------------------------------------------
   4+ 4041              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4041              ; designed by Leonardo Miliani. More info at
   6+ 4041              ; www DOT leonardomiliani DOT com
   7+ 4041              ; ------------------------------------------------------------------------------
   8+ 4041              ; Code Revision:
   9+ 4041              ; R1.0 - 20190511 - First revision: ASCII chars (from 0 to 127)
  10+ 4041              ; R1.1 - 20190521 - Expanded to 255 chars
  11+ 4041              ; R1.2 - 20191209 - Start adding graphic chars to be coherent with 8x8 fonts
  12+ 4041              ; R1.3 - 20191226 - Added extended char codes (128-255)
  13+ 4041              ; R1.4 - 20200228 - adopted more usual hexadecimal & binary prefixes
  14+ 4041              ; R1.5 - 20200524 - New style for char #252
  15+ 4041              ; R1.6 - 20200704 - Redefined chars 105, 106, and 252
  16+ 4041              ; ------------------------------------------------------------------------------
  17+ 4041              ;
  18+ 4041              ;-------------------------------------------------------------------------------
  19+ 4041              ;
  20+ 4041              ;               6 x 8    C  H  A  R  S  E  T
  21+ 4041              ;
  22+ 4041              ;-------------------------------------------------------------------------------
  23+ 4041              ;
  24+ 4041              ;       6X8 CHARS, DESIGNED FOR TEXT BUT USABLE IN GRAPHICS 1 MODE TOO
  25+ 4041              ;       UPDATE: NOW GRAPHICS 1 MODE HAS ITS OWN CHAR SET
  26+ 4041
  27+ 4041              CHRST68 equ $
  28+ 4041 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  28+ 4045 00 00 00 00
  29+ 4049 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  29+ 404D 00 00 00 00
  30+ 4051 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  30+ 4055 00 00 00 00
  31+ 4059 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  31+ 405D 00 00 00 00
  32+ 4061 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  32+ 4065 00 00 00 00
  33+ 4069 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  33+ 406D 00 00 00 00
  34+ 4071 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  34+ 4075 00 00 00 00
  35+ 4079 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  35+ 407D 00 00 00 00
  36+ 4081 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 (backspace)
  36+ 4085 00 00 00 00
  37+ 4089 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  37+ 408D 00 00 00 00
  38+ 4091 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  38+ 4095 00 00 00 00
  39+ 4099 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11
  39+ 409D 00 00 00 00
  40+ 40A1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  40+ 40A5 00 00 00 00
  41+ 40A9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 (carriage return)
  41+ 40AD 00 00 00 00
  42+ 40B1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL
  42+ 40B5 00 00 00 00
  43+ 40B9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  43+ 40BD 00 00 00 00
  44+ 40C1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  44+ 40C5 00 00 00 00
  45+ 40C9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  45+ 40CD 00 00 00 00
  46+ 40D1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  46+ 40D5 00 00 00 00
  47+ 40D9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  47+ 40DD 00 00 00 00
  48+ 40E1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT
  48+ 40E5 00 00 00 00
  49+ 40E9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  49+ 40ED 00 00 00 00
  50+ 40F1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6
  50+ 40F5 00 00 00 00
  51+ 40F9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7
  51+ 40FD 00 00 00 00
  52+ 4101 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP
  52+ 4105 00 00 00 00
  53+ 4109 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 (home)
  53+ 410D 00 00 00 00
  54+ 4111 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26
  54+ 4115 00 00 00 00
  55+ 4119 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 (escape)
  55+ 411D 00 00 00 00
  56+ 4121 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 (cursor left)
  56+ 4125 00 00 00 00
  57+ 4129 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 (cursor right)
  57+ 412D 00 00 00 00
  58+ 4131 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 (cursor up)
  58+ 4135 00 00 00 00
  59+ 4139 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 (cursor down)
  59+ 413D 00 00 00 00
  60+ 4141 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32: space
  60+ 4145 00 00 00 00
  61+ 4149 20 20 20 20          defb $20,$20,$20,$20,$20,$00,$20,$00 ; char 33: !
  61+ 414D 20 00 20 00
  62+ 4151 50 50 00 00          defb $50,$50,$00,$00,$00,$00,$00,$00 ; char 34: "
  62+ 4155 00 00 00 00
  63+ 4159 50 50 F8 50          defb $50,$50,$f8,$50,$f8,$50,$50,$00 ; char 35: #
  63+ 415D F8 50 50 00
  64+ 4161 20 78 A0 70          defb $20,$78,$a0,$70,$28,$f0,$20,$00 ; char 36: $
  64+ 4165 28 F0 20 00
  65+ 4169 C0 C8 10 20          defb $c0,$c8,$10,$20,$40,$98,$18,$00 ; char 37: %
  65+ 416D 40 98 18 00
  66+ 4171 60 90 A0 40          defb $60,$90,$a0,$40,$a8,$90,$68,$00 ; char 38: &
  66+ 4175 A8 90 68 00
  67+ 4179 60 20 40 00          defb $60,$20,$40,$00,$00,$00,$00,$00 ; char 39: '
  67+ 417D 00 00 00 00
  68+ 4181 10 20 40 40          defb $10,$20,$40,$40,$40,$20,$10,$00 ; char 40: (
  68+ 4185 40 20 10 00
  69+ 4189 40 20 10 10          defb $40,$20,$10,$10,$10,$20,$40,$00 ; char 41: )
  69+ 418D 10 20 40 00
  70+ 4191 00 20 A8 70          defb $00,$20,$a8,$70,$a8,$20,$00,$00 ; char 42: *
  70+ 4195 A8 20 00 00
  71+ 4199 00 20 20 F8          defb $00,$20,$20,$f8,$20,$20,$00,$00 ; char 43: +
  71+ 419D 20 20 00 00
  72+ 41A1 00 00 00 00          defb $00,$00,$00,$00,$60,$20,$40,$00 ; char 44: ,
  72+ 41A5 60 20 40 00
  73+ 41A9 00 00 00 F8          defb $00,$00,$00,$f8,$00,$00,$00,$00 ; char 45: -
  73+ 41AD 00 00 00 00
  74+ 41B1 00 00 00 00          defb $00,$00,$00,$00,$00,$60,$60,$00 ; char 46: .
  74+ 41B5 00 60 60 00
  75+ 41B9 00 08 10 20          defb $00,$08,$10,$20,$40,$80,$00,$00 ; char 47: /
  75+ 41BD 40 80 00 00
  76+ 41C1 70 88 98 A8          defb $70,$88,$98,$a8,$c8,$88,$70,$00 ; char 48: 0
  76+ 41C5 C8 88 70 00
  77+ 41C9 20 60 20 20          defb $20,$60,$20,$20,$20,$20,$70,$00 ; char 49: 1
  77+ 41CD 20 20 70 00
  78+ 41D1 70 88 08 10          defb $70,$88,$08,$10,$20,$40,$f8,$00 ; char 50: 2
  78+ 41D5 20 40 F8 00
  79+ 41D9 F8 10 20 10          defb $f8,$10,$20,$10,$08,$88,$70,$00 ; char 51: 3
  79+ 41DD 08 88 70 00
  80+ 41E1 10 30 50 90          defb $10,$30,$50,$90,$f8,$10,$10,$00 ; char 52: 4
  80+ 41E5 F8 10 10 00
  81+ 41E9 F8 80 F0 08          defb $f8,$80,$f0,$08,$08,$88,$70,$00 ; char 53: 5
  81+ 41ED 08 88 70 00
  82+ 41F1 30 40 80 F0          defb $30,$40,$80,$f0,$88,$88,$70,$00 ; char 54: 6
  82+ 41F5 88 88 70 00
  83+ 41F9 F8 08 10 20          defb $f8,$08,$10,$20,$40,$40,$40,$00 ; char 55: 7
  83+ 41FD 40 40 40 00
  84+ 4201 70 88 88 70          defb $70,$88,$88,$70,$88,$88,$70,$00 ; char 56: 8
  84+ 4205 88 88 70 00
  85+ 4209 70 88 88 78          defb $70,$88,$88,$78,$08,$10,$60,$00 ; char 57: 9
  85+ 420D 08 10 60 00
  86+ 4211 00 30 30 00          defb $00,$30,$30,$00,$30,$30,$00,$00 ; char 58: :
  86+ 4215 30 30 00 00
  87+ 4219 00 30 30 00          defb $00,$30,$30,$00,$30,$10,$20,$00 ; char 59: ;
  87+ 421D 30 10 20 00
  88+ 4221 10 20 40 80          defb $10,$20,$40,$80,$40,$20,$10,$00 ; char 60: <
  88+ 4225 40 20 10 00
  89+ 4229 00 00 F8 00          defb $00,$00,$f8,$00,$f8,$00,$00,$00 ; char 61: =
  89+ 422D F8 00 00 00
  90+ 4231 40 20 10 08          defb $40,$20,$10,$08,$10,$20,$40,$00 ; char 62: >
  90+ 4235 10 20 40 00
  91+ 4239 70 88 08 10          defb $70,$88,$08,$10,$20,$00,$20,$00 ; char 63: ?
  91+ 423D 20 00 20 00
  92+ 4241 70 88 08 68          defb $70,$88,$08,$68,$a8,$a8,$70,$00 ; char 64: @
  92+ 4245 A8 A8 70 00
  93+ 4249 70 88 88 88          defb $70,$88,$88,$88,$f8,$88,$88,$00 ; char 65: A
  93+ 424D F8 88 88 00
  94+ 4251 F0 88 88 F0          defb $f0,$88,$88,$f0,$88,$88,$f0,$00 ; char 66: B
  94+ 4255 88 88 F0 00
  95+ 4259 70 88 80 80          defb $70,$88,$80,$80,$80,$88,$70,$00 ; char 67: C
  95+ 425D 80 88 70 00
  96+ 4261 E0 90 88 88          defb $e0,$90,$88,$88,$88,$90,$e0,$00 ; char 68: D
  96+ 4265 88 90 E0 00
  97+ 4269 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$f8,$00 ; char 69: E
  97+ 426D 80 80 F8 00
  98+ 4271 F8 80 80 F0          defb $f8,$80,$80,$f0,$80,$80,$80,$00 ; char 70: F
  98+ 4275 80 80 80 00
  99+ 4279 70 88 80 B8          defb $70,$88,$80,$b8,$88,$88,$78,$00 ; char 71: G
  99+ 427D 88 88 78 00
 100+ 4281 88 88 88 F8          defb $88,$88,$88,$f8,$88,$88,$88,$00 ; char 72: H
 100+ 4285 88 88 88 00
 101+ 4289 70 20 20 20          defb $70,$20,$20,$20,$20,$20,$70,$00 ; char 73: I
 101+ 428D 20 20 70 00
 102+ 4291 38 10 10 10          defb $38,$10,$10,$10,$10,$90,$60,$00 ; char 74: J
 102+ 4295 10 90 60 00
 103+ 4299 88 90 A0 C0          defb $88,$90,$a0,$c0,$a0,$90,$88,$00 ; char 75: K
 103+ 429D A0 90 88 00
 104+ 42A1 80 80 80 80          defb $80,$80,$80,$80,$80,$80,$f8,$00 ; char 76: L
 104+ 42A5 80 80 F8 00
 105+ 42A9 88 D8 A8 A8          defb $88,$d8,$a8,$a8,$88,$88,$88,$00 ; char 77: M
 105+ 42AD 88 88 88 00
 106+ 42B1 88 C8 A8 98          defb $88,$c8,$a8,$98,$88,$88,$88,$00 ; char 78: N
 106+ 42B5 88 88 88 00
 107+ 42B9 70 88 88 88          defb $70,$88,$88,$88,$88,$88,$70,$00 ; char 79: O
 107+ 42BD 88 88 70 00
 108+ 42C1 F0 88 88 F0          defb $f0,$88,$88,$f0,$80,$80,$80,$00 ; char 80: P
 108+ 42C5 80 80 80 00
 109+ 42C9 70 88 88 88          defb $70,$88,$88,$88,$a8,$90,$68,$00 ; char 81: Q
 109+ 42CD A8 90 68 00
 110+ 42D1 F0 88 88 F0          defb $f0,$88,$88,$f0,$a0,$90,$88,$00 ; char 82: R
 110+ 42D5 A0 90 88 00
 111+ 42D9 78 80 80 70          defb $78,$80,$80,$70,$08,$08,$f0,$00 ; char 83: S
 111+ 42DD 08 08 F0 00
 112+ 42E1 F8 20 20 20          defb $f8,$20,$20,$20,$20,$20,$20,$00 ; char 84: T
 112+ 42E5 20 20 20 00
 113+ 42E9 88 88 88 88          defb $88,$88,$88,$88,$88,$88,$70,$00 ; char 85: U
 113+ 42ED 88 88 70 00
 114+ 42F1 88 88 88 88          defb $88,$88,$88,$88,$88,$50,$20,$00 ; char 86: V
 114+ 42F5 88 50 20 00
 115+ 42F9 88 88 88 88          defb $88,$88,$88,$88,$a8,$a8,$50,$00 ; char 87: W
 115+ 42FD A8 A8 50 00
 116+ 4301 88 88 50 20          defb $88,$88,$50,$20,$50,$88,$88,$00 ; char 88: X
 116+ 4305 50 88 88 00
 117+ 4309 88 88 88 50          defb $88,$88,$88,$50,$20,$20,$20,$00 ; char 89: Y
 117+ 430D 20 20 20 00
 118+ 4311 F8 08 10 20          defb $f8,$08,$10,$20,$40,$80,$f8,$00 ; char 90: Z
 118+ 4315 40 80 F8 00
 119+ 4319 70 40 40 40          defb $70,$40,$40,$40,$40,$40,$70,$00 ; char 91: [
 119+ 431D 40 40 70 00
 120+ 4321 00 80 40 20          defb $00,$80,$40,$20,$10,$08,$00,$00 ; char 92: \
 120+ 4325 10 08 00 00
 121+ 4329 70 10 10 10          defb $70,$10,$10,$10,$10,$10,$70,$00 ; char 93: ]
 121+ 432D 10 10 70 00
 122+ 4331 20 50 88 00          defb $20,$50,$88,$00,$00,$00,$00,$00 ; char 94: ^
 122+ 4335 00 00 00 00
 123+ 4339 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$FC ; char 95: _ (underscore)
 123+ 433D 00 00 00 FC
 124+ 4341 40 20 10 00          defb $40,$20,$10,$00,$00,$00,$00,$00 ; char 96: `
 124+ 4345 00 00 00 00
 125+ 4349 00 00 70 08          defb $00,$00,$70,$08,$78,$88,$78,$00 ; char 97: a
 125+ 434D 78 88 78 00
 126+ 4351 80 80 80 B0          defb $80,$80,$80,$b0,$c8,$88,$f0,$00 ; char 98: b
 126+ 4355 C8 88 F0 00
 127+ 4359 00 00 70 80          defb $00,$00,$70,$80,$80,$88,$70,$00 ; char 99: c
 127+ 435D 80 88 70 00
 128+ 4361 08 08 08 68          defb $08,$08,$08,$68,$98,$88,$78,$00 ; char 100: d
 128+ 4365 98 88 78 00
 129+ 4369 00 00 70 88          defb $00,$00,$70,$88,$f8,$80,$70,$00 ; char 101: e
 129+ 436D F8 80 70 00
 130+ 4371 30 48 40 E0          defb $30,$48,$40,$e0,$40,$40,$40,$00 ; char 102: f
 130+ 4375 40 40 40 00
 131+ 4379 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$70,$00 ; char 103: g
 131+ 437D 78 08 70 00
 132+ 4381 80 80 B0 C8          defb $80,$80,$b0,$c8,$88,$88,$88,$00 ; char 104: h
 132+ 4385 88 88 88 00
 133+ 4389 20 00 20 20          defb $20,$00,$20,$20,$20,$20,$20,$00 ; char 105: i
 133+ 438D 20 20 20 00
 134+ 4391 08 00 18 08          defb $08,$00,$18,$08,$08,$88,$70,$00 ; char 106: j
 134+ 4395 08 88 70 00
 135+ 4399 80 80 90 A0          defb $80,$80,$90,$a0,$c0,$a0,$90,$00 ; char 107: k
 135+ 439D C0 A0 90 00
 136+ 43A1 60 20 20 20          defb $60,$20,$20,$20,$20,$20,$70,$00 ; char 108: l
 136+ 43A5 20 20 70 00
 137+ 43A9 00 00 D0 A8          defb $00,$00,$d0,$a8,$a8,$88,$88,$00 ; char 109: m
 137+ 43AD A8 88 88 00
 138+ 43B1 00 00 B0 C8          defb $00,$00,$b0,$c8,$88,$88,$88,$00 ; char 110: n
 138+ 43B5 88 88 88 00
 139+ 43B9 00 00 70 88          defb $00,$00,$70,$88,$88,$88,$70,$00 ; char 111: o
 139+ 43BD 88 88 70 00
 140+ 43C1 00 00 F0 88          defb $00,$00,$f0,$88,$f0,$80,$80,$00 ; char 112: p
 140+ 43C5 F0 80 80 00
 141+ 43C9 00 00 78 88          defb $00,$00,$78,$88,$78,$08,$08,$00 ; char 113: q
 141+ 43CD 78 08 08 00
 142+ 43D1 00 00 B0 C8          defb $00,$00,$b0,$c8,$80,$80,$80,$00 ; char 114: r
 142+ 43D5 80 80 80 00
 143+ 43D9 00 00 70 80          defb $00,$00,$70,$80,$70,$08,$f0,$00 ; char 115: s
 143+ 43DD 70 08 F0 00
 144+ 43E1 40 40 E0 40          defb $40,$40,$e0,$40,$40,$48,$30,$00 ; char 116: t
 144+ 43E5 40 48 30 00
 145+ 43E9 00 00 88 88          defb $00,$00,$88,$88,$88,$98,$68,$00 ; char 117: u
 145+ 43ED 88 98 68 00
 146+ 43F1 00 00 88 88          defb $00,$00,$88,$88,$88,$50,$20,$00 ; char 118: v
 146+ 43F5 88 50 20 00
 147+ 43F9 00 00 88 88          defb $00,$00,$88,$88,$a8,$a8,$50,$00 ; char 119: w
 147+ 43FD A8 A8 50 00
 148+ 4401 00 00 88 50          defb $00,$00,$88,$50,$20,$50,$88,$00 ; char 120: x
 148+ 4405 20 50 88 00
 149+ 4409 00 00 88 98          defb $00,$00,$88,$98,$68,$08,$70,$00 ; char 121: y
 149+ 440D 68 08 70 00
 150+ 4411 00 00 F8 10          defb $00,$00,$f8,$10,$20,$40,$f8,$00 ; char 122: z
 150+ 4415 20 40 F8 00
 151+ 4419 10 20 20 40          defb $10,$20,$20,$40,$20,$20,$10,$00 ; char 123: {
 151+ 441D 20 20 10 00
 152+ 4421 20 20 20 20          defb $20,$20,$20,$20,$20,$20,$20,$00 ; char 124: |
 152+ 4425 20 20 20 00
 153+ 4429 20 10 10 08          defb $20,$10,$10,$08,$10,$10,$20,$00 ; char 125: }
 153+ 442D 10 10 20 00
 154+ 4431 00 28 50 00          defb $00,$28,$50,$00,$00,$00,$00,$00 ; char 126: ~
 154+ 4435 00 00 00 00
 155+ 4439 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 127: (delete) - here end the standard ASCII (0-127)
 155+ 443D 00 00 00 00
 156+ 4441 78 84 CC 84          defb %01111000,%10000100,%11001100,%10000100,%10110100,%10000100,%01111000,%00000000 ; char 128 (open face)
 156+ 4445 B4 84 78 00
 157+ 4449 78 FC B4 FC          defb %01111000,%11111100,%10110100,%11111100,%10110100,%11001100,%01111000,%00000000 ; char 129 (full face)
 157+ 444D B4 CC 78 00
 158+ 4451 48 FC FC FC          defb %01001000,%11111100,%11111100,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 130 (hearts)
 158+ 4455 FC 78 30 00
 159+ 4459 00 20 70 F8          defb %00000000,%00100000,%01110000,%11111000,%11111000,%01110000,%00100000,%00000000 ; char 131 (diamonds)
 159+ 445D F8 70 20 00
 160+ 4461 70 20 A8 F8          defb %01110000,%00100000,%10101000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 132 (clubs)
 160+ 4465 A8 20 70 00
 161+ 4469 20 70 F8 F8          defb %00100000,%01110000,%11111000,%11111000,%10101000,%00100000,%01110000,%00000000 ; char 133 (spades)
 161+ 446D A8 20 70 00
 162+ 4471 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 134
 162+ 4475 FC 30 30 30
 163+ 4479 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 135
 163+ 447D 3C 30 30 30
 164+ 4481 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 136
 164+ 4485 F0 30 30 30
 165+ 4489 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00000000,%00000000,%00000000 ; char 137
 165+ 448D F0 00 00 00
 166+ 4491 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00000000,%00000000,%00000000 ; char 138
 166+ 4495 3C 00 00 00
 167+ 4499 30 30 30 FC          defb %00110000,%00110000,%00110000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 139
 167+ 449D FC 00 00 00
 168+ 44A1 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00111100,%00110000,%00110000,%00110000 ; char 140
 168+ 44A5 3C 30 30 30
 169+ 44A9 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00110000,%00110000,%00110000 ; char 141
 169+ 44AD FC 30 30 30
 170+ 44B1 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11110000,%00110000,%00110000,%00110000 ; char 142
 170+ 44B5 F0 30 30 30
 171+ 44B9 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%11111100,%00000000,%00000000,%00000000 ; char 143
 171+ 44BD FC 00 00 00
 172+ 44C1 30 30 30 30          defb %00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000,%00110000 ; char 144
 172+ 44C5 30 30 30 30
 173+ 44C9 0C 1C 18 38          defb %00001100,%00011100,%00011000,%00111000,%01110000,%01100000,%11100000,%11000000 ; char 145
 173+ 44CD 70 60 E0 C0
 174+ 44D1 C0 E0 60 70          defb %11000000,%11100000,%01100000,%01110000,%00111000,%00011000,%00011100,%00001100 ; char 146
 174+ 44D5 38 18 1C 0C
 175+ 44D9 CC CC 78 30          defb %11001100,%11001100,%01111000,%00110000,%00110000,%01111000,%11001100,%11001100 ; char 147
 175+ 44DD 30 78 CC CC
 176+ 44E1 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 148
 176+ 44E5 20 20 20 20
 177+ 44E9 00 00 00 3C          defb %00000000,%00000000,%00000000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 149
 177+ 44ED 20 20 20 20
 178+ 44F1 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 150
 178+ 44F5 20 20 20 20
 179+ 44F9 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 151
 179+ 44FD 00 00 00 00
 180+ 4501 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00000000,%00000000,%00000000,%00000000 ; char 152
 180+ 4505 00 00 00 00
 181+ 4509 20 20 20 FC          defb %00100000,%00100000,%00100000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 153
 181+ 450D 00 00 00 00
 182+ 4511 20 20 20 3C          defb %00100000,%00100000,%00100000,%00111100,%00100000,%00100000,%00100000,%00100000 ; char 154
 182+ 4515 20 20 20 20
 183+ 4519 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00100000,%00100000,%00100000,%00100000 ; char 155
 183+ 451D 20 20 20 20
 184+ 4521 20 20 20 E0          defb %00100000,%00100000,%00100000,%11100000,%00100000,%00100000,%00100000,%00100000 ; char 156
 184+ 4525 20 20 20 20
 185+ 4529 00 00 00 FC          defb %00000000,%00000000,%00000000,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 157
 185+ 452D 00 00 00 00
 186+ 4531 20 20 20 20          defb %00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000,%00100000 ; char 158
 186+ 4535 20 20 20 20
 187+ 4539 04 08 08 10          defb %00000100,%00001000,%00001000,%00010000,%00100000,%01000000,%01000000,%10000000 ; char 159
 187+ 453D 20 40 40 80
 188+ 4541 80 40 40 20          defb %10000000,%01000000,%01000000,%00100000,%00010000,%00001000,%00001000,%00000100 ; char 160
 188+ 4545 10 08 08 04
 189+ 4549 84 48 48 30          defb %10000100,%01001000,%01001000,%00110000,%00110000,%01001000,%01001000,%10000100 ; char 161
 189+ 454D 30 48 48 84
 190+ 4551 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 162
 190+ 4555 00 00 FC FC
 191+ 4559 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111100,%11111100,%11111100,%11111100 ; char 163
 191+ 455D FC FC FC FC
 192+ 4561 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 164
 192+ 4565 FC FC FC FC
 193+ 4569 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 193+ 456D 00 00 00 00
 194+ 4571 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%00000000,%00000000,%00000000,%00000000 ; char 166
 194+ 4575 00 00 00 00
 195+ 4579 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 167
 195+ 457D FC FC 00 00
 196+ 4581 80 80 80 80          defb %10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000,%10000000 ; char 168
 196+ 4585 80 80 80 80
 197+ 4589 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000,%11100000 ; char 169
 197+ 458D E0 E0 E0 E0
 198+ 4591 F8 F8 F8 F8          defb %11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000,%11111000 ; char 170
 198+ 4595 F8 F8 F8 F8
 199+ 4599 04 04 04 04          defb %00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100,%00000100 ; char 171
 199+ 459D 04 04 04 04
 200+ 45A1 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100,%00011100 ; char 172
 200+ 45A5 1C 1C 1C 1C
 201+ 45A9 7C 7C 7C 7C          defb %01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100,%01111100 ; char 173
 201+ 45AD 7C 7C 7C 7C
 202+ 45B1 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 174
 202+ 45B5 84 84 84 FC
 203+ 45B9 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%11100000,%11100000,%11100000 ; char 175
 203+ 45BD E0 E0 E0 E0
 204+ 45C1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00011100,%00011100,%00011100 ; char 176
 204+ 45C5 1C 1C 1C 1C
 205+ 45C9 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 177
 205+ 45CD 00 00 00 00
 206+ 45D1 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 178
 206+ 45D5 00 00 00 00
 207+ 45D9 E0 E0 E0 E0          defb %11100000,%11100000,%11100000,%11100000,%00011100,%00011100,%00011100,%00011100 ; char 179
 207+ 45DD 1C 1C 1C 1C
 208+ 45E1 1C 1C 1C 1C          defb %00011100,%00011100,%00011100,%00011100,%11100000,%11100000,%11100000,%11100000 ; char 180
 208+ 45E5 E0 E0 E0 E0
 209+ 45E9 78 78 78 78          defb %01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000,%01111000 ; char 181
 209+ 45ED 78 78 78 78
 210+ 45F1 CC CC CC CC          defb %11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100,%11001100 ; char 182
 210+ 45F5 CC CC CC CC
 211+ 45F9 FC FC 00 00          defb %11111100,%11111100,%00000000,%00000000,%00000000,%00000000,%11111100,%11111100 ; char 183
 211+ 45FD 00 00 FC FC
 212+ 4601 00 00 FC FC          defb %00000000,%00000000,%11111100,%11111100,%11111100,%11111100,%00000000,%00000000 ; char 184
 212+ 4605 FC FC 00 00
 213+ 4609 30 30 CC CC          defb %00110000,%00110000,%11001100,%11001100,%00110000,%00110000,%11001100,%11001100 ; char 185
 213+ 460D 30 30 CC CC
 214+ 4611 54 A8 54 A8          defb %01010100,%10101000,%01010100,%10101000,%01010100,%10101000,%01010100,%10101000 ; char 186
 214+ 4615 54 A8 54 A8
 215+ 4619 64 30 98 CC          defb %01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100 ; char 187
 215+ 461D 64 30 98 CC
 216+ 4621 CC 64 30 98          defb %11001100,%01100100,%00110000,%10011000,%11001100,%01100100,%00110000,%10011000 ; char 188
 216+ 4625 CC 64 30 98
 217+ 4629 30 98 CC 64          defb %00110000,%10011000,%11001100,%01100100,%00110000,%10011000,%11001100,%01100100 ; char 189
 217+ 462D 30 98 CC 64
 218+ 4631 64 CC 98 30          defb %01100100,%11001100,%10011000,%00110000,%01100100,%11001100,%10011000,%00110000 ; char 190
 218+ 4635 64 CC 98 30
 219+ 4639 20 20 F8 20          defb %00100000,%00100000,%11111000,%00100000,%00100000,%00000000,%11111000,%00000000 ; char 191 (Â±)
 219+ 463D 20 00 F8 00
 220+ 4641 C0 30 08 30          defb %11000000,%00110000,%00001000,%00110000,%11000000,%00000000,%11111000,%00000000 ; char 192 (â¥)
 220+ 4645 C0 00 F8 00
 221+ 4649 18 60 80 60          defb %00011000,%01100000,%10000000,%01100000,%00011000,%00000000,%11111000,%00000000 ; char 193 (â¤)
 221+ 464D 18 00 F8 00
 222+ 4651 3C 20 20 20          defb %00111100,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 222+ 4655 A0 60 20 00
 223+ 4659 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 223+ 465D 00 00 00 00
 224+ 4661 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 224+ 4665 70 00 00 00
 225+ 4669 00 00 54 A8          defb %00000000,%00000000,%01010100,%10101000,%00000000,%11111100,%00000000,%00000000 ; char 197
 225+ 466D 00 FC 00 00
 226+ 4671 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 226+ 4675 54 A8 00 00
 227+ 4679 00 80 C0 E0          defb %00000000,%10000000,%11000000,%11100000,%11100000,%11000000,%10000000,%00000000 ; char 199
 227+ 467D E0 C0 80 00
 228+ 4681 FC 78 30 00          defb %11111100,%01111000,%00110000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 200
 228+ 4685 00 00 00 00
 229+ 4689 00 04 0C 1C          defb %00000000,%00000100,%00001100,%00011100,%00011100,%00001100,%00000100,%00000000 ; char 201
 229+ 468D 1C 0C 04 00
 230+ 4691 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00110000,%01111000,%11111100 ; char 202
 230+ 4695 00 30 78 FC
 231+ 4699 20 70 F8 20          defb %00100000,%01110000,%11111000,%00100000,%00100000,%00100000,%00100000,%00000000 ; char 203 (up arrow)
 231+ 469D 20 20 20 00
 232+ 46A1 3C 1C 1C 24          defb %00111100,%00011100,%00011100,%00100100,%01000000,%10000000,%00000000,%00000000 ; char 204 (up right arrow)
 232+ 46A5 40 80 00 00
 233+ 46A9 00 10 18 FC          defb %00000000,%00010000,%00011000,%11111100,%00011000,%00010000,%00000000,%00000000 ; char 205 (right arrow)
 233+ 46AD 18 10 00 00
 234+ 46B1 00 00 80 40          defb %00000000,%00000000,%10000000,%01000000,%00100100,%00011100,%00011100,%00111100 ; char 206 (down right arrow)
 234+ 46B5 24 1C 1C 3C
 235+ 46B9 00 20 20 20          defb %00000000,%00100000,%00100000,%00100000,%00100000,%11111000,%01110000,%00100000 ; char 207 (down arrow)
 235+ 46BD 20 F8 70 20
 236+ 46C1 00 00 04 08          defb %00000000,%00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000 ; char 208 (down left arrow)
 236+ 46C5 90 E0 E0 F0
 237+ 46C9 00 20 60 FC          defb %00000000,%00100000,%01100000,%11111100,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 237+ 46CD 60 20 00 00
 238+ 46D1 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 238+ 46D5 08 04 00 00
 239+ 46D9 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 239+ 46DD F0 44 38 00
 240+ 46E1 00 04 78 A8          defb %00000000,%00000100,%01111000,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 240+ 46E5 28 28 28 00
 241+ 46E9 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00011100,%00100000,%00100000,%00100000 ; char 213
 241+ 46ED 1C 20 20 20
 242+ 46F1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11100000,%00010000,%00010000,%00010000 ; char 214
 242+ 46F5 E0 10 10 10
 243+ 46F9 10 10 10 E0          defb %00010000,%00010000,%00010000,%11100000,%00000000,%00000000,%00000000,%00000000 ; char 215
 243+ 46FD 00 00 00 00
 244+ 4701 20 20 20 1C          defb %00100000,%00100000,%00100000,%00011100,%00000000,%00000000,%00000000,%00000000 ; char 216
 244+ 4705 00 00 00 00
 245+ 4709 00 00 00 1C          defb %00000000,%00000000,%00000000,%00011100,%00111100,%00110000,%00110000,%00110000 ; char 217
 245+ 470D 3C 30 30 30
 246+ 4711 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00110000,%00110000,%00110000 ; char 218
 246+ 4715 F0 30 30 30
 247+ 4719 30 30 30 F0          defb %00110000,%00110000,%00110000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 247+ 471D E0 00 00 00
 248+ 4721 30 30 30 3C          defb %00110000,%00110000,%00110000,%00111100,%00011100,%00000000,%00000000,%00000000 ; char 220
 248+ 4725 1C 00 00 00
 249+ 4729 00 30 48 48          defb %00000000,%00110000,%01001000,%01001000,%01001000,%00110000,%00000000,%00000000 ; char 221
 249+ 472D 48 30 00 00
 250+ 4731 00 30 78 78          defb %00000000,%00110000,%01111000,%01111000,%01111000,%00110000,%00000000,%00000000 ; char 222
 250+ 4735 78 30 00 00
 251+ 4739 00 30 78 FC          defb %00000000,%00110000,%01111000,%11111100,%11111100,%01111000,%00110000,%00000000 ; char 223
 251+ 473D FC 78 30 00
 252+ 4741 FC F8 F0 E0          defb %11111100,%11111000,%11110000,%11100000,%11100000,%11000000,%10000000,%10000000 ; char 224
 252+ 4745 E0 C0 80 80
 253+ 4749 FC 7C 3C 1C          defb %11111100,%01111100,%00111100,%00011100,%00011100,%00001100,%00000100,%00000100 ; char 225
 253+ 474D 1C 0C 04 04
 254+ 4751 04 04 0C 1C          defb %00000100,%00000100,%00001100,%00011100,%00011100,%00111100,%01111100,%11111100 ; char 226
 254+ 4755 1C 3C 7C FC
 255+ 4759 80 80 C0 E0          defb %10000000,%10000000,%11000000,%11100000,%11100000,%11110000,%11111000,%11111100 ; char 227
 255+ 475D E0 F0 F8 FC
 256+ 4761 00 04 0C D8          defb %00000000,%00000100,%00001100,%11011000,%11110000,%11100000,%11000000,%00000000 ; char 228 (checkmark)
 256+ 4765 F0 E0 C0 00
 257+ 4769 00 CC 78 30          defb %00000000,%11001100,%01111000,%00110000,%01111000,%11001100,%00000000,%00000000 ; char 229 (x)
 257+ 476D 78 CC 00 00
 258+ 4771 70 88 88 88          defb %01110000,%10001000,%10001000,%10001000,%01110000,%00100000,%01110000,%00100000 ; char 230 (female)
 258+ 4775 70 20 70 20
 259+ 4779 00 1C 0C 74          defb %00000000,%00011100,%00001100,%01110100,%10010000,%10010000,%01100000,%00000000 ; char 231 (male)
 259+ 477D 90 90 60 00
 260+ 4781 F8 84 84 84          defb %11111000,%10000100,%10000100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 232 (new doc)
 260+ 4785 84 84 84 FC
 261+ 4789 00 F0 FC 84          defb %00000000,%11110000,%11111100,%10000100,%10000100,%10000100,%10000100,%11111100 ; char 233 (folder)
 261+ 478D 84 84 84 FC
 262+ 4791 30 78 FC 48          defb %00110000,%01111000,%11111100,%01001000,%01001000,%01001000,%01001000,%01111000 ; char 234 (trash bin)
 262+ 4795 48 48 48 78
 263+ 4799 FC 84 84 84          defb %11111100,%10000100,%10000100,%10000100,%11111100,%10110100,%10110100,%11111100 ; char 235 (floppy disk)
 263+ 479D FC B4 B4 FC
 264+ 47A1 00 00 D4 D8          defb %00000000,%00000000,%11010100,%11011000,%11010100,%11010100,%00000000,%00000000 ; char 236 (OK)
 264+ 47A5 D4 D4 00 00
 265+ 47A9 30 78 FC 78          defb %00110000,%01111000,%11111100,%01111000,%01111000,%01001000,%01001000,%01001000 ; char 237 (home)
 265+ 47AD 78 48 48 48
 266+ 47B1 78 84 A4 A4          defb %01111000,%10000100,%10100100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 238 (clock)
 266+ 47B5 B4 84 78 00
 267+ 47B9 00 00 08 F4          defb %00000000,%00000000,%00001000,%11110100,%10101000,%10000000,%00000000,%00000000 ; char 239 (key)
 267+ 47BD A8 80 00 00
 268+ 47C1 20 30 78 B0          defb %00100000,%00110000,%01111000,%10110000,%10100000,%10001000,%01110000,%00000000 ; char 240 (undo)
 268+ 47C5 A0 88 70 00
 269+ 47C9 00 FC CC B4          defb %00000000,%11111100,%11001100,%10110100,%10000100,%10000100,%11111100,%00000000 ; char 241 (letter)
 269+ 47CD 84 84 FC 00
 270+ 47D1 60 90 90 F0          defb %01100000,%10010000,%10010000,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 242 (lock)
 270+ 47D5 F0 F0 F0 00
 271+ 47D9 08 14 14 F0          defb %00001000,%00010100,%00010100,%11110000,%11110000,%11110000,%11110000,%00000000 ; char 243 (unlock)
 271+ 47DD F0 F0 F0 00
 272+ 47E1 FC FC 84 B4          defb %11111100,%11111100,%10000100,%10110100,%10010100,%10010100,%10000100,%11111100 ; char 244 (calendar)
 272+ 47E5 94 94 84 FC
 273+ 47E9 00 04 38 58          defb %00000000,%00000100,%00111000,%01011000,%01101000,%01110000,%10000000,%00000000 ; char 245 (diameter)
 273+ 47ED 68 70 80 00
 274+ 47F1 78 84 84 84          defb %01111000,%10000100,%10000100,%10000100,%01101100,%00011000,%00001000,%00000000 ; char 246 (baloon)
 274+ 47F5 6C 18 08 00
 275+ 47F9 30 28 28 28          defb %00110000,%00101000,%00101000,%00101000,%00100000,%01100000,%11100000,%01000000 ; char 247 (note)
 275+ 47FD 20 60 E0 40
 276+ 4801 20 68 E4 E4          defb %00100000,%01101000,%11100100,%11100100,%11100100,%01101000,%00100000,%00000000 ; char 248 (audio on)
 276+ 4805 E4 68 20 00
 277+ 4809 20 60 E0 E0          defb %00100000,%01100000,%11100000,%11100000,%11100000,%01100000,%00100000,%00000000 ; char 249 (audio off)
 277+ 480D E0 60 20 00
 278+ 4811 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11110000,%10010000 ; char 250 (pointer)
 278+ 4815 F8 FC F0 90
 279+ 4819 78 84 B4 A4          defb %01111000,%10000100,%10110100,%10100100,%10110100,%10000100,%01111000,%00000000 ; char 251 (Â©)
 279+ 481D B4 84 78 00
 280+ 4821 30 48 40 E0          defb %00110000,%01001000,%01000000,%11100000,%01000000,%01001000,%10110000,%00000000 ; char 252 (Â£)
 280+ 4825 40 48 B0 00
 281+ 4829 78 84 F0 48          defb %01111000,%10000100,%11110000,%01001000,%01001000,%00111100,%10000100,%01111000 ; char 253 (Â§)
 281+ 482D 48 3C 84 78
 282+ 4831 00 00 20 00          defb %00000000,%00000000,%00100000,%00000000,%11111000,%00000000,%00100000,%00000000 ; char 254 (Ã·)
 282+ 4835 F8 00 20 00
 283+ 4839 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 255 (cursor)
 283+ 483D FC FC FC FC
 284+ 4841                      ; here ends the ASCII table
 285+ 4841
# file closed: ../include/vdp/6x8fonts-r16.asm
  85  4841                  INCLUDE "../include/vdp/8x8fonts-r18.asm"
# file opened: ../include/vdp/8x8fonts-r18.asm
   1+ 4841              ; ------------------------------------------------------------------------------
   2+ 4841              ; LM80C - 8x8 CHARSET - R1.8
   3+ 4841              ; ------------------------------------------------------------------------------
   4+ 4841              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 4841              ; designed by Leonardo Miliani. More info at
   6+ 4841              ; www DOT leonardomiliani DOT com
   7+ 4841              ; ------------------------------------------------------------------------------
   8+ 4841              ; Code Revision:
   9+ 4841              ; R1.0 - 20190615 - First revision: ASCII chars (from 0 to 255) - actually, they are 6x8 pixels
  10+ 4841              ; R1.1 - 20190616 - Converted to 8x8 pixels
  11+ 4841              ; R1.2 - 20191013 - Added new graphic chars and reorganized previous ones
  12+ 4841              ; R1.3 - 20191015 - More graphic chars
  13+ 4841              ; R1.4 - 20191202 - Fixed char 11/12, added new special chars
  14+ 4841              ; R1.5 - 20191210 - Changed several graphic chars
  15+ 4841              ; R1.6 - 20200125 - Removed double chars, changed with new ones
  16+ 4841              ; R1.7 - 20200228 - adopted more usual hexadecimal & binary prefixes
  17+ 4841              ; R1.8 - 20200524 - New style for char #252
  18+ 4841              ; ------------------------------------------------------------------------------
  19+ 4841              ;
  20+ 4841              ;-------------------------------------------------------------------------------
  21+ 4841              ;
  22+ 4841              ;               8 x 8    C  H  A  R  S  E  T
  23+ 4841              ;
  24+ 4841              ;-------------------------------------------------------------------------------
  25+ 4841              ;
  26+ 4841              ;       8X8 CHARS, DESIGNED FOR GRAPHICS 1 MODE
  27+ 4841
  28+ 4841              CHRST88 equ $
  29+ 4841 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 0 (null char)
  29+ 4845 00 00 00 00
  30+ 4849 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 1 F1
  30+ 484D 00 00 00 00
  31+ 4851 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 2 F2
  31+ 4855 00 00 00 00
  32+ 4859 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 3 CTRL-C
  32+ 485D 00 00 00 00
  33+ 4861 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 4 F3
  33+ 4865 00 00 00 00
  34+ 4869 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 5 F4
  34+ 486D 00 00 00 00
  35+ 4871 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 6 F5
  35+ 4875 00 00 00 00
  36+ 4879 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 7 (bell)
  36+ 487D 00 00 00 00
  37+ 4881 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 8 DEL key (backspace)
  37+ 4885 00 00 00 00
  38+ 4889 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 9 (H. tab)
  38+ 488D 00 00 00 00
  39+ 4891 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 10 (line feed)
  39+ 4895 00 00 00 00
  40+ 4899 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 11 (unused)
  40+ 489D 00 00 00 00
  41+ 48A1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 12 Form feed (clear screen)
  41+ 48A5 00 00 00 00
  42+ 48A9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 13 RETURN key (carriage return)
  42+ 48AD 00 00 00 00
  43+ 48B1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 14 CTRL key
  43+ 48B5 00 00 00 00
  44+ 48B9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 15 CTRL-O
  44+ 48BD 00 00 00 00
  45+ 48C1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 16 C=/Graphic key
  45+ 48C5 00 00 00 00
  46+ 48C9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 17 CTRL-Q
  46+ 48CD 00 00 00 00
  47+ 48D1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 18 CTRL-R
  47+ 48D5 00 00 00 00
  48+ 48D9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 19 CTRL-S
  48+ 48DD 00 00 00 00
  49+ 48E1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 20 SHIFT key
  49+ 48E5 00 00 00 00
  50+ 48E9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 21 CTRL-U
  50+ 48ED 00 00 00 00
  51+ 48F1 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 22 F6 key
  51+ 48F5 00 00 00 00
  52+ 48F9 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 23 F7 key
  52+ 48FD 00 00 00 00
  53+ 4901 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 24 HELP key
  53+ 4905 00 00 00 00
  54+ 4909 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 25 HOME key
  54+ 490D 00 00 00 00
  55+ 4911 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 26 INSERT key
  55+ 4915 00 00 00 00
  56+ 4919 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 27 ESCAPE key
  56+ 491D 00 00 00 00
  57+ 4921 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 28 CRSR LEFT key (cursor left)
  57+ 4925 00 00 00 00
  58+ 4929 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 29 CRSR RIGHT key (cursor right)
  58+ 492D 00 00 00 00
  59+ 4931 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 30 CRSR UP key (cursor up)
  59+ 4935 00 00 00 00
  60+ 4939 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 31 CRSR DOWN key (cursor down)
  60+ 493D 00 00 00 00
  61+ 4941 00 00 00 00          defb $00,$00,$00,$00,$00,$00,$00,$00 ; char 32 SPACE key
  61+ 4945 00 00 00 00
  62+ 4949 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00000000,%00010000,%00000000 ; char 33 - !
  62+ 494D 10 00 10 00
  63+ 4951 28 28 28 00          defb %00101000,%00101000,%00101000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 34 - "
  63+ 4955 00 00 00 00
  64+ 4959 28 28 FE 28          defb %00101000,%00101000,%11111110,%00101000,%11111110,%00101000,%00101000,%00000000 ; char 35 - #
  64+ 495D FE 28 28 00
  65+ 4961 10 3C 50 38          defb %00010000,%00111100,%01010000,%00111000,%00010100,%01111000,%00010000,%00000000 ; char 36 - $
  65+ 4965 14 78 10 00
  66+ 4969 00 62 64 08          defb %00000000,%01100010,%01100100,%00001000,%00010000,%00100110,%01000110,%00000000 ; char 37 - %
  66+ 496D 10 26 46 00
  67+ 4971 00 30 48 30          defb %00000000,%00110000,%01001000,%00110000,%01001010,%01000100,%00111010,%00000000 ; char 38 - &
  67+ 4975 4A 44 3A 00
  68+ 4979 08 10 20 00          defb %00001000,%00010000,%00100000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 39 - '
  68+ 497D 00 00 00 00
  69+ 4981 08 10 20 20          defb %00001000,%00010000,%00100000,%00100000,%00100000,%00010000,%00001000,%00000000 ; char 40 - (
  69+ 4985 20 10 08 00
  70+ 4989 20 10 08 08          defb %00100000,%00010000,%00001000,%00001000,%00001000,%00010000,%00100000,%00000000 ; char 41 - )
  70+ 498D 08 10 20 00
  71+ 4991 00 10 54 38          defb %00000000,%00010000,%01010100,%00111000,%00111000,%01010100,%00010000,%00000000 ; char 42 - *
  71+ 4995 38 54 10 00
  72+ 4999 00 10 10 7C          defb %00000000,%00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%00000000 ; char 43 - +
  72+ 499D 10 10 00 00
  73+ 49A1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00001000,%00010000 ; char 44 - ,
  73+ 49A5 00 18 08 10
  74+ 49A9 00 00 00 7C          defb %00000000,%00000000,%00000000,%01111100,%00000000,%00000000,%00000000,%00000000 ; char 45 - -
  74+ 49AD 00 00 00 00
  75+ 49B1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00011000,%00011000,%00000000 ; char 46 - .
  75+ 49B5 00 18 18 00
  76+ 49B9 00 02 04 08          defb %00000000,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%00000000 ; char 47 - /
  76+ 49BD 10 20 40 00
  77+ 49C1 38 44 4C 54          defb %00111000,%01000100,%01001100,%01010100,%01100100,%01000100,%00111000,%00000000 ; char 48 - 0
  77+ 49C5 64 44 38 00
  78+ 49C9 10 30 50 10          defb %00010000,%00110000,%01010000,%00010000,%00010000,%00010000,%01111100,%00000000 ; char 49 - 1
  78+ 49CD 10 10 7C 00
  79+ 49D1 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 50 - 2
  79+ 49D5 10 20 7C 00
  80+ 49D9 7C 08 10 08          defb %01111100,%00001000,%00010000,%00001000,%00000100,%01000100,%00111000,%00000000 ; char 51 - 3
  80+ 49DD 04 44 38 00
  81+ 49E1 08 18 28 48          defb %00001000,%00011000,%00101000,%01001000,%01111100,%00001000,%00001000,%00000000 ; char 52 - 4
  81+ 49E5 7C 08 08 00
  82+ 49E9 7C 40 78 04          defb %01111100,%01000000,%01111000,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 53 - 5
  82+ 49ED 04 44 38 00
  83+ 49F1 38 44 40 78          defb %00111000,%01000100,%01000000,%01111000,%01000100,%01000100,%00111000,%00000000 ; char 54 - 6
  83+ 49F5 44 44 38 00
  84+ 49F9 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%00100000,%00100000,%00000000 ; char 55 - 7
  84+ 49FD 20 20 20 00
  85+ 4A01 38 44 44 38          defb %00111000,%01000100,%01000100,%00111000,%01000100,%01000100,%00111000,%00000000 ; char 56 - 8
  85+ 4A05 44 44 38 00
  86+ 4A09 38 44 44 3C          defb %00111000,%01000100,%01000100,%00111100,%00000100,%01000100,%00111000,%00000000 ; char 57 - 9
  86+ 4A0D 04 44 38 00
  87+ 4A11 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00011000,%00000000,%00000000 ; char 58 - :
  87+ 4A15 18 18 00 00
  88+ 4A19 00 18 18 00          defb %00000000,%00011000,%00011000,%00000000,%00011000,%00001000,%00010000,%00000000 ; char 59 - ;
  88+ 4A1D 18 08 10 00
  89+ 4A21 04 08 10 20          defb %00000100,%00001000,%00010000,%00100000,%00010000,%00001000,%00000100,%00000000 ; char 60 - <
  89+ 4A25 10 08 04 00
  90+ 4A29 00 00 7E 00          defb %00000000,%00000000,%01111110,%00000000,%01111110,%00000000,%00000000,%00000000 ; char 61 - =
  90+ 4A2D 7E 00 00 00
  91+ 4A31 20 10 08 04          defb %00100000,%00010000,%00001000,%00000100,%00001000,%00010000,%00100000,%00000000 ; char 62 - >
  91+ 4A35 08 10 20 00
  92+ 4A39 38 44 04 08          defb %00111000,%01000100,%00000100,%00001000,%00010000,%00000000,%00010000,%00000000 ; char 63 - ?
  92+ 4A3D 10 00 10 00
  93+ 4A41 78 84 BC AC          defb %01111000,%10000100,%10111100,%10101100,%10111000,%10000000,%10000100,%01111000 ; char 64 - @
  93+ 4A45 B8 80 84 78
  94+ 4A49 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%00000000 ; char 65 - A
  94+ 4A4D 7C 44 44 00
  95+ 4A51 78 44 44 78          defb %01111000,%01000100,%01000100,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 66 - B
  95+ 4A55 44 44 78 00
  96+ 4A59 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 67 - C
  96+ 4A5D 40 44 38 00
  97+ 4A61 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01000100,%01000100,%01111000,%00000000 ; char 68 - D
  97+ 4A65 44 44 78 00
  98+ 4A69 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01111100,%00000000 ; char 69 - E
  98+ 4A6D 40 40 7C 00
  99+ 4A71 7C 40 40 70          defb %01111100,%01000000,%01000000,%01110000,%01000000,%01000000,%01000000,%00000000 ; char 70 - F
  99+ 4A75 40 40 40 00
 100+ 4A79 38 44 40 40          defb %00111000,%01000100,%01000000,%01000000,%01011100,%01000100,%00111000,%00000000 ; char 71 - G
 100+ 4A7D 5C 44 38 00
 101+ 4A81 44 44 44 7C          defb %01000100,%01000100,%01000100,%01111100,%01000100,%01000100,%01000100,%00000000 ; char 72 - H
 101+ 4A85 44 44 44 00
 102+ 4A89 38 10 10 10          defb %00111000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 73 - I
 102+ 4A8D 10 10 38 00
 103+ 4A91 3C 04 04 04          defb %00111100,%00000100,%00000100,%00000100,%00000100,%01000100,%00111000,%00000000 ; char 74 - J
 103+ 4A95 04 44 38 00
 104+ 4A99 44 44 48 70          defb %01000100,%01000100,%01001000,%01110000,%01001000,%01000100,%01000100,%00000000 ; char 75 - K
 104+ 4A9D 48 44 44 00
 105+ 4AA1 40 40 40 40          defb %01000000,%01000000,%01000000,%01000000,%01000000,%01000000,%01111100,%00000000 ; char 76 - L
 105+ 4AA5 40 40 7C 00
 106+ 4AA9 42 66 5A 42          defb %01000010,%01100110,%01011010,%01000010,%01000010,%01000010,%01000010,%00000000 ; char 77 - M
 106+ 4AAD 42 42 42 00
 107+ 4AB1 44 64 54 4C          defb %01000100,%01100100,%01010100,%01001100,%01000100,%01000100,%01000100,%00000000 ; char 78 - N
 107+ 4AB5 44 44 44 00
 108+ 4AB9 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 79 - O
 108+ 4ABD 44 44 38 00
 109+ 4AC1 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01000000,%01000000,%00000000 ; char 80 - P
 109+ 4AC5 78 40 40 00
 110+ 4AC9 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%01010100,%01001000,%00110100,%00000000 ; char 81 - Q
 110+ 4ACD 54 48 34 00
 111+ 4AD1 78 44 44 44          defb %01111000,%01000100,%01000100,%01000100,%01111000,%01001000,%01000100,%00000000 ; char 82 - R
 111+ 4AD5 78 48 44 00
 112+ 4AD9 3C 40 40 38          defb %00111100,%01000000,%01000000,%00111000,%00000100,%00000100,%01111000,%00000000 ; char 83 - S
 112+ 4ADD 04 04 78 00
 113+ 4AE1 7C 10 10 10          defb %01111100,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 84 - T
 113+ 4AE5 10 10 10 00
 114+ 4AE9 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 85 - U
 114+ 4AED 44 44 38 00
 115+ 4AF1 44 44 44 44          defb %01000100,%01000100,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 86 - V
 115+ 4AF5 44 28 10 00
 116+ 4AF9 42 42 42 42          defb %01000010,%01000010,%01000010,%01000010,%01011010,%01011010,%00100100,%00000000 ; char 87 - W
 116+ 4AFD 5A 5A 24 00
 117+ 4B01 44 44 28 10          defb %01000100,%01000100,%00101000,%00010000,%00101000,%01000100,%01000100,%00000000 ; char 88 - X
 117+ 4B05 28 44 44 00
 118+ 4B09 44 44 44 28          defb %01000100,%01000100,%01000100,%00101000,%00010000,%00010000,%00010000,%00000000 ; char 89 - Y
 118+ 4B0D 10 10 10 00
 119+ 4B11 7C 04 08 10          defb %01111100,%00000100,%00001000,%00010000,%00100000,%01000000,%01111100,%00000000 ; char 90 - Z
 119+ 4B15 20 40 7C 00
 120+ 4B19 38 20 20 20          defb %00111000,%00100000,%00100000,%00100000,%00100000,%00100000,%00111000,%00000000 ; char 91 - [
 120+ 4B1D 20 20 38 00
 121+ 4B21 00 40 20 10          defb %00000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000000 ; char 92 - \
 121+ 4B25 08 04 02 00
 122+ 4B29 38 08 08 08          defb %00111000,%00001000,%00001000,%00001000,%00001000,%00001000,%00111000,%00000000 ; char 93 - ]
 122+ 4B2D 08 08 38 00
 123+ 4B31 10 28 44 00          defb %00010000,%00101000,%01000100,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 94 - ^
 123+ 4B35 00 00 00 00
 124+ 4B39 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%01111110,%00000000 ; char 95 _ (underscore)
 124+ 4B3D 00 00 7E 00
 125+ 4B41 20 10 08 00          defb %00100000,%00010000,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 96 - `
 125+ 4B45 00 00 00 00
 126+ 4B49 00 00 38 04          defb %00000000,%00000000,%00111000,%00000100,%00111100,%01000100,%00111100,%00000000 ; char 97 - a
 126+ 4B4D 3C 44 3C 00
 127+ 4B51 40 40 40 78          defb %01000000,%01000000,%01000000,%01111000,%01000100,%01000100,%01111000,%00000000 ; char 98 - b
 127+ 4B55 44 44 78 00
 128+ 4B59 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%01000000,%01000100,%00111000,%00000000 ; char 99 - c
 128+ 4B5D 40 44 38 00
 129+ 4B61 04 04 04 3C          defb %00000100,%00000100,%00000100,%00111100,%01000100,%01000100,%00111100,%00000000 ; char 100 - d
 129+ 4B65 44 44 3C 00
 130+ 4B69 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01111100,%01000000,%00111000,%00000000 ; char 101 - e
 130+ 4B6D 7C 40 38 00
 131+ 4B71 18 24 20 70          defb %00011000,%00100100,%00100000,%01110000,%00100000,%00100000,%00100000,%00000000 ; char 102 - f
 131+ 4B75 20 20 20 00
 132+ 4B79 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00111000 ; char 103 - g
 132+ 4B7D 44 3C 04 38
 133+ 4B81 40 40 58 64          defb %01000000,%01000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 104 - h
 133+ 4B85 44 44 44 00
 134+ 4B89 00 10 00 10          defb %00000000,%00010000,%00000000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 105 - i
 134+ 4B8D 10 10 10 00
 135+ 4B91 08 00 18 08          defb %00001000,%00000000,%00011000,%00001000,%00001000,%00001000,%01001000,%00110000 ; char 106 - j
 135+ 4B95 08 08 48 30
 136+ 4B99 40 40 48 50          defb %01000000,%01000000,%01001000,%01010000,%01100000,%01010000,%01001000,%00000000 ; char 107 - k
 136+ 4B9D 60 50 48 00
 137+ 4BA1 30 10 10 10          defb %00110000,%00010000,%00010000,%00010000,%00010000,%00010000,%00111000,%00000000 ; char 108 - l
 137+ 4BA5 10 10 38 00
 138+ 4BA9 00 00 54 6A          defb %00000000,%00000000,%01010100,%01101010,%01001010,%01000010,%01000010,%00000000 ; char 109 - m
 138+ 4BAD 4A 42 42 00
 139+ 4BB1 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000100,%01000100,%01000100,%00000000 ; char 110 - n
 139+ 4BB5 44 44 44 00
 140+ 4BB9 00 00 38 44          defb %00000000,%00000000,%00111000,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 111: o
 140+ 4BBD 44 44 38 00
 141+ 4BC1 00 00 78 44          defb %00000000,%00000000,%01111000,%01000100,%01000100,%01111000,%01000000,%01000000 ; char 112: p
 141+ 4BC5 44 78 40 40
 142+ 4BC9 00 00 3C 44          defb %00000000,%00000000,%00111100,%01000100,%01000100,%00111100,%00000100,%00000100 ; char 113: q
 142+ 4BCD 44 3C 04 04
 143+ 4BD1 00 00 58 64          defb %00000000,%00000000,%01011000,%01100100,%01000000,%01000000,%01000000,%00000000 ; char 114: r
 143+ 4BD5 40 40 40 00
 144+ 4BD9 00 00 38 40          defb %00000000,%00000000,%00111000,%01000000,%00111000,%00000100,%01111000,%00000000 ; char 115: s
 144+ 4BDD 38 04 78 00
 145+ 4BE1 20 20 70 20          defb %00100000,%00100000,%01110000,%00100000,%00100000,%00100100,%00011000,%00000000 ; char 116: t
 145+ 4BE5 20 24 18 00
 146+ 4BE9 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%01001100,%00110100,%00000000 ; char 117: u
 146+ 4BED 44 4C 34 00
 147+ 4BF1 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01000100,%00101000,%00010000,%00000000 ; char 118: v
 147+ 4BF5 44 28 10 00
 148+ 4BF9 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01010100,%01010100,%00101000,%00000000 ; char 119: w
 148+ 4BFD 54 54 28 00
 149+ 4C01 00 00 44 28          defb %00000000,%00000000,%01000100,%00101000,%00010000,%00101000,%01000100,%00000000 ; char 120: x
 149+ 4C05 10 28 44 00
 150+ 4C09 00 00 44 44          defb %00000000,%00000000,%01000100,%01000100,%01001100,%00110100,%00000100,%00111000 ; char 121: y
 150+ 4C0D 4C 34 04 38
 151+ 4C11 00 00 7C 08          defb %00000000,%00000000,%01111100,%00001000,%00010000,%00100000,%01111100,%00000000 ; char 122: z
 151+ 4C15 10 20 7C 00
 152+ 4C19 18 20 20 40          defb %00011000,%00100000,%00100000,%01000000,%00100000,%00100000,%00011000,%00000000 ; char 123: {
 152+ 4C1D 20 20 18 00
 153+ 4C21 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 124: |
 153+ 4C25 10 10 10 00
 154+ 4C29 30 08 08 04          defb %00110000,%00001000,%00001000,%00000100,%00001000,%00001000,%00110000,%00000000 ; char 125: }
 154+ 4C2D 08 08 30 00
 155+ 4C31 20 54 08 00          defb %00100000,%01010100,%00001000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 126: ~
 155+ 4C35 00 00 00 00
 156+ 4C39 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 127 (delete) - end the standard ASCII (0-127)
 156+ 4C3D 00 00 00 00
 157+ 4C41 3C 42 A5 81          defb %00111100,%01000010,%10100101,%10000001,%10100101,%10011001,%01000010,%00111100 ; char 128 (open face)
 157+ 4C45 A5 99 42 3C
 158+ 4C49 3C 7E DB FF          defb %00111100,%01111110,%11011011,%11111111,%11011011,%11100111,%01111110,%00111100 ; char 129 (full face)
 158+ 4C4D DB E7 7E 3C
 159+ 4C51 6C FE FE FE          defb %01101100,%11111110,%11111110,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 130 (hearts)
 159+ 4C55 7C 38 10 00
 160+ 4C59 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%01111100,%00111000,%00010000,%00000000 ; char 131 (diamonds)
 160+ 4C5D 7C 38 10 00
 161+ 4C61 10 38 54 FE          defb %00010000,%00111000,%01010100,%11111110,%01010100,%00010000,%01111100,%00000000 ; char 132 (clus)
 161+ 4C65 54 10 7C 00
 162+ 4C69 10 38 7C FE          defb %00010000,%00111000,%01111100,%11111110,%11010110,%00010000,%01111100,%00000000 ; char 133 (spades)
 162+ 4C6D D6 10 7C 00
 163+ 4C71 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 134
 163+ 4C75 FF 18 18 18
 164+ 4C79 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 135
 164+ 4C7D 1F 18 18 18
 165+ 4C81 00 00 00 F8          defb %00000000,%00000000,%00000000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 136
 165+ 4C85 F8 18 18 18
 166+ 4C89 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00000000,%00000000,%00000000 ; char 137
 166+ 4C8D F8 00 00 00
 167+ 4C91 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00000000,%00000000,%00000000 ; char 138
 167+ 4C95 1F 00 00 00
 168+ 4C99 18 18 18 FF          defb %00011000,%00011000,%00011000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 139
 168+ 4C9D FF 00 00 00
 169+ 4CA1 18 18 18 1F          defb %00011000,%00011000,%00011000,%00011111,%00011111,%00011000,%00011000,%00011000 ; char 140
 169+ 4CA5 1F 18 18 18
 170+ 4CA9 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00011000,%00011000,%00011000 ; char 141
 170+ 4CAD FF 18 18 18
 171+ 4CB1 18 18 18 F8          defb %00011000,%00011000,%00011000,%11111000,%11111000,%00011000,%00011000,%00011000 ; char 142
 171+ 4CB5 F8 18 18 18
 172+ 4CB9 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; char 143
 172+ 4CBD FF 00 00 00
 173+ 4CC1 18 18 18 18          defb %00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000,%00011000 ; char 144
 173+ 4CC5 18 18 18 18
 174+ 4CC9 03 07 0E 1C          defb %00000011,%00000111,%00001110,%00011100,%00111000,%01110000,%11100000,%11000000 ; char 145
 174+ 4CCD 38 70 E0 C0
 175+ 4CD1 C0 E0 70 38          defb %11000000,%11100000,%01110000,%00111000,%00011100,%00001110,%00000111,%00000011 ; char 146
 175+ 4CD5 1C 0E 07 03
 176+ 4CD9 C3 E7 7E 3C          defb %11000011,%11100111,%01111110,%00111100,%00111100,%01111110,%11100111,%11000011 ; char 147
 176+ 4CDD 3C 7E E7 C3
 177+ 4CE1 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 148
 177+ 4CE5 10 10 10 10
 178+ 4CE9 00 00 00 1F          defb %00000000,%00000000,%00000000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 149
 178+ 4CED 10 10 10 10
 179+ 4CF1 00 00 00 F0          defb %00000000,%00000000,%00000000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 150
 179+ 4CF5 10 10 10 10
 180+ 4CF9 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 151
 180+ 4CFD 00 00 00 00
 181+ 4D01 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00000000,%00000000,%00000000,%00000000 ; char 152
 181+ 4D05 00 00 00 00
 182+ 4D09 10 10 10 FF          defb %00010000,%00010000,%00010000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 153
 182+ 4D0D 00 00 00 00
 183+ 4D11 10 10 10 1F          defb %00010000,%00010000,%00010000,%00011111,%00010000,%00010000,%00010000,%00010000 ; char 154
 183+ 4D15 10 10 10 10
 184+ 4D19 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00010000,%00010000,%00010000,%00010000 ; char 155
 184+ 4D1D 10 10 10 10
 185+ 4D21 10 10 10 F0          defb %00010000,%00010000,%00010000,%11110000,%00010000,%00010000,%00010000,%00010000 ; char 156
 185+ 4D25 10 10 10 10
 186+ 4D29 00 00 00 FF          defb %00000000,%00000000,%00000000,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 157
 186+ 4D2D 00 00 00 00
 187+ 4D31 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000,%00010000 ; char 158
 187+ 4D35 10 10 10 10
 188+ 4D39 01 02 04 08          defb %00000001,%00000010,%00000100,%00001000,%00010000,%00100000,%01000000,%10000000 ; char 159
 188+ 4D3D 10 20 40 80
 189+ 4D41 80 40 20 10          defb %10000000,%01000000,%00100000,%00010000,%00001000,%00000100,%00000010,%00000001 ; char 160
 189+ 4D45 08 04 02 01
 190+ 4D49 81 42 24 18          defb %10000001,%01000010,%00100100,%00011000,%00011000,%00100100,%01000010,%10000001 ; char 161
 190+ 4D4D 18 24 42 81
 191+ 4D51 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 162
 191+ 4D55 00 00 FF FF
 192+ 4D59 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; char 163
 192+ 4D5D FF FF FF FF
 193+ 4D61 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 164
 193+ 4D65 FF FF FF FF
 194+ 4D69 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; char 165
 194+ 4D6D 00 00 00 00
 195+ 4D71 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; char 166
 195+ 4D75 00 00 00 00
 196+ 4D79 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 167
 196+ 4D7D FF FF 00 00
 197+ 4D81 C0 C0 C0 C0          defb %11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000,%11000000 ; char 168
 197+ 4D85 C0 C0 C0 C0
 198+ 4D89 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; char 169
 198+ 4D8D F0 F0 F0 F0
 199+ 4D91 FC FC FC FC          defb %11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100,%11111100 ; char 170
 199+ 4D95 FC FC FC FC
 200+ 4D99 03 03 03 03          defb %00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011,%00000011 ; char 171
 200+ 4D9D 03 03 03 03
 201+ 4DA1 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; char 172
 201+ 4DA5 0F 0F 0F 0F
 202+ 4DA9 3F 3F 3F 3F          defb %00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111,%00111111 ; char 173
 202+ 4DAD 3F 3F 3F 3F
 203+ 4DB1 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 174
 203+ 4DB5 81 81 81 FF
 204+ 4DB9 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; char 175
 204+ 4DBD F0 F0 F0 F0
 205+ 4DC1 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; char 176
 205+ 4DC5 0F 0F 0F 0F
 206+ 4DC9 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; char 177
 206+ 4DCD 00 00 00 00
 207+ 4DD1 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; char 178
 207+ 4DD5 00 00 00 00
 208+ 4DD9 F0 F0 F0 F0          defb %11110000,%11110000,%11110000,%11110000,%00001111,%00001111,%00001111,%00001111 ; char 179
 208+ 4DDD 0F 0F 0F 0F
 209+ 4DE1 0F 0F 0F 0F          defb %00001111,%00001111,%00001111,%00001111,%11110000,%11110000,%11110000,%11110000 ; char 180
 209+ 4DE5 F0 F0 F0 F0
 210+ 4DE9 3C 3C 3C 3C          defb %00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100,%00111100 ; char 181
 210+ 4DED 3C 3C 3C 3C
 211+ 4DF1 C3 C3 C3 C3          defb %11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011,%11000011 ; char 182
 211+ 4DF5 C3 C3 C3 C3
 212+ 4DF9 FF FF 00 00          defb %11111111,%11111111,%00000000,%00000000,%00000000,%00000000,%11111111,%11111111 ; char 183
 212+ 4DFD 00 00 FF FF
 213+ 4E01 00 00 FF FF          defb %00000000,%00000000,%11111111,%11111111,%11111111,%11111111,%00000000,%00000000 ; char 184
 213+ 4E05 FF FF 00 00
 214+ 4E09 33 33 CC CC          defb %00110011,%00110011,%11001100,%11001100,%00110011,%00110011,%11001100,%11001100 ; char 185
 214+ 4E0D 33 33 CC CC
 215+ 4E11 55 AA 55 AA          defb %01010101,%10101010,%01010101,%10101010,%01010101,%10101010,%01010101,%10101010 ; char 186
 215+ 4E15 55 AA 55 AA
 216+ 4E19 66 33 99 CC          defb %01100110,%00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100 ; char 187
 216+ 4E1D 66 33 99 CC
 217+ 4E21 CC 99 33 66          defb %11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011,%01100110 ; char 188
 217+ 4E25 CC 99 33 66
 218+ 4E29 33 99 CC 66          defb %00110011,%10011001,%11001100,%01100110,%00110011,%10011001,%11001100,%01100110 ; char 189
 218+ 4E2D 33 99 CC 66
 219+ 4E31 66 CC 99 33          defb %01100110,%11001100,%10011001,%00110011,%01100110,%11001100,%10011001,%00110011 ; char 190
 219+ 4E35 66 CC 99 33
 220+ 4E39 10 10 7C 10          defb %00010000,%00010000,%01111100,%00010000,%00010000,%00000000,%01111100,%00000000 ; char 191 (Â±)
 220+ 4E3D 10 00 7C 00
 221+ 4E41 60 18 06 18          defb %01100000,%00011000,%00000110,%00011000,%01100000,%00000000,%01111110,%00000000 ; char 192 (â¥)
 221+ 4E45 60 00 7E 00
 222+ 4E49 06 18 60 18          defb %00000110,%00011000,%01100000,%00011000,%00000110,%00000000,%01111110,%00000000 ; char 193 (â¤)
 222+ 4E4D 06 00 7E 00
 223+ 4E51 3E 20 20 20          defb %00111110,%00100000,%00100000,%00100000,%10100000,%01100000,%00100000,%00000000 ; char 194 (square root)
 223+ 4E55 A0 60 20 00
 224+ 4E59 30 48 48 30          defb %00110000,%01001000,%01001000,%00110000,%00000000,%00000000,%00000000,%00000000 ; char 195 (Â°)
 224+ 4E5D 00 00 00 00
 225+ 4E61 60 10 30 40          defb %01100000,%00010000,%00110000,%01000000,%01110000,%00000000,%00000000,%00000000 ; char 196 (Â²)
 225+ 4E65 70 00 00 00
 226+ 4E69 00 00 2A 54          defb %00000000,%00000000,%00101010,%01010100,%00000000,%01111110,%00000000,%00000000 ; char 197
 226+ 4E6D 00 7E 00 00
 227+ 4E71 00 54 A8 00          defb %00000000,%01010100,%10101000,%00000000,%01010100,%10101000,%00000000,%00000000 ; char 198 (â)
 227+ 4E75 54 A8 00 00
 228+ 4E79 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11100000,%11000000,%10000000,%00000000 ; char 199
 228+ 4E7D E0 C0 80 00
 229+ 4E81 FE 7C 38 10          defb %11111110,%01111100,%00111000,%00010000,%00000000,%00000000,%00000000,%00000000 ; char 200
 229+ 4E85 00 00 00 00
 230+ 4E89 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00000111,%00000011,%00000001,%00000000 ; char 201
 230+ 4E8D 07 03 01 00
 231+ 4E91 00 00 00 00          defb %00000000,%00000000,%00000000,%00000000,%00010000,%00111000,%01111100,%11111110 ; char 202
 231+ 4E95 10 38 7C FE
 232+ 4E99 10 38 7C 10          defb %00010000,%00111000,%01111100,%00010000,%00010000,%00010000,%00010000,%00000000 ; char 203 (up arrow)
 232+ 4E9D 10 10 10 00
 233+ 4EA1 1E 0E 0E 12          defb %00011110,%00001110,%00001110,%00010010,%00100000,%01000000,%00000000,%00000000 ; char 204 (up right arrow)
 233+ 4EA5 20 40 00 00
 234+ 4EA9 00 08 0C FE          defb %00000000,%00001000,%00001100,%11111110,%00001100,%00001000,%00000000,%00000000 ; char 205 (right arrow)
 234+ 4EAD 0C 08 00 00
 235+ 4EB1 00 40 20 12          defb %00000000,%01000000,%00100000,%00010010,%00001110,%00001110,%00011110,%00000000 ; char 206 (down right arrow)
 235+ 4EB5 0E 0E 1E 00
 236+ 4EB9 10 10 10 10          defb %00010000,%00010000,%00010000,%00010000,%01111100,%00111000,%00010000,%00000000 ; char 207 (down arrow)
 236+ 4EBD 7C 38 10 00
 237+ 4EC1 00 04 08 90          defb %00000000,%00000100,%00001000,%10010000,%11100000,%11100000,%11110000,%00000000 ; char 208 (down left arrow)
 237+ 4EC5 E0 E0 F0 00
 238+ 4EC9 00 20 60 FE          defb %00000000,%00100000,%01100000,%11111110,%01100000,%00100000,%00000000,%00000000 ; char 209 (left arrow)
 238+ 4ECD 60 20 00 00
 239+ 4ED1 F0 E0 E0 90          defb %11110000,%11100000,%11100000,%10010000,%00001000,%00000100,%00000000,%00000000 ; char 210 (up left arrow)
 239+ 4ED5 08 04 00 00
 240+ 4ED9 38 44 F0 40          defb %00111000,%01000100,%11110000,%01000000,%11110000,%01000100,%00111000,%00000000 ; char 211 (euro)
 240+ 4EDD F0 44 38 00
 241+ 4EE1 00 02 7C A8          defb %00000000,%00000010,%01111100,%10101000,%00101000,%00101000,%00101000,%00000000 ; char 212 (greek pi)
 241+ 4EE5 28 28 28 00
 242+ 4EE9 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001000,%00010000,%00010000,%00010000 ; char 213
 242+ 4EED 08 10 10 10
 243+ 4EF1 00 00 00 C0          defb %00000000,%00000000,%00000000,%11000000,%00100000,%00010000,%00010000,%00010000 ; char 214
 243+ 4EF5 20 10 10 10
 244+ 4EF9 10 10 20 C0          defb %00010000,%00010000,%00100000,%11000000,%00000000,%00000000,%00000000,%00000000 ; char 215
 244+ 4EFD 00 00 00 00
 245+ 4F01 10 10 08 07          defb %00010000,%00010000,%00001000,%00000111,%00000000,%00000000,%00000000,%00000000 ; char 216
 245+ 4F05 00 00 00 00
 246+ 4F09 00 00 00 07          defb %00000000,%00000000,%00000000,%00000111,%00001111,%00011100,%00011000,%00011000 ; char 217
 246+ 4F0D 0F 1C 18 18
 247+ 4F11 00 00 00 E0          defb %00000000,%00000000,%00000000,%11100000,%11110000,%00111000,%00011000,%00011000 ; char 218
 247+ 4F15 F0 38 18 18
 248+ 4F19 18 18 38 F0          defb %00011000,%00011000,%00111000,%11110000,%11100000,%00000000,%00000000,%00000000 ; char 219
 248+ 4F1D E0 00 00 00
 249+ 4F21 18 18 1C 0F          defb %00011000,%00011000,%00011100,%00001111,%00000111,%00000000,%00000000,%00000000 ; char 220
 249+ 4F25 07 00 00 00
 250+ 4F29 00 3C 42 42          defb %00000000,%00111100,%01000010,%01000010,%01000010,%01000010,%00111100,%00000000 ; char 221
 250+ 4F2D 42 42 3C 00
 251+ 4F31 00 3C 7E 7E          defb %00000000,%00111100,%01111110,%01111110,%01111110,%01111110,%00111100,%00000000 ; char 222
 251+ 4F35 7E 7E 3C 00
 252+ 4F39 00 18 3C 7E          defb %00000000,%00011000,%00111100,%01111110,%01111110,%00111100,%00011000,%00000000 ; char 223
 252+ 4F3D 7E 3C 18 00
 253+ 4F41 FF FE FC F8          defb %11111111,%11111110,%11111100,%11111000,%11110000,%11100000,%11000000,%10000000 ; char 224
 253+ 4F45 F0 E0 C0 80
 254+ 4F49 FF 7F 3F 1F          defb %11111111,%01111111,%00111111,%00011111,%00001111,%00000111,%00000011,%00000001 ; char 225
 254+ 4F4D 0F 07 03 01
 255+ 4F51 01 03 07 0F          defb %00000001,%00000011,%00000111,%00001111,%00011111,%00111111,%01111111,%11111111 ; char 226
 255+ 4F55 1F 3F 7F FF
 256+ 4F59 80 C0 E0 F0          defb %10000000,%11000000,%11100000,%11110000,%11111000,%11111100,%11111110,%11111111 ; char 227
 256+ 4F5D F8 FC FE FF
 257+ 4F61 00 02 06 6C          defb %00000000,%00000010,%00000110,%01101100,%01111000,%01110000,%01100000,%00000000 ; char 228 (checkmark)
 257+ 4F65 78 70 60 00
 258+ 4F69 00 66 3C 18          defb %00000000,%01100110,%00111100,%00011000,%00111100,%01100110,%00000000,%00000000 ; char 229 (x)
 258+ 4F6D 3C 66 00 00
 259+ 4F71 38 44 44 44          defb %00111000,%01000100,%01000100,%01000100,%00111000,%00010000,%00111000,%00010000 ; char 230 (female)
 259+ 4F75 38 10 38 10
 260+ 4F79 07 03 3D 44          defb %00000111,%00000011,%00111101,%01000100,%01000100,%01000100,%00111000,%00000000 ; char 231 (male)
 260+ 4F7D 44 44 38 00
 261+ 4F81 78 44 42 42          defb %01111000,%01000100,%01000010,%01000010,%01000010,%01000010,%01000010,%01111110 ; char 232 (new doc)
 261+ 4F85 42 42 42 7E
 262+ 4F89 00 F8 FF 81          defb %00000000,%11111000,%11111111,%10000001,%10000001,%10000001,%10000001,%11111111 ; char 233 (folder)
 262+ 4F8D 81 81 81 FF
 263+ 4F91 10 7C FE 54          defb %00010000,%01111100,%11111110,%01010100,%01010100,%01010100,%01010100,%01111100 ; char 234 (trash bin)
 263+ 4F95 54 54 54 7C
 264+ 4F99 FF 81 81 81          defb %11111111,%10000001,%10000001,%10000001,%10111101,%10101101,%10101101,%11111111 ; char 235 (floppy disk)
 264+ 4F9D BD AD AD FF
 265+ 4FA1 00 EA AA AC          defb %00000000,%11101010,%10101010,%10101100,%10101100,%10101010,%11101010,%00000000 ; char 236 (OK)
 265+ 4FA5 AC AA EA 00
 266+ 4FA9 18 7E FF 7E          defb %00011000,%01111110,%11111111,%01111110,%01111110,%01100110,%01100110,%01100110 ; char 237 (home)
 266+ 4FAD 7E 66 66 66
 267+ 4FB1 3C 42 91 91          defb %00111100,%01000010,%10010001,%10010001,%10011101,%10000001,%01000010,%00111100 ; char 238 (clock)
 267+ 4FB5 9D 81 42 3C
 268+ 4FB9 00 02 05 FD          defb %00000000,%00000010,%00000101,%11111101,%10100101,%10100010,%00000000,%00000000 ; char 239 (key)
 268+ 4FBD A5 A2 00 00
 269+ 4FC1 08 0C 3E 4C          defb %00001000,%00001100,%00111110,%01001100,%01001000,%01000010,%01000010,%00111100 ; char 240 (undo)
 269+ 4FC5 48 42 42 3C
 270+ 4FC9 00 FF C3 A5          defb %00000000,%11111111,%11000011,%10100101,%10011001,%10000001,%11111111,%00000000 ; char 241 (letter)
 270+ 4FCD 99 81 FF 00
 271+ 4FD1 38 44 44 7C          defb %00111000,%01000100,%01000100,%01111100,%01111100,%01111100,%01111100,%00000000 ; char 242 (lock)
 271+ 4FD5 7C 7C 7C 00
 272+ 4FD9 06 09 09 F8          defb %00000110,%00001001,%00001001,%11111000,%11111000,%11111000,%11111000,%00000000 ; char 243 (unlock)
 272+ 4FDD F8 F8 F8 00
 273+ 4FE1 FF FF 81 AD          defb %11111111,%11111111,%10000001,%10101101,%10100101,%10100101,%10000001,%11111111 ; char 244 (calendar)
 273+ 4FE5 A5 A5 81 FF
 274+ 4FE9 01 1A 24 4A          defb %00000001,%00011010,%00100100,%01001010,%01010010,%00100100,%01011000,%10000000 ; char 245 (diameter)
 274+ 4FED 52 24 58 80
 275+ 4FF1 7E 81 81 81          defb %01111110,%10000001,%10000001,%10000001,%10000001,%01110110,%00001100,%00000100 ; char 246 (baloon)
 275+ 4FF5 81 76 0C 04
 276+ 4FF9 0C 0A 0A 0A          defb %00001100,%00001010,%00001010,%00001010,%00001000,%00011000,%00111000,%00010000 ; char 247 (note)
 276+ 4FFD 08 18 38 10
 277+ 5001 12 31 F5 F5          defb %00010010,%00110001,%11110101,%11110101,%11110101,%11110101,%00110001,%00010010 ; char 248 (audio on)
 277+ 5005 F5 F5 31 12
 278+ 5009 10 30 F0 F0          defb %00010000,%00110000,%11110000,%11110000,%11110000,%11110000,%00110000,%00010000 ; char 249 (audio off)
 278+ 500D F0 F0 30 10
 279+ 5011 40 60 70 78          defb %01000000,%01100000,%01110000,%01111000,%01111100,%01111110,%01111000,%01001000 ; char 250 (pointer)
 279+ 5015 7C 7E 78 48
 280+ 5019 3C 42 99 A1          defb %00111100,%01000010,%10011001,%10100001,%10100001,%10011001,%01000010,%00111100 ; char 251 (Â©)
 280+ 501D A1 99 42 3C
 281+ 5021 18 24 20 78          defb %00011000,%00100100,%00100000,%01111000,%00100000,%00100010,%01011100,%00000000 ; char 252 (Â£)
 281+ 5025 20 22 5C 00
 282+ 5029 3C 42 78 24          defb %00111100,%01000010,%01111000,%00100100,%00100100,%00011110,%01000010,%00111100 ; char 253 (Â§)
 282+ 502D 24 1E 42 3C
 283+ 5031 00 00 10 00          defb %00000000,%00000000,%00010000,%00000000,%01111100,%00000000,%00010000,%00000000 ; char 254 (Ã·)
 283+ 5035 7C 00 10 00
 284+ 5039 FF FF FF FF          defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; char 255 (cursor)
 284+ 503D FF FF FF FF
 285+ 5041
# file closed: ../include/vdp/8x8fonts-r18.asm
  86  5041                  INCLUDE "../include/vdp/logo-fonts.asm"
# file opened: ../include/vdp/logo-fonts.asm
   1+ 5041              ; ------------------------------------------------------------------------------
   2+ 5041              ; LM80C - LOGO CHARSET - R1.1
   3+ 5041              ; ------------------------------------------------------------------------------
   4+ 5041              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5041              ; designed by Leonardo Miliani. More info at
   6+ 5041              ; www DOT leonardomiliani DOT com
   7+ 5041              ; ------------------------------------------------------------------------------
   8+ 5041              ; Code Revision:
   9+ 5041              ; R1.0 - 20200124 - First revision: logo chars
  10+ 5041              ; R1.1 - 20200229 - Adopted usual hexadecimal & binary prefixes
  11+ 5041              ; ------------------------------------------------------------------------------
  12+ 5041
  13+ 5041              LOGOFONT:   equ $
  14+ 5041 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000,%00000000 ; 0
  14+ 5045 00 00 00 00
  15+ 5049 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111,%11111111 ; 1
  15+ 504D FF FF FF FF
  16+ 5051 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00000000,%00000000,%00000000,%00000000 ; 2
  16+ 5055 00 00 00 00
  17+ 5059 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111,%00001111 ; 3
  17+ 505D 0F 0F 0F 0F
  18+ 5061 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11111111,%11111111,%11111111,%11111111 ; 4
  18+ 5065 FF FF FF FF
  19+ 5069 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000,%11110000 ; 5
  19+ 506D F0 F0 F0 F0
  20+ 5071 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%00001111,%00001111,%00001111,%00001111 ; 6
  20+ 5075 0F 0F 0F 0F
  21+ 5079 00 00 00 00              defb %00000000,%00000000,%00000000,%00000000,%11110000,%11110000,%11110000,%11110000 ; 7
  21+ 507D F0 F0 F0 F0
  22+ 5081 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%00000000,%00000000,%00000000,%00000000 ; 8
  22+ 5085 00 00 00 00
  23+ 5089 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%00000000,%00000000,%00000000,%00000000 ; 9
  23+ 508D 00 00 00 00
  24+ 5091 00 00 00 FC              defb %00000000,%00000000,%00000000,%11111100,%11111111,%00000111,%00000011,%00000000 ; 10
  24+ 5095 FF 07 03 00
  25+ 5099 00 00 00 3F              defb %00000000,%00000000,%00000000,%00111111,%11111111,%11100000,%11000000,%00000000 ; 11
  25+ 509D FF E0 C0 00
  26+ 50A1 18 18 1F 19              defb %00011000,%00011000,%00011111,%00011001,%00011001,%00011111,%00011000,%00011000 ; 12
  26+ 50A5 19 1F 18 18
  27+ 50A9 18 18 F8 98              defb %00011000,%00011000,%11111000,%10011000,%10011000,%11111000,%00011000,%00011000 ; 13
  27+ 50AD 98 F8 18 18
  28+ 50B1 18 18 1C 1F              defb %00011000,%00011000,%00011100,%00011111,%00001111,%00000000,%00000000,%00000000 ; 14
  28+ 50B5 0F 00 00 00
  29+ 50B9 00 00 00 0F              defb %00000000,%00000000,%00000000,%00001111,%00011111,%00011100,%00011000,%00011000 ; 15
  29+ 50BD 1F 1C 18 18
  30+ 50C1 00 00 00 F0              defb %00000000,%00000000,%00000000,%11110000,%11111000,%00111000,%00011000,%00011000 ; 16
  30+ 50C5 F8 38 18 18
  31+ 50C9 18 18 38 F8              defb %00011000,%00011000,%00111000,%11111000,%11110000,%00000000,%00000000,%00000000 ; 17
  31+ 50CD F0 00 00 00
  32+ 50D1 00 00 00 FF              defb %00000000,%00000000,%00000000,%11111111,%11111111,%00000000,%00000000,%00000000 ; 18
  32+ 50D5 FF 00 00 00
  33+ 50D9 0F 0F 0F 0F              defb %00001111,%00001111,%00001111,%00001111,%11111111,%11111111,%11111111,%11111111 ; 19
  33+ 50DD FF FF FF FF
  34+ 50E1 F0 F0 F0 F0              defb %11110000,%11110000,%11110000,%11110000,%11111111,%11111111,%11111111,%11111111 ; 20
  34+ 50E5 FF FF FF FF
  35+ 50E9 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%11110000,%11110000,%11110000,%11110000 ; 21
  35+ 50ED F0 F0 F0 F0
  36+ 50F1 FF FF FF FF              defb %11111111,%11111111,%11111111,%11111111,%00001111,%00001111,%00001111,%00001111 ; 22
  36+ 50F5 0F 0F 0F 0F
  37+ 50F9 00 30 78 78              defb %00000000,%00110000,%01111000,%01111000,%00110000,%00000000,%00000000,%00000000 ; 23
  37+ 50FD 30 00 00 00
  38+ 5101
# file closed: ../include/vdp/logo-fonts.asm
  87  5101
  88  5101              ; include workspace equates
  89  5101                  INCLUDE "../include/workspace/workspace-r1.0.asm"
# file opened: ../include/workspace/workspace-r1.0.asm
   1+ 5101              ; ------------------------------------------------------------------------------
   2+ 5101              ; LM80C 64K - WORKSPACE EQUATES - R1.0
   3+ 5101              ; ------------------------------------------------------------------------------
   4+ 5101              ; The following code is intended to be used with LM80C Z80-based computer
   5+ 5101              ; designed by Leonardo Miliani. Code and computer schematics are released under
   6+ 5101              ; the therms of the GNU GPL License 3.0 and in the form of "as is", without no
   7+ 5101              ; kind of warranty: you can use them at your own risk.
   8+ 5101              ; You are free to use them for any non-commercial use: you are only asked to
   9+ 5101              ; maintain the copyright notices, include this advice and the note to the
  10+ 5101              ; attribution of the original version to Leonardo Miliani, if you intend to
  11+ 5101              ; redistribuite them.
  12+ 5101              ; https://www.leonardomiliani.com
  13+ 5101              ;
  14+ 5101              ; Please support me by visiting the following links:
  15+ 5101              ; Main project page: https://www.leonardomiliani.com
  16+ 5101              ; Schematics and code: https://github.com/leomil72/LM80C
  17+ 5101              ; Videos about the computer: https://www.youtube.com/user/leomil72/videos
  18+ 5101              ; Hackaday page: https://hackaday.io/project/165246-lm80c-color-computer
  19+ 5101              ; ------------------------------------------------------------------------------
  20+ 5101
  21+ 5101              ; set starting of RAM based on computer model
  22+ 5101                  IFDEF LM80C64K
  23+ 5101 ~            SERBUF_START    equ     END_OF_FW       ; RAM starts here
  24+ 5101                  ELSE
  25+ 5101              SERBUF_START    equ     $8000           ; RAM starts here
  26+ 5101                  ENDIF
  27+ 5101
  28+ 5101              ;-------------------------------------------------------------------------------
  29+ 5101              serInPtr        equ     SERBUF_START + SER_BUFSIZE
  30+ 5101              serRdPtr        equ     serInPtr+2
  31+ 5101              serBufUsed      equ     serRdPtr+2
  32+ 5101              basicStarted    equ     serBufUsed+1
  33+ 5101              bufWrap         equ     (SERBUF_START + SER_BUFSIZE) & $FF
  34+ 5101              TEMPSTACK       equ     CURPOS - 3      ; top of BASIC line input buffer so is "free ram" when BASIC resets
  35+ 5101
  36+ 5101              ; BASIC WORK SPACE LOCATIONS
  37+ 5101              ; THE INTERPRETER ALLOCATES THE FOLLOWING RAM CELLS
  38+ 5101              ; TO STORE IMPORTANT VALUES USED FOR SOME SPECIFIC FUNCTIONS:
  39+ 5101              ; THEY CAN BE VECTOR (ADDRESSES) FUNCTIONS, SYSTEM DATAS (I.E. VARIABLES)
  40+ 5101              ; AND SO ON. THE FIRST CELLS ARE FILLED WITH VALUES STORED INTO ROM AT $(INITAB) ADDRESS
  41+ 5101              WRKSPC          equ     basicStarted+$01; (3) BASIC Work space
  42+ 5101              NMIUSR          equ     WRKSPC+$03      ; (3) NMI exit point routine
  43+ 5101              USR             equ     NMIUSR+$03      ; (3) "USR (x)" jump  <-- in (USR+$01)/(USR+$02) the user can store the address of a specific machine language routine
  44+ 5101              OUTSUB          equ     USR+$03         ; (1) "out p,n"
  45+ 5101              OTPORT          equ     OUTSUB+$01      ; (2) Port (p)
  46+ 5101              DIVSUP          equ     OTPORT+$02      ; (1) Division support routine
  47+ 5101              DIV1            equ     DIVSUP+$01      ; (4) <- Values
  48+ 5101              DIV2            equ     DIV1+$04        ; (4) <-   to
  49+ 5101              DIV3            equ     DIV2+$04        ; (3) <-   be
  50+ 5101              DIV4            equ     DIV3+$03        ; (2) <-inserted
  51+ 5101              SEED            equ     DIV4+$02        ; (35) Random number seed  <-- starting address of a seed table
  52+ 5101              LSTRND          equ     SEED+$23        ; (4) Last random number
  53+ 5101              INPSUB          equ     LSTRND+$04      ; (1) INP A,(x) Routine
  54+ 5101              INPORT          equ     INPSUB+$01      ; (2) PORT (x)
  55+ 5101              LWIDTH          equ     INPORT+$02      ; (1) Terminal width
  56+ 5101              COMMAN          equ     LWIDTH+$01      ; (1) Width for commas
  57+ 5101              NULFLG          equ     COMMAN+$01      ; (1) Null after input byte flag
  58+ 5101              CTLOFG          equ     NULFLG+$01      ; (1) Control "O" flag
  59+ 5101              CHKSUM          equ     CTLOFG+$01      ; (2) Array load/save check sum
  60+ 5101              NMIFLG          equ     CHKSUM+$02      ; (1) Flag for NMI break routine
  61+ 5101              BRKFLG          equ     NMIFLG+$01      ; (1) Break flag
  62+ 5101              RINPUT          equ     BRKFLG+$01      ; (3) Input reflection
  63+ 5101              STRSPC          equ     RINPUT+$03      ; (2) Pointer to bottom (start) of string space - default is 100 bytes below the top of memory
  64+ 5101              LINEAT          equ     STRSPC+$02      ; (2) Current line number. -1 means "direct mode", while -2 means cold start.
  65+ 5101              HLPLN           equ     LINEAT+$02      ; (2) Current line with errors
  66+ 5101              KEYDEL          equ     HLPLN+$02       ; (1) delay before key auto-repeat starts
  67+ 5101              AUTOKE          equ     KEYDEL+$01      ; (1) delay for key auto-repeat
  68+ 5101              FNKEYS          equ     AUTOKE+$01      ; (128) default text of FN keys
  69+ 5101              BASTXT          equ     FNKEYS+$80      ; (3) Pointer to start of BASIC program in memory
  70+ 5101              ; - - - - - - - - - - - - - - - - - - -   the above are locations pre-filled by the firmware at startup
  71+ 5101              BUFFER          equ     BASTXT+$03      ; (5) Input buffer
  72+ 5101              STACK           equ     BUFFER+$05      ; (85) Initial stack
  73+ 5101              CURPOS          equ     STACK+$55       ; (1) Character position on line
  74+ 5101              LCRFLG          equ     CURPOS+$01      ; (1) Locate/Create flag for DIM statement
  75+ 5101              TYPE            equ     LCRFLG+$01      ; (1) Data type flag: 0=numeric, non-zero=string
  76+ 5101              DATFLG          equ     TYPE+$01        ; (1) Literal statement flag
  77+ 5101              LSTRAM          equ     DATFLG+$01      ; (2) Last available RAM location usable by BASIC
  78+ 5101              TMSTPT          equ     LSTRAM+$02      ; (2) Temporary string pointer
  79+ 5101              TMSTPL          equ     TMSTPT+$02      ; (12) Temporary string pool
  80+ 5101              TMPSTR          equ     TMSTPL+$0C      ; (4) Temporary string
  81+ 5101              STRBOT          equ     TMPSTR+$04      ; (2) Bottom of string space
  82+ 5101              CUROPR          equ     STRBOT+$02      ; (2) Current operator in EVAL
  83+ 5101              LOOPST          equ     CUROPR+$02      ; (2) First statement of loop
  84+ 5101              DATLIN          equ     LOOPST+$02      ; (2) Line of current DATA item
  85+ 5101              FORFLG          equ     DATLIN+$02      ; (1) "FOR" loop flag
  86+ 5101              LSTBIN          equ     FORFLG+$01      ; (1) Last byte entered
  87+ 5101              READFG          equ     LSTBIN+$01      ; (1) Read/Input flag
  88+ 5101              BRKLIN          equ     READFG+$01      ; (2) Line of break
  89+ 5101              NXTOPR          equ     BRKLIN+$02      ; (2) Next operator in EVAL
  90+ 5101              ERRLIN          equ     NXTOPR+$02      ; (2) Line of error
  91+ 5101              CONTAD          equ     ERRLIN+$02      ; (2) Where to CONTinue
  92+ 5101              TMRCNT          equ     CONTAD+$02      ; (4) TMR counter for 1/100 seconds
  93+ 5101              CTC0IV          equ     TMRCNT+$04      ; (3) CTC0 interrupt vector
  94+ 5101              CTC1IV          equ     CTC0IV+$03      ; (3) CTC1 interrupt vector
  95+ 5101              CTC2IV          equ     CTC1IV+$03      ; (3) CTC2 interrupt vector
  96+ 5101              CTC3IV          equ     CTC2IV+$03      ; (3) CTC3 interrupt vector
  97+ 5101              ; - - - - - - - - - - - - - - - - - - -   VIDEO REGISTERS - FROM HERE...
  98+ 5101              SCR_SIZE_W      equ     CTC3IV+$03      ; (1) screen width (it can be either 40 chars or 32 chars/bytes)
  99+ 5101              SCR_SIZE_H      equ     SCR_SIZE_W+$01  ; (1) screen height (it can be 24/48/192: 24 for text, 48 for MC, 192 for graphics)
 100+ 5101              SCR_MODE        equ     SCR_SIZE_H+$01  ; (1) screen mode (0=text, 1=G1, 2=G2, 3=MC, 4=ExG2)
 101+ 5101              SCR_NAM_TB      equ     SCR_MODE+$02    ; (2) video name table address
 102+ 5101              SCR_CURS_X      equ     SCR_NAM_TB+$02  ; (1) cursor X
 103+ 5101              SCR_CURS_Y      equ     SCR_CURS_X+$01  ; (1) cursor Y
 104+ 5101              SCR_CUR_NX      equ     SCR_CURS_Y+$01  ; (1) new cursor X position
 105+ 5101              SCR_CUR_NY      equ     SCR_CUR_NX+$01  ; (1) new cursor Y position
 106+ 5101              SCR_ORG_CHR     equ     SCR_CUR_NY+$01  ; (1) original char positioned under the cursor
 107+ 5101              CRSR_STATE      equ     SCR_ORG_CHR+$01 ; (1) state of cursor (1=on, 0=off)
 108+ 5101              LSTCSRSTA       equ     CRSR_STATE+$01  ; (1) last cursor state
 109+ 5101              PRNTVIDEO       equ     LSTCSRSTA+$01   ; (1) print on video buffer (1=on / 0=off) set to off on graphic only modes
 110+ 5101              CHR4VID         equ     PRNTVIDEO+$01   ; (1) char for video buffer
 111+ 5101              FRGNDCLR        equ     CHR4VID+$01     ; (1) foreground color as set by SCREEN or COLOR commands
 112+ 5101              BKGNDCLR        equ     FRGNDCLR+$01    ; (1) background color as set by SCREEN or COLOR commands
 113+ 5101              TMPBFR1         equ     BKGNDCLR+$01    ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 114+ 5101              TMPBFR2         equ     TMPBFR1+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 115+ 5101              TMPBFR3         equ     TMPBFR2+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 116+ 5101              TMPBFR4         equ     TMPBFR3+$02     ; (2) word for general purposes use (temp. buffer for 1 or 2 bytes)
 117+ 5101              VIDEOBUFF       equ     TMPBFR4+$02     ; (40) buffer used for video scrolling and other purposes
 118+ 5101              VIDTMP1         equ     VIDEOBUFF+$28   ; (2) temporary video word
 119+ 5101              VIDTMP2         equ     VIDTMP1+$02     ; (2) temporary video word
 120+ 5101              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO VPD OUT OF THIS RANGE,
 121+ 5101                                                      ; OTHERWISE YOU WILL HAVE TO CHECK THE POINTER IN "CLR_RAM_REG" FUNCTION
 122+ 5101              ; - - - - - - - - - - - - - - - - - - -   SOUND & KEYBOARD REGISTERS - FROM HERE...
 123+ 5101              CHASNDDTN       equ     VIDTMP2+$02     ; (2) sound Ch.A duration (in 1/100s)
 124+ 5101              CHBSNDDTN       equ     CHASNDDTN+$02   ; (2) sound Ch.B duration (in 1/100s)
 125+ 5101              CHCSNDDTN       equ     CHBSNDDTN+$02   ; (2) sound Ch.C duration (in 1/100s)
 126+ 5101              KBDNPT          equ     CHCSNDDTN+$02   ; (1) temp cell used to flag if input comes from keyboard
 127+ 5101              KBTMP           equ     KBDNPT+$01      ; (1) temp cell used by keyboard scanner
 128+ 5101              TMPKEYBFR       equ     KBTMP+$01       ; (1) temp buffer for last key pressed
 129+ 5101              LASTKEYPRSD     equ     TMPKEYBFR+$01   ; (1) last key code pressed
 130+ 5101              STATUSKEY       equ     LASTKEYPRSD+$01 ; (1) status key, used for auto-repeat
 131+ 5101              KEYTMR          equ     STATUSKEY+$01   ; (2) timer used for auto-repeat key
 132+ 5101              CONTROLKEYS     equ     KEYTMR+$02      ; (1) flags for control keys (bit#0=SHIFT; bit#1=CTRL; bit#2=C=)
 133+ 5101              ; - - - - - - - - - - - - - - - - - - -   ...TO HERE. DO NOT ADD ANYTHING RELATED TO PSG OUT OF THIS RANGE,
 134+ 5101                                                      ; OTHERWISE YOU WILL HAVE TO CHANGE THE POINTER IN "initPSG" FUNCTION
 135+ 5101              SERIALS_EN      equ     CONTROLKEYS+$01 ; (1) serial ports status: bit 0 for Port1 (A), bit 1 for Port2 (B): 0=OFF, 1=ON
 136+ 5101              SERABITS        equ     SERIALS_EN+$01  ; (1) serial port A data bits
 137+ 5101              SERBBITS        equ     SERABITS+$01    ; (1) serial port B data bits
 138+ 5101              DOS_EN          equ     SERBBITS+$01    ; (1) DOS enable/disable (1/0)
 139+ 5101              ; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 140+ 5101                                                      ; from here there are the RAM locations that
 141+ 5101                                                      ; are saved during SAVE
 142+ 5101              PROGND          equ     DOS_EN+$01      ; (2) End of program
 143+ 5101              VAREND          equ     PROGND+$02      ; (2) End of variables
 144+ 5101              ARREND          equ     VAREND+$02      ; (2) End of arrays
 145+ 5101              NXTDAT          equ     ARREND+$02      ; (2) Next data item
 146+ 5101              FNRGNM          equ     NXTDAT+$02      ; (2) Name of FN argument
 147+ 5101              FNARG           equ     FNRGNM+$02      ; (4) FN argument value
 148+ 5101              FPREG           equ     FNARG+$04       ; (3) Floating point register
 149+ 5101              FPEXP           equ     FPREG+$03       ; (1) Floating point exponent
 150+ 5101              SGNRES          equ     FPEXP+$01       ; (1) Sign of result
 151+ 5101              PBUFF           equ     SGNRES+$01      ; (13) Number print buffer
 152+ 5101              MULVAL          equ     PBUFF+$0D       ; (3) Multiplier
 153+ 5101              PROGST          equ     MULVAL+$03      ; (100) Start of program text area
 154+ 5101              STLOOK          equ     PROGST+$64      ; Start of memory test
 155+ 5101
# file closed: ../include/workspace/workspace-r1.0.asm
  90  5101
  91  5101              ; END OF ASSEMBLY SOURCE
  92  5101
  93  5101
  94  5101              ;-------------------------------------------------------------------------------
  95  5101
# file closed: LM80C-firmware-r3.18.asm

Value    Label
------ - -----------------------------------------------------------
0x8216   CHCSNDDTN
0x8214   CHBSNDDTN
0x80A8   NMIFLG
0x4031   DV16_16_LP
0x402C X DIV_16_16
0x4020   DIV_16_8LP
0x4011   DIV_8_8LOOP
0x4001   EXMUL16
0x3FF8   MLP1
0x3FF1   MLP
0x3FD1 X TSTBIT
0x3F91   BINIT
0x3FA4   CHKBIN
0x3F73   BITOUT2
0x3F6F   BITOUT
0x3F61   ZEROSUP
0x3F5B X BIN2
0x3F43   NOSUB7
0x3F47   HEXIT
0x3F23   HEXLP
0x3F28   HEXLP1
0x3F50   HXERR
0x3F30   GETHEX
0x3F13   ADD301
0x3F03   ADD30
0x3EED   HEX4
0x3EEB   HEX3
0x3EDC   HEX1
0x3EDE   HEX2
0x3E88   PRTEND
0x3E7C   PRTK1
0x3E79   OPNQT1
0x3E61   CLSQT1
0x3EBD   CHKEY5
0x3E49   PTCHR1
0x3EBA   CHKEY4
0x3E51   CLSQT
0x3E14   PRTK3
0x3E2C   PRTCHR
0x3E63   OPNQT
0x3E17   CNTLTK
0x3E02   LDKEY
0x3EB1   CHKEY2
0x3E7B   PRTCKEY
0x3EAC   CHKEY1
0x3DEB X PRTK2
0x3DE9   PRTK4
0x3DD5   CPKYEND
0x3DCD   CPKEY1
0x3DC5   CPKEY3
0x3DBE   CPKEY2
0x3DAE   CPKEY
0x3DA0   DECLN1
0x3E8A   SETREP
0x3D70   KEYCH
0x3DD7   LSTKEYS
0x3D4E   HLPERR
0x3D2C   DIRMOD
0x3CF3   EXNRM
0x3CE5   ENCHB
0x3CBA   SRLCNT
0x3CA2   STRPAR
0x3C85   SETPAR2
0x3C76   BITS8
0x3C6B   BITS7
0x3C7A   SETPAR
0x3C61   BITS6
0x3C3E   SET_CTC
0x3D10   CTC_CFG
0x3D1B   SCERR1
0x3C2D   SET_PT
0x3C14   CKBPS
0x3CFA   SUP_BPS
0x3C08   SETSER
0x3BFB   DEFSER
0x3BB0   CNTSER3
0x3B93   CNTRX2
0x3B9E   CNTSER2
0x3B60   SERLED
0x3B5A   SRPT2
0x3B37   RPTRSSR
0x3B2A   RSTSERS
0x3B64   CNTSER
0x3B26   CHKZSER
0x3B17   SERVAR
0x3D1F   SCERR
0x81EC   SIOBFR
0x81EB   STPBT
0x81EA   PARBT
0x81E9   DATABT
0x81E7   BPS
0x81E6   PRTNUM
0x3AD1   RPTCVB2
0x3AC8   RPTCVB1
0x3ABB   CNTVALY
0x3A8B   CNTCL7
0x3A67   CNTCL6
0x3A43   CNTCL5
0x3A21   CNTCL4
0x39FB   CNTCL3
0x39D7   CNTCL2
0x3AB5   VALIDY
0x39B3   CNTCL1
0x3AB0   VALIDX
0x3984   PLTCRL
0x3975   DLSZ
0x398D   ENDCRL
0x3948   RPTCL1
0x3935   RPTCRL
0x3991   DRWCRL
0x81F0   DC
0x81EE   YI
0x81EC   XI
0x81EA   RADIUS
0x81E8   YC
0x81E6   XC
0x38C4   DXGR
0x38ED   ENDDRAW
0x3894   CNTDRW
0x3878   RPTDRW
0x3875   STRE2
0x3868   ER2
0x4006   negHL
0x3845   Y1GR
0x381B   X1GR
0x4003   absHL
0x3AC0   CLRVDBF
0x81F2   DX
0x81F0   SY
0x81EE   SX
0x81EC   E2
0x81EA   ER
0x81E8   Y2
0x81E6   X2
0x81E0   Y1
0x81DE   X1
0x400D   DIV_8_8
0x3788   PXLSET
0x3764   CNTPLT1
0x3784   NOGD
0x3790   XY2HL
0x36FF   PNTEND
0x3709   CTPOINT
0x36B6   PAINT5
0x3685   PAINT3
0x36C6   CHECKPY
0x3672   PAINT2
0x3743   CNTPLOT
0x3642   MNPAINT
0x363F   PAINT1
0x363E   PAINT11
0x36C5   CHECKPA
0x3630   PAINT0
0x36BD   EXITPAI
0x3623   NXTLOOP
0x36C1   EXITPA2
0x371D   PNTRTN
0x3AD8   CLRPRM
0x81EA   ORGSP
0x81E9 X SPB
0x81E8 X SPA
0x81E6   PNT
0x35B5   GPCPCH1
0x35AA X GPCPCHR
0x3590   GPNTCO1
0x3586 X GPNTCOL
0x357B   RPGPNT
0x3566   GPNT
0x3551   CNTGPT2
0x35D2   CKCOL
0x81EC   TMPHL
0x81EA   NUMCHR
0x81E8   CHRPNT
0x81E6   TMPADR
0x81DE   MIXCOL
0x81E0   TMPCLR
0x81E4   GY
0x81E2   GX
0x3AF1   GMERR
0x34EB   CHKG2M
0x34E5   CHKCLR0
0x34B0   RPTLDCL
0x34A6   LOADCLR
0x34BB   SETBRCL
0x34D4   MIXCLRS
0x349F   CLREX2
0x3496   CLRG2
0x348D   CLRG1
0x3483   CLRTXT
0x3486   CLRMC
0x34E1   CHKCLR1
0x33DB   CKMAGN
0x3428   CHKSCAR
0x33D0 X SETVDP
0x33E9   SCVDP
0x33AC   RPTPS
0x33A7 X DIR_PAU
0x3381 X RECWRD
0x335D X ARET
0x3338   ATNTAB
0x332E   ATN1
0x32E7   SINTAB
0x32CB   SIN1
0x32E3   QUARTR
0x32DF   HALFPI
0x3278   RND2
0x325C   RND1
0x3289   RNDTAB
0x809B   LSTRND
0x3281   RESEED
0x8078   SEED
0x3208   SUMLP
0x31FF   SMSER1
0x31CF   EXPTAB
0x3177   POWER2
0x315A   POWER1
0x313C   NEGAFT
0x3107   EXPTEN
0x3105   OUTEXP
0x3114   NOENED
0x30E9   SUPTLZ
0x30F5   DOEBIT
0x30C4   TRYAGN
0x30B5   DIGTXT
0x312A   POWERS
0x30A4   MAKNUM
0x307F   GTSIXD
0x3088   INRNG
0x306A   SIXDIG
0x3117   RNGTST
0x3111   JSTZER
0x305B   SPCFST
0x8237   PBUFF
0x3005   MULTEN
0x2FFA   ENDCON
0x3004   SCALPL
0x2FEE   SCALMI
0x302E   EDIGIT
0x2FD9   EXPLP
0x2FEB   CONEXP
0x2FE7   DPOINT
0x300C   ADDIG
0x2FC3   MANLP
0x2FBB   CNVNUM
0x2FAA   NOMLAD
0x2F9C   MLDBLP
0x2F74   DCBCDE
0x2F3D   CMPFP
0x2F05   DETHLB
0x2EFE   INCHL
0x2EB1   RETREL
0x2E91   MLSP10
0x2E84   OVTST1
0x2E89   OVTST2
0x2E8A   OVTST3
0x2E36   RESDIV
0x806A   DIVSUP
0x2E23   DIVLP
0x8076   DIV4
0x806B   DIV1
0x806F   DIV2
0x8073   DIV3
0x2DF0   DIV10
0x2D88   NOMADD
0x2D77   MUL8LP
0x2D9A   BYTSFT
0x2D6E   MULT8
0x8244   MULVAL
0x2E66   ADDEXP
0x2D4C   FPMULT
0x2D43   MULLN2
0x3023   RSCALE
0x31F0   SUMSER
0x2DFE   DVBCDE
0x2CFE   LOGTAB
0x2CFA   UNITY
0x2CE8   SHRLP
0x2CE5   SHRITE
0x2CD8   SCALLP
0x8236   SGNRES
0x2CA9   FPROND
0x2C98   RONDB
0x2C7C   NORMAL
0x2C78   SAVEXP
0x2C84   PNORM
0x2C5F   CONPOS
0x2CEC   SHRT1
0x2C97   RONDUP
0x2CB6   PLUCDE
0x2C51   MINCDE
0x2CD6   SCALE
0x2F0E   SIGNS
0x2C2B   NOSWAP
0x2C0E   SUBCDE
0x2C08   SUBPHL
0x2C11   FPADD
0x3126   HALF
0x2BFF   ROUND
0x2BFC X ENDINK2
0x2BE1   CHKINK
0x2BDD   SRTINK
0x2BF3   ENDINK
0x2BC9   INKEY2
0x2BBA   CMP_A
0x2B68   NOS3
0x2B4F   NOS2
0x2B3C   NOS1
0x2B0C   SNDOVR
0x2B5F   WRTSND
0x2AD7   SND1
0x2A69   RPVOLCG
0x2A75   VOLCH
0x29CE   PKEPRMS
0x29B8   SYSRET
0x29AA   NOSYSPR
0x296C   NMIINT
0x2978   NMIVR1
0x2962   NMIEINT
0x295E   NMI2
0x2969   NMIDINT
0x293C   DISNMI
0x294D   NM1
0x8068   OTPORT
0x2905   WAITLP
0x2904   NOXOR
0x8067   OUTSUB
0x290E   SETIO
0x809F   INPSUB
0x80A0   INPORT
0x28CD   VAL2
0x28D0   VAL3
0x28C3   VAL1
0x2C77   RESZER
0x288E   RSTSTR
0x28D9   MIDNUM
0x285A   LVINSTR
0x2864   CNTZIN
0x2804   RP2INST
0x282D   CNT1INS
0x27DD   RPTINST
0x284F   RZINSTR
0x81F4   DY
0x27CC   EMPTINS
0x81EE   TF
0x81EC   TP
0x81EA   PT2
0x81E6   PT
0x81E4   ADRS2
0x81E2   LNS2
0x81E0   ADRS1
0x81DE   LNS1
0x2753   ALLFOL
0x274B   MID1
0x3FB2   BINERR
0x2749   RIGHT1
0x28D4   LFRGNM
0x2924   MAKINT
0x2728 X GTFLNM
0x2719   GETLEN
0x2702   POPHL
0x26E3   GETSTR
0x26DA   TSALP
0x26D0   SSTSA
0x26E9   GSTRHL
0x263D   GRBARY
0x2674   SCNEND
0x261D   GNXARY
0x264E   STRADD
0x261E   ARRLP
0x2608   SMPVAR
0x264B   STPOOL
0x25F7   GRBLP
0x25E9   GARBLP
0x25DA   TESTOS
0x25BE   GRBDON
0x25AD   PRSLP
0x25A2   PRNUMS
0x2583   TSTOPL
0x2577   CRTSTE
0x2568   QTSTLP
0x2552   MKTMST
0x26D9   TOSTRA
0x2555   CRTMST
0x25BC   TESTR
0x2741   TOPOOL
0x2533   STR1
0x255B   SVSTAD
0x251C   CHEKFN
0x2494   PASSA
0x2EBF   RETINT
0x25E6   GARBGE
0x247F   FRENUM
0x245E   ENDTMR
0x242A   FNDELP
0x2449   ENDDIM
0x2408   ZERARY
0x2F94   MLDEBC
0x23EA   DEFSIZ
0x23E2   CRARLP
0x23C2   BSERR
0x2425   FINDEL
0x23A9   NXTARY
0x23C7   CREARY
0x2395   FNDARY
0x236D   SCPTLP
0x234B   ZEROLP
0x235C   RETNUL
0x2359   RETADR
0x231A   FNTHR
0x2325   CFEVAL
0x230C   FNDVAR
0x2D98   POPHRT
0x822E   FNARG
0x2367   SBSCPT
0x22F2   NSCFOR
0x238F   ARLDSV
0x22E2   NOTSTR
0x22C7   ENDNAM
0x22D3   CHARTY
0x22C6   SVNAM2
0x22AF   GTFNAM
0x8193   LCRFLG
0x229C   DIMRET
0x2EBA   FLGREL
0x2EB3   FLGDIF
0x2263   CMPSTR
0x26EA   GSTRDE
0x26E6   GSTRCU
0x227B   CMPRES
0x2239   CMPLG1
0x2237   CMPLOG
0x2220   PXOR1
0x2213 X PAND1
0x2218   POR1
0x2484   ACPASS
0x2EE9   FPBCDE
0x21F8   CNTLGC
0x21DE   SGNEXP
0x21D5   GOFUNC
0x21CD   FNVAL
0x218E   FRMEVL
0x2186   RETNUM
0x2ED1   INVSGN
0x2172   EVLPAR
0x219C   FNOFST
0x24C6   DOFN
0x2285   EVNOT
0x217A   MINUS
0x3F87   BINTFP
0x3F17   HEXTFP
0x214F   NOTAMP
0x218B   CONVAR
0x2ED9   STAKFP
0x210D   STKTHS
0x2699   CONCAT
0x2225   TSTRED
0x81AC   CUROPR
0x20E5   FOPRND
0x20C9   RLTLP
0x20BC   EVAL3
0x81B7   NXTOPR
0x20B9   EVAL2
0x2124   OPRND
0x20B0   EVAL1
0x20A9   OPNPAR
0x209F   TSTSTR
0x208B   KILFOR
0x2EF7   LOADFP
0x2C02   ADDPHL
0x2EE6   PHLTFP
0x2053   NEXT1
0x2045   FANDT
0x201C   EXTIG
0x2001   MORDT
0x2FAF   ASCTFP
0x1FF5   LTSTND
0x2565   DTSTR
0x1FDB   ITMSEP
0x1FDE   STRENT
0x1FEA   INPBIN
0x202C   FDTLP
0x1FC0   ANTVLU
0x1F94   NEDMOR
0x1F98   GTVLUS
0x1F8C   NXTITM
0x1F6F   NOPMPT
0x250E   IDTEST
0x81B4   READFG
0x1F44   BADINP
0x1F32   REDO
0x1F23   SPCLP
0x1F1C   DOSPC
0x291E   FNDNUM
0x1EFC   ZONELP
0x1EE9   CNTEND
0x25A6   PRS1
0x2561   CRTST
0x304D   NUMASC
0x1EC6   PRNTST
0x1F2B   NEXITM
0x1EEE   DOCOM
0x1F07   DOTAB
0x1E7F   PRNTLP
0x1E78   MRPRNT
0x1E61   IF0
0x1E6A   IF1
0x1E58   IFGO
0x1E3C   ONGOLP
0x1E3B   ONGO
0x2921   GETINT
0x2F00   FPTHL
0x2F03   DETHL4
0x253D   SAVSTR
0x2704   BAKTMP
0x81A6   TMPSTR
0x1E1C   MVSTPT
0x1E14   CRESTR
0x8232   FPREG
0x1DED   LETSTR
0x1E25   LETNUM
0x20A0   CHKTYP
0x20AD   EVAL
0x8194   TYPE
0x22AA   GETVAR
0x1DC4   NXTSTT
0x1DC1   NXTSTL
0x1DBA   NXTDTA
0x1DB5   RETLIN
0x1D77   RUNLIN
0x1D30   STORED
0x1CE6   GTLNLP
0x1CE3   GETLN
0x2F23   CMPNUM
0x2F50   FPINT
0x8235   FPEXP
0x1CC2   DEPINT
0x1CBF X POSINT
0x2B12   NOISUP
0x1CBC   FPSINT
0x1CB4   CHKLTR
0x80A6   CHKSUM
0x1CA7 X ACCSUM
0x1C88   ERRINT
0x81B9   ERRLIN
0x1C77   NOLIN
0x1C61   INPBRK
0x80A9   BRKFLG
0x1C4B   STALL
0x1C55   BRK
0x822A   NXTDAT
0x1C38   UPDATA
0x1C37   RESTNL
0x1BFA   ONJMP
0x1BF9   IFJMP
0x1C64   ENDPRG
0x1BD2   RUNCNT
0x1BCE   PUTFID
0x2EA8   TSTSGN
0x1BC5   SAVSTP
0x2EF4   BCDEFP
0x209B   GETNUM
0x209E   TSTNUM
0x1B89   FORFND
0x1B6D   FORSLP
0x81AE   LOOPST
0x1B52   CNTWTSP
0x1B46   WTSPC
0x1B3E   LVSRLN
0x1B33   SRCLN1
0x1B10   OUTWRD
0x1B1E   NXTLN
0x1AF7   LSTLP3
0x1AF4   LSTLP2
0x1AE8   LST07
0x1AE5   LST08
0x1B40   TSTSPC
0x1C3D   TSTBRK
0x36A4   PAINT4
0x1ABA   LST02
0x1AB7   LST05
0x1A7A   LST06
0x1AA3   LST03
0x1A7E   LSTNOT
0x1A5F   LST01H
0x1AC3   LISTLP
0x1B32   SRCLN
0x1B2C   SRCHLIN
0x1A5C   LST01
0x1A8B   LSTALL
0x335E   GETINP
0x3FB7   MONOUT
0x1A0F   SND2VID
0x19FC   INCLEN
0x8192   CURPOS
0x80A2   LWIDTH
0x1A00   DINPOS
0x25D8   POPAF
0x19D1   CHKSYN
0x19C2   OUTIT
0x19C5   OUTNBS
0x3FD8   OUTNCR
0x19AE   PUTBUF
0x1ED5   ENDINP
0x19A8   GMNCR
0x19B3   PUTCTL
0x1973   PROCES
0x1A1D   CLOTST
0x194B   KILIN
0x1940   DELCHR
0x195A   MORINP
0x1948   OTKLN
0x1934   ECHDEL
0x80A4   NULFLG
0x1920   DODEL
0x1907   NXTCHR
0x1901   TSTREM
0x18FE   SETLIT
0x18E0   NOCHNG
0x18D7   NOSPC
0x18E8   MATCH
0x18C6   NXTBYT
0x18B6   GETNXT
0x18B4   SEARCH
0x18EC   RETNAD
0x189B   FNDWRD
0x1917   ENDBUF
0x1910   CPYLIT
0x18F0   MOVDIR
0x1871   CRNCLP
0x8195   DATFLG
0x80AA   RINPUT
0x1854   DOAGN
0x822C   FNRGNM
0x81B2   FORFLG
0x81BB   CONTAD
0x8198   TMSTPT
0x819A   TMSTPL
0x8226   VAREND
0x81AA   STRBOT
0x81B5   BRKLIN
0x1825   INTVAR
0x17F8   SRCHLP
0x8135   BASTXT
0x17E9   FNDEND
0x17DD   PTRLP
0x1821   RUNFST
0x17D0   MOVBUF
0x17D8   SETPTR
0x17A2   SFTPRG
0x8224   PROGND
0x17B1   INEWLN
0x1D91   ULERR
0x179A   LINFND
0x17F5   SRCHLN
0x81B3   LSTBIN
0x1BF2   EXCUTE
0x1868   CRUNCH
0x1951   GETLIN
0x1756   GETCMD
0x1748   POPNOK
0x303A   LINEIN
0x80B1   HLPLN
0x1744   PTLN
0x1727   ERRIN
0x19DC   OUTC
0x1ECD   STTLIN
0x80A5   CTLOFG
0x1701   TMERR
0x16FE   OVERR
0x16FB   UFERR
0x16F8   DDERR
0x16F5   NFERR
0x16F2   DZERR
0x81B0   DATLIN
0x16E9   DATSNR
0x16E7   LDG1ND
0x16D6   LDG1
0x16C9   EXITGM
0x1703   ERROR
0x16C4   OMERR
0x8228   ARREND
0x16AC   CHKSTK
0x16A1   MOVLP
0x169E   MOVSTR
0x16B5   ENFMEM
0x169B   MOVUP
0x1692   INDFND
0x167C   LOKFOR
0x1678   BAKSTK
0x1672   BRKMSG
0x166D   OKMSG
0x166C   ZERBYT
0x1668   INMSG
0x1661   ERRMSG
0x15DF X DEFFNKS
0x15DD   AUTORP
0x1951   TTYLIN
0x1CDD   FCERR
0x21F1   POR
0x21F6   PXOR
0x21EE   PAND
0x2C62   BNORM
0x314A   POWER
0x2D9F   DINT
0x2DA7   MOD
0x2DFC   DIV
0x2D4A   MULT
0x2C0C   PSUB
0x3029   PADD
0x156A   PRITAB
0x00E9   ZLEFT
0x00E1   ZINSTR
0x00E0   ZPOINT
0x00CA   ZSGN
0x00C9   ZLTH
0x00C8   ZEQUAL
0x00C7   ZGTR
0x00C6   ZOR
0x00C2 X ZDINT
0x00C1 X ZMOD
0x00C0 X ZDIV
0x00BF X ZTIMES
0x00BE   ZMINUS
0x00BD   ZPLUS
0x00BC   ZSTEP
0x00BB   ZNOT
0x00BA   ZTHEN
0x00B9   ZSPC
0x00B8   ZFN
0x00B7   ZTO
0x00B6   ZTAB
0x00B5   ZNEW
0x00AF   ZPRINT
0x00AE   ZELSE
0x008E   ZREM
0x008C   ZGOSUB
0x0088   ZGOTO
0x0083   ZDATA
0x0081   ZFOR
0x0080   ZEND
0x1815   NEW
0x3EC1   SAVE
0x3EC0   LOAD
0x1D07   CLEAR
0x1A30   LIST
0x1C8E   CONT
0x1E7C   PRINT
0x3FBA   RESET
0x298C   SYS
0x3374   WIDTH
0x34F4   GPRINT
0x2932   NMI
0x3D53   KEY
0x3360   CLS
0x3D38   HELP
0x3AF6   SERIAL
0x35E5   PAINT
0x38F1   CIRCLE
0x37BB   DRAW
0x3728   PLOT
0x3438   COLOR
0x339E   PAUSE
0x2A47   VOLUME
0x2A80   SOUND
0x29F4   LOCATE
0x2B74   VREG
0x2A26   SREG
0x29E9   VPOKE
0x3387   DOKE
0x29E4   POKE
0x2499   DEF
0x28F0   WAIT
0x3EC3   ERASE
0x3EC2   FILES
0x1E2C   ON
0x28EA   POUT
0x1C5A   STOP
0x1DBD   REM
0x1D96   RETURN
0x1D67   GOSUB
0x1C22   RESTOR
0x1E4A   IF
0x1D53   RUN
0x1D78   GOTO
0x1DD2   LET
0x1F87   READ
0x22A5   DIM
0x1F55   INPUT
0x1DBB   DATA
0x2050   NEXT
0x1B59   FOR
0x1C5C   PEND
0x14FE   WORDTB
0x1371   WORDS
0x2875   MID
0x286B   RIGHT
0x2745   LEFT
0x3F55   BIN
0x3EC4   HEX
0x2735   CHR
0x2724   ASC
0x28A5   VAL
0x252D   STR
0x3B9A   RXEND
0x2715   LEN
0x2775   INSTR
0x36D5   POINT
0x2BAF   INKEY
0x2B9B   SSTAT
0x2B90   VSTAT
0x29C1   VPEEK
0x337C   DEEK
0x29BA   PEEK
0x3311   ATN
0x32FC   TAN
0x33BD   SCREEN
0x329B   SIN
0x3295   COS
0x318F   EXP
0x2D0B   LOG
0x3220   RND
0x3141   SQR
0x2491   POS
0x28DE   INP
0x2463   FRE
0x81E8   PT1
0x8064   USR
0x2ECD   ABS_
0x2F7B   INT
0x244D   TMR
0x2EB7   SGN
0x132D   FNCTAB
0x1749   PRNTOK
0x3D60   RESFN
0x12BE   BRKRET
0x813D   STACK
0x12D3   BFREE
0x3042   PRNTHL
0x12CA   BLNSPC
0x1816   CLRPTR
0x80AD   STRSPC
0x8196   LSTRAM
0x1287   NODOS
0x19CB   CPDEHL
0x16EF   SNERR
0x1CE2   ATOH
0x1270   SETTOP
0x124C   MLOOP
0x82AB   STLOOK
0x125E   TSTMEM
0x1C12   GETCHR
0x1858   PROMPT
0x25A3   PRS
0x1322   MEMMSG
0x1236   MSIZE
0x1249   MNOASK
0x2A8E   CTSNDC
0x8247   PROGST
0x8138   BUFFER
0x1EDF   PRNTCRLF
0x183B   CLREG
0x1B06   FNDTOK
0x1661   INITBE
0x1588   INITAB
0x121B   INIT
0x805E   WRKSPC
0x2485   ABPASS
0x1EC2   PRNTNB
0x1CC8   DEINT
0x1214   CSTART
0x12BB   WARMST
0x120D   STARTB
0x1057 X ERRORS
0x11FD   HPMSG
0x1055 X HPPTR
0x11E7   SOMSG
0x11CE   SAMSG
0x1051 X SAPTR
0x11B9   SCMSG
0x104F X SCPTR
0x104D X GMPRT
0x119D   BNMSG
0x104B X BNPTR
0x1192   HXMSG
0x1049 X HXPTR
0x1182   MOMSG
0x1047 X MOPTR
0x3EFA   BYT2ASC
0x116C   UFMSG
0x1045 X UFPTR
0x115D   CNMSG
0x1043 X CNPTR
0x1142   STMSG
0x1041 X STPTR
0x1053 X SOPTR
0x1132   LSMSG
0x103F X LSPTR
0x111E   OSMSG
0x103D X OSPTR
0x110F   TMMSG
0x103B X TMPTR
0x1100   IDMSG
0x1039 X IDPTR
0x10EF   DZMSG
0x1037 X DZPTR
0x10DA   DDMSG
0x1035 X DDPTR
0x10CC   BSMSG
0x1033 X BSPTR
0x10BD   ULMSG
0x3EB4   CHKEY3
0x1031 X ULPTR
0x10AF   OMMSG
0x102F X OMPTR
0x10A6   OVMSG
0x102D X OVPTR
0x1090   FCMSG
0x102B X FCPTR
0x1084   ODMSG
0x1029 X ODPTR
0x106F   RGMSG
0x1027 X RGPTR
0x1068   SNMSG
0x1025 X SNPTR
0x1057   NFMSG
0x1023 X NFPTR
0x1023   ERRTBL
0x0032   HP
0x0030   SO
0x002E   SA
0x002C   SC
0x002A   GM
0x0028   BN
0x0026 X HX
0x0024   MO
0x0022   UF
0x0020   CN
0x001E   ST
0x1F21   ASPCS
0x001C   LS
0x001A   OS
0x0018   TM
0x0016   ID
0x0014   DZ
0x0012   DD
0x0010   BS
0x000E   UL
0x000C   OM
0x000A   OV
0x0008   FC
0x0006   OD
0x0004   RG
0x0002   SN
0x0000   NF
0x007F   DEL
0x0020   SPC
0x001B   ESC
0x0015   CTRLU
0x0013   CTRLS
0x0012   CTRLR
0x0011   CTRLQ
0x000F   CTRLO
0x0007   CTRLG
0x0EFB   CNTFNK
0x0F0E   PRNTFNK
0x0F01   PUTCHRBUF1
0x0EE7   LDFNKEYCHR
0x80B5   FNKEYS
0x80AF   LINEAT
0x12E1   SIGNON
0x0ECE X LVKBRDCHK
0x0EC7   PNT2VD
0x0EBA   PUTCHRBUF
0x0EA8   SNDKEYTOBFR
0x0ECF   PRNTFNKEY
0x0EA0   CHKFNK
0x0F1B   FNKEYSORD
0x0E9A   CNTKBCK
0x0003   CTRLC
0x80B4   AUTOKE
0x2C65   BNRMLP
0x0E87   SENDKEY
0x0E58   SETNEWAUTO
0x0ECA   LVKBRDCHK2
0x80B3   KEYDEL
0x0E68   CHKAUTO
0x821D   KEYTMR
0x0E7A   NEWKEY
0x0FA3   KBMAP_ALT
0x0FE3   KBMAP_CTRL
0x0E1F   CHKALT
0x0E26   LOADMAP
0x0F63   KBMAP_SFT
0x0E16   CHKCTRL
0x0F23   KBMAP
0x0E02   CHKLN
0x821C   STATUSKEY
0x821B   LASTKEYPRSD
0x0DEA   ENDCTRLCK
0x0DE4   TESTCTRL
0x0E00   FINDKEY
0x0DD7   TESTALT
0x8219   KBTMP
0x0DEE   NOKEYPRSD
0x0DA8   RPTKBDRD
0x0DA4   CHECKKBD
0x0D96   CHECKCTRL
0x821F   CONTROLKEYS
0x0D88   CHECKALT
0x0D48   CNTCHKSND
0x0D0D   CHKSNDCH
0x0CDB   RPTWLCMBP
0x0CF1   NOBPDAT
0x0CD8   SENDSND
0x0CE9   WLCBPDAT
0x0CFE   WRTSNDREG
0x0CF9   SETSNDREG
0x0CBF   SNDREGCFG
0x0CAB   CLRPSGREGS
0x0CA7   EMPTSNDBFR
0x0B59 X VDPMODESETEX2
0x0B51 X VDPMODESETMC
0x0B49 X VDPMODESET2
0x2562   QTSTR
0x0B41 X VDPMODESET1
0x0B2F   SENDCHRPTRNS
0x4841   CHRST88
0x0B2D   NXTCHAR
0x4041   CHRST68
0x0B0E   LDREGVLS
0x0B39   VDPMODESET
0x0AF7   RSTVDPRAMREG
0x8212   CHASNDDTN
0x0AE8   EMPTVRM
0x0A7C X CNTNULL2
0x0A6F   RPTNLLSRC2
0x3FE9   MUL16
0x0A4A   ADDNEWLINE
0x0A17   SNDCHRTOBFR
0x09FE   CNTNULL
0x09EE   RPTNLLSRC
0x0A36   PRNTRETURN
0x81E4   TMPBFR4
0x81E2   TMPBFR3
0x81E0   SRTTXT
0x81E0   TMPBFR2
0x09C4   RPTEMPTYROW
0x09A9   WRITEBUF
0x0980   LOADNEXTCOL
0x81E6   VIDEOBUFF
0x096E   SCROLLNXTRW
0x8210   VIDTMP2
0x820E   VIDTMP1
0x094C   EXITCURSOR_ON
0x0936   EXITCURSORDOWN
0x0916   EXITCURSORRGHT
0x0910   CONTCRSRGT
0x08FD   CHCKYPOS2
0x08E2   EXITCURSORUP
0x08B9   CHKYPOS
0x08A6   EXITCURSORLEFT
0x08A3   CONTCRSLFT
0x0892   CHCKYPOS
0x08A8   MVCRS2LFT
0x0863   MVBKSP
0x0876   LVBKSP
0x082F X ENDINSRT
0x082A   NXTINST
0x3FDE   CMP16
0x0819   CHKHL
0x81E2   ENDTXT
0x0A57   ENDOFLN
0x81DE   CUR_POS
0x07F7   PUTCRSCHR
0x0955   SCROLLUP
0x07B7   SETCRSRY
0x07B8   SETCSRCOORDS
0x07CA   EXITCHAR2VID
0x078E   NXTCPCK
0x0781   RPTCPCK
0x07D7   PLACEHOLDER
0x000A   LF
0x07FB   INSERTKEY
0x001A   INSRT
0x0919   CURSORDOWN
0x001F   CRSDN
0x08E4   CURSORRIGHT
0x001D   CRSRGT
0x08CB   CURSORUP
0x001E   CRSUP
0x087F   CURSORLEFT
0x001C   CRSLFT
0x083C   BACKSPACE
0x3455   CNTCKCL
0x0008   BKSP
0x09D0   CRGRETURN
0x000C   CS
0x0019   HOME
0x0750   CHRTBL
0x401D   DIV_16_8
0x073F   HL2XY
0x0A7D   POS_TB_CRS_32
0x0731   CONT_POS_CURS
0x0AAD   POS_TB_CRS_40
0x81D9   LSTCSRSTA
0x06E9   MOVSHOWCRS
0x06FE   NEWCRSRCOORD
0x0713   RSTCHRCRS
0x071C   LOAD_CRSR_POS
0x06D2   READ_VSTAT
0x06C7   WRITE_VREG
0x06B2   WRITE_VIDEO_LOC
0x069D   READ_VIDEO_LOC
0x06E3   MOVCRS
0x81D5   SCR_CUR_NX
0x0000   NLLCR
0x81D6   SCR_CUR_NY
0x0693   ATHOME
0x06D9   POS_CURSOR
0x0686   CLEARVIDBUF
0x0673   RPTFLL1
0x0660   SNDCLRSET
0x065C   STARTEMPTY
0x0626   CLRG2PTNTBL
0x060B   RPTEMPTYBUF
0x0605   LDCOLSTOEMPTY
0x0645   EMPTYMC
0x0614   EMPTYG2
0x05E9   LVCKSPLK
0x0D53   READKBLN
0x05DB X CHKSPCK
0x05CC   SNDLOGPT
0x2CC2   COMPL
0x5041   LOGOFONT
0x0CD5   NOBEEP
0x0CCF   WLCMBEEP
0x0597   RPT100
0x05AD   BEEPOFF
0x05A1   SETBEEP
0x056D   DEC_D
0x8223   DOS_EN
0x81DE   TMPBFR1
0x055C   RPT104
0x05B5   LOADLOGOCHRS
0x0554   RPT103
0x0B61   LM80CLOGO
0x053E   RPT102
0x0CB2   RSTPSG
0x053B   RPT101
0x05D6   CLRTABLE
0x0589   ERASECLRTBL
0x066A   SETNAMETABLE
0x0B04   SET_GFX_MODE2
0x81D7   SCR_ORG_CHR
0x05EB   EMPTYVIDBUF
0x0476   LDCLRTBMD1
0x81DC   FRGNDCLR
0x067D   SETVDPADRS
0x0507   ENDVDPSET
0x81D1   SCR_NAM_TB
0x80A3   COMMAN
0x81CE   SCR_SIZE_H
0x81CD   SCR_SIZE_W
0x81DD   BKGNDCLR
0x81D4   SCR_CURS_Y
0x04FE   LDCLRTBEX2
0x81D3   SCR_CURS_X
0x0B18   LOADCHARSET
0x0414 X TXTMD
0x04C4   EXG2MD
0x04A1   MCMD
0x047F   G2MD
0x043E   G1MD
0x81CF   SCR_MODE
0x0AF1   CLR_RAM_REG
0x0AFC   SET_GFX_MODE
0x0ADD   EMPTY_VRAM
0x0385   RESTMR
0x038A   CTCCONF
0x035C X SIO_B_SETS
0x0356   SIO_A_SETS
0x034B   COUNTER
0x0349   DEC_E
0x0345   LEDLIGHT
0x120A   WARM
0x1207   COLD
0x094E   CURSOR_OFF
0x0321   ECHO_CHAR
0x0314   CHECKWARM
0x02FD   CORW
0x0939   CURSOR_ON
0x03D2   MSGTXT2
0x0309   COLDSTART
0x805D   basicStarted
0x0396   MSGTXT1
0x81DA   PRNTVIDEO
0x3FC9   INITST
0x03EF   initVDP
0x0512   SHOW_LOGO
0x0CA1   initPSG
0x0360   initCTC
0x033B   HELLOWRLD
0x02B3 X INIT_HW2
0x818F   TEMPSTACK
0x0D68   KEYBOARD
0x0D03   MNGSNDS
0x07D8   FLASHCURSOR
0x029C   CHKCRSR
0x0296   INCTMR3
0x81BD   TMRCNT
0x028D   CH3_TIMER
0x027F   RAWPRINT
0x026B   EXTXA
0x026E   TX_EMP
0x0266   TXA_EXIT
0x0257   CNTTXA
0x0249   RXA_EXIT
0x0238   NOTRDWRAP
0x805A   serRdPtr
0x8000   SERBUF_START
0x020B   NOTWRAP
0x0058   bufWrap
0x8058   serInPtr
0x01FF   NOTFULL
0x805C   serBufUsed
0x01E2   SIO_B_EI
0x01E8   SIO_RXEN
0x01DA   SIO_A_EI
0x01D0   SIO_RXDI
0x01B0 X B_RTS_ON
0x01B6   SIO_RTS_ON
0x01A8   A_RTS_ON
0x8222   SERBBITS
0x019C   SIO_RTS_OFF
0x8221   SERABITS
0x0180   EMPTYCHBBFR
0x01CA   SIO_B_DI
0x0196   B_RTS_OFF
0x3D24   SOERR
0x015C   CHABFREMPTY
0x014E   EMPTYCHABFR
0x8220   SERIALS_EN
0x01C2   SIO_A_DI
0x11A8   GMMSG
0x076E   CHAR2VID
0x81D8   CRSR_STATE
0x8218   KBDNPT
0x0120   CNTRXCHA
0x000D   CR
0x81DB   CHR4VID
0x0130   LVRXCHA
0x01F4   CHARINTOBFR
0x821A   TMPKEYBFR
0x018E   A_RTS_OFF
0x00EC   FMVEREND
0x00D0 X FWVER
0x8061   NMIUSR
0x81CA   CTC3IV
0x81C7   CTC2IV
0x81C4   CTC1IV
0x81C1   CTC0IV
0x027A   CKINCHAR
0x0018 X RST18
0x0223   RXA
0x0010 X RST10
0x0135   SPEC_RXA_CNDT
0x0100   RX_CHA_AVAIL
0x024D   TXA
0x0008 X RST08
0x0167   SPEC_RXB_CNDT
0x0164   RX_CHB_AVAIL
0x02B0   INIT_HW
0x0000 X RST00
0x0005   SER_EMPTYSIZE
0x0050   SER_FULLSIZE
0x0058   SER_BUFSIZE
0x0041   PSG_DAT
0x0040   PSG_REG
0x0032   VDP_SET
0x0030   VDP_DAT
0x0021   SIO_DB
0x0020   SIO_DA
0x0023   SIO_CB
0x0022   SIO_CA
0x0013   CTC_CH3
0x0012   CTC_CH2
0x0011   CTC_CH1
0x0010   CTC_CH0
0x0003   PIO_CB
0x0002 X PIO_CA
0x0001   PIO_DB
0x0000 X PIO_DA
